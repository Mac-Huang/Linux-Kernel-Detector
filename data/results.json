{
  "summary": {
    "total_files_analyzed": 35588,
    "files_with_issues": 1431,
    "total_issues_found": 3122,
    "critical_issues": 347,
    "high_priority_issues": 2670,
    "medium_priority_issues": 13,
    "low_priority_issues": 92
  },
  "findings": [
    {
      "file": "linux\\fs\\anon_inodes.c",
      "line": 184,
      "pattern": "code.*duplication",
      "rule": "code_quality",
      "severity": "low",
      "match": "code duplication",
      "context": [
        " * Creates a new file by hooking it on a single inode. This is useful for files",
        " * that do not need to have a full-fledged inode in order to operate correctly.",
        " * All the files created with anon_inode_getfile() will share a single inode,",
        " * hence saving memory and avoiding code duplication for the file/inode/dentry",
        " * setup.  Returns the newly created file* or an error pointer.",
        " */",
        "struct file *anon_inode_getfile(const char *name,"
      ]
    },
    {
      "file": "linux\\fs\\anon_inodes.c",
      "line": 209,
      "pattern": "code.*duplication",
      "rule": "code_quality",
      "severity": "low",
      "match": "code duplication",
      "context": [
        " * Creates a new file by hooking it on a single inode. This is useful for files",
        " * that do not need to have a full-fledged inode in order to operate correctly.",
        " * All the files created with anon_inode_getfile() will share a single inode,",
        " * hence saving memory and avoiding code duplication for the file/inode/dentry",
        " * setup. Allows setting the fmode. Returns the newly created file* or an error",
        " * pointer.",
        " */"
      ]
    },
    {
      "file": "linux\\fs\\anon_inodes.c",
      "line": 307,
      "pattern": "code.*duplication",
      "rule": "code_quality",
      "severity": "low",
      "match": "code duplication",
      "context": [
        " * useful for files that do not need to have a full-fledged inode in",
        " * order to operate correctly.  All the files created with",
        " * anon_inode_getfd() will use the same singleton inode, reducing",
        " * memory use and avoiding code duplication for the file/inode/dentry",
        " * setup.  Returns a newly created file descriptor or an error code.",
        " */",
        "int anon_inode_getfd(const char *name, const struct file_operations *fops,"
      ]
    },
    {
      "file": "linux\\fs\\aio.c",
      "line": 1463,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\t\t/* Pass requests_done to kill_ioctx() where it can be set",
        "\t\t * in a thread-safe way. If we try to set it here then we have",
        "\t\t * a race condition if two io_destroy() called simultaneously.",
        "\t\t */",
        "\t\tret = kill_ioctx(current->mm, ioctx, &wait);",
        "\t\tpercpu_ref_put(&ioctx->users);"
      ]
    },
    {
      "file": "linux\\fs\\binfmt_flat.c",
      "line": 239,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\tif (buf[3] & EXTRA_FIELD) {",
        "\t\tret += 2 + buf[10] + (buf[11] << 8);",
        "\t\tif (unlikely(ret >= LBUFSIZE)) {",
        "\t\t\tpr_debug(\"buffer overflow (EXTRA)?\\n\");",
        "\t\t\tgoto out_free_buf;",
        "\t\t}",
        "\t}"
      ]
    },
    {
      "file": "linux\\fs\\binfmt_flat.c",
      "line": 247,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\twhile (ret < LBUFSIZE && buf[ret++] != 0)",
        "\t\t\t;",
        "\t\tif (unlikely(ret == LBUFSIZE)) {",
        "\t\t\tpr_debug(\"buffer overflow (ORIG_NAME)?\\n\");",
        "\t\t\tgoto out_free_buf;",
        "\t\t}",
        "\t}"
      ]
    },
    {
      "file": "linux\\fs\\binfmt_flat.c",
      "line": 255,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\twhile (ret < LBUFSIZE && buf[ret++] != 0)",
        "\t\t\t;",
        "\t\tif (unlikely(ret == LBUFSIZE)) {",
        "\t\t\tpr_debug(\"buffer overflow (COMMENT)?\\n\");",
        "\t\t\tgoto out_free_buf;",
        "\t\t}",
        "\t}"
      ]
    },
    {
      "file": "linux\\fs\\binfmt_flat.c",
      "line": 868,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "stack overflow",
      "context": [
        "",
        "\t/*",
        "\t * We have to add the size of our arguments to our stack size",
        "\t * otherwise it's too easy for users to create stack overflows",
        "\t * by passing in a huge argument list.  And yes,  we have to be",
        "\t * pedantic and include space for the argv/envp array as it may have",
        "\t * a lot of entries."
      ]
    },
    {
      "file": "linux\\fs\\bpf_fs_kfuncs.c",
      "line": 227,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t\t/* This xattr is set by BPF LSM, so we do not call",
        "\t\t * security_inode_post_setxattr. Otherwise, we would",
        "\t\t * risk deadlocks by calling back to the same kfunc.",
        "\t\t *",
        "\t\t * This is the same as security_inode_setsecurity().",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\fs\\bpf_fs_kfuncs.c",
      "line": 264,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t\t/* This xattr is removed by BPF LSM, so we do not call",
        "\t\t * security_inode_post_removexattr. Otherwise, we would",
        "\t\t * risk deadlocks by calling back to the same kfunc.",
        "\t\t */",
        "\t}",
        "\treturn ret;"
      ]
    },
    {
      "file": "linux\\fs\\eventfd.c",
      "line": 61,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Deadlock",
      "context": [
        "\tunsigned long flags;",
        "",
        "\t/*",
        "\t * Deadlock or stack overflow issues can happen if we recurse here",
        "\t * through waitqueue wakeup handlers. If the caller users potentially",
        "\t * nested waitqueues with custom wakeup handlers, then it should",
        "\t * check eventfd_signal_allowed() before calling this function. If"
      ]
    },
    {
      "file": "linux\\fs\\eventfd.c",
      "line": 61,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "stack overflow",
      "context": [
        "\tunsigned long flags;",
        "",
        "\t/*",
        "\t * Deadlock or stack overflow issues can happen if we recurse here",
        "\t * through waitqueue wakeup handlers. If the caller users potentially",
        "\t * nested waitqueues with custom wakeup handlers, then it should",
        "\t * check eventfd_signal_allowed() before calling this function. If"
      ]
    },
    {
      "file": "linux\\fs\\eventpoll.c",
      "line": 64,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * The epnested_mutex is acquired when inserting an epoll fd onto another",
        " * epoll fd. We do this so that we walk the epoll tree and ensure that this",
        " * insertion does not create a cycle of epoll file descriptors, which",
        " * could lead to deadlock. We need a global mutex to prevent two",
        " * simultaneous inserts (A into B and B into A) from racing and",
        " * constructing a cycle without either insert observing that it is",
        " * going to."
      ]
    },
    {
      "file": "linux\\fs\\file_table.c",
      "line": 549,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * synchronous analog of fput(); for kernel threads that might be needed",
        " * in some umount() (and thus can't use flush_delayed_fput() without",
        " * risking deadlocks), need to wait for completion of __fput() and know",
        " * for this specific struct file it won't involve anything that would",
        " * need them.  Use only if you really need it - at the very least,",
        " * don't blindly convert fput() by kernel thread to that."
      ]
    },
    {
      "file": "linux\\fs\\locks.c",
      "line": 144,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "",
        "/*",
        " * The blocked_hash is used to find POSIX lock loops for deadlock detection.",
        " * It is protected by blocked_lock_lock.",
        " *",
        " * We hash locks by lockowner in order to optimize searching for the lock a"
      ]
    },
    {
      "file": "linux\\fs\\locks.c",
      "line": 992,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Deadlock",
      "context": [
        "EXPORT_SYMBOL(posix_test_lock);",
        "",
        "/*",
        " * Deadlock detection:",
        " *",
        " * We attempt to detect deadlocks that are due purely to posix file",
        " * locks."
      ]
    },
    {
      "file": "linux\\fs\\locks.c",
      "line": 994,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * Deadlock detection:",
        " *",
        " * We attempt to detect deadlocks that are due purely to posix file",
        " * locks.",
        " *",
        " * We assume that a task can be waiting for at most one lock at a time."
      ]
    },
    {
      "file": "linux\\fs\\locks.c",
      "line": 1007,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * Since we do this before we ever put a process to sleep on a lock, we",
        " * are ensured that there is never a cycle; that is what guarantees that",
        " * the while() loop in posix_locks_deadlock() eventually completes.",
        " *",
        " * Note: the above assumption may not be true when handling lock",
        " * requests from a broken NFS client. It may also fail in the presence"
      ]
    },
    {
      "file": "linux\\fs\\locks.c",
      "line": 1016,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * For FL_OFDLCK locks, the owner is the filp, not the files_struct.",
        " * Because the owner is not even nominally tied to a thread of",
        " * execution, the deadlock detection below can't reasonably work well. Just",
        " * skip it for those.",
        " *",
        " * In principle, we could do a more limited deadlock detection on FL_OFDLCK"
      ]
    },
    {
      "file": "linux\\fs\\locks.c",
      "line": 1019,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * execution, the deadlock detection below can't reasonably work well. Just",
        " * skip it for those.",
        " *",
        " * In principle, we could do a more limited deadlock detection on FL_OFDLCK",
        " * locks that just checks for the case where two tasks are attempting to",
        " * upgrade from read to write locks on the same inode.",
        " */"
      ]
    },
    {
      "file": "linux\\fs\\locks.c",
      "line": 1042,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "}",
        "",
        "/* Must be called with the blocked_lock_lock held! */",
        "static bool posix_locks_deadlock(struct file_lock *caller_fl,",
        "\t\t\t\t struct file_lock *block_fl)",
        "{",
        "\tstruct file_lock_core *caller = &caller_fl->c;"
      ]
    },
    {
      "file": "linux\\fs\\locks.c",
      "line": 1052,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tlockdep_assert_held(&blocked_lock_lock);",
        "",
        "\t/*",
        "\t * This deadlock detector can't reasonably detect deadlocks with",
        "\t * FL_OFDLCK locks, since they aren't owned by a process, per-se.",
        "\t */",
        "\tif (caller->flc_flags & FL_OFDLCK)"
      ]
    },
    {
      "file": "linux\\fs\\locks.c",
      "line": 1052,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tlockdep_assert_held(&blocked_lock_lock);",
        "",
        "\t/*",
        "\t * This deadlock detector can't reasonably detect deadlocks with",
        "\t * FL_OFDLCK locks, since they aren't owned by a process, per-se.",
        "\t */",
        "\tif (caller->flc_flags & FL_OFDLCK)"
      ]
    },
    {
      "file": "linux\\fs\\locks.c",
      "line": 1207,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Deadlock",
      "context": [
        "\t\t\tif (!(request->c.flc_flags & FL_SLEEP))",
        "\t\t\t\tgoto out;",
        "\t\t\t/*",
        "\t\t\t * Deadlock detection and insertion into the blocked",
        "\t\t\t * locks list must be done while holding the same lock!",
        "\t\t\t */",
        "\t\t\terror = -EDEADLK;"
      ]
    },
    {
      "file": "linux\\fs\\locks.c",
      "line": 1214,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\tspin_lock(&blocked_lock_lock);",
        "\t\t\t/*",
        "\t\t\t * Ensure that we don't find any locks blocked on this",
        "\t\t\t * request during deadlock detection.",
        "\t\t\t */",
        "\t\t\t__locks_wake_up_blocks(&request->c);",
        "\t\t\tif (likely(!posix_locks_deadlock(request, fl))) {"
      ]
    },
    {
      "file": "linux\\fs\\locks.c",
      "line": 1217,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t * request during deadlock detection.",
        "\t\t\t */",
        "\t\t\t__locks_wake_up_blocks(&request->c);",
        "\t\t\tif (likely(!posix_locks_deadlock(request, fl))) {",
        "\t\t\t\terror = FILE_LOCK_DEFERRED;",
        "\t\t\t\t__locks_insert_block(&fl->c, &request->c,",
        "\t\t\t\t\t\t     posix_locks_conflict);"
      ]
    },
    {
      "file": "linux\\fs\\pipe.c",
      "line": 102,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "}",
        "EXPORT_SYMBOL(pipe_unlock);",
        "",
        "void pipe_double_lock(struct pipe_inode_info *pipe1,",
        "\t\t      struct pipe_inode_info *pipe2)",
        "{",
        "\tBUG_ON(pipe1 == pipe2);"
      ]
    },
    {
      "file": "linux\\fs\\read_write.c",
      "line": 1623,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * for server-side-copy between any two sb.",
        "\t *",
        "\t * In any case, we call do_splice_direct() and not splice_file_range(),",
        "\t * without file_start_write() held, to avoid possible deadlocks related",
        "\t * to splicing from input file, while file_start_write() is held on",
        "\t * the output file on a different sb.",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\select.c",
      "line": 107,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race-condition",
      "context": [
        "/*",
        " * Ok, Peter made a complicated, but straightforward multiple_wait() function.",
        " * I have rewritten this, taking some shortcuts: This code may not be easy to",
        " * follow, but it should be free of race-conditions, and it's practical. If you",
        " * understand what I'm doing here, then you understand how the linux",
        " * sleep/wakeup mechanism works.",
        " *"
      ]
    },
    {
      "file": "linux\\fs\\splice.c",
      "line": 1736,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\treturn ret;",
        "",
        "\t/*",
        "\t * Potential ABBA deadlock, work around it by ordering lock",
        "\t * grabbing by pipe info address. Otherwise two different processes",
        "\t * could deadlock (one doing tee from A -> B, the other from B -> A).",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\splice.c",
      "line": 1738,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Potential ABBA deadlock, work around it by ordering lock",
        "\t * grabbing by pipe info address. Otherwise two different processes",
        "\t * could deadlock (one doing tee from A -> B, the other from B -> A).",
        "\t */",
        "\tpipe_double_lock(ipipe, opipe);",
        ""
      ]
    },
    {
      "file": "linux\\fs\\splice.c",
      "line": 1859,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tssize_t ret = 0;",
        "",
        "\t/*",
        "\t * Potential ABBA deadlock, work around it by ordering lock",
        "\t * grabbing by pipe info address. Otherwise two different processes",
        "\t * could deadlock (one doing tee from A -> B, the other from B -> A).",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\splice.c",
      "line": 1861,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Potential ABBA deadlock, work around it by ordering lock",
        "\t * grabbing by pipe info address. Otherwise two different processes",
        "\t * could deadlock (one doing tee from A -> B, the other from B -> A).",
        "\t */",
        "\tpipe_double_lock(ipipe, opipe);",
        ""
      ]
    },
    {
      "file": "linux\\fs\\splice.c",
      "line": 1740,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "\t * grabbing by pipe info address. Otherwise two different processes",
        "\t * could deadlock (one doing tee from A -> B, the other from B -> A).",
        "\t */",
        "\tpipe_double_lock(ipipe, opipe);",
        "",
        "\ti_tail = ipipe->tail;",
        "\to_head = opipe->head;"
      ]
    },
    {
      "file": "linux\\fs\\splice.c",
      "line": 1863,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "\t * grabbing by pipe info address. Otherwise two different processes",
        "\t * could deadlock (one doing tee from A -> B, the other from B -> A).",
        "\t */",
        "\tpipe_double_lock(ipipe, opipe);",
        "",
        "\ti_tail = ipipe->tail;",
        "\to_head = opipe->head;"
      ]
    },
    {
      "file": "linux\\fs\\super.c",
      "line": 175,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * One thing we have to be careful of with a per-sb shrinker is that we don't",
        " * drop the last active reference to the superblock from within the shrinker.",
        " * If that happens we could trigger unregistering the shrinker from within the",
        " * shrinker path and that leads to deadlock on the shrinker_mutex. Hence we",
        " * take a passive reference to the superblock to avoid this from occurring.",
        " */",
        "static unsigned long super_cache_scan(struct shrinker *shrink,"
      ]
    },
    {
      "file": "linux\\fs\\super.c",
      "line": 191,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Deadlock",
      "context": [
        "\tsb = shrink->private_data;",
        "",
        "\t/*",
        "\t * Deadlock avoidance.  We may hold various FS locks, and we don't want",
        "\t * to recurse into the FS that called us in clear_inode() and friends..",
        "\t */",
        "\tif (!(sc->gfp_mask & __GFP_FS))"
      ]
    },
    {
      "file": "linux\\fs\\super.c",
      "line": 340,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * In case that succeeds, it will acquire the s_umount",
        "\t * lock of the old one. Since these are clearly distrinct",
        "\t * locks, and this object isn't exposed yet, there's no",
        "\t * risk of deadlocks.",
        "\t *",
        "\t * Annotate this by putting this lock in a different",
        "\t * subclass."
      ]
    },
    {
      "file": "linux\\kernel\\acct.c",
      "line": 37,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *  real mess with do_remount_sb(). 9/11/98, AV.",
        " *",
        " *  Fixed a bunch of races (and pair of leaks). Probably not the best way,",
        " *  but this one obviously doesn't introduce deadlocks. Later. BTW, found",
        " *  one race (and leak) in BSD implementation.",
        " *  OK, that's better. ANOTHER race and leak in BSD variant. There always",
        " *  is one more bug... 10/11/98, AV."
      ]
    },
    {
      "file": "linux\\kernel\\acct.c",
      "line": 556,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * First check to see if there is enough free_space to continue",
        "\t * the process accounting system. Then get freeze protection. If",
        "\t * the fs is frozen, just skip the write as we could deadlock",
        "\t * the system otherwise.",
        "\t */",
        "\tif (check_free_space(acct) && file_start_write_trylock(file)) {"
      ]
    },
    {
      "file": "linux\\kernel\\auditfilter.c",
      "line": 1179,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tstruct audit_netlink_list *dest;",
        "",
        "\t/* We can't just spew out the rules here because we might fill",
        "\t * the available socket buffer space and deadlock waiting for",
        "\t * auditctl to read from it... which isn't ever going to",
        "\t * happen if we're actually running in the context of auditctl",
        "\t * trying to _send_ the stuff */"
      ]
    },
    {
      "file": "linux\\kernel\\auditsc.c",
      "line": 1229,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "",
        "\t\t/* write as much as we can to the audit log */",
        "\t\tif (len_buf >= 0) {",
        "\t\t\t/* NOTE: some magic numbers here - basically if we",
        "\t\t\t *       can't fit a reasonable amount of data into the",
        "\t\t\t *       existing audit buffer, flush it and start with",
        "\t\t\t *       a new buffer */"
      ]
    },
    {
      "file": "linux\\kernel\\cpu.c",
      "line": 1488,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Ensure that the control task does not run on the to be offlined",
        "\t * CPU to prevent a deadlock against cfs_b->period_timer.",
        "\t * Also keep at least one housekeeping cpu onlined to avoid generating",
        "\t * an empty sched_domain span.",
        "\t */"
      ]
    },
    {
      "file": "linux\\kernel\\kprobes.c",
      "line": 276,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double free",
      "context": [
        "\tidx = __find_insn_page(c, slot, &kip);",
        "\t/* Mark and sweep: this may sleep */",
        "\tif (kip) {",
        "\t\t/* Check double free */",
        "\t\tWARN_ON(kip->slot_used[idx] != SLOT_USED);",
        "\t\tif (dirty) {",
        "\t\t\tkip->slot_used[idx] = SLOT_DIRTY;"
      ]
    },
    {
      "file": "linux\\kernel\\kprobes.c",
      "line": 528,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * The optimization/unoptimization refers 'online_cpus' via",
        "\t * stop_machine() and cpu-hotplug modifies the 'online_cpus'.",
        "\t * And same time, 'text_mutex' will be held in cpu-hotplug and here.",
        "\t * This combination can cause a deadlock (cpu-hotplug tries to lock",
        "\t * 'text_mutex' but stop_machine() can not be done because",
        "\t * the 'online_cpus' has been changed)",
        "\t * To avoid this deadlock, caller must have locked cpu-hotplug"
      ]
    },
    {
      "file": "linux\\kernel\\kprobes.c",
      "line": 531,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * This combination can cause a deadlock (cpu-hotplug tries to lock",
        "\t * 'text_mutex' but stop_machine() can not be done because",
        "\t * the 'online_cpus' has been changed)",
        "\t * To avoid this deadlock, caller must have locked cpu-hotplug",
        "\t * for preventing cpu-hotplug outside of 'text_mutex' locking.",
        "\t */",
        "\tlockdep_assert_cpus_held();"
      ]
    },
    {
      "file": "linux\\kernel\\kprobes.c",
      "line": 2482,
      "pattern": "long.*functions",
      "rule": "code_quality",
      "severity": "low",
      "match": "long to the said functions",
      "context": [
        " * Lookup and populate the kprobe_blacklist.",
        " *",
        " * Unlike the kretprobe blacklist, we'll need to determine",
        " * the range of addresses that belong to the said functions,",
        " * since a kprobe need not necessarily be at the beginning",
        " * of a function.",
        " */"
      ]
    },
    {
      "file": "linux\\kernel\\kthread.c",
      "line": 211,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * kthread_should_stop() for freezable kthreads, which will enter",
        " * refrigerator if necessary.  This function is safe from kthread_stop() /",
        " * freezer deadlock and freezable kthreads should use this function instead",
        " * of calling try_to_freeze() directly.",
        " */",
        "bool kthread_freezable_should_stop(bool *was_frozen)"
      ]
    },
    {
      "file": "linux\\kernel\\kthread.c",
      "line": 1368,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * timer_delete_sync() must be called to make sure that the timer",
        "\t * callback is not running. The lock must be temporary released",
        "\t * to avoid a deadlock with the callback. In the meantime,",
        "\t * any queuing is blocked by setting the canceling counter.",
        "\t */",
        "\twork->canceling++;"
      ]
    },
    {
      "file": "linux\\kernel\\panic.c",
      "line": 336,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Disable local interrupts. This will prevent panic_smp_self_stop",
        "\t * from deadlocking the first cpu that invokes the panic, since",
        "\t * there is nothing to prevent an interrupt handler (that runs",
        "\t * after setting panic_cpu) from invoking panic() again.",
        "\t */"
      ]
    },
    {
      "file": "linux\\kernel\\reboot.c",
      "line": 722,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "",
        "/*",
        " * Reboot system call: for obvious reasons only root may call it,",
        " * and even root needs to set up some magic numbers in the registers",
        " * so that some mistake won't make this reboot the whole machine.",
        " * You can also set the meaning of the ctrl-alt-del-key here.",
        " *"
      ]
    },
    {
      "file": "linux\\kernel\\relay.c",
      "line": 573,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tif (waitqueue_active(&buf->read_wait)) {",
        "\t\t\t/*",
        "\t\t\t * Calling wake_up_interruptible() from here",
        "\t\t\t * will deadlock if we happen to be logging",
        "\t\t\t * from the scheduler (trying to re-grab",
        "\t\t\t * rq->lock), so defer it.",
        "\t\t\t */"
      ]
    },
    {
      "file": "linux\\kernel\\smp.c",
      "line": 647,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tthis_cpu = get_cpu();",
        "",
        "\t/*",
        "\t * Can deadlock when called with interrupts disabled.",
        "\t * We allow cpu's that are not yet online though, as no one else can",
        "\t * send smp call function interrupt to this cpu and as such deadlocks",
        "\t * can't happen."
      ]
    },
    {
      "file": "linux\\kernel\\smp.c",
      "line": 649,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Can deadlock when called with interrupts disabled.",
        "\t * We allow cpu's that are not yet online though, as no one else can",
        "\t * send smp call function interrupt to this cpu and as such deadlocks",
        "\t * can't happen.",
        "\t */",
        "\tWARN_ON_ONCE(cpu_online(this_cpu) && irqs_disabled()"
      ]
    },
    {
      "file": "linux\\kernel\\smp.c",
      "line": 656,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t     && !oops_in_progress);",
        "",
        "\t/*",
        "\t * When @wait we can deadlock when we interrupt between llist_add() and",
        "\t * arch_send_call_function_ipi*(); when !@wait we can deadlock due to",
        "\t * csd_lock() on because the interrupt context uses the same csd",
        "\t * storage."
      ]
    },
    {
      "file": "linux\\kernel\\smp.c",
      "line": 657,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * When @wait we can deadlock when we interrupt between llist_add() and",
        "\t * arch_send_call_function_ipi*(); when !@wait we can deadlock due to",
        "\t * csd_lock() on because the interrupt context uses the same csd",
        "\t * storage.",
        "\t */"
      ]
    },
    {
      "file": "linux\\kernel\\smp.c",
      "line": 800,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tlockdep_assert_preemption_disabled();",
        "",
        "\t/*",
        "\t * Can deadlock when called with interrupts disabled.",
        "\t * We allow cpu's that are not yet online though, as no one else can",
        "\t * send smp call function interrupt to this cpu and as such deadlocks",
        "\t * can't happen."
      ]
    },
    {
      "file": "linux\\kernel\\smp.c",
      "line": 802,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Can deadlock when called with interrupts disabled.",
        "\t * We allow cpu's that are not yet online though, as no one else can",
        "\t * send smp call function interrupt to this cpu and as such deadlocks",
        "\t * can't happen.",
        "\t */",
        "\tif (cpu_online(this_cpu) && !oops_in_progress &&"
      ]
    },
    {
      "file": "linux\\kernel\\smp.c",
      "line": 810,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tlockdep_assert_irqs_enabled();",
        "",
        "\t/*",
        "\t * When @wait we can deadlock when we interrupt between llist_add() and",
        "\t * arch_send_call_function_ipi*(); when !@wait we can deadlock due to",
        "\t * csd_lock() on because the interrupt context uses the same csd",
        "\t * storage."
      ]
    },
    {
      "file": "linux\\kernel\\smp.c",
      "line": 811,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * When @wait we can deadlock when we interrupt between llist_add() and",
        "\t * arch_send_call_function_ipi*(); when !@wait we can deadlock due to",
        "\t * csd_lock() on because the interrupt context uses the same csd",
        "\t * storage.",
        "\t */"
      ]
    },
    {
      "file": "linux\\kernel\\softirq.c",
      "line": 507,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * When we run softirqs from irq_exit() and thus on the hardirq stack we need",
        " * to keep the lockdep irq context tracking as tight as possible in order to",
        " * not miss-qualify lock contexts and miss possible deadlocks.",
        " */",
        "",
        "static inline bool lockdep_softirq_start(void)"
      ]
    },
    {
      "file": "linux\\kernel\\signal.c",
      "line": 5016,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * kdb_send_sig - Allows kdb to send signals without exposing",
        " * signal internals.  This function checks if the required locks are",
        " * available before calling the main signal code, to avoid kdb",
        " * deadlocks.",
        " */",
        "void kdb_send_sig(struct task_struct *t, int sig)",
        "{"
      ]
    },
    {
      "file": "linux\\kernel\\signal.c",
      "line": 5033,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tif (!task_is_running(t) && new_t) {",
        "\t\tspin_unlock(&t->sighand->siglock);",
        "\t\tkdb_printf(\"Process is not RUNNING, sending a signal from \"",
        "\t\t\t   \"kdb risks deadlock\\n\"",
        "\t\t\t   \"on the run queue locks. \"",
        "\t\t\t   \"The signal has _not_ been sent.\\n\"",
        "\t\t\t   \"Reissue the kill command if you want to risk \""
      ]
    },
    {
      "file": "linux\\kernel\\signal.c",
      "line": 5037,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t   \"on the run queue locks. \"",
        "\t\t\t   \"The signal has _not_ been sent.\\n\"",
        "\t\t\t   \"Reissue the kill command if you want to risk \"",
        "\t\t\t   \"the deadlock.\\n\");",
        "\t\treturn;",
        "\t}",
        "\tret = send_signal_locked(sig, SEND_SIG_PRIV, t, PIDTYPE_PID);"
      ]
    },
    {
      "file": "linux\\kernel\\stop_machine.c",
      "line": 289,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Ensure that if we race with __stop_cpus() the stoppers won't get",
        "\t * queued up in reverse order leading to system deadlock.",
        "\t *",
        "\t * We can't miss stop_cpus_in_progress if queue_stop_cpus_work() has",
        "\t * queued a work on cpu1 but not on cpu2, we hold both locks."
      ]
    },
    {
      "file": "linux\\kernel\\stop_machine.c",
      "line": 403,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Disable preemption while queueing to avoid getting",
        "\t * preempted by a stopper which might wait for other stoppers",
        "\t * to enter @fn which can lead to deadlock.",
        "\t */",
        "\tpreempt_disable();",
        "\tstop_cpus_in_progress = true;"
      ]
    },
    {
      "file": "linux\\kernel\\torture.c",
      "line": 657,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/* OK, shut down the system. */",
        "",
        "\tVERBOSE_TOROUT_STRING(\"torture_shutdown task shutting down system\");",
        "\tshutdown_task = NULL;\t/* Avoid self-kill deadlock. */",
        "\tif (torture_shutdown_hook)",
        "\t\ttorture_shutdown_hook();",
        "\telse"
      ]
    },
    {
      "file": "linux\\kernel\\watch_queue.c",
      "line": 624,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tspin_unlock_bh(&wqueue->lock);",
        "",
        "\t\t/* We can't do the next bit under the queue lock as we need to",
        "\t\t * get the list lock - which would cause a deadlock if someone",
        "\t\t * was removing from the opposite direction at the same time or",
        "\t\t * posting a notification.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\kernel\\workqueue.c",
      "line": 502,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * I: kthread_worker to release pwq's. pwq release needs to be bounced to a",
        " * process context while holding a pool lock. Bounce to a dedicated kthread",
        " * worker to avoid A-A deadlocks.",
        " */",
        "static struct kthread_worker *pwq_release_worker __ro_after_init;",
        ""
      ]
    },
    {
      "file": "linux\\kernel\\workqueue.c",
      "line": 1099,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * false positives.  Note that this isn't complete as one may construct a",
        " * work function which can introduce dependency onto itself through a",
        " * recycled work item.  Well, if somebody wants to shoot oneself in the",
        " * foot that badly, there's only so much we can do, and if such deadlock",
        " * actually occurs, it should be easy to locate the culprit work function.",
        " *",
        " * CONTEXT:"
      ]
    },
    {
      "file": "linux\\kernel\\workqueue.c",
      "line": 1644,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\treturn;",
        "\t/*",
        "\t * @pwq can't be released under pool->lock, bounce to a dedicated",
        "\t * kthread_worker to avoid A-A deadlocks.",
        "\t */",
        "\tkthread_queue_work(pwq_release_worker, &pwq->release_work);",
        "}"
      ]
    },
    {
      "file": "linux\\kernel\\workqueue.c",
      "line": 3021,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t/*",
        "\t\t * We've been trying to create a new worker but",
        "\t\t * haven't been successful.  We might be hitting an",
        "\t\t * allocation deadlock.  Send distress signals to",
        "\t\t * rescuers.",
        "\t\t */",
        "\t\tlist_for_each_entry(work, &pool->worklist, entry)"
      ]
    },
    {
      "file": "linux\\kernel\\workqueue.c",
      "line": 3042,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * have at least one idle worker on return from this function.  If",
        " * creating a new worker takes longer than MAYDAY_INTERVAL, mayday is",
        " * sent to all rescuers with works scheduled on @pool to resolve",
        " * possible allocation deadlock.",
        " *",
        " * On return, need_to_create_worker() is guaranteed to be %false and",
        " * may_start_working() %true."
      ]
    },
    {
      "file": "linux\\kernel\\workqueue.c",
      "line": 3227,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t *\t\tC(C)",
        "\t *",
        "\t * Which would create W1->C->W1 dependencies, even though there is no",
        "\t * actual deadlock possible. There are two solutions, using a",
        "\t * read-recursive acquire on the work(queue) 'locks', but this will then",
        "\t * hit the lockdep limitation on recursive locks, or simply discard",
        "\t * these locks."
      ]
    },
    {
      "file": "linux\\kernel\\workqueue.c",
      "line": 3232,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * hit the lockdep limitation on recursive locks, or simply discard",
        "\t * these locks.",
        "\t *",
        "\t * AFAICT there is no possible deadlock scenario between the",
        "\t * flush_work() and complete() primitives (except for single-threaded",
        "\t * workqueues), so hiding them isn't a problem.",
        "\t */"
      ]
    },
    {
      "file": "linux\\kernel\\workqueue.c",
      "line": 3265,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * The following prevents a kworker from hogging CPU on !PREEMPTION",
        "\t * kernels, where a requeueing work item waiting for something to",
        "\t * happen could deadlock with stop_machine as such work item could",
        "\t * indefinitely requeue itself while all other CPUs are trapped in",
        "\t * stop_machine. At the same time, report a quiescent RCU state so",
        "\t * the same condition doesn't freeze RCU."
      ]
    },
    {
      "file": "linux\\kernel\\workqueue.c",
      "line": 3430,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * Regular work processing on a pool may block trying to create a new",
        " * worker which uses GFP_KERNEL allocation which has slight chance of",
        " * developing into deadlock if some works currently on the same queue",
        " * need to be processed to satisfy the GFP_KERNEL allocation.  This is",
        " * the problem rescuer solves.",
        " *"
      ]
    },
    {
      "file": "linux\\kernel\\workqueue.c",
      "line": 3701,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * already running, or will not be at all), check if @target_wq doesn't have",
        " * %WQ_MEM_RECLAIM and verify that %current is not reclaiming memory or running",
        " * on a workqueue which doesn't have %WQ_MEM_RECLAIM as that can break forward-",
        " * progress guarantee leading to a deadlock.",
        " */",
        "static void check_flush_dependency(struct workqueue_struct *target_wq,",
        "\t\t\t\t   struct work_struct *target_work,"
      ]
    },
    {
      "file": "linux\\kernel\\workqueue.c",
      "line": 3775,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * debugobject calls are safe here even with pool->lock locked",
        "\t * as we know for sure that this will not trigger any of the",
        "\t * checks and call back into the fixup functions where we",
        "\t * might deadlock.",
        "\t *",
        "\t * BH and threaded workqueues need separate lockdep keys to avoid",
        "\t * spuriously triggering \"inconsistent {SOFTIRQ-ON-W} -> {IN-SOFTIRQ-W}"
      ]
    },
    {
      "file": "linux\\kernel\\workqueue.c",
      "line": 4181,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\ttouch_work_lockdep_map(work, wq);",
        "",
        "\t/*",
        "\t * Force a lock recursion deadlock when using flush_work() inside a",
        "\t * single-threaded or rescuer equipped workqueue.",
        "\t *",
        "\t * For single threaded workqueues the deadlock happens when the work"
      ]
    },
    {
      "file": "linux\\kernel\\workqueue.c",
      "line": 4184,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * Force a lock recursion deadlock when using flush_work() inside a",
        "\t * single-threaded or rescuer equipped workqueue.",
        "\t *",
        "\t * For single threaded workqueues the deadlock happens when the work",
        "\t * is after the work issuing the flush_work(). For rescuer equipped",
        "\t * workqueues the deadlock happens when the rescuer stalls, blocking",
        "\t * forward progress."
      ]
    },
    {
      "file": "linux\\kernel\\workqueue.c",
      "line": 4186,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t *",
        "\t * For single threaded workqueues the deadlock happens when the work",
        "\t * is after the work issuing the flush_work(). For rescuer equipped",
        "\t * workqueues the deadlock happens when the rescuer stalls, blocking",
        "\t * forward progress.",
        "\t */",
        "\tif (!from_cancel && (wq->saved_max_active == 1 || wq->rescuer))"
      ]
    },
    {
      "file": "linux\\kernel\\workqueue.c",
      "line": 6342,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\traw_spin_lock_irqsave(&pwq->pool->lock, irq_flags);",
        "\t\tif (!pwq_is_empty(pwq)) {",
        "\t\t\t/*",
        "\t\t\t * Defer printing to avoid deadlocks in console",
        "\t\t\t * drivers that queue work while holding locks",
        "\t\t\t * also taken in their write paths.",
        "\t\t\t */"
      ]
    },
    {
      "file": "linux\\kernel\\workqueue.c",
      "line": 6381,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\thung = jiffies_to_msecs(jiffies - pool->watchdog_ts) / 1000;",
        "",
        "\t/*",
        "\t * Defer printing to avoid deadlocks in console drivers that",
        "\t * queue work while holding locks also taken in their write",
        "\t * paths.",
        "\t */"
      ]
    },
    {
      "file": "linux\\kernel\\workqueue.c",
      "line": 7511,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\thash_for_each(pool->busy_hash, bkt, worker, hentry) {",
        "\t\tif (task_is_running(worker->task)) {",
        "\t\t\t/*",
        "\t\t\t * Defer printing to avoid deadlocks in console",
        "\t\t\t * drivers that queue work while holding locks",
        "\t\t\t * also taken in their write paths.",
        "\t\t\t */"
      ]
    },
    {
      "file": "linux\\mm\\kmemleak.c",
      "line": 22,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory block. The kmemleak",
      "context": [
        " *   object_list is the main list holding the metadata (struct",
        " *   kmemleak_object) for the allocated memory blocks. The object trees are",
        " *   red black trees used to look-up metadata based on a pointer to the",
        " *   corresponding memory block. The kmemleak_object structures are added to",
        " *   the object_list and the object tree root in the create_object() function",
        " *   called from the kmemleak_alloc{,_phys,_percpu}() callback and removed in",
        " *   delete_object() called from the kmemleak_free{,_phys,_percpu}() callback"
      ]
    },
    {
      "file": "linux\\mm\\kmemleak.c",
      "line": 237,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory scanning, parameters and debug/kmemleak",
      "context": [
        "static unsigned long jiffies_scan_wait;",
        "/* enables or disables the task stacks scanning */",
        "static int kmemleak_stack_scan = 1;",
        "/* protects the memory scanning, parameters and debug/kmemleak file access */",
        "static DEFINE_MUTEX(scan_mutex);",
        "/* setting kmemleak=on, will set this var, skipping the disable */",
        "static int kmemleak_skip_disable;"
      ]
    },
    {
      "file": "linux\\mm\\kmemleak.c",
      "line": 415,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory block metadata (kmemleak",
      "context": [
        "}",
        "",
        "/*",
        " * Look-up a memory block metadata (kmemleak_object) in the object search",
        " * tree based on a pointer value. If alias is 0, only values pointing to the",
        " * beginning of the memory block are allowed. The kmemleak_lock must be held",
        " * when calling this function."
      ]
    },
    {
      "file": "linux\\mm\\kmemleak.c",
      "line": 417,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory block are allowed. The kmemleak",
      "context": [
        "/*",
        " * Look-up a memory block metadata (kmemleak_object) in the object search",
        " * tree based on a pointer value. If alias is 0, only values pointing to the",
        " * beginning of the memory block are allowed. The kmemleak_lock must be held",
        " * when calling this function.",
        " */",
        "static struct kmemleak_object *__lookup_object(unsigned long ptr, int alias,"
      ]
    },
    {
      "file": "linux\\mm\\kmemleak.c",
      "line": 467,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "Memory pool allocation and freeing. kmemleak",
      "context": [
        "}",
        "",
        "/*",
        " * Memory pool allocation and freeing. kmemleak_lock must not be held.",
        " */",
        "static struct kmemleak_object *mem_pool_alloc(gfp_t gfp)",
        "{"
      ]
    },
    {
      "file": "linux\\mm\\kmemleak.c",
      "line": 491,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "Memory pool empty, consider increasing CONFIG_DEBUG_KMEMLEAK",
      "context": [
        "\telse if (mem_pool_free_count)",
        "\t\tobject = &mem_pool[--mem_pool_free_count];",
        "\telse",
        "\t\tpr_warn_once(\"Memory pool empty, consider increasing CONFIG_DEBUG_KMEMLEAK_MEM_POOL_SIZE\\n\");",
        "\traw_spin_unlock_irqrestore(&kmemleak_lock, flags);",
        "",
        "\treturn object;"
      ]
    },
    {
      "file": "linux\\mm\\kmemleak.c",
      "line": 1068,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        " * @size:\tsize of the object",
        " * @min_count:\tminimum number of references to this object. If during memory",
        " *\t\tscanning a number of references less than @min_count is found,",
        " *\t\tthe object is reported as a memory leak. If @min_count is 0,",
        " *\t\tthe object is never reported as a leak. If @min_count is -1,",
        " *\t\tthe object is ignored (not scanned and not reported as a leak)",
        " * @gfp:\tkmalloc() flags used for kmemleak internal memory allocations"
      ]
    },
    {
      "file": "linux\\mm\\kmemleak.c",
      "line": 1549,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory block corresponding to a kmemleak",
      "context": [
        "#endif",
        "",
        "/*",
        " * Scan a memory block corresponding to a kmemleak_object. A condition is",
        " * that object->use_count >= 1.",
        " */",
        "static void scan_object(struct kmemleak_object *object)"
      ]
    },
    {
      "file": "linux\\mm\\kmemleak.c",
      "line": 1615,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "",
        "/*",
        " * Scan the objects already referenced (gray objects). More objects will be",
        " * referenced and, if there are no memory leaks, all the objects are scanned.",
        " */",
        "static void scan_gray_list(void)",
        "{"
      ]
    },
    {
      "file": "linux\\mm\\kmemleak.c",
      "line": 1856,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leaks (see /sys/kernel/debug/kmemleak",
      "context": [
        "\tif (new_leaks) {",
        "\t\tkmemleak_found_leaks = true;",
        "",
        "\t\tpr_info(\"%d new suspected memory leaks (see /sys/kernel/debug/kmemleak)\\n\",",
        "\t\t\tnew_leaks);",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\mm\\kmemleak.c",
      "line": 2196,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory scanning thread and free the kmemleak",
      "context": [
        "}",
        "",
        "/*",
        " * Stop the memory scanning thread and free the kmemleak internal objects if",
        " * no previous scan thread (otherwise, kmemleak may still have some useful",
        " * information on memory leaks).",
        " */"
      ]
    },
    {
      "file": "linux\\mm\\kmemleak.c",
      "line": 2198,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "/*",
        " * Stop the memory scanning thread and free the kmemleak internal objects if",
        " * no previous scan thread (otherwise, kmemleak may still have some useful",
        " * information on memory leaks).",
        " */",
        "static void kmemleak_do_cleanup(struct work_struct *work)",
        "{"
      ]
    },
    {
      "file": "linux\\mm\\kmemleak.c",
      "line": 2217,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory with \\\"echo clear > /sys/kernel/debug/kmemleak",
      "context": [
        "\tif (!kmemleak_found_leaks)",
        "\t\t__kmemleak_do_cleanup();",
        "\telse",
        "\t\tpr_info(\"Kmemleak disabled without freeing internal data. Reclaim the memory with \\\"echo clear > /sys/kernel/debug/kmemleak\\\".\\n\");",
        "}",
        "",
        "static DECLARE_WORK(cleanup_work, kmemleak_do_cleanup);"
      ]
    },
    {
      "file": "linux\\mm\\kmemleak.c",
      "line": 2241,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\telse",
        "\t\tkmemleak_free_enabled = 0;",
        "",
        "\tpr_info(\"Kernel memory leak detector disabled\\n\");",
        "}",
        "",
        "/*"
      ]
    },
    {
      "file": "linux\\mm\\kmemleak.c",
      "line": 2322,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\t\tmutex_unlock(&scan_mutex);",
        "\t}",
        "",
        "\tpr_info(\"Kernel memory leak detector initialized (mem pool available: %d)\\n\",",
        "\t\tmem_pool_free_count);",
        "",
        "\treturn 0;"
      ]
    },
    {
      "file": "linux\\mm\\maccess.c",
      "line": 18,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory isn't leak",
      "context": [
        "",
        "/*",
        " * The below only uses kmsan_check_memory() to ensure uninitialized kernel",
        " * memory isn't leaked.",
        " */",
        "#define copy_from_kernel_nofault_loop(dst, src, len, type, err_label)\t\\",
        "\twhile (len >= sizeof(type)) {\t\t\t\t\t\\"
      ]
    },
    {
      "file": "linux\\mm\\memblock.c",
      "line": 1525,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory block, it is never reported as leak",
      "context": [
        " * memory region.",
        " *",
        " * In addition, function using kmemleak_alloc_phys for allocated boot",
        " * memory block, it is never reported as leaks.",
        " *",
        " * Return:",
        " * Physical address of allocated memory block on success, %0 on failure."
      ]
    },
    {
      "file": "linux\\mm\\memory-failure.c",
      "line": 953,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        " * XXX: It is possible that a page is isolated from LRU cache,",
        " * and then kept in swap cache or failed to remove from page cache.",
        " * The page count will stop it from being freed by unpoison.",
        " * Stress tests should be aware of this memory leak problem.",
        " */",
        "static int delete_from_lru_cache(struct folio *folio)",
        "{"
      ]
    },
    {
      "file": "linux\\mm\\memory.c",
      "line": 6534,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        " *",
        " * If the PTE maps a refcounted page, callers are responsible to protect",
        " * against invalidation with MMU notifiers; otherwise access to the PFN at",
        " * a later point in time can trigger use-after-free.",
        " *",
        " * Only IO mappings and raw PFN mappings are allowed.  The mmap semaphore",
        " * should be taken for read, and the mmap semaphore cannot be released"
      ]
    },
    {
      "file": "linux\\mm\\page_ext.c",
      "line": 414,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "",
        "\t/*",
        "\t * Freeing of page_ext is done in 3 steps to avoid",
        "\t * use-after-free of it:",
        "\t * 1) Traverse all the sections and mark their page_ext",
        "\t *    as invalid.",
        "\t * 2) Wait for all the existing users of page_ext who"
      ]
    },
    {
      "file": "linux\\mm\\slab_common.c",
      "line": 464,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "",
        "/*",
        " * For a given kmem_cache, kmem_cache_destroy() should only be called",
        " * once or there will be a use-after-free problem. The actual deletion",
        " * and release of the kobject does not need slab_mutex or cpu_hotplug_lock",
        " * protection. So they are now done without holding those locks.",
        " */"
      ]
    },
    {
      "file": "linux\\mm\\slab_common.c",
      "line": 1237,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free or double-free",
      "context": [
        "\t * We need to first check that the pointer to the object is valid.",
        "\t * The KASAN report printed from ksize() is more useful, then when",
        "\t * it's printed later when the behaviour could be undefined due to",
        "\t * a potential use-after-free or double-free.",
        "\t *",
        "\t * We use kasan_check_byte(), which is supported for the hardware",
        "\t * tag-based KASAN mode, unlike kasan_check_read/write()."
      ]
    },
    {
      "file": "linux\\mm\\slab_common.c",
      "line": 1237,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double-free",
      "context": [
        "\t * We need to first check that the pointer to the object is valid.",
        "\t * The KASAN report printed from ksize() is more useful, then when",
        "\t * it's printed later when the behaviour could be undefined due to",
        "\t * a potential use-after-free or double-free.",
        "\t *",
        "\t * We use kasan_check_byte(), which is supported for the hardware",
        "\t * tag-based KASAN mode, unlike kasan_check_read/write()."
      ]
    },
    {
      "file": "linux\\mm\\slab_common.c",
      "line": 1599,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double-argument of kvfree",
      "context": [
        "",
        "\t/*",
        "\t * This is used when the \"bulk\" path can not be used for the",
        "\t * double-argument of kvfree_rcu().  This happens when the",
        "\t * page-cache is empty, which means that objects are instead",
        "\t * queued on a linked list through their rcu_head structures.",
        "\t * This list is named \"Channel 3\"."
      ]
    },
    {
      "file": "linux\\mm\\slab_common.c",
      "line": 1954,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double kfree",
      "context": [
        "",
        "\t// Queue the object but don't yet schedule the batch.",
        "\tif (debug_rcu_head_queue(ptr)) {",
        "\t\t// Probable double kfree_rcu(), just leak.",
        "\t\tWARN_ONCE(1, \"%s(): Double-freed call. rcu_head %p\\n\",",
        "\t\t\t  __func__, head);",
        ""
      ]
    },
    {
      "file": "linux\\mm\\slab_common.c",
      "line": 1955,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "Double-free",
      "context": [
        "\t// Queue the object but don't yet schedule the batch.",
        "\tif (debug_rcu_head_queue(ptr)) {",
        "\t\t// Probable double kfree_rcu(), just leak.",
        "\t\tWARN_ONCE(1, \"%s(): Double-freed call. rcu_head %p\\n\",",
        "\t\t\t  __func__, head);",
        "",
        "\t\t// Mark as success and leave."
      ]
    },
    {
      "file": "linux\\mm\\slub.c",
      "line": 1162,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t\t/*",
        "\t\t * Here and below, avoid overwriting the KMSAN shadow. Keeping",
        "\t\t * the shadow makes it possible to distinguish uninit-value",
        "\t\t * from use-after-free.",
        "\t\t */",
        "\t\tmemset_no_sanitize_memory(p - s->red_left_pad, val,",
        "\t\t\t\t\t  s->red_left_pad);"
      ]
    },
    {
      "file": "linux\\mm\\slub.c",
      "line": 2314,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "Use KCSAN to help debug racy use-after-free",
      "context": [
        "\tif (!(s->flags & SLAB_DEBUG_OBJECTS))",
        "\t\tdebug_check_no_obj_freed(x, s->object_size);",
        "",
        "\t/* Use KCSAN to help debug racy use-after-free. */",
        "\tif (!still_accessible)",
        "\t\t__kcsan_check_access(x, s->object_size,",
        "\t\t\t\t     KCSAN_ACCESS_WRITE | KCSAN_ACCESS_ASSERT);"
      ]
    },
    {
      "file": "linux\\mm\\slub.c",
      "line": 370,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "DOUBLE_FAIL,\t/* Failures of slab free",
      "context": [
        "\tDEACTIVATE_BYPASS,\t/* Implicit deactivation */",
        "\tORDER_FALLBACK,\t\t/* Number of times fallback was necessary */",
        "\tCMPXCHG_DOUBLE_CPU_FAIL,/* Failures of this_cpu_cmpxchg_double */",
        "\tCMPXCHG_DOUBLE_FAIL,\t/* Failures of slab freelist update */",
        "\tCPU_PARTIAL_ALLOC,\t/* Used cpu partial on alloc */",
        "\tCPU_PARTIAL_FREE,\t/* Refill cpu partial on free */",
        "\tCPU_PARTIAL_NODE,\t/* Refill cpu partial from node partial */"
      ]
    },
    {
      "file": "linux\\mm\\slub.c",
      "line": 546,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double free",
      "context": [
        "\tunsigned long freeptr_addr = (unsigned long)object + s->offset;",
        "",
        "#ifdef CONFIG_SLAB_FREELIST_HARDENED",
        "\tBUG_ON(object == fp); /* naive detection of double free or corruption */",
        "#endif",
        "",
        "\tfreeptr_addr = (unsigned long)kasan_reset_tag((void *)freeptr_addr);"
      ]
    },
    {
      "file": "linux\\mm\\slub.c",
      "line": 4857,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double-free",
      "context": [
        "\tif (unlikely(ZERO_OR_NULL_PTR(p)))",
        "\t\tgoto alloc_new;",
        "",
        "\t/* Check for double-free. */",
        "\tif (!kasan_check_byte(p))",
        "\t\treturn NULL;",
        ""
      ]
    },
    {
      "file": "linux\\mm\\swapfile.c",
      "line": 2816,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "USED flag after all resources are free",
      "context": [
        "\tfilp_close(swap_file, NULL);",
        "",
        "\t/*",
        "\t * Clear the SWP_USED flag after all resources are freed so that swapon",
        "\t * can reuse this swap_info in alloc_swap_info() safely.  It is ok to",
        "\t * not hold p->lock after we cleared its SWP_WRITEOK.",
        "\t */"
      ]
    },
    {
      "file": "linux\\net\\socket.c",
      "line": 444,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " *\tfunction will increment ref. count on file by 1.",
        " *",
        " *\tIn any case returned fd MAY BE not valid!",
        " *\tThis race condition is unavoidable",
        " *\twith shared fd spaces, we cannot solve it inside kernel,",
        " *\tbut we take care of internal coherence yet.",
        " */"
      ]
    },
    {
      "file": "linux\\net\\socket.c",
      "line": 1488,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/* Compatibility.",
        "",
        "\t   This uglymoron is moved from INET layer to here to avoid",
        "\t   deadlock in module load.",
        "\t */",
        "\tif (family == PF_INET && type == SOCK_PACKET) {",
        "\t\tpr_info_once(\"%s uses obsolete (PF_INET,SOCK_PACKET)\\n\","
      ]
    },
    {
      "file": "linux\\arch\\arm\\kernel\\hw_breakpoint.c",
      "line": 1079,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double lock",
      "context": [
        "\t\tbreak;",
        "\tcase ARM_DEBUG_ARCH_V7_1:",
        "\t\t/*",
        "\t\t * Ensure the OS double lock is clear.",
        "\t\t */",
        "\t\tARM_DBG_READ(c1, c3, 4, val);",
        "\t\tif ((val & 0x1) == 1)"
      ]
    },
    {
      "file": "linux\\arch\\arm\\kernel\\traps.c",
      "line": 314,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\toops_enter();",
        "",
        "\t/* racy, but better than risking deadlock. */",
        "\traw_local_irq_save(flags);",
        "\tcpu = smp_processor_id();",
        "\tif (!arch_spin_trylock(&die_lock)) {"
      ]
    },
    {
      "file": "linux\\arch\\arm\\kernel\\topology.c",
      "line": 124,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing clock",
      "context": [
        "",
        "\t\trate = of_get_property(cn, \"clock-frequency\", &len);",
        "\t\tif (!rate || len != 4) {",
        "\t\t\tpr_err(\"%pOF missing clock-frequency property\\n\", cn);",
        "\t\t\tcontinue;",
        "\t\t}",
        ""
      ]
    },
    {
      "file": "linux\\arch\\arm\\mm\\fault.c",
      "line": 165,
      "pattern": "null.*pointer.*dereference",
      "rule": "memory_management",
      "severity": "high",
      "match": "NULL pointer dereference",
      "context": [
        "\t * No handler, we'll have to terminate things with extreme prejudice.",
        "\t */",
        "\tif (addr < PAGE_SIZE) {",
        "\t\tmsg = \"NULL pointer dereference\";",
        "\t} else {",
        "\t\tif (is_translation_fault(fsr) &&",
        "\t\t    kfence_handle_page_fault(addr, is_write_fault(fsr), regs))"
      ]
    },
    {
      "file": "linux\\arch\\arm64\\kernel\\cpufeature.c",
      "line": 551,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DoubleLock",
      "context": [
        "};",
        "",
        "static const struct arm64_ftr_bits ftr_id_aa64dfr0[] = {",
        "\tS_ARM64_FTR_BITS(FTR_HIDDEN, FTR_STRICT, FTR_LOWER_SAFE, ID_AA64DFR0_EL1_DoubleLock_SHIFT, 4, 0),",
        "\tARM64_FTR_BITS(FTR_HIDDEN, FTR_NONSTRICT, FTR_LOWER_SAFE, ID_AA64DFR0_EL1_PMSVer_SHIFT, 4, 0),",
        "\tARM64_FTR_BITS(FTR_HIDDEN, FTR_STRICT, FTR_LOWER_SAFE, ID_AA64DFR0_EL1_CTX_CMPs_SHIFT, 4, 0),",
        "\tARM64_FTR_BITS(FTR_HIDDEN, FTR_STRICT, FTR_LOWER_SAFE, ID_AA64DFR0_EL1_WRPs_SHIFT, 4, 0),"
      ]
    },
    {
      "file": "linux\\arch\\arm64\\kernel\\sdei.c",
      "line": 238,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tif (elr != read_sysreg(elr_el1)) {",
        "\t\t/*",
        "\t\t * We took a synchronous exception from the SDEI handler.",
        "\t\t * This could deadlock, and if you interrupt KVM it will",
        "\t\t * hyp-panic instead.",
        "\t\t */",
        "\t\tpr_warn(\"unsafe: exception during handler\\n\");"
      ]
    },
    {
      "file": "linux\\arch\\arm64\\kernel\\topology.c",
      "line": 445,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "{",
        "\t/*",
        "\t * Abort call on counterless CPU or when interrupts are",
        "\t * disabled - can lead to deadlock in smp sync call.",
        "\t */",
        "\tif (!cpu_has_amu_feat(cpu))",
        "\t\treturn -EOPNOTSUPP;"
      ]
    },
    {
      "file": "linux\\arch\\arm64\\mm\\fault.c",
      "line": 399,
      "pattern": "null.*pointer.*dereference",
      "rule": "memory_management",
      "severity": "high",
      "match": "NULL pointer dereference",
      "context": [
        "\t\telse",
        "\t\t\tmsg = \"read from unreadable memory\";",
        "\t} else if (addr < PAGE_SIZE) {",
        "\t\tmsg = \"NULL pointer dereference\";",
        "\t} else {",
        "\t\tif (esr_fsc_is_translation_fault(esr) &&",
        "\t\t    kfence_handle_page_fault(addr, esr & ESR_ELx_WNR, regs))"
      ]
    },
    {
      "file": "linux\\arch\\arm64\\mm\\pageattr.c",
      "line": 259,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory, %d pages will be leak",
      "context": [
        "\t * If the request to change state fails, then the only sensible cause",
        "\t * of action for the caller is to leak the memory",
        "\t */",
        "\tWARN(ret, \"Failed to encrypt memory, %d pages will be leaked\",",
        "\t     numpages);",
        "",
        "\treturn ret;"
      ]
    },
    {
      "file": "linux\\arch\\arm64\\mm\\pageattr.c",
      "line": 269,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory, %d pages will be leak",
      "context": [
        "{",
        "\tint ret = __set_memory_enc_dec(addr, numpages, false);",
        "",
        "\tWARN(ret, \"Failed to decrypt memory, %d pages will be leaked\",",
        "\t     numpages);",
        "",
        "\treturn ret;"
      ]
    },
    {
      "file": "linux\\arch\\m68k\\mm\\fault.c",
      "line": 48,
      "pattern": "null.*pointer.*dereference",
      "rule": "memory_management",
      "severity": "high",
      "match": "NULL pointer dereference",
      "context": [
        "\t\t * terminate things with extreme prejudice.",
        "\t\t */",
        "\t\tif ((unsigned long)addr < PAGE_SIZE)",
        "\t\t\tpr_alert(\"Unable to handle kernel NULL pointer dereference\");",
        "\t\telse",
        "\t\t\tpr_alert(\"Unable to handle kernel access\");",
        "\t\tpr_cont(\" at virtual address %p\\n\", addr);"
      ]
    },
    {
      "file": "linux\\arch\\mips\\kernel\\mips-cm.c",
      "line": 341,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * may modify the redirect register. We do so here in a",
        "\t\t * slightly obscure way by using a spin lock, since this has",
        "\t\t * the neat property of also catching any nested uses of",
        "\t\t * mips_cm_lock_other() leading to a deadlock or a nice warning",
        "\t\t * with lockdep enabled.",
        "\t\t */",
        "\t\tspin_lock_irqsave(this_cpu_ptr(&cm_core_lock),"
      ]
    },
    {
      "file": "linux\\arch\\nios2\\mm\\fault.c",
      "line": 192,
      "pattern": "null.*pointer.*dereference",
      "rule": "memory_management",
      "severity": "high",
      "match": "NULL pointer dereference",
      "context": [
        "\tbust_spinlocks(1);",
        "",
        "\tpr_alert(\"Unable to handle kernel %s at virtual address %08lx\",",
        "\t\taddress < PAGE_SIZE ? \"NULL pointer dereference\" :",
        "\t\t\"paging request\", address);",
        "\tpr_alert(\"ea = %08lx, ra = %08lx, cause = %ld\\n\", regs->ea, regs->ra,",
        "\t\tcause);"
      ]
    },
    {
      "file": "linux\\arch\\openrisc\\kernel\\setup.c",
      "line": 153,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing CPU 'clock",
      "context": [
        "\tif (of_property_read_u32(cpu, \"clock-frequency\",",
        "\t\t\t\t &cpuinfo->clock_frequency)) {",
        "\t\tprintk(KERN_WARNING",
        "\t\t       \"Device tree missing CPU 'clock-frequency' parameter.\"",
        "\t\t       \"Assuming frequency 25MHZ\"",
        "\t\t       \"This is probably not what you want.\");",
        "\t}"
      ]
    },
    {
      "file": "linux\\arch\\openrisc\\mm\\fault.c",
      "line": 248,
      "pattern": "null.*pointer.*dereference",
      "rule": "memory_management",
      "severity": "high",
      "match": "NULL pointer dereference",
      "context": [
        "",
        "\tif ((unsigned long)(address) < PAGE_SIZE)",
        "\t\tprintk(KERN_ALERT",
        "\t\t       \"Unable to handle kernel NULL pointer dereference\");",
        "\telse",
        "\t\tprintk(KERN_ALERT \"Unable to handle kernel access\");",
        "\tprintk(\" at virtual address 0x%08lx\\n\", address);"
      ]
    },
    {
      "file": "linux\\arch\\parisc\\kernel\\firmware.c",
      "line": 1282,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * down the system. Under hardware control pressing the power button",
        " * powers off the system immediately.",
        " *",
        " * The _panic version relies on spin_trylock to prevent deadlock",
        " * on panic path.",
        " */",
        "int pdc_soft_power_button(int sw_control)"
      ]
    },
    {
      "file": "linux\\arch\\powerpc\\kernel\\traps.c",
      "line": 188,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\toops_enter();",
        "",
        "\t/* racy, but better than risking deadlock. */",
        "\traw_local_irq_save(flags);",
        "\tcpu = smp_processor_id();",
        "\tif (!arch_spin_trylock(&die_lock)) {"
      ]
    },
    {
      "file": "linux\\arch\\powerpc\\kernel\\watchdog.c",
      "line": 208,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Double check some things under lock",
      "context": [
        "\tint c;",
        "",
        "\twd_smp_lock(&flags);",
        "\t/* Double check some things under lock */",
        "\ttb = get_tb();",
        "\tlast_reset = wd_smp_last_reset_tb;",
        "\tif ((s64)(tb - last_reset) < (s64)wd_smp_panic_timeout_tb)"
      ]
    },
    {
      "file": "linux\\arch\\powerpc\\kernel\\watchdog.c",
      "line": 331,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Double check under lock",
      "context": [
        "",
        "none_pending:",
        "\t\t/*",
        "\t\t * Double check under lock because more than one CPU could see",
        "\t\t * a clear mask with the lockless check after clearing their",
        "\t\t * pending bits.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\arch\\powerpc\\mm\\fault.c",
      "line": 621,
      "pattern": "null.*pointer.*dereference",
      "rule": "memory_management",
      "severity": "high",
      "match": "NULL pointer dereference",
      "context": [
        "\t/* kernel has accessed a bad area */",
        "",
        "\tif (regs->dar < PAGE_SIZE)",
        "\t\tmsg = \"Kernel NULL pointer dereference\";",
        "\telse",
        "\t\tmsg = \"Unable to handle kernel data access\";",
        ""
      ]
    },
    {
      "file": "linux\\arch\\riscv\\kernel\\unaligned_access_speed.c",
      "line": 118,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\t/*",
        "\t * Set the value of fast_misaligned_access of a CPU. These operations",
        "\t * are atomic to avoid race conditions.",
        "\t */",
        "\tif (speed == RISCV_HWPROBE_MISALIGNED_SCALAR_FAST)",
        "\t\tcpumask_set_cpu(cpu, &fast_misaligned_access);"
      ]
    },
    {
      "file": "linux\\arch\\riscv\\mm\\fault.c",
      "line": 103,
      "pattern": "null.*pointer.*dereference",
      "rule": "memory_management",
      "severity": "high",
      "match": "NULL pointer dereference",
      "context": [
        "\t * terminate things with extreme prejudice.",
        "\t */",
        "\tif (addr < PAGE_SIZE)",
        "\t\tmsg = \"NULL pointer dereference\";",
        "\telse {",
        "\t\tif (kfence_handle_page_fault(addr, regs->cause == EXC_STORE_PAGE_FAULT, regs))",
        "\t\t\treturn;"
      ]
    },
    {
      "file": "linux\\arch\\s390\\mm\\gmap.c",
      "line": 2421,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        " *",
        " * If the ASCE is a SEGMENT type then this function will return -EINVAL,",
        " * otherwise the pointers in the host_to_guest radix tree will keep pointing",
        " * to the wrong pages, causing use-after-free and memory corruption.",
        " * If the allocation of the new top level page table fails, the ASCE is not",
        " * replaced.",
        " * In any case, the old ASCE is always removed from the gmap CRST list."
      ]
    },
    {
      "file": "linux\\arch\\sh\\mm\\fault.c",
      "line": 212,
      "pattern": "null.*pointer.*dereference",
      "rule": "memory_management",
      "severity": "high",
      "match": "NULL pointer dereference",
      "context": [
        "\t\treturn;",
        "",
        "\tpr_alert(\"BUG: unable to handle kernel %s at %08lx\\n\",",
        "\t\t address < PAGE_SIZE ? \"NULL pointer dereference\"",
        "\t\t\t\t     : \"paging request\",",
        "\t\t address);",
        "\tpr_alert(\"PC:\");"
      ]
    },
    {
      "file": "linux\\arch\\sparc\\kernel\\process_32.c",
      "line": 235,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/* do_fork() grabs the parent semaphore, we must release it",
        "\t * temporarily so we can build the child clone stack frame",
        "\t * without deadlocking.",
        "\t */",
        "\tif (__copy_user(sp, src, size))",
        "\t\tsp = NULL;"
      ]
    },
    {
      "file": "linux\\arch\\sparc\\kernel\\process_32.c",
      "line": 293,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * A new process must start with interrupts disabled, see schedule_tail()",
        "\t * and finish_task_switch(). (If we do not do it and if a timer interrupt",
        "\t * hits before we unlock and attempts to take the rq->lock, we deadlock.)",
        "\t *",
        "\t * Thus, kpsr |= PSR_PIL.",
        "\t */"
      ]
    },
    {
      "file": "linux\\arch\\sparc\\kernel\\smp_64.c",
      "line": 593,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\tint i, this_busy_nack = 0;",
        "",
        "\t\t\t/* Delay some random time with interrupts enabled",
        "\t\t\t * to prevent deadlock.",
        "\t\t\t */",
        "\t\t\tudelay(2 * nack_busy_id);",
        ""
      ]
    },
    {
      "file": "linux\\arch\\sparc\\kernel\\unaligned_32.c",
      "line": 223,
      "pattern": "null.*pointer.*dereference",
      "rule": "memory_management",
      "severity": "high",
      "match": "NULL pointer dereference",
      "context": [
        "\tif (!entry) {",
        "\t\tunsigned long address = compute_effective_address(regs, insn);",
        "        \tif(address < PAGE_SIZE) {",
        "                \tprintk(KERN_ALERT \"Unable to handle kernel NULL pointer dereference in mna handler\");",
        "        \t} else",
        "                \tprintk(KERN_ALERT \"Unable to handle kernel paging request in mna handler\");",
        "\t        printk(KERN_ALERT \" at virtual address %08lx\\n\",address);"
      ]
    },
    {
      "file": "linux\\arch\\sparc\\mm\\fault_32.c",
      "line": 45,
      "pattern": "null.*pointer.*dereference",
      "rule": "memory_management",
      "severity": "high",
      "match": "NULL pointer dereference",
      "context": [
        "{",
        "\tif ((unsigned long) address < PAGE_SIZE) {",
        "\t\tprintk(KERN_ALERT",
        "\t\t    \"Unable to handle kernel NULL pointer dereference\\n\");",
        "\t} else {",
        "\t\tprintk(KERN_ALERT \"Unable to handle kernel paging request at virtual address %08lx\\n\",",
        "\t\t       address);"
      ]
    },
    {
      "file": "linux\\arch\\um\\kernel\\trap.c",
      "line": 70,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * For example, if we have a kernel bug that causes a page",
        " * fault, we don't want to just use mmap_read_lock() to get",
        " * the mm lock, because that would deadlock if the bug were",
        " * to happen while we're holding the mm lock for writing.",
        " *",
        " * So this checks the exception tables on kernel faults in"
      ]
    },
    {
      "file": "linux\\arch\\x86\\kernel\\crash.c",
      "line": 122,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tcpu_emergency_stop_pt();",
        "",
        "#ifdef CONFIG_X86_IO_APIC",
        "\t/* Prevent crash_kexec() from deadlocking on ioapic_lock. */",
        "\tioapic_zap_locks();",
        "\tclear_IO_APIC();",
        "#endif"
      ]
    },
    {
      "file": "linux\\arch\\x86\\kernel\\dumpstack.c",
      "line": 337,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\toops_enter();",
        "",
        "\t/* racy, but better than risking deadlock. */",
        "\traw_local_irq_save(flags);",
        "\tcpu = smp_processor_id();",
        "\tif (!arch_spin_trylock(&die_lock)) {"
      ]
    },
    {
      "file": "linux\\arch\\x86\\kernel\\reboot.c",
      "line": 948,
      "pattern": "null.*pointer.*dereference",
      "rule": "memory_management",
      "severity": "high",
      "match": "NULL pointer dereference",
      "context": [
        "",
        "\t/*",
        "\t * Leave the nmi callback set, shootdown is a one-time thing.  Clearing",
        "\t * the callback could result in a NULL pointer dereference if a CPU",
        "\t * (finally) responds after the timeout expires.",
        "\t */",
        "}"
      ]
    },
    {
      "file": "linux\\arch\\x86\\mm\\fault.c",
      "line": 536,
      "pattern": "null.*pointer.*dereference",
      "rule": "memory_management",
      "severity": "high",
      "match": "NULL pointer dereference",
      "context": [
        "\t}",
        "",
        "\tif (address < PAGE_SIZE && !user_mode(regs))",
        "\t\tpr_alert(\"BUG: kernel NULL pointer dereference, address: %px\\n\",",
        "\t\t\t(void *)address);",
        "\telse",
        "\t\tpr_alert(\"BUG: unable to handle page fault for address: %px\\n\","
      ]
    },
    {
      "file": "linux\\arch\\x86\\net\\bpf_jit_comp.c",
      "line": 1506,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "stack overflow",
      "context": [
        "#define LOAD_TAIL_CALL_CNT_PTR(stack)\t\t\t\t\\",
        "\t__LOAD_TCC_PTR(BPF_TAIL_CALL_CNT_PTR_STACK_OFF(stack))",
        "",
        "/* Memory size/value to protect private stack overflow/underflow */",
        "#define PRIV_STACK_GUARD_SZ    8",
        "#define PRIV_STACK_GUARD_VAL   0xEB9F12345678eb9fULL",
        ""
      ]
    },
    {
      "file": "linux\\arch\\x86\\net\\bpf_jit_comp.c",
      "line": 3533,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "stack overflow",
      "context": [
        "\t\tstack_ptr = per_cpu_ptr(priv_stack_ptr, cpu);",
        "\t\tif (stack_ptr[0] != PRIV_STACK_GUARD_VAL ||",
        "\t\t    stack_ptr[underflow_idx] != PRIV_STACK_GUARD_VAL) {",
        "\t\t\tpr_err(\"BPF private stack overflow/underflow detected for prog %sx\\n\",",
        "\t\t\t       bpf_get_prog_name(prog));",
        "\t\t\tbreak;",
        "\t\t}"
      ]
    },
    {
      "file": "linux\\arch\\x86\\net\\bpf_jit_comp.c",
      "line": 3598,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "stack size plus two memory guards to protect overflow",
      "context": [
        "\tpriv_stack_ptr = prog->aux->priv_stack_ptr;",
        "\tif (!priv_stack_ptr && prog->aux->jits_use_priv_stack) {",
        "\t\t/* Allocate actual private stack size with verifier-calculated",
        "\t\t * stack size plus two memory guards to protect overflow and",
        "\t\t * underflow.",
        "\t\t */",
        "\t\tpriv_stack_alloc_sz = round_up(prog->aux->stack_depth, 8) +"
      ]
    },
    {
      "file": "linux\\arch\\x86\\kernel\\apic\\apic.c",
      "line": 1035,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t}",
        "",
        "\t/*",
        "\t * the NMI deadlock-detector uses this.",
        "\t */",
        "\tinc_irq_stat(apic_timer_irqs);",
        ""
      ]
    },
    {
      "file": "linux\\arch\\x86\\kernel\\cpu\\common.c",
      "line": 1962,
      "pattern": "incorrect.*flags",
      "rule": "api_usage",
      "severity": "medium",
      "match": "incorrect flags",
      "context": [
        "\t * Vendor-specific initialization.  In this section we",
        "\t * canonicalize the feature flags, meaning if there are",
        "\t * features a certain CPU supports which CPUID doesn't",
        "\t * tell us, CPUID claiming incorrect flags, or other bugs,",
        "\t * we handle them here.",
        "\t *",
        "\t * At the end of this section, c->x86_capability better"
      ]
    },
    {
      "file": "linux\\arch\\x86\\kernel\\cpu\\intel.c",
      "line": 228,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t/*",
        "\t * Atom erratum AAE44/AAF40/AAG38/AAH41:",
        "\t *",
        "\t * A race condition between speculative fetches and invalidating",
        "\t * a large page.  This is worked around in microcode, but we",
        "\t * need the microcode to have already been loaded... so if it is",
        "\t * not, recommend a BIOS update and disable large pages."
      ]
    },
    {
      "file": "linux\\arch\\x86\\kernel\\cpu\\umwait.c",
      "line": 72,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * This code is protected by the CPU hotplug already and",
        "\t * orig_umwait_control_cached is never changed after it caches",
        "\t * the original control MSR value in umwait_init(). So there",
        "\t * is no race condition here.",
        "\t */",
        "\twrmsrq(MSR_IA32_UMWAIT_CONTROL, orig_umwait_control_cached);",
        ""
      ]
    },
    {
      "file": "linux\\arch\\x86\\kernel\\cpu\\mce\\core.c",
      "line": 125,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tm->cpuid\t= cpuid_eax(1);",
        "\tm->cpuvendor\t= boot_cpu_data.x86_vendor;",
        "\tm->mcgcap\t= native_rdmsrq(MSR_IA32_MCG_CAP);",
        "\t/* need the internal __ version to avoid deadlocks */",
        "\tm->time\t\t= __ktime_get_real_seconds();",
        "}",
        ""
      ]
    },
    {
      "file": "linux\\arch\\x86\\kernel\\cpu\\mce\\core.c",
      "line": 1098,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * For UC somewhere we let the CPU who detects it handle it.",
        "\t * Also must let continue the others, otherwise the handling",
        "\t * CPU could deadlock on a lock.",
        "\t */",
        "",
        "\t/*"
      ]
    },
    {
      "file": "linux\\arch\\x86\\kernel\\cpu\\mce\\core.c",
      "line": 1789,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t__this_cpu_write(mce_next_interval, check_interval * HZ);",
        "}",
        "",
        "/* Must not be called in IRQ context where timer_delete_sync() can deadlock */",
        "static void mce_timer_delete_all(void)",
        "{",
        "\tint cpu;"
      ]
    },
    {
      "file": "linux\\arch\\x86\\kernel\\cpu\\mce\\dev-mcelog.c",
      "line": 28,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "/*",
        " * Lockless MCE logging infrastructure.",
        " * This avoids deadlocks on printk locks without having to break locks. Also",
        " * separate MCEs from kernel messages to avoid bogus bug reports.",
        " */",
        ""
      ]
    },
    {
      "file": "linux\\arch\\x86\\kvm\\mmu\\mmu.c",
      "line": 6679,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t * deletion, mmu_notifier callbacks will be unable to reach the SPTEs",
        "\t * associated with the deleted memslot once the update completes, and",
        "\t * Deferring the zap until the final reference to the root is put would",
        "\t * lead to use-after-free.",
        "\t */",
        "\tif (tdp_mmu_enabled)",
        "\t\tkvm_tdp_mmu_zap_invalidated_roots(kvm, true);"
      ]
    },
    {
      "file": "linux\\arch\\x86\\kvm\\mmu\\mmu.c",
      "line": 7222,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t * Since accounting information is stored in struct kvm_arch_memory_slot,",
        "\t * all MMU pages that are shadowing guest PTEs must be zapped before the",
        "\t * memslot is deleted, as freeing such pages after the memslot is freed",
        "\t * will result in use-after-free, e.g. in unaccount_shadowed().",
        "\t */",
        "\tfor (i = 0; i < slot->npages; i++) {",
        "\t\tstruct kvm_mmu_page *sp;"
      ]
    },
    {
      "file": "linux\\arch\\x86\\kvm\\mmu\\tdp_mmu.c",
      "line": 69,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use it after it is free",
      "context": [
        " * the memory.",
        " * By only accessing TDP MMU page table memory in an RCU read critical",
        " * section, and freeing it after a grace period, lockless access to that",
        " * memory won't use it after it is freed.",
        " */",
        "static void tdp_mmu_free_sp_rcu_callback(struct rcu_head *head)",
        "{"
      ]
    },
    {
      "file": "linux\\arch\\x86\\kvm\\mmu\\tdp_mmu.c",
      "line": 892,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t * must drop all references to relevant pages prior to completing the",
        "\t * callback.  Dropping mmu_lock with an unreachable root would result",
        "\t * in zapping SPTEs after a relevant mmu_notifier callback completes",
        "\t * and lead to use-after-free as zapping a SPTE triggers \"writeback\" of",
        "\t * dirty accessed bits to the SPTE's associated struct page.",
        "\t */",
        "\tWARN_ON_ONCE(!refcount_read(&root->tdp_mmu_root_count));"
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpi_dbg.c",
      "line": 150,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tbool ret;",
        "",
        "\t/*",
        "\t * The usage count is prepared to avoid race conditions between the",
        "\t * starts and the stops of the debugger thread.",
        "\t */",
        "\tmutex_lock(&acpi_aml_io.lock);"
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\utils.c",
      "line": 150,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "\t} else {",
        "\t\tif (buffer->length < size_required) {",
        "\t\t\tbuffer->length = size_required;",
        "\t\t\treturn AE_BUFFER_OVERFLOW;",
        "\t\t} else if (buffer->length != size_required ||",
        "\t\t\t   !buffer->pointer) {",
        "\t\t\treturn AE_BAD_PARAMETER;"
      ]
    },
    {
      "file": "linux\\drivers\\ata\\ahci_mvebu.c",
      "line": 64,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Enable the regret bit to allow the SATA unit to regret a",
        "\t * request that didn't receive an acknowlegde and avoid a",
        "\t * deadlock",
        "\t */",
        "\twritel(0x4, hpriv->mmio + AHCI_VENDOR_SPECIFIC_0_ADDR);",
        "\twritel(0x80, hpriv->mmio + AHCI_VENDOR_SPECIFIC_0_DATA);"
      ]
    },
    {
      "file": "linux\\drivers\\ata\\ata_piix.c",
      "line": 64,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *\t450NX:\terrata #19\t- DMA hangs on old 450NX",
        " *\t450NX:  errata #20\t- DMA hangs on old 450NX",
        " *\t450NX:  errata #25\t- Corruption with DMA on old 450NX",
        " *\tICH3    errata #15      - IDE deadlock under high load",
        " *\t\t\t\t  (BIOS must set dev 31 fn 0 bit 23)",
        " *\tICH3\terrata #18\t- Don't use native mode",
        " */"
      ]
    },
    {
      "file": "linux\\drivers\\ata\\libata-eh.c",
      "line": 2877,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t/* postreset() should clear hardware SError.  Although SError",
        "\t * is cleared during link resume, clearing SError here is",
        "\t * necessary as some PHYs raise hotplug events after SRST.",
        "\t * This introduces race condition where hotplug occurs between",
        "\t * reset and here.  This race is mediated by cross checking",
        "\t * link onlineness and classification result later.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\atm\\eni.c",
      "line": 48,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * KNOWN BUGS:",
        " *",
        " * - may run into JK-JK bug and deadlock",
        " * - should allocate UBR channel first",
        " * - buffer space allocation algorithm is stupid",
        " *   (RX: should be maxSDU+maxdelay*rate"
      ]
    },
    {
      "file": "linux\\drivers\\atm\\iphase.c",
      "line": 1161,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "                    IF_ERR(printk(\" cause: packet time out\\n\");)",
        "                }",
        "                else {",
        "                    IF_ERR(printk(\" cause: buffer overflow\\n\");)",
        "                }",
        "\t\tgoto out_free_desc;",
        "\t}  "
      ]
    },
    {
      "file": "linux\\drivers\\atm\\lanai.c",
      "line": 292,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tstruct atm_vcc *cbrvcc;",
        "\tint number;",
        "\tint board_rev;",
        "/* TODO - look at race conditions with maintence of conf1/conf2 */",
        "/* TODO - transmit locking: should we use _irq not _irqsave? */",
        "/* TODO - organize above in some rational fashion (see <asm/cache.h>) */",
        "};"
      ]
    },
    {
      "file": "linux\\drivers\\atm\\lanai.c",
      "line": 250,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "};",
        "",
        "struct lanai_dev_stats {",
        "\tunsigned ovfl_trash;\t/* # of cells dropped - buffer overflow */",
        "\tunsigned vci_trash;\t/* # of cells dropped - closed vci */",
        "\tunsigned hec_err;\t/* # of cells dropped - bad HEC */",
        "\tunsigned atm_ovfl;\t/* # of cells dropped - rx fifo overflow */"
      ]
    },
    {
      "file": "linux\\drivers\\atm\\lanai.c",
      "line": 1003,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "\tlanai->magicno = eeprom_be4(lanai, EEPROM_MAGIC);",
        "\tv = eeprom_be4(lanai, EEPROM_MAGIC_REV);",
        "\tif ((lanai->magicno ^ v) != 0xFFFFFFFF) {",
        "\t\tprintk(KERN_ERR DEV_LABEL \"(itf %d): EEPROM magic numbers \"",
        "\t\t    \"don't match (0x%08X, inverse 0x%08X)\\n\", lanai->number,",
        "\t\t    lanai->magicno, v);",
        "\t\treturn -EIO;"
      ]
    },
    {
      "file": "linux\\drivers\\auxdisplay\\ks0108.c",
      "line": 46,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * ks0108 Exported Commands (don't lock)",
        " *",
        " *   You _should_ lock in the top driver: This functions _should not_",
        " *   get race conditions in any way. Locking for each byte here would be",
        " *   so slow and useless.",
        " *",
        " *   There are not bit definitions because they are not flags,"
      ]
    },
    {
      "file": "linux\\drivers\\base\\arch_topology.c",
      "line": 115,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "",
        "\t/*",
        "\t * Make sure all references to previous sft_data are dropped to avoid",
        "\t * use-after-free races.",
        "\t */",
        "\tsynchronize_rcu();",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\base\\core.c",
      "line": 2557,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\t *",
        "\t * Drivers still can add resources into device after device",
        "\t * is deleted but alive, so release devres here to avoid",
        "\t * possible memory leak.",
        "\t */",
        "\tdevres_release_all(dev);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\base\\core.c",
      "line": 3368,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\tmutex_lock(&gdp_mutex);",
        "\t/**",
        "\t * There is a race condition between removing glue directory",
        "\t * and adding a new device under the glue directory.",
        "\t *",
        "\t * CPU1:                                         CPU2:"
      ]
    },
    {
      "file": "linux\\drivers\\base\\devres.c",
      "line": 1257,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "void devm_free_percpu(struct device *dev, void __percpu *pdata)",
        "{",
        "\t/*",
        "\t * Use devres_release() to prevent memory leakage as",
        "\t * devm_free_pages() does.",
        "\t */",
        "\tWARN_ON(devres_release(dev, devm_percpu_release, devm_percpu_match,"
      ]
    },
    {
      "file": "linux\\drivers\\base\\cpu.c",
      "line": 599,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "stack_overflow",
      "context": [
        "CPU_SHOW_VULN_FALLBACK(srbds);",
        "CPU_SHOW_VULN_FALLBACK(mmio_stale_data);",
        "CPU_SHOW_VULN_FALLBACK(retbleed);",
        "CPU_SHOW_VULN_FALLBACK(spec_rstack_overflow);",
        "CPU_SHOW_VULN_FALLBACK(gds);",
        "CPU_SHOW_VULN_FALLBACK(reg_file_data_sampling);",
        "CPU_SHOW_VULN_FALLBACK(ghostwrite);"
      ]
    },
    {
      "file": "linux\\drivers\\base\\cpu.c",
      "line": 617,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "stack_overflow, 0444, cpu_show_spec_rstack_overflow",
      "context": [
        "static DEVICE_ATTR(srbds, 0444, cpu_show_srbds, NULL);",
        "static DEVICE_ATTR(mmio_stale_data, 0444, cpu_show_mmio_stale_data, NULL);",
        "static DEVICE_ATTR(retbleed, 0444, cpu_show_retbleed, NULL);",
        "static DEVICE_ATTR(spec_rstack_overflow, 0444, cpu_show_spec_rstack_overflow, NULL);",
        "static DEVICE_ATTR(gather_data_sampling, 0444, cpu_show_gds, NULL);",
        "static DEVICE_ATTR(reg_file_data_sampling, 0444, cpu_show_reg_file_data_sampling, NULL);",
        "static DEVICE_ATTR(ghostwrite, 0444, cpu_show_ghostwrite, NULL);"
      ]
    },
    {
      "file": "linux\\drivers\\base\\cpu.c",
      "line": 636,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "stack_overflow",
      "context": [
        "\t&dev_attr_srbds.attr,",
        "\t&dev_attr_mmio_stale_data.attr,",
        "\t&dev_attr_retbleed.attr,",
        "\t&dev_attr_spec_rstack_overflow.attr,",
        "\t&dev_attr_gather_data_sampling.attr,",
        "\t&dev_attr_reg_file_data_sampling.attr,",
        "\t&dev_attr_ghostwrite.attr,"
      ]
    },
    {
      "file": "linux\\drivers\\base\\dd.c",
      "line": 164,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * list and schedules the deferred probe workqueue to process them.  It",
        " * should be called anytime a driver is successfully bound to a device.",
        " *",
        " * Note, there is a race condition in multi-threaded probe. In the case where",
        " * more than one device is probing at the same time, it is possible for one",
        " * probe to complete successfully while another is about to defer. If the second",
        " * depends on the first, then it will get put on the pending list after the"
      ]
    },
    {
      "file": "linux\\drivers\\base\\dd.c",
      "line": 1316,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * If anyone calls device_release_driver() recursively from",
        "\t * within their ->remove callback for the same device, they",
        "\t * will deadlock right here.",
        "\t */",
        "\tdevice_release_driver_internal(dev, NULL, NULL);",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\block\\amiflop.c",
      "line": 54,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * - Fixed Bug accessing multiple disks",
        " * - some code cleanup",
        " * - added trackbuffer for each drive to speed things up",
        " * - fixed some race conditions (who finds the next may send it to me ;-)",
        " */",
        "",
        "#include <linux/module.h>"
      ]
    },
    {
      "file": "linux\\drivers\\block\\ataflop.c",
      "line": 1085,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tlocal_irq_save(flags);",
        "",
        "\tif (!MultReadInProgress) {",
        "\t\t/* This prevents a race condition that could arise if the",
        "\t\t * interrupt is triggered while the calling of this timer",
        "\t\t * callback function takes place. The IRQ function then has",
        "\t\t * already cleared 'MultReadInProgress'  when flow of control"
      ]
    },
    {
      "file": "linux\\drivers\\block\\nbd.c",
      "line": 772,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t\t\t/*",
        "\t\t\t * The completion might already have come in,",
        "\t\t\t * so break for the last one instead of letting",
        "\t\t\t * the iterator do it. This prevents use-after-free",
        "\t\t\t * of the bio.",
        "\t\t\t */",
        "\t\t\tif (is_last)"
      ]
    },
    {
      "file": "linux\\drivers\\block\\nbd.c",
      "line": 987,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "",
        "\t\t/*",
        "\t\t * Grab .q_usage_counter so request pool won't go away, then no",
        "\t\t * request use-after-free is possible during nbd_handle_reply().",
        "\t\t * If queue is frozen, there won't be any inflight requests, we",
        "\t\t * needn't to handle the incoming garbage message.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\block\\nbd.c",
      "line": 6,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * Network block device - make block devices work over TCP",
        " *",
        " * Note that you can not swap over this thing, yet. Seems to work but",
        " * deadlocks sometimes - you can not swap over TCP in general.",
        " * ",
        " * Copyright 1997-2000, 2008 Pavel Machek <pavel@ucw.cz>",
        " * Parts copyright 2001 Steven Whitehouse <steve@chygwyn.com>"
      ]
    },
    {
      "file": "linux\\drivers\\block\\nbd.c",
      "line": 292,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tif (!refcount_dec_and_test(&nbd->refs))",
        "\t\treturn;",
        "",
        "\t/* Call del_gendisk() asynchrounously to prevent deadlock */",
        "\tif (test_bit(NBD_DESTROY_ON_DISCONNECT, &nbd->flags))",
        "\t\tqueue_work(nbd_del_wq, &nbd->remove_work);",
        "\telse"
      ]
    },
    {
      "file": "linux\\drivers\\block\\nbd.c",
      "line": 2480,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * reason we don't take a ref here is because we can't",
        "\t * take a ref in the index == -1 case as we would need",
        "\t * to put under the nbd_index_mutex, which could",
        "\t * deadlock if we are configured to remove ourselves",
        "\t * once we're disconnected.",
        "\t */",
        "\tif (refcount_read(&nbd->config_refs))"
      ]
    },
    {
      "file": "linux\\drivers\\block\\rbd.c",
      "line": 2089,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\tif (snap_id == CEPH_NOSNAP) {",
        "\t\t/*",
        "\t\t * Protect against possible race conditions during lock",
        "\t\t * ownership transitions.",
        "\t\t */",
        "\t\tret = ceph_cls_assert_locked(req, which++, RBD_LOCK_NAME,"
      ]
    },
    {
      "file": "linux\\drivers\\block\\rbd.c",
      "line": 4561,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "}",
        "",
        "/*",
        " * header_rwsem must not be held to avoid a deadlock with",
        " * rbd_dev_refresh() when flushing notifies.",
        " */",
        "static void rbd_unregister_watch(struct rbd_device *rbd_dev)"
      ]
    },
    {
      "file": "linux\\drivers\\block\\ublk_drv.c",
      "line": 1575,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t *",
        "\t * More importantly, we have to provide forward progress guarantee",
        "\t * without holding ub->mutex, otherwise control task grabbing",
        "\t * ub->mutex triggers deadlock",
        "\t *",
        "\t * All requests may be inflight, so ->canceling may not be set, set",
        "\t * it now."
      ]
    },
    {
      "file": "linux\\drivers\\block\\ublk_drv.c",
      "line": 1786,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *   uring_cmd are done",
        " *",
        " * Do _not_ try to acquire ub->mutex before all inflight requests are",
        " * aborted, otherwise deadlock may be caused.",
        " */",
        "static void ublk_uring_cmd_cancel_fn(struct io_uring_cmd *cmd,",
        "\t\tunsigned int issue_flags)"
      ]
    },
    {
      "file": "linux\\drivers\\block\\ublk_drv.c",
      "line": 1595,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double check after grabbing lock",
      "context": [
        "\t */",
        "\tmutex_lock(&ub->mutex);",
        "",
        "\t/* double check after grabbing lock */",
        "\tif (!ub->ub_disk)",
        "\t\tgoto unlock;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\bluetooth\\btintel_pcie.c",
      "line": 402,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tstruct rxq *rxq = &data->rxq;",
        "",
        "\t/* Post (BTINTEL_PCIE_RX_DESCS_COUNT - 3) buffers to overcome the",
        "\t * hardware issues leading to race condition at the firmware.",
        "\t */",
        "",
        "\tfor (i = 0; i < rxq->count - 3; i++) {"
      ]
    },
    {
      "file": "linux\\drivers\\bluetooth\\hci_qca.c",
      "line": 2558,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t\t\treturn;",
        "",
        "\t\t/* The serdev must be in open state when control logic arrives",
        "\t\t * here, so also fix the use-after-free issue caused by that",
        "\t\t * the serdev is flushed or wrote after it is closed.",
        "\t\t */",
        "\t\tserdev_device_write_flush(serdev);"
      ]
    },
    {
      "file": "linux\\drivers\\cdrom\\cdrom.c",
      "line": 159,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "  -- Various other cleanups.",
        "",
        "  3.04 Sep 12, 1999 - Jens Axboe <axboe@image.dk>",
        "  -- Fixed a couple of possible memory leaks (if an operation failed and",
        "  we didn't free the buffer before returning the error).",
        "  -- Integrated Uniform CD Changer handling from Richard Sharman",
        "  <rsharman@pobox.com>."
      ]
    },
    {
      "file": "linux\\drivers\\char\\random.c",
      "line": 108,
      "pattern": "long.*functions",
      "rule": "code_quality",
      "severity": "low",
      "match": "long} family of functions",
      "context": [
        " * Returns whether or not the input pool has been seeded and thus guaranteed",
        " * to supply cryptographically secure random numbers. This applies to: the",
        " * /dev/urandom device, the get_random_bytes function, and the get_random_{u8,",
        " * u16,u32,u64,long} family of functions.",
        " *",
        " * Returns: true if the input pool has been seeded.",
        " *          false if the input pool has not been seeded."
      ]
    },
    {
      "file": "linux\\drivers\\char\\random.c",
      "line": 131,
      "pattern": "long.*functions",
      "rule": "code_quality",
      "severity": "low",
      "match": "long} family of functions. Using any of these functions",
      "context": [
        " * Wait for the input pool to be seeded and thus guaranteed to supply",
        " * cryptographically secure random numbers. This applies to: the /dev/urandom",
        " * device, the get_random_bytes function, and the get_random_{u8,u16,u32,u64,",
        " * long} family of functions. Using any of these functions without first",
        " * calling this function forfeits the guarantee of security.",
        " *",
        " * Returns: 0 if the input pool has been seeded."
      ]
    },
    {
      "file": "linux\\drivers\\clk\\clk-cdce925.c",
      "line": 656,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing parent clock",
      "context": [
        "",
        "\tparent_name = of_clk_get_parent_name(node, 0);",
        "\tif (!parent_name) {",
        "\t\tdev_err(&client->dev, \"missing parent clock\\n\");",
        "\t\treturn -ENODEV;",
        "\t}",
        "\tdev_dbg(&client->dev, \"parent is: %s\\n\", parent_name);"
      ]
    },
    {
      "file": "linux\\drivers\\clk\\clk-fixed-factor.c",
      "line": 85,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double free",
      "context": [
        "",
        "\t/*",
        "\t * We can not use clk_hw_unregister_fixed_factor, since it will kfree()",
        "\t * the hw, resulting in double free. Just unregister the hw and let",
        "\t * devres code kfree() it.",
        "\t */",
        "\tclk_hw_unregister(&fix->hw);"
      ]
    },
    {
      "file": "linux\\drivers\\clk\\clk-fixed-rate.c",
      "line": 58,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double free",
      "context": [
        "",
        "\t/*",
        "\t * We can not use clk_hw_unregister_fixed_rate, since it will kfree()",
        "\t * the hw, resulting in double free. Just unregister the hw and let",
        "\t * devres code kfree() it.",
        "\t */",
        "\tclk_hw_unregister(&fix->hw);"
      ]
    },
    {
      "file": "linux\\drivers\\clk\\clk-nomadik.c",
      "line": 561,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing clock",
      "context": [
        "\t\tnomadik_src_init();",
        "",
        "\tif (of_property_read_u32(np, \"clock-id\", &clk_id)) {",
        "\t\tpr_err(\"%s: SRC clock \\\"%s\\\" missing clock-id property\\n\",",
        "\t\t\t__func__, clk_name);",
        "\t\treturn;",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\clk\\clk-si5351.c",
      "line": 1475,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing parent clock",
      "context": [
        "\t */",
        "\tif (IS_ERR(drvdata->pxtal) &&",
        "\t    (drvdata->variant != SI5351_VARIANT_C || IS_ERR(drvdata->pclkin))) {",
        "\t\tdev_err(&client->dev, \"missing parent clock\\n\");",
        "\t\treturn -EINVAL;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\clk\\clk.c",
      "line": 134,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * clk_pm_runtime_get_all() - Runtime \"get\" all clk provider devices",
        " *",
        " * Call clk_pm_runtime_get() on all runtime PM enabled clks in the clk tree so",
        " * that disabling unused clks avoids a deadlock where a device is runtime PM",
        " * resuming/suspending and the runtime PM callback is trying to grab the",
        " * prepare_lock for something like clk_prepare_enable() while",
        " * clk_disable_unused_subtree() holds the prepare_lock and is trying to runtime"
      ]
    },
    {
      "file": "linux\\drivers\\clk\\clk.c",
      "line": 159,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Runtime PM \"get\" all the devices that are needed for the clks",
        "\t * currently registered. Do this without holding the prepare_lock, to",
        "\t * avoid the deadlock.",
        "\t */",
        "\thlist_for_each_entry(core, &clk_rpm_list, rpm_node) {",
        "\t\tret = clk_pm_runtime_get(core);"
      ]
    },
    {
      "file": "linux\\drivers\\clk\\clk_test.c",
      "line": 3322,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing assigned-clock",
      "context": [
        "\t\t * Test that an assigned-clock-rates property without an assigned-clocks",
        "\t\t * property fails when the property is in the provider.",
        "\t\t */",
        "\t\t.desc = \"provider missing assigned-clocks\",",
        "\t\tTEST_PARAM_OVERLAY(kunit_clk_assigned_rates_without),",
        "\t\t.rate0 = 3000,",
        "\t},"
      ]
    },
    {
      "file": "linux\\drivers\\clk\\clk_test.c",
      "line": 3331,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing assigned-clock",
      "context": [
        "\t\t * Test that an assigned-clock-rates property without an assigned-clocks",
        "\t\t * property fails when the property is in the consumer.",
        "\t\t */",
        "\t\t.desc = \"consumer missing assigned-clocks\",",
        "\t\tTEST_PARAM_OVERLAY(kunit_clk_assigned_rates_without_consumer),",
        "\t\t.rate0 = 3000,",
        "\t\t.consumer_test = true,"
      ]
    },
    {
      "file": "linux\\drivers\\clocksource\\timer-cs5535.c",
      "line": 61,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "races by clearing CMP1 and CMP2 uncondition",
      "context": [
        "",
        "static void disable_timer(struct cs5535_mfgpt_timer *timer)",
        "{",
        "\t/* avoid races by clearing CMP1 and CMP2 unconditionally */",
        "\tcs5535_mfgpt_write(timer, MFGPT_REG_SETUP,",
        "\t\t\t(uint16_t) ~MFGPT_SETUP_CNTEN | MFGPT_SETUP_CMP1 |",
        "\t\t\t\tMFGPT_SETUP_CMP2);"
      ]
    },
    {
      "file": "linux\\drivers\\clocksource\\timer-nxp-stm.c",
      "line": 75,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "static int stm_instances;",
        "",
        "/*",
        " * This global lock is used to prevent race conditions with the",
        " * stm_instances in case the driver is using the ASYNC option",
        " */",
        "static DEFINE_MUTEX(stm_instances_lock);"
      ]
    },
    {
      "file": "linux\\drivers\\clocksource\\timer-tegra.c",
      "line": 190,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "/*",
        " * tegra_rtc_read - Reads the Tegra RTC registers",
        " * Care must be taken that this function is not called while the",
        " * tegra_rtc driver could be executing to avoid race conditions",
        " * on the RTC shadow register",
        " */",
        "static u64 tegra_rtc_read_ms(struct clocksource *cs)"
      ]
    },
    {
      "file": "linux\\drivers\\comedi\\comedi_fops.c",
      "line": 2644,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tstruct comedi_subdevice *new_s;",
        "",
        "\t\t/*",
        "\t\t * To avoid deadlock, cannot acquire dev->mutex",
        "\t\t * while dev->attach_lock is held.",
        "\t\t */",
        "\t\tup_read(&dev->attach_lock);"
      ]
    },
    {
      "file": "linux\\drivers\\comedi\\comedi_fops.c",
      "line": 2771,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tstruct comedi_subdevice *new_s;",
        "",
        "\t\t/*",
        "\t\t * To avoid deadlock, cannot acquire dev->mutex",
        "\t\t * while dev->attach_lock is held.",
        "\t\t */",
        "\t\tup_read(&dev->attach_lock);"
      ]
    },
    {
      "file": "linux\\drivers\\counter\\i8254.c",
      "line": 45,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "/**",
        " * struct i8254 - I8254 device private data structure",
        " * @lock:\tsynchronization lock to prevent I/O race conditions",
        " * @preset:\tarray of Counter Register states",
        " * @out_mode:\tarray of mode configuration states",
        " * @map:\tRegmap for the device"
      ]
    },
    {
      "file": "linux\\drivers\\counter\\ti-ecap-capture.c",
      "line": 80,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "/**",
        " * struct ecap_cnt_dev - device private data structure",
        " * @enabled: device state",
        " * @lock:    synchronization lock to prevent I/O race conditions",
        " * @clk:     device clock",
        " * @regmap:  device register map",
        " * @nb_ovf:  number of overflows since capture start"
      ]
    },
    {
      "file": "linux\\drivers\\cpufreq\\cpufreq.c",
      "line": 375,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "{",
        "",
        "\t/*",
        "\t * Catch double invocations of _begin() which lead to self-deadlock.",
        "\t * ASYNC_NOTIFICATION drivers are left out because the cpufreq core",
        "\t * doesn't invoke _begin() on their behalf, and hence the chances of",
        "\t * double invocations are very low. Moreover, there are scenarios"
      ]
    },
    {
      "file": "linux\\drivers\\cpufreq\\cpufreq.c",
      "line": 375,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double invocations of _begin() which lead to self-deadlock",
      "context": [
        "{",
        "",
        "\t/*",
        "\t * Catch double invocations of _begin() which lead to self-deadlock.",
        "\t * ASYNC_NOTIFICATION drivers are left out because the cpufreq core",
        "\t * doesn't invoke _begin() on their behalf, and hence the chances of",
        "\t * double invocations are very low. Moreover, there are scenarios"
      ]
    },
    {
      "file": "linux\\drivers\\cpufreq\\mediatek-cpufreq.c",
      "line": 52,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tbool need_voltage_tracking;",
        "\tint vproc_on_boot;",
        "\tint pre_vproc;",
        "\t/* Avoid race condition for regulators between notify and policy */",
        "\tstruct mutex reg_lock;",
        "\tstruct notifier_block opp_nb;",
        "\tunsigned int opp_cpu;"
      ]
    },
    {
      "file": "linux\\drivers\\cpufreq\\pxa2xx-cpufreq.c",
      "line": 215,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * only power savings will suffer from this.",
        "\t *",
        "\t * Note: if the voltage change fails, and a return value is returned, a",
        "\t * bug is triggered (seems a deadlock). Should anybody find out where,",
        "\t * the \"return 0\" should become a \"return ret\".",
        "\t */",
        "\tif (vcc_core && new_freq_cpu < policy->cur)"
      ]
    },
    {
      "file": "linux\\drivers\\cpuidle\\coupled.c",
      "line": 119,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * The cpuidle_coupled_poke_pending mask is used to avoid calling",
        " * __smp_call_function_single with the per cpu call_single_data_t struct already",
        " * in use.  This prevents a deadlock where two cpus are waiting for each others",
        " * call_single_data_t struct to be available",
        " */",
        "static cpumask_t cpuidle_coupled_poke_pending;"
      ]
    },
    {
      "file": "linux\\drivers\\crypto\\sahara.c",
      "line": 304,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer disabled/overflow",
      "context": [
        "\t\"CTX read during processing\",",
        "\t\"HW error\",",
        "\t\"Input buffer disabled/underflow\",",
        "\t\"Output buffer disabled/overflow\",",
        "\t\"DES key parity error\",",
        "\t\"Reserved\"",
        "};"
      ]
    },
    {
      "file": "linux\\drivers\\devfreq\\mtk-cci-devfreq.c",
      "line": 32,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tstruct clk *inter_clk;",
        "\tint inter_voltage;",
        "\tunsigned long pre_freq;",
        "\t/* Avoid race condition for regulators between notify and policy */",
        "\tstruct mutex reg_lock;",
        "\tstruct notifier_block opp_nb;",
        "\tconst struct mtk_ccifreq_platform_data *soc_data;"
      ]
    },
    {
      "file": "linux\\drivers\\dma\\amba-pl08x.c",
      "line": 940,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tbool success;",
        "",
        "\t\t/*",
        "\t\t * Eww.  We know this isn't going to deadlock",
        "\t\t * but lockdep probably doesn't.",
        "\t\t */",
        "\t\tspin_lock(&next->vc.lock);"
      ]
    },
    {
      "file": "linux\\drivers\\dma\\at_hdmac.c",
      "line": 651,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * removing the number of bytes corresponding to this amount of data.",
        " *",
        " * However, the DSCR and CTRLA registers cannot be read both atomically. Hence a",
        " * race condition may occur: the first read register may refer to one LLI",
        " * whereas the second read may refer to a later LLI in the list because of the",
        " * DMA transfer progression inbetween the two reads.",
        " *"
      ]
    },
    {
      "file": "linux\\drivers\\dma\\fsl-edma-main.c",
      "line": 746,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Missing DMA block clock",
      "context": [
        "\tif (drvdata->flags & FSL_EDMA_DRV_HAS_DMACLK) {",
        "\t\tfsl_edma->dmaclk = devm_clk_get_enabled(&pdev->dev, \"dma\");",
        "\t\tif (IS_ERR(fsl_edma->dmaclk)) {",
        "\t\t\tdev_err(&pdev->dev, \"Missing DMA block clock.\\n\");",
        "\t\t\treturn PTR_ERR(fsl_edma->dmaclk);",
        "\t\t}",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\dma\\fsl-edma-main.c",
      "line": 773,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Missing DMAMUX block clock",
      "context": [
        "\t\tsprintf(clkname, \"dmamux%d\", i);",
        "\t\tfsl_edma->muxclk[i] = devm_clk_get_enabled(&pdev->dev, clkname);",
        "\t\tif (IS_ERR(fsl_edma->muxclk[i])) {",
        "\t\t\tdev_err(&pdev->dev, \"Missing DMAMUX block clock.\\n\");",
        "\t\t\t/* on error: disable all previously enabled clks */",
        "\t\t\treturn PTR_ERR(fsl_edma->muxclk[i]);",
        "\t\t}"
      ]
    },
    {
      "file": "linux\\drivers\\dma\\imx-dma.c",
      "line": 59,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "Buffer overflow",
      "context": [
        "#define DMA_DBTOSR  0x0c\t\t/* Burst timeout status Register */",
        "#define DMA_DRTOSR  0x10\t\t/* Request timeout Register */",
        "#define DMA_DSESR   0x14\t\t/* Transfer Error Status Register */",
        "#define DMA_DBOSR   0x18\t\t/* Buffer overflow status Register */",
        "#define DMA_DBTOCR  0x1c\t\t/* Burst timeout control Register */",
        "#define DMA_WSRA    0x40\t\t/* W-Size Register A */",
        "#define DMA_XSRA    0x44\t\t/* X-Size Register A */"
      ]
    },
    {
      "file": "linux\\drivers\\dma\\milbeaut-hdmac.c",
      "line": 552,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free errors as e.g. *mdev is kfree",
      "context": [
        "\t\tif (ret) {",
        "\t\t\t/*",
        "\t\t\t * This results in resource leakage and maybe also",
        "\t\t\t * use-after-free errors as e.g. *mdev is kfreed.",
        "\t\t\t */",
        "\t\t\tdev_alert(&pdev->dev, \"Failed to terminate channel %d (%pe)\\n\",",
        "\t\t\t\t  chan->chan_id, ERR_PTR(ret));"
      ]
    },
    {
      "file": "linux\\drivers\\dma\\milbeaut-hdmac.c",
      "line": 545,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\t * ->device_free_chan_resources() hook. However, each channel might",
        "\t * be still holding one descriptor that was on-flight at that moment.",
        "\t * Terminate it to make sure this hardware is no longer running. Then,",
        "\t * free the channel resources once again to avoid memory leak.",
        "\t */",
        "\tlist_for_each_entry(chan, &mdev->ddev.channels, device_node) {",
        "\t\tret = dmaengine_terminate_sync(chan);"
      ]
    },
    {
      "file": "linux\\drivers\\dma\\milbeaut-xdmac.c",
      "line": 389,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free errors as e.g. *mdev is kfree",
      "context": [
        "\t\tif (ret) {",
        "\t\t\t/*",
        "\t\t\t * This results in resource leakage and maybe also",
        "\t\t\t * use-after-free errors as e.g. *mdev is kfreed.",
        "\t\t\t */",
        "\t\t\tdev_alert(&pdev->dev, \"Failed to terminate channel %d (%pe)\\n\",",
        "\t\t\t\t  chan->chan_id, ERR_PTR(ret));"
      ]
    },
    {
      "file": "linux\\drivers\\dma\\milbeaut-xdmac.c",
      "line": 382,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\t * ->device_free_chan_resources() hook. However, each channel might",
        "\t * be still holding one descriptor that was on-flight at that moment.",
        "\t * Terminate it to make sure this hardware is no longer running. Then,",
        "\t * free the channel resources once again to avoid memory leak.",
        "\t */",
        "\tlist_for_each_entry(chan, &mdev->ddev.channels, device_node) {",
        "\t\tret = dmaengine_terminate_sync(chan);"
      ]
    },
    {
      "file": "linux\\drivers\\dma\\tegra20-apb-dma.c",
      "line": 1458,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Missing controller clock",
      "context": [
        "",
        "\ttdma->dma_clk = devm_clk_get(&pdev->dev, NULL);",
        "\tif (IS_ERR(tdma->dma_clk)) {",
        "\t\tdev_err(&pdev->dev, \"Error: Missing controller clock\\n\");",
        "\t\treturn PTR_ERR(tdma->dma_clk);",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\dma\\tegra210-adma.c",
      "line": 1083,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Missing ahub controller clock",
      "context": [
        "",
        "\ttdma->ahub_clk = devm_clk_get(&pdev->dev, \"d_audio\");",
        "\tif (IS_ERR(tdma->ahub_clk)) {",
        "\t\tdev_err(&pdev->dev, \"Error: Missing ahub controller clock\\n\");",
        "\t\treturn PTR_ERR(tdma->ahub_clk);",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\dma\\uniphier-mdmac.c",
      "line": 474,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free errors as e.g. *mdev is kfree",
      "context": [
        "\t\tif (ret) {",
        "\t\t\t/*",
        "\t\t\t * This results in resource leakage and maybe also",
        "\t\t\t * use-after-free errors as e.g. *mdev is kfreed.",
        "\t\t\t */",
        "\t\t\tdev_alert(&pdev->dev, \"Failed to terminate channel %d (%pe)\\n\",",
        "\t\t\t\t  chan->chan_id, ERR_PTR(ret));"
      ]
    },
    {
      "file": "linux\\drivers\\dma\\uniphier-mdmac.c",
      "line": 467,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\t * ->device_free_chan_resources() hook. However, each channel might",
        "\t * be still holding one descriptor that was on-flight at that moment.",
        "\t * Terminate it to make sure this hardware is no longer running. Then,",
        "\t * free the channel resources once again to avoid memory leak.",
        "\t */",
        "\tlist_for_each_entry(chan, &mdev->ddev.channels, device_node) {",
        "\t\tret = dmaengine_terminate_sync(chan);"
      ]
    },
    {
      "file": "linux\\drivers\\dma\\uniphier-xdmac.c",
      "line": 585,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free errors as e.g. *xdev is kfree",
      "context": [
        "\t\tif (ret) {",
        "\t\t\t/*",
        "\t\t\t * This results in resource leakage and maybe also",
        "\t\t\t * use-after-free errors as e.g. *xdev is kfreed.",
        "\t\t\t */",
        "\t\t\tdev_alert(&pdev->dev, \"Failed to terminate channel %d (%pe)\\n\",",
        "\t\t\t\t  chan->chan_id, ERR_PTR(ret));"
      ]
    },
    {
      "file": "linux\\drivers\\dma\\uniphier-xdmac.c",
      "line": 578,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\t * ->device_free_chan_resources() hook. However, each channel might",
        "\t * be still holding one descriptor that was on-flight at that moment.",
        "\t * Terminate it to make sure this hardware is no longer running. Then,",
        "\t * free the channel resources once again to avoid memory leak.",
        "\t */",
        "\tlist_for_each_entry(chan, &ddev->channels, device_node) {",
        "\t\tret = dmaengine_terminate_sync(chan);"
      ]
    },
    {
      "file": "linux\\drivers\\dma-buf\\dma-buf.c",
      "line": 865,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/**",
        " * DOC: locking convention",
        " *",
        " * In order to avoid deadlock situations between dma-buf exports and importers,",
        " * all dma-buf API users must follow the common dma-buf locking convention.",
        " *",
        " * Convention for importers"
      ]
    },
    {
      "file": "linux\\drivers\\dma-buf\\dma-fence-chain.c",
      "line": 184,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "stack overflow",
      "context": [
        "\tstruct dma_fence *prev;",
        "",
        "\t/* Manually unlink the chain as much as possible to avoid recursion",
        "\t * and potential stack overflow.",
        "\t */",
        "\twhile ((prev = rcu_dereference_protected(chain->prev, true))) {",
        "\t\tstruct dma_fence_chain *prev_chain;"
      ]
    },
    {
      "file": "linux\\drivers\\dma-buf\\dma-fence-array.c",
      "line": 220,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "stack overflow",
      "context": [
        "\t/*",
        "\t * dma_fence_array objects should never contain any other fence",
        "\t * containers or otherwise we run into recursion and potential kernel",
        "\t * stack overflow on operations on the dma_fence_array.",
        "\t *",
        "\t * The correct way of handling this is to flatten out the array by the",
        "\t * caller instead."
      ]
    },
    {
      "file": "linux\\drivers\\dma-buf\\dma-fence.c",
      "line": 709,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " *",
        " * *WARNING*:",
        " * Cancelling a callback should only be done if you really know what you're",
        " * doing, since deadlocks and race conditions could occur all too easily. For",
        " * this reason, it should only ever be done on hardware lockup recovery,",
        " * with a reference held to the fence.",
        " *"
      ]
    },
    {
      "file": "linux\\drivers\\dma-buf\\dma-fence.c",
      "line": 89,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *   Drivers should not try to second guess timeout handling of fences from",
        " *   other drivers.",
        " *",
        " * * To ensure there's no deadlocks of dma_fence_wait() against other locks",
        " *   drivers should annotate all code required to reach dma_fence_signal(),",
        " *   which completes the fences, with dma_fence_begin_signalling() and",
        " *   dma_fence_end_signalling()."
      ]
    },
    {
      "file": "linux\\drivers\\dma-buf\\dma-fence.c",
      "line": 226,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *   allocation sites through &mmu_notifier and &shrinker.",
        " *",
        " * Furthermore lockdep does not handle cross-release dependencies, which means",
        " * any deadlocks between dma_fence_wait() and dma_fence_signal() can't be caught",
        " * at runtime with some quick testing. The simplest example is one thread",
        " * waiting on a &dma_fence while holding a lock::",
        " *"
      ]
    },
    {
      "file": "linux\\drivers\\dma-buf\\dma-fence.c",
      "line": 257,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * * All code necessary to complete a &dma_fence must be annotated, from the",
        " *   point where a fence is accessible to other threads, to the point where",
        " *   dma_fence_signal() is called. Un-annotated code can contain deadlock issues,",
        " *   and due to the very strict rules and many corner cases it is infeasible to",
        " *   catch these just with review or normal stress testing.",
        " *"
      ]
    },
    {
      "file": "linux\\drivers\\dma-buf\\dma-fence.c",
      "line": 280,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * * Validation against the cross driver contract is implemented by priming",
        " *   lockdep with the relevant hierarchy at boot-up. This means even just",
        " *   testing with a single device is enough to validate a driver, at least as",
        " *   far as deadlocks with dma_fence_wait() against dma_fence_signal() are",
        " *   concerned.",
        " */",
        "#ifdef CONFIG_LOCKDEP"
      ]
    },
    {
      "file": "linux\\drivers\\dma-buf\\dma-fence.c",
      "line": 709,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * *WARNING*:",
        " * Cancelling a callback should only be done if you really know what you're",
        " * doing, since deadlocks and race conditions could occur all too easily. For",
        " * this reason, it should only ever be done on hardware lockup recovery,",
        " * with a reference held to the fence.",
        " *"
      ]
    },
    {
      "file": "linux\\drivers\\dma-buf\\sw_sync.c",
      "line": 305,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * *WARNING*",
        " *",
        " * improper use of this can result in deadlocking kernel drivers from userspace.",
        " */",
        "",
        "/* opening sw_sync create a new sync obj */"
      ]
    },
    {
      "file": "linux\\drivers\\edac\\cpc925_edac.c",
      "line": 247,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "Buffer Overflow",
      "context": [
        "#define REG_LINKERR_OFFSET\t0x70120",
        "enum linkerr_bits {",
        "\tLINKERR_EOC_ERR\t\t= CPC925_BIT(17), /* End-Of-Chain error */",
        "\tLINKERR_OVF_ERR\t\t= CPC925_BIT(18), /* Receive Buffer Overflow */",
        "\tLINKERR_PROT_ERR\t= CPC925_BIT(19), /* Protocol error */",
        "",
        "\tHT_LINKERR_DETECTED\t= (LINKERR_EOC_ERR | LINKERR_OVF_ERR |"
      ]
    },
    {
      "file": "linux\\drivers\\firewire\\sbp2.c",
      "line": 1221,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tcontainer_of((void *)tgt, struct Scsi_Host, hostdata[0]);",
        "\tstruct scsi_device *sdev;",
        "",
        "\t/* prevent deadlocks */",
        "\tsbp2_unblock(tgt);",
        "",
        "\tlist_for_each_entry_safe(lu, next, &tgt->lu_list, link) {"
      ]
    },
    {
      "file": "linux\\drivers\\gpio\\gpio-104-dio-48e.c",
      "line": 111,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "/**",
        " * struct dio48e_gpio - GPIO device private data structure",
        " * @lock:\tsynchronization lock to prevent I/O race conditions",
        " * @map:\tRegmap for the device",
        " * @regs:\tvirtual mapping for device registers",
        " * @flags:\tIRQ flags saved during locking"
      ]
    },
    {
      "file": "linux\\drivers\\gpio\\gpio-aggregator.c",
      "line": 1406,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\t/*",
        "\t * CAVEAT: This must occur after configfs registration. Otherwise,",
        "\t * a race condition could arise: driver attribute groups might be",
        "\t * exposed and accessed by users before configfs registration",
        "\t * completes. new_device_store() does not expect a partially",
        "\t * initialized configfs state."
      ]
    },
    {
      "file": "linux\\drivers\\gpio\\gpio-aggregator.c",
      "line": 215,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * Normally, we acquire aggr->lock within the configfs",
        "\t\t * callback. However, in the legacy sysfs interface case,",
        "\t\t * calling configfs_(un)register_group while holding",
        "\t\t * aggr->lock could cause a deadlock. Fortunately, this is",
        "\t\t * unnecessary because the new_device/delete_device path",
        "\t\t * and the module unload path are mutually exclusive,",
        "\t\t * thanks to an explicit try_module_get. That's why this"
      ]
    },
    {
      "file": "linux\\drivers\\gpio\\gpio-aggregator.c",
      "line": 1376,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "{",
        "\t/*",
        "\t * Configfs callbacks acquire gpio_aggregator_lock when accessing",
        "\t * gpio_aggregator_idr, so to prevent lock inversion deadlock, we",
        "\t * cannot protect idr_for_each invocation here with",
        "\t * gpio_aggregator_lock, as gpio_aggregator_idr_remove() accesses",
        "\t * configfs groups. Fortunately, the new_device/delete_device path"
      ]
    },
    {
      "file": "linux\\drivers\\gpio\\gpio-mvebu.c",
      "line": 476,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " *\t\t       Interrupt are masked by EDGE_MASK registers.",
        " * Both-edge handlers: Similar to regular Edge handlers, but also swaps",
        " *\t\t       the polarity to catch the next line transaction.",
        " *\t\t       This is a race condition that might not perfectly",
        " *\t\t       work on some use cases.",
        " *",
        " * Every eight GPIO lines are grouped (OR'ed) before going up to main"
      ]
    },
    {
      "file": "linux\\drivers\\gpio\\gpio-pcie-idio-24.c",
      "line": 149,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "/**",
        " * struct idio_24_gpio - GPIO device private data structure",
        " * @map:\tregmap for the device",
        " * @lock:\tsynchronization lock to prevent I/O race conditions",
        " * @irq_type:\ttype configuration for IRQs",
        " */",
        "struct idio_24_gpio {"
      ]
    },
    {
      "file": "linux\\drivers\\gpio\\gpio-ws16c48.c",
      "line": 105,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "/**",
        " * struct ws16c48_gpio - GPIO device private data structure",
        " * @map:\tregmap for the device",
        " * @lock:\tsynchronization lock to prevent I/O race conditions",
        " * @irq_mask:\tI/O bits affected by interrupts",
        " */",
        "struct ws16c48_gpio {"
      ]
    },
    {
      "file": "linux\\drivers\\gpio\\gpiolib-legacy.c",
      "line": 16,
      "pattern": "deprecated.*function",
      "rule": "api_usage",
      "severity": "medium",
      "match": "DEPRECATED** This function",
      "context": [
        "#include \"gpiolib.h\"",
        "",
        "/*",
        " * **DEPRECATED** This function is deprecated and must not be used in new code.",
        " */",
        "void gpio_free(unsigned gpio)",
        "{"
      ]
    },
    {
      "file": "linux\\drivers\\gpio\\gpiolib-legacy.c",
      "line": 30,
      "pattern": "deprecated.*function",
      "rule": "api_usage",
      "severity": "medium",
      "match": "DEPRECATED** This function",
      "context": [
        " * @flags:\tGPIO configuration as specified by GPIOF_*",
        " * @label:\ta literal description string of this GPIO",
        " *",
        " * **DEPRECATED** This function is deprecated and must not be used in new code.",
        " *",
        " * Returns:",
        " * 0 on success, or negative errno on failure."
      ]
    },
    {
      "file": "linux\\drivers\\gpio\\gpiolib-legacy.c",
      "line": 66,
      "pattern": "deprecated.*function",
      "rule": "api_usage",
      "severity": "medium",
      "match": "DEPRECATED** This function",
      "context": [
        "EXPORT_SYMBOL_GPL(gpio_request_one);",
        "",
        "/*",
        " * **DEPRECATED** This function is deprecated and must not be used in new code.",
        " */",
        "int gpio_request(unsigned gpio, const char *label)",
        "{"
      ]
    },
    {
      "file": "linux\\drivers\\gpio\\gpiolib-legacy.c",
      "line": 99,
      "pattern": "deprecated.*function",
      "rule": "api_usage",
      "severity": "medium",
      "match": "DEPRECATED** This function",
      "context": [
        " * GPIOs requested with this function will be automatically freed",
        " * on driver detach.",
        " *",
        " * **DEPRECATED** This function is deprecated and must not be used in new code.",
        " *",
        " * Returns:",
        " * 0 on success, or negative errno on failure."
      ]
    },
    {
      "file": "linux\\drivers\\gpio\\gpiolib-legacy.c",
      "line": 133,
      "pattern": "deprecated.*function",
      "rule": "api_usage",
      "severity": "medium",
      "match": "DEPRECATED** This function",
      "context": [
        " * @flags: GPIO configuration as specified by GPIOF_*",
        " * @label: a literal description string of this GPIO",
        " *",
        " * **DEPRECATED** This function is deprecated and must not be used in new code.",
        " *",
        " * Returns:",
        " * 0 on success, or negative errno on failure."
      ]
    },
    {
      "file": "linux\\drivers\\gpio\\gpiolib-of.c",
      "line": 455,
      "pattern": "deprecated.*function",
      "rule": "api_usage",
      "severity": "medium",
      "match": "DEPRECATED** This function",
      "context": [
        " * @propname:\tName of property containing gpio specifier(s)",
        " * @index:\tindex of the GPIO",
        " *",
        " * **DEPRECATED** This function is deprecated and must not be used in new code.",
        " *",
        " * Returns:",
        " * GPIO number to use with Linux generic GPIO API, or one of the errno"
      ]
    },
    {
      "file": "linux\\drivers\\gpio\\gpiolib.c",
      "line": 1898,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tstruct irq_domain *domain = gc->irq.domain;",
        "",
        "\t/*",
        "\t * Avoid race condition with other code, which tries to lookup",
        "\t * an IRQ before the irqchip has been properly registered,",
        "\t * i.e. while gpiochip is still being brought up.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\gpio\\gpiolib.c",
      "line": 4010,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "#ifdef CONFIG_GPIOLIB_IRQCHIP",
        "\tif (gc->irq.chip) {",
        "\t\t/*",
        "\t\t * Avoid race condition with other code, which tries to lookup",
        "\t\t * an IRQ before the irqchip has been properly registered,",
        "\t\t * i.e. while gpiochip is still being brought up.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\greybus\\gb-beagleplay.c",
      "line": 403,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "Buffer Overflow",
      "context": [
        "\t\t\t\tbg->rx_buffer[bg->rx_buffer_len] = c;",
        "\t\t\t\tbg->rx_buffer_len++;",
        "\t\t\t} else {",
        "\t\t\t\tdev_err_ratelimited(&bg->sd->dev, \"RX Buffer Overflow\");",
        "\t\t\t\tbg->rx_buffer_len = 0;",
        "\t\t\t}",
        "\t\t}"
      ]
    },
    {
      "file": "linux\\drivers\\hid\\hid-core.c",
      "line": 404,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "stack overflow",
      "context": [
        "\tcase HID_GLOBAL_ITEM_TAG_PUSH:",
        "",
        "\t\tif (parser->global_stack_ptr == HID_GLOBAL_STACK_SIZE) {",
        "\t\t\thid_err(parser->device, \"global environment stack overflow\\n\");",
        "\t\t\treturn -1;",
        "\t\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\hid\\hid-picolcd_debugfs.c",
      "line": 363,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing\", \"data_missing\", \"block",
      "context": [
        " * Helper code for HID report level dumping/debugging",
        " */",
        "static const char * const error_codes[] = {",
        "\t\"success\", \"parameter missing\", \"data_missing\", \"block readonly\",",
        "\t\"block not erasable\", \"block too big\", \"section overflow\",",
        "\t\"invalid command length\", \"invalid data length\",",
        "};"
      ]
    },
    {
      "file": "linux\\drivers\\hid\\hid-steam.c",
      "line": 342,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t/*",
        "\t * The report ID is always 0, so strip the first byte from the output.",
        "\t * hid_report_len() is not counting the report ID, so +1 to the length",
        "\t * or else we get a EOVERFLOW. We are safe from a buffer overflow",
        "\t * because hid_alloc_report_buf() allocates +7 bytes.",
        "\t */",
        "\tret = hid_hw_raw_request(steam->hdev, 0x00,"
      ]
    },
    {
      "file": "linux\\drivers\\hid\\hid-wiimote-modules.c",
      "line": 147,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\telse",
        "\t\tvalue = 0;",
        "",
        "\t/* Locking state.lock here might deadlock with input_event() calls.",
        "\t * schedule_work acts as barrier. Merging multiple changes is fine. */",
        "\twdata->state.cache_rumble = value;",
        "\tschedule_work(&wdata->rumble_worker);"
      ]
    },
    {
      "file": "linux\\drivers\\hid\\hid-wiimote-modules.c",
      "line": 1805,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\telse",
        "\t\tvalue = 0;",
        "",
        "\t/* Locking state.lock here might deadlock with input_event() calls.",
        "\t * schedule_work acts as barrier. Merging multiple changes is fine. */",
        "\twdata->state.cache_rumble = value;",
        "\tschedule_work(&wdata->rumble_worker);"
      ]
    },
    {
      "file": "linux\\drivers\\hsi\\hsi_core.c",
      "line": 712,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * @event: The event type",
        " *",
        " * Clients should not be concerned about wake line behavior. However, due",
        " * to a race condition in HSI HW protocol, clients need to be notified",
        " * about wake line changes, so they can implement a workaround for it.",
        " *",
        " * Events:"
      ]
    },
    {
      "file": "linux\\drivers\\hv\\channel.c",
      "line": 450,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory will be leak",
      "context": [
        "\t * Set the \"decrypted\" flag to true for the set_memory_decrypted()",
        "\t * success case. In the failure case, the encryption state of the",
        "\t * memory is unknown. Leave \"decrypted\" as true to ensure the",
        "\t * memory will be leaked instead of going back on the free list.",
        "\t */",
        "\tgpadl->decrypted = true;",
        "\tret = set_memory_decrypted((unsigned long)kbuffer,"
      ]
    },
    {
      "file": "linux\\drivers\\hv\\channel.c",
      "line": 544,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory is leak",
      "context": [
        "\tif (ret) {",
        "\t\t/*",
        "\t\t * If set_memory_encrypted() fails, the decrypted flag is",
        "\t\t * left as true so the memory is leaked instead of being",
        "\t\t * put back on the free list.",
        "\t\t */",
        "\t\tif (!set_memory_encrypted((unsigned long)kbuffer, PFN_UP(size)))"
      ]
    },
    {
      "file": "linux\\drivers\\hv\\channel.c",
      "line": 1165,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "/*",
        " * vmbus_next_request_id - Returns a new request id. It is also",
        " * the index at which the guest memory address is stored.",
        " * Uses a spin lock to avoid race conditions.",
        " * @channel: Pointer to the VMbus channel struct",
        " * @rqst_add: Guest memory address to be stored in the array",
        " */"
      ]
    },
    {
      "file": "linux\\drivers\\hv\\channel.c",
      "line": 1267,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "/*",
        " * vmbus_request_addr - Returns the memory address stored at @trans_id",
        " * in @rqstor. Uses a spin lock to avoid race conditions.",
        " * @channel: Pointer to the VMbus channel struct",
        " * @trans_id: Request id sent back from Hyper-V. Becomes the requestor's",
        " * next request id."
      ]
    },
    {
      "file": "linux\\drivers\\hv\\connection.c",
      "line": 252,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory is unknown. So leak",
      "context": [
        "\tif (ret) {",
        "\t\t/*",
        "\t\t * If set_memory_decrypted() fails, the encryption state",
        "\t\t * of the memory is unknown. So leak the memory instead",
        "\t\t * of risking returning decrypted memory to the free list.",
        "\t\t * For simplicity, always handle both pages the same.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\hv\\channel_mgmt.c",
      "line": 682,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * OPEN_CHANNEL message (the host may rescind a channel at any time,",
        "\t * e.g. in the case of hot removing a NIC), and vmbus_onoffer_rescind()",
        "\t * may not wake up the vmbus_open() as it's blocked due to a non-zero",
        "\t * vmbus_connection.offer_in_progress, and finally we have a deadlock.",
        "\t *",
        "\t * The above is also true for primary channels, if the related device",
        "\t * drivers use sync probing mode by default."
      ]
    },
    {
      "file": "linux\\drivers\\hv\\channel_mgmt.c",
      "line": 689,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t *",
        "\t * And, usually the handling of primary channels and sub-channels can",
        "\t * depend on each other, so we should offload them to different",
        "\t * workqueues to avoid possible deadlock, e.g. in sync-probing mode,",
        "\t * NIC1's netvsc_subchan_work() can race with NIC2's netvsc_probe() ->",
        "\t * rtnl_lock(), and causes deadlock: the former gets the rtnl_lock",
        "\t * and waits for all the sub-channels to appear, but the latter"
      ]
    },
    {
      "file": "linux\\drivers\\hv\\channel_mgmt.c",
      "line": 691,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * depend on each other, so we should offload them to different",
        "\t * workqueues to avoid possible deadlock, e.g. in sync-probing mode,",
        "\t * NIC1's netvsc_subchan_work() can race with NIC2's netvsc_probe() ->",
        "\t * rtnl_lock(), and causes deadlock: the former gets the rtnl_lock",
        "\t * and waits for all the sub-channels to appear, but the latter",
        "\t * can't get the rtnl_lock and this blocks the handling of",
        "\t * sub-channels."
      ]
    },
    {
      "file": "linux\\drivers\\hv\\hv_balloon.c",
      "line": 1391,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t/*",
        "\t\t * disable free page reporting if multiple hypercall",
        "\t\t * failure flag set. It is not done in the page_reporting",
        "\t\t * callback context as that causes a deadlock between",
        "\t\t * page_reporting_process() and page_reporting_unregister()",
        "\t\t */",
        "\t\tif (hv_hypercall_multi_failure >= HV_MAX_FAILURES) {"
      ]
    },
    {
      "file": "linux\\drivers\\hv\\ring_buffer.c",
      "line": 560,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * inappropriately.",
        " *",
        " * Determining when to signal is tricky. There are three key data inputs",
        " * that must be handled in this order to avoid race conditions:",
        " *",
        " * 1. Update the read_index",
        " * 2. Read the pending_send_sz"
      ]
    },
    {
      "file": "linux\\drivers\\hv\\vmbus_drv.c",
      "line": 1952,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "Race condition",
      "context": [
        " * time, and \"ring\" sysfs is needed only when uio_hv_generic is bound to that device. To avoid",
        " * exposing the ring buffer by default, this function is reponsible to enable visibility of",
        " * ring for userspace to use.",
        " * Note: Race conditions can happen with userspace and it is not encouraged to create new",
        " * use-cases for this. This was added to maintain backward compatibility, while solving",
        " * one of the race conditions in uio_hv_generic while creating sysfs. See comments with",
        " * vmbus_add_dynid() and vmbus_device_register()."
      ]
    },
    {
      "file": "linux\\drivers\\hv\\vmbus_drv.c",
      "line": 1954,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * ring for userspace to use.",
        " * Note: Race conditions can happen with userspace and it is not encouraged to create new",
        " * use-cases for this. This was added to maintain backward compatibility, while solving",
        " * one of the race conditions in uio_hv_generic while creating sysfs. See comments with",
        " * vmbus_add_dynid() and vmbus_device_register().",
        " *",
        " * Returns 0 on success or error code on failure."
      ]
    },
    {
      "file": "linux\\drivers\\hv\\vmbus_drv.c",
      "line": 2101,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * here. The race can't result in a kernel failure, but the user space",
        "\t * program may get an error in accessing \"channels\" or its",
        "\t * subdirectories. See also comments with vmbus_add_dynid() about a",
        "\t * related race condition.",
        "\t */",
        "\tchild_device_obj->channels_kset = kset_create_and_add(\"channels\",",
        "\t\t\t\t\t\t\t      NULL, kobj);"
      ]
    },
    {
      "file": "linux\\drivers\\hwmon\\asus-ec-sensors.c",
      "line": 820,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "Race condition",
      "context": [
        "\tif (prev_bank) {",
        "\t\t/* oops... somebody else is working with the EC too */",
        "\t\tdev_warn(dev,",
        "\t\t\t\"Concurrent access to the ACPI EC detected.\\nRace condition possible.\");",
        "\t}",
        "",
        "\t/* read registers minimizing bank switches. */"
      ]
    },
    {
      "file": "linux\\drivers\\hwmon\\fschmd.c",
      "line": 803,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * We get called from drivers/char/misc.c with misc_mtx hold, and we",
        "\t * call misc_register() from fschmd_probe() with watchdog_data_mutex",
        "\t * hold, as misc_register() takes the misc_mtx lock, this is a possible",
        "\t * deadlock, so we use mutex_trylock here.",
        "\t */",
        "\tif (!mutex_trylock(&watchdog_data_mutex))",
        "\t\treturn -ERESTARTSYS;"
      ]
    },
    {
      "file": "linux\\drivers\\hwmon\\it87.c",
      "line": 777,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * Must be called with data->update_lock held, except during initialization.",
        " * Must be called with SMBus accesses disabled.",
        " * We ignore the IT87 BUSY flag at this moment - it could lead to deadlocks,",
        " * would slow down the IT87 access and should not be necessary.",
        " */",
        "static int it87_read_value(struct it87_data *data, u8 reg)"
      ]
    },
    {
      "file": "linux\\drivers\\hwmon\\it87.c",
      "line": 789,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * Must be called with data->update_lock held, except during initialization.",
        " * Must be called with SMBus accesses disabled.",
        " * We ignore the IT87 BUSY flag at this moment - it could lead to deadlocks,",
        " * would slow down the IT87 access and should not be necessary.",
        " */",
        "static void it87_write_value(struct it87_data *data, u8 reg, u8 value)"
      ]
    },
    {
      "file": "linux\\drivers\\hwmon\\lm78.c",
      "line": 673,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * The SMBus locks itself, but ISA access must be locked explicitly!",
        " * We don't want to lock the whole ISA bus, so we lock each client",
        " * separately.",
        " * We ignore the LM78 BUSY flag at this moment - it could lead to deadlocks,",
        " * would slow down the LM78 access and should not be necessary.",
        " */",
        "static int lm78_read_value(struct lm78_data *data, u8 reg)"
      ]
    },
    {
      "file": "linux\\drivers\\hwmon\\w83781d.c",
      "line": 1723,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * The SMBus locks itself, usually, but nothing may access the Winbond between",
        " * bank switches. ISA access must always be locked explicitly!",
        " * We ignore the W83781D BUSY flag at this moment - it could lead to deadlocks,",
        " * would slow down the W83781D access and should not be necessary.",
        " * There are some ugly typecasts here, but the good news is - they should",
        " * nowhere else be necessary!"
      ]
    },
    {
      "file": "linux\\drivers\\hwmon\\w83793.c",
      "line": 1296,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * We get called from drivers/char/misc.c with misc_mtx hold, and we",
        "\t * call misc_register() from  w83793_probe() with watchdog_data_mutex",
        "\t * hold, as misc_register() takes the misc_mtx lock, this is a possible",
        "\t * deadlock, so we use mutex_trylock here.",
        "\t */",
        "\tif (!mutex_trylock(&watchdog_data_mutex))",
        "\t\treturn -ERESTARTSYS;"
      ]
    },
    {
      "file": "linux\\drivers\\i2c\\i2c-core-base.c",
      "line": 2625,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t\treturn;",
        "",
        "\tmodule_put(adap->owner);",
        "\t/* Should be last, otherwise we risk use-after-free with 'adap' */",
        "\tput_device(&adap->dev);",
        "}",
        "EXPORT_SYMBOL(i2c_put_adapter);"
      ]
    },
    {
      "file": "linux\\drivers\\i2c\\i2c-core-smbus.c",
      "line": 569,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "racepoints are condition",
      "context": [
        "\tif (res)",
        "\t\treturn res;",
        "",
        "\t/* If enabled, the following two tracepoints are conditional on",
        "\t * read_write and protocol.",
        "\t */",
        "\ttrace_smbus_write(adapter, addr, flags, read_write,"
      ]
    },
    {
      "file": "linux\\drivers\\i2c\\i2c-core-smbus.c",
      "line": 612,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "racepoint is condition",
      "context": [
        "\t\t\t\t      command, protocol, data);",
        "",
        "trace:",
        "\t/* If enabled, the reply tracepoint is conditional on read_write. */",
        "\ttrace_smbus_reply(adapter, addr, flags, read_write,",
        "\t\t\t  command, protocol, data, res);",
        "\ttrace_smbus_result(adapter, addr, flags, read_write,"
      ]
    },
    {
      "file": "linux\\drivers\\iio\\industrialio-buffer.c",
      "line": 1969,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * The fence will be unref'd in iio_buffer_cleanup.",
        "\t * It can't be done here, as the unref functions might try to lock the",
        "\t * resv object, which can deadlock.",
        "\t */",
        "\tINIT_WORK(&iio_fence->work, iio_buffer_cleanup);",
        "\tschedule_work(&iio_fence->work);"
      ]
    },
    {
      "file": "linux\\drivers\\iommu\\iommu.c",
      "line": 1918,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * FIXME: Mis-locked because the ops->probe_finalize() call-back",
        "\t\t * of some IOMMU drivers calls arm_iommu_attach_device() which",
        "\t\t * in-turn might call back into IOMMU core code, where it tries",
        "\t\t * to take group->mutex, resulting in a deadlock.",
        "\t\t */",
        "\t\tfor_each_group_device(group, gdev)",
        "\t\t\tiommu_group_do_probe_finalize(gdev->dev);"
      ]
    },
    {
      "file": "linux\\drivers\\iommu\\ipmmu-vmsa.c",
      "line": 262,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t\t     !(val & IMCTR_FLUSH), 1, TLB_LOOP_TIMEOUT,",
        "\t\t\t\t     false, domain, IMCTR))",
        "\t\tdev_err_ratelimited(domain->mmu->dev,",
        "\t\t\t\"TLB sync timed out -- MMU may be deadlocked\\n\");",
        "}",
        "",
        "static void ipmmu_tlb_invalidate(struct ipmmu_vmsa_domain *domain)"
      ]
    },
    {
      "file": "linux\\drivers\\irqchip\\irq-gic-v3-its.c",
      "line": 244,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory cannot be encrypted again then we must leak",
      "context": [
        "static void its_free_pages(void *addr, unsigned int order)",
        "{",
        "\t/*",
        "\t * If the memory cannot be encrypted again then we must leak the pages.",
        "\t * set_memory_encrypted() will already have WARNed.",
        "\t */",
        "\tif (set_memory_encrypted((unsigned long)addr, 1 << order))"
      ]
    },
    {
      "file": "linux\\drivers\\irqchip\\irq-ti-sci-inta.c",
      "line": 418,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * Note: This is the core api where the actual allocation happens for input",
        " *\t hwirq. This allocation involves creating a parent irq for vint.",
        " *\t If this is done in irq_domain_ops.alloc() then a deadlock is reached",
        " *\t for allocation. So this allocation is being done in request_resources()",
        " *",
        " * Return: 0 if all went well else corresponding error."
      ]
    },
    {
      "file": "linux\\drivers\\macintosh\\smu.c",
      "line": 652,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Ok, we are matched, now expose all i2c busses. We have to defer",
        "\t * that unfortunately or it would deadlock inside the device model",
        "\t */",
        "\tschedule_work(&smu_expose_childs_work);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\macintosh\\windfarm_pm121.c",
      "line": 423,
      "pattern": "hardcoded.*values",
      "rule": "code_quality",
      "severity": "low",
      "match": "hardcoded values",
      "context": [
        "\t},",
        "};",
        "",
        "/* the hardcoded values */",
        "#define\tPM121_SYS_GD\t\t0x00000000",
        "#define\tPM121_SYS_GR\t\t0x00019999",
        "#define\tPM121_SYS_HISTORY_SIZE\t2"
      ]
    },
    {
      "file": "linux\\drivers\\mailbox\\mailbox-th1520.c",
      "line": 304,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t *    any other devm_ resources are released.",
        "\t *",
        "\t * This ordering guarantees that no interrupts can be triggered from the device",
        "\t * while it is being unbound, preventing race conditions and ensuring system",
        "\t * stability.",
        "\t */",
        "\tret = request_irq(priv->irq, th1520_mbox_isr,"
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-bufio.c",
      "line": 1822,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * read if dm_bufio_get function is used. Both dm_bufio_get and",
        "\t * dm_bufio_prefetch can be used in the driver request routine.",
        "\t * If the user called both dm_bufio_prefetch and dm_bufio_get on",
        "\t * the same buffer, it would deadlock if we waited.",
        "\t */",
        "\tif (nf == NF_GET && unlikely(test_bit_acquire(B_READING, &b->state))) {",
        "\t\tcache_put_and_wake(c, b);"
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-bufio.c",
      "line": 1882,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * read if dm_bufio_get function is used. Both dm_bufio_get and",
        "\t\t * dm_bufio_prefetch can be used in the driver request routine.",
        "\t\t * If the user called both dm_bufio_prefetch and dm_bufio_get on",
        "\t\t * the same buffer, it would deadlock if we waited.",
        "\t\t */",
        "\t\tif (nf == NF_GET && unlikely(test_bit_acquire(B_READING, &b->state))) {",
        "\t\t\tcache_put_and_wake(c, b);"
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-cache-metadata.c",
      "line": 1787,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Replacement block manager (new_bm) is created and old_bm destroyed outside of",
        "\t * cmd root_lock to avoid ABBA deadlock that would result (due to life-cycle of",
        "\t * shrinker associated with the block manager's bufio client vs cmd root_lock).",
        "\t * - must take shrinker_mutex without holding cmd->root_lock",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-cache-metadata.c",
      "line": 1781,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double-checked with cmd->root_lock",
      "context": [
        "\tint r = -EINVAL;",
        "\tstruct dm_block_manager *old_bm = NULL, *new_bm = NULL;",
        "",
        "\t/* fail_io is double-checked with cmd->root_lock held below */",
        "\tif (unlikely(cmd->fail_io))",
        "\t\treturn r;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-crypt.c",
      "line": 1673,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * core should split the bio as needed).",
        " *",
        " * This function may be called concurrently. If we allocate from the mempool",
        " * concurrently, there is a possibility of deadlock. For example, if we have",
        " * mempool of 256 pages, two processes, each wanting 256, pages allocate from",
        " * the mempool concurrently, it may deadlock in a situation where both processes",
        " * have allocated 128 pages and the mempool is exhausted."
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-crypt.c",
      "line": 1675,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * This function may be called concurrently. If we allocate from the mempool",
        " * concurrently, there is a possibility of deadlock. For example, if we have",
        " * mempool of 256 pages, two processes, each wanting 256, pages allocate from",
        " * the mempool concurrently, it may deadlock in a situation where both processes",
        " * have allocated 128 pages and the mempool is exhausted.",
        " *",
        " * In order to avoid this scenario we allocate the pages under a mutex."
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-kcopyd.c",
      "line": 344,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *---------------------------------------------------------------",
        " * kcopyd_jobs need to be allocated by the *clients* of kcopyd,",
        " * for this reason we use a mempool to prevent the client from",
        " * ever having to do io (which could cause a deadlock).",
        " *---------------------------------------------------------------",
        " */",
        "struct kcopyd_job {"
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-ioctl.c",
      "line": 1834,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer_overflow",
      "context": [
        "",
        "\tif (r == 1) {",
        "\t\tparam->flags |= DM_DATA_OUT_FLAG;",
        "\t\tif (dm_message_test_buffer_overflow(result, maxlen))",
        "\t\t\tparam->flags |= DM_BUFFER_FULL_FLAG;",
        "\t\telse",
        "\t\t\tparam->data_size = param->data_start + strlen(result) + 1;"
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-raid.c",
      "line": 3834,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * For raid456, if reshape is interrupted, IO across reshape position",
        "\t * will never make progress, while caller will wait for IO to be done.",
        "\t * Inform raid456 to handle those IO to prevent deadlock.",
        "\t */",
        "\tif (mddev->pers && mddev->pers->prepare_suspend)",
        "\t\tmddev->pers->prepare_suspend(mddev);"
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-raid.c",
      "line": 3854,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tif (!test_and_set_bit(RT_FLAG_RS_SUSPENDED, &rs->runtime_flags)) {",
        "\t\t/*",
        "\t\t * sync_thread must be stopped during suspend, and writes have",
        "\t\t * to be stopped before suspending to avoid deadlocks.",
        "\t\t */",
        "\t\tmd_stop_writes(&rs->md);",
        "\t\tmddev_suspend(&rs->md, false);"
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-raid1.c",
      "line": 482,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "static void hold_bio(struct mirror_set *ms, struct bio *bio)",
        "{",
        "\t/*",
        "\t * Lock is required to avoid race condition during suspend",
        "\t * process.",
        "\t */",
        "\tspin_lock_irq(&ms->lock);"
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-stats.c",
      "line": 1261,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory_amount leak",
      "context": [
        "\tif (dm_stat_need_rcu_barrier)",
        "\t\trcu_barrier();",
        "\tif (WARN_ON(shared_memory_amount))",
        "\t\tDMCRIT(\"shared_memory_amount leaked: %lu\", shared_memory_amount);",
        "}",
        "",
        "module_param_named(stats_current_allocated_bytes, shared_memory_amount, ulong, 0444);"
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-stats.c",
      "line": 690,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\tif (!end) {",
        "\t\t/*",
        "\t\t * A race condition can at worst result in the merged flag being",
        "\t\t * misrepresented, so we don't have to disable preemption here.",
        "\t\t */",
        "\t\tlast = raw_cpu_ptr(stats->last);"
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-stats.c",
      "line": 921,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer_overflow",
      "context": [
        "\t\tDMEMIT(\"\\n\");",
        "",
        "\t\tif (unlikely(sz + 1 >= maxlen))",
        "\t\t\tgoto buffer_overflow;",
        "",
        "\t\tcond_resched();",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-stats.c",
      "line": 929,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer_overflow",
      "context": [
        "\tif (clear)",
        "\t\t__dm_stat_clear(s, idx_start, idx_end, false);",
        "",
        "buffer_overflow:",
        "\tmutex_unlock(&stats->mutex);",
        "",
        "\treturn 1;"
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-stats.c",
      "line": 1094,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\tgoto ret_einval;",
        "",
        "\t/*",
        "\t * If a buffer overflow happens after we created the region,",
        "\t * it's too late (the userspace would retry with a larger",
        "\t * buffer, but the region id that caused the overflow is already",
        "\t * leaked).  So we must detect buffer overflow in advance."
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-stats.c",
      "line": 1096,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer, but the region id that caused the overflow",
      "context": [
        "\t/*",
        "\t * If a buffer overflow happens after we created the region,",
        "\t * it's too late (the userspace would retry with a larger",
        "\t * buffer, but the region id that caused the overflow is already",
        "\t * leaked).  So we must detect buffer overflow in advance.",
        "\t */",
        "\tsnprintf(result, maxlen, \"%d\", INT_MAX);"
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-stats.c",
      "line": 1097,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t * If a buffer overflow happens after we created the region,",
        "\t * it's too late (the userspace would retry with a larger",
        "\t * buffer, but the region id that caused the overflow is already",
        "\t * leaked).  So we must detect buffer overflow in advance.",
        "\t */",
        "\tsnprintf(result, maxlen, \"%d\", INT_MAX);",
        "\tif (dm_message_test_buffer_overflow(result, maxlen)) {"
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-stats.c",
      "line": 1100,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer_overflow",
      "context": [
        "\t * leaked).  So we must detect buffer overflow in advance.",
        "\t */",
        "\tsnprintf(result, maxlen, \"%d\", INT_MAX);",
        "\tif (dm_message_test_buffer_overflow(result, maxlen)) {",
        "\t\tr = 1;",
        "\t\tgoto ret;",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-thin-metadata.c",
      "line": 1901,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double-checked with pmd->root_lock",
      "context": [
        "{",
        "\tint r = -EINVAL;",
        "",
        "\t/* fail_io is double-checked with pmd->root_lock held below */",
        "\tif (unlikely(pmd->fail_io))",
        "\t\treturn r;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-verity-fec.c",
      "line": 707,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Missing \" DM_VERITY_OPT_FEC_BLOCK",
      "context": [
        "\tf->rsn = DM_VERITY_FEC_RSM - f->roots;",
        "",
        "\tif (!f->blocks) {",
        "\t\tti->error = \"Missing \" DM_VERITY_OPT_FEC_BLOCKS;",
        "\t\treturn -EINVAL;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-thin.c",
      "line": 2766,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tcase 0:",
        "\t\tif (unlikely(result.shared)) {",
        "\t\t\t/*",
        "\t\t\t * We have a race condition here between the",
        "\t\t\t * result.shared value returned by the lookup and",
        "\t\t\t * snapshot creation, which may cause new",
        "\t\t\t * sharing."
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-verity-target.c",
      "line": 82,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * The variable hash_verified is set to 0 when allocating the buffer, then",
        " * it can be changed to 1 and it is never reset to 0 again.",
        " *",
        " * There is no lock around this value, a race condition can at worst cause",
        " * that multiple processes verify the hash of the same buffer simultaneously",
        " * and write 1 to hash_verified simultaneously.",
        " * This condition is harmless, so we don't need locking."
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm.c",
      "line": 1575,
      "pattern": "null.*pointer.*dereference",
      "rule": "memory_management",
      "severity": "high",
      "match": "NULL pointer dereference",
      "context": [
        "\t\t\t * associated with any target (because the device may be",
        "\t\t\t * used by multiple targets), so we set tio->ti = NULL.",
        "\t\t\t * We must check for NULL in the I/O processing path, to",
        "\t\t\t * avoid NULL pointer dereference.",
        "\t\t\t */",
        "\t\t\tclone = alloc_tio(ci, NULL, 0, &len, GFP_NOIO);",
        "\t\t\tatomic_add(1, &ci->io->io_count);"
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm.c",
      "line": 2690,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tset_bit(DMF_POST_SUSPENDING, &md->flags);",
        "\t\tdm_table_postsuspend_targets(map);",
        "\t}",
        "\t/* dm_put_live_table must be before fsleep, otherwise deadlock is possible */",
        "\tdm_put_live_table(md, srcu_idx);",
        "\tmutex_unlock(&md->suspend_lock);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm.c",
      "line": 3022,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\tmap = rcu_dereference_protected(md->map, lockdep_is_held(&md->suspend_lock));",
        "\tif (!map) {",
        "\t\t/* avoid deadlock with fs/namespace.c:do_mount() */",
        "\t\tsuspend_flags &= ~DM_SUSPEND_LOCKFS_FLAG;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\md\\md.c",
      "line": 470,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tint err = 0;",
        "",
        "\t/*",
        "\t * hold reconfig_mutex to wait for normal io will deadlock, because",
        "\t * other context can't update super_block, and normal io can rely on",
        "\t * updating super_block.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\md\\md.c",
      "line": 505,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * For raid456, io might be waiting for reshape to make progress,",
        "\t * allow new reshape to start while waiting for io to be done to",
        "\t * prevent deadlock.",
        "\t */",
        "\tWRITE_ONCE(mddev->suspended, mddev->suspended + 1);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\md\\md.c",
      "line": 833,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t/* These cannot be removed under reconfig_mutex as",
        "\t\t * an access to the files will try to take reconfig_mutex",
        "\t\t * while holding the file unremovable, which leads to",
        "\t\t * a deadlock.",
        "\t\t * So hold set sysfs_active while the remove in happeing,",
        "\t\t * and anything else which might set ->to_remove or my",
        "\t\t * otherwise change the sysfs namespace will fail with"
      ]
    },
    {
      "file": "linux\\drivers\\md\\md.c",
      "line": 8082,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * md_thread is a 'system-thread', it's priority should be very",
        "\t * high. We avoid resource deadlocks individually in each",
        "\t * raid personality. (RAID5 does preallocation) We also use RR and",
        "\t * the very same RT priority as kswapd, thus we will never get",
        "\t * into a priority inversion deadlock."
      ]
    },
    {
      "file": "linux\\drivers\\md\\md.c",
      "line": 8085,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * high. We avoid resource deadlocks individually in each",
        "\t * raid personality. (RAID5 does preallocation) We also use RR and",
        "\t * the very same RT priority as kswapd, thus we will never get",
        "\t * into a priority inversion deadlock.",
        "\t *",
        "\t * we definitely have to have equal or higher priority than",
        "\t * bdflush, otherwise bdflush will deadlock if there are too"
      ]
    },
    {
      "file": "linux\\drivers\\md\\md.c",
      "line": 8088,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * into a priority inversion deadlock.",
        "\t *",
        "\t * we definitely have to have equal or higher priority than",
        "\t * bdflush, otherwise bdflush will deadlock if there are too",
        "\t * many dirty RAID5 blocks.",
        "\t */",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\md\\md.c",
      "line": 9061,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * Before starting a resync we must have set curr_resync to",
        "\t * 2, and then checked that every \"conflicting\" array has curr_resync",
        "\t * less than ours.  When we find one that is the same or higher",
        "\t * we wait on resync_wait.  To avoid deadlock, we reduce curr_resync",
        "\t * to 1 if we choose to yield (based arbitrarily on address of mddev structure).",
        "\t * This will mean we have to start checking from the beginning again.",
        "\t *"
      ]
    },
    {
      "file": "linux\\drivers\\md\\md.c",
      "line": 9913,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Recording new badblocks for faulty rdev will force unnecessary",
        "\t * super block updating. This is fragile for external management because",
        "\t * userspace daemon may trying to remove this device and deadlock may",
        "\t * occur. This will be probably solved in the mdadm, but it is safer to",
        "\t * avoid it.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\md\\raid1-10.c",
      "line": 167,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * current->bio_list will be set under submit_bio() context, in this case bitmap",
        " * io will be added to the list and wait for current io submission to finish,",
        " * while current io submission must wait for bitmap io to be done. In order to",
        " * avoid such deadlock, submit bitmap io asynchronously.",
        " */",
        "static inline void raid1_prepare_flush_writes(struct mddev *mddev)",
        "{"
      ]
    },
    {
      "file": "linux\\drivers\\md\\raid1.c",
      "line": 1071,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t/*",
        "\t * After holding conf->resync_lock, conf->nr_pending[idx]",
        "\t * should be decreased before waiting for barrier to drop.",
        "\t * Otherwise, we may encounter a race condition because",
        "\t * raise_barrer() might be waiting for conf->nr_pending[idx]",
        "\t * to be 0 at same time.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\md\\raid1.c",
      "line": 1327,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * If r1_bio is set, we are blocking the raid1d thread",
        "\t * so there is a tiny risk of deadlock.  So ask for",
        "\t * emergency memory if needed.",
        "\t */",
        "\tgfp_t gfp = r1_bio ? (GFP_NOIO | __GFP_HIGH) : GFP_NOIO;"
      ]
    },
    {
      "file": "linux\\drivers\\md\\raid5-cache.c",
      "line": 371,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * Total log space (in sectors) needed to flush all data in cache",
        " *",
        " * To avoid deadlock due to log space, it is necessary to reserve log",
        " * space to flush critical stripes (stripes that occupying log space near",
        " * last_checkpoint). This function helps check how much log space is",
        " * required to flush all cached stripes."
      ]
    },
    {
      "file": "linux\\drivers\\md\\raid5-cache.c",
      "line": 1330,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * reconfig_mutex hold. The first step of raid5_quiesce() is waiting",
        "\t * for all IO finish, hence waiting for reclaim thread, while reclaim",
        "\t * thread is calling this function and waiting for reconfig mutex. So",
        "\t * there is a deadlock. We workaround this issue with a trylock.",
        "\t * FIXME: we could miss discard if we can't take reconfig mutex",
        "\t */",
        "\tset_mask_bits(&mddev->sb_flags, 0,"
      ]
    },
    {
      "file": "linux\\drivers\\md\\raid5.c",
      "line": 821,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t * Must release the reference to batch_last before",
        "\t\t\t * waiting, on quiesce, otherwise the batch_last will",
        "\t\t\t * hold a reference to a stripe and raid5_quiesce()",
        "\t\t\t * will deadlock waiting for active_stripes to go to",
        "\t\t\t * zero.",
        "\t\t\t */",
        "\t\t\tif (ctx && ctx->batch_last) {"
      ]
    },
    {
      "file": "linux\\drivers\\md\\raid5.c",
      "line": 858,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tset_bit(R5_INACTIVE_BLOCKED, &conf->cache_state);",
        "\t\tr5l_wake_reclaim(conf->log, 0);",
        "",
        "\t\t/* release batch_last before wait to avoid risk of deadlock */",
        "\t\tif (ctx && ctx->batch_last) {",
        "\t\t\traid5_release_stripe(ctx->batch_last);",
        "\t\t\tctx->batch_last = NULL;"
      ]
    },
    {
      "file": "linux\\drivers\\md\\raid5.c",
      "line": 5812,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\tset_bit(R5_Overlap, &dev->flags);",
        "\t\t\tspin_unlock_irq(&sh->stripe_lock);",
        "\t\t\traid5_release_stripe(sh);",
        "\t\t\t/* release batch_last before wait to avoid risk of deadlock */",
        "\t\t\tif (ctx->batch_last) {",
        "\t\t\t\traid5_release_stripe(ctx->batch_last);",
        "\t\t\t\tctx->batch_last = NULL;"
      ]
    },
    {
      "file": "linux\\drivers\\md\\raid5.c",
      "line": 6162,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t * scheduling and waiting for work to be done,",
        "\t\t\t * otherwise the batch_last stripe head could prevent",
        "\t\t\t * raid5_activate_delayed() from making progress",
        "\t\t\t * and thus deadlocking.",
        "\t\t\t */",
        "\t\t\tif (ctx.batch_last) {",
        "\t\t\t\traid5_release_stripe(ctx.batch_last);"
      ]
    },
    {
      "file": "linux\\drivers\\md\\raid5.c",
      "line": 8155,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tif (test_bit(Journal, &rdev->flags) && conf->log) {",
        "\t\t/*",
        "\t\t * we can't wait pending write here, as this is called in",
        "\t\t * raid5d, wait will deadlock.",
        "\t\t * neilb: there is no locking about new writes here,",
        "\t\t * so this cannot be safe.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\md\\raid5.c",
      "line": 1290,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DOUBLE_LOCK",
      "context": [
        "\t\t\tif (op == REQ_OP_DISCARD)",
        "\t\t\t\tbi->bi_vcnt = 0;",
        "\t\t\tif (rrdev)",
        "\t\t\t\tset_bit(R5_DOUBLE_LOCKED, &sh->dev[i].flags);",
        "",
        "\t\t\tmddev_trace_remap(conf->mddev, bi, sh->dev[i].sector);",
        "\t\t\tif (should_defer && op_is_write(op))"
      ]
    },
    {
      "file": "linux\\drivers\\md\\raid5.c",
      "line": 2898,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DOUBLE_LOCK",
      "context": [
        "\t\tset_bit(STRIPE_BATCH_ERR, &sh->batch_head->state);",
        "",
        "\tbio_uninit(bi);",
        "\tif (!test_and_clear_bit(R5_DOUBLE_LOCKED, &sh->dev[i].flags))",
        "\t\tclear_bit(R5_LOCKED, &sh->dev[i].flags);",
        "\tset_bit(STRIPE_HANDLE, &sh->state);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\mfd\\madera-core.c",
      "line": 491,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Missing MCLK2, requires 32kHz clock",
      "context": [
        "",
        "\t/* Not using devm_clk_get to prevent breakage of existing DTs */",
        "\tif (!madera->mclk[MADERA_MCLK2].clk)",
        "\t\tdev_warn(madera->dev, \"Missing MCLK2, requires 32kHz clock\\n\");",
        "",
        "\tret = madera_get_reset_gpio(madera);",
        "\tif (ret)"
      ]
    },
    {
      "file": "linux\\drivers\\mfd\\syscon.c",
      "line": 90,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing hwlock",
      "context": [
        "\t} else if (ret < 0) {",
        "\t\tswitch (ret) {",
        "\t\tcase -ENOENT:",
        "\t\t\t/* Ignore missing hwlock, it's optional. */",
        "\t\t\tbreak;",
        "\t\tdefault:",
        "\t\t\tpr_err(\"Failed to retrieve valid hwlock: %d\\n\", ret);"
      ]
    },
    {
      "file": "linux\\drivers\\mfd\\tps65010.c",
      "line": 334,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\tpr_info(\"%s: power off button\\n\", DRIVER_NAME);",
        "#if 0",
        "\t\t\t/* REVISIT:  this might need its own workqueue",
        "\t\t\t * plus tweaks including deadlock avoidance ...",
        "\t\t\t * also needs to get error handling and probably",
        "\t\t\t * an #ifdef CONFIG_HIBERNATION",
        "\t\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\misc\\kgdbts.c",
      "line": 794,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t}",
        "",
        "\tif (put_buf_cnt >= BUFMAX) {",
        "\t\teprintk(\"kgdbts: ERROR: put buffer overflow on\"",
        "\t\t\t   \" '%s' line %i\\n\", ts.name, ts.idx);",
        "\t\tput_buf_cnt = 0;",
        "\t\treturn 0;"
      ]
    },
    {
      "file": "linux\\drivers\\misc\\kgdbts.c",
      "line": 809,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t/* End of packet == #XX so look for the '#' */",
        "\tif (put_buf_cnt > 3 && put_buf[put_buf_cnt - 3] == '#') {",
        "\t\tif (put_buf_cnt >= BUFMAX) {",
        "\t\t\teprintk(\"kgdbts: ERROR: put buffer overflow on\"",
        "\t\t\t\t\" '%s' line %i\\n\", ts.name, ts.idx);",
        "\t\t\tput_buf_cnt = 0;",
        "\t\t\treturn 0;"
      ]
    },
    {
      "file": "linux\\drivers\\misc\\pch_phub.c",
      "line": 74,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "#define PCH_PHUB_BRI_QUEUE_MAXSIZE_REG\t\t0x000C",
        "#define PCH_PHUB_COMP_RESP_TIMEOUT_REG\t\t0x0010",
        "#define PCH_PHUB_BUS_SLAVE_CONTROL_REG\t\t0x0014",
        "#define PCH_PHUB_DEADLOCK_AVOID_TYPE_REG\t0x0018",
        "#define PCH_PHUB_INTPIN_REG_WPERMIT_REG0\t0x0020",
        "#define PCH_PHUB_INTPIN_REG_WPERMIT_REG1\t0x0024",
        "#define PCH_PHUB_INTPIN_REG_WPERMIT_REG2\t0x0028"
      ]
    },
    {
      "file": "linux\\drivers\\misc\\pch_phub.c",
      "line": 93,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * @bri_q_maxsize_reg:\t\t\tBRI_QUEUE_MAXSIZE register val",
        " * @comp_resp_timeout_reg:\t\tCOMP_RESP_TIMEOUT register val",
        " * @bus_slave_control_reg:\t\tBUS_SLAVE_CONTROL_REG register val",
        " * @deadlock_avoid_type_reg:\t\tDEADLOCK_AVOID_TYPE register val",
        " * @intpin_reg_wpermit_reg0:\t\tINTPIN_REG_WPERMIT register 0 val",
        " * @intpin_reg_wpermit_reg1:\t\tINTPIN_REG_WPERMIT register 1 val",
        " * @intpin_reg_wpermit_reg2:\t\tINTPIN_REG_WPERMIT register 2 val"
      ]
    },
    {
      "file": "linux\\drivers\\misc\\pch_phub.c",
      "line": 93,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        " * @bri_q_maxsize_reg:\t\t\tBRI_QUEUE_MAXSIZE register val",
        " * @comp_resp_timeout_reg:\t\tCOMP_RESP_TIMEOUT register val",
        " * @bus_slave_control_reg:\t\tBUS_SLAVE_CONTROL_REG register val",
        " * @deadlock_avoid_type_reg:\t\tDEADLOCK_AVOID_TYPE register val",
        " * @intpin_reg_wpermit_reg0:\t\tINTPIN_REG_WPERMIT register 0 val",
        " * @intpin_reg_wpermit_reg1:\t\tINTPIN_REG_WPERMIT register 1 val",
        " * @intpin_reg_wpermit_reg2:\t\tINTPIN_REG_WPERMIT register 2 val"
      ]
    },
    {
      "file": "linux\\drivers\\misc\\pch_phub.c",
      "line": 115,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tu32 bri_q_maxsize_reg;",
        "\tu32 comp_resp_timeout_reg;",
        "\tu32 bus_slave_control_reg;",
        "\tu32 deadlock_avoid_type_reg;",
        "\tu32 intpin_reg_wpermit_reg0;",
        "\tu32 intpin_reg_wpermit_reg1;",
        "\tu32 intpin_reg_wpermit_reg2;"
      ]
    },
    {
      "file": "linux\\drivers\\misc\\pch_phub.c",
      "line": 167,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t\tioread32(p + PCH_PHUB_COMP_RESP_TIMEOUT_REG);",
        "\tchip->bus_slave_control_reg =",
        "\t\t\t\tioread32(p + PCH_PHUB_BUS_SLAVE_CONTROL_REG);",
        "\tchip->deadlock_avoid_type_reg =",
        "\t\t\t\tioread32(p + PCH_PHUB_DEADLOCK_AVOID_TYPE_REG);",
        "\tchip->intpin_reg_wpermit_reg0 =",
        "\t\t\t\tioread32(p + PCH_PHUB_INTPIN_REG_WPERMIT_REG0);"
      ]
    },
    {
      "file": "linux\\drivers\\misc\\pch_phub.c",
      "line": 168,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\tchip->bus_slave_control_reg =",
        "\t\t\t\tioread32(p + PCH_PHUB_BUS_SLAVE_CONTROL_REG);",
        "\tchip->deadlock_avoid_type_reg =",
        "\t\t\t\tioread32(p + PCH_PHUB_DEADLOCK_AVOID_TYPE_REG);",
        "\tchip->intpin_reg_wpermit_reg0 =",
        "\t\t\t\tioread32(p + PCH_PHUB_INTPIN_REG_WPERMIT_REG0);",
        "\tchip->intpin_reg_wpermit_reg1 ="
      ]
    },
    {
      "file": "linux\\drivers\\misc\\pch_phub.c",
      "line": 184,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\"chip->bri_q_maxsize_reg=%x, \"",
        "\t\t\"chip->comp_resp_timeout_reg=%x, \"",
        "\t\t\"chip->bus_slave_control_reg=%x, \"",
        "\t\t\"chip->deadlock_avoid_type_reg=%x, \"",
        "\t\t\"chip->intpin_reg_wpermit_reg0=%x, \"",
        "\t\t\"chip->intpin_reg_wpermit_reg1=%x, \"",
        "\t\t\"chip->intpin_reg_wpermit_reg2=%x, \""
      ]
    },
    {
      "file": "linux\\drivers\\misc\\pch_phub.c",
      "line": 195,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tchip->bri_q_maxsize_reg,",
        "\t\tchip->comp_resp_timeout_reg,",
        "\t\tchip->bus_slave_control_reg,",
        "\t\tchip->deadlock_avoid_type_reg,",
        "\t\tchip->intpin_reg_wpermit_reg0,",
        "\t\tchip->intpin_reg_wpermit_reg1,",
        "\t\tchip->intpin_reg_wpermit_reg2,"
      ]
    },
    {
      "file": "linux\\drivers\\misc\\pch_phub.c",
      "line": 228,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t\t\tp + PCH_PHUB_COMP_RESP_TIMEOUT_REG);",
        "\tiowrite32(chip->bus_slave_control_reg,",
        "\t\t\t\t\tp + PCH_PHUB_BUS_SLAVE_CONTROL_REG);",
        "\tiowrite32(chip->deadlock_avoid_type_reg,",
        "\t\t\t\t\tp + PCH_PHUB_DEADLOCK_AVOID_TYPE_REG);",
        "\tiowrite32(chip->intpin_reg_wpermit_reg0,",
        "\t\t\t\t\tp + PCH_PHUB_INTPIN_REG_WPERMIT_REG0);"
      ]
    },
    {
      "file": "linux\\drivers\\misc\\pch_phub.c",
      "line": 229,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\tiowrite32(chip->bus_slave_control_reg,",
        "\t\t\t\t\tp + PCH_PHUB_BUS_SLAVE_CONTROL_REG);",
        "\tiowrite32(chip->deadlock_avoid_type_reg,",
        "\t\t\t\t\tp + PCH_PHUB_DEADLOCK_AVOID_TYPE_REG);",
        "\tiowrite32(chip->intpin_reg_wpermit_reg0,",
        "\t\t\t\t\tp + PCH_PHUB_INTPIN_REG_WPERMIT_REG0);",
        "\tiowrite32(chip->intpin_reg_wpermit_reg1,"
      ]
    },
    {
      "file": "linux\\drivers\\misc\\pch_phub.c",
      "line": 245,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\"chip->bri_q_maxsize_reg=%x, \"",
        "\t\t\"chip->comp_resp_timeout_reg=%x, \"",
        "\t\t\"chip->bus_slave_control_reg=%x, \"",
        "\t\t\"chip->deadlock_avoid_type_reg=%x, \"",
        "\t\t\"chip->intpin_reg_wpermit_reg0=%x, \"",
        "\t\t\"chip->intpin_reg_wpermit_reg1=%x, \"",
        "\t\t\"chip->intpin_reg_wpermit_reg2=%x, \""
      ]
    },
    {
      "file": "linux\\drivers\\misc\\pch_phub.c",
      "line": 256,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tchip->bri_q_maxsize_reg,",
        "\t\tchip->comp_resp_timeout_reg,",
        "\t\tchip->bus_slave_control_reg,",
        "\t\tchip->deadlock_avoid_type_reg,",
        "\t\tchip->intpin_reg_wpermit_reg0,",
        "\t\tchip->intpin_reg_wpermit_reg1,",
        "\t\tchip->intpin_reg_wpermit_reg2,"
      ]
    },
    {
      "file": "linux\\drivers\\mtd\\nftlcore.c",
      "line": 294,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "USED found after SECTOR_FREE",
      "context": [
        "\t\t\t\t\tBlockMap[block] = thisEUN;",
        "\t\t\t\telse",
        "\t\t\t\t\tprintk(KERN_WARNING",
        "\t\t\t\t\t       \"SECTOR_USED found after SECTOR_FREE \"",
        "\t\t\t\t\t       \"in Virtual Unit Chain %d for block %d\\n\",",
        "\t\t\t\t\t       thisVUC, block);",
        "\t\t\t\tbreak;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\virtio_net.c",
      "line": 3362,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Make sure refill_work does not run concurrently to",
        "\t * avoid napi_disable race which leads to deadlock.",
        "\t */",
        "\tdisable_delayed_refill(vi);",
        "\tcancel_delayed_work_sync(&vi->refill);"
      ]
    },
    {
      "file": "linux\\drivers\\net\\virtio_net.c",
      "line": 3374,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "{",
        "\t/*",
        "\t * Make sure refill_work does not run concurrently to",
        "\t * avoid napi_disable race which leads to deadlock.",
        "\t */",
        "\tdisable_delayed_refill(vi);",
        "\tcancel_delayed_work_sync(&vi->refill);"
      ]
    },
    {
      "file": "linux\\drivers\\ntb\\ntb_transport.c",
      "line": 1681,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "",
        "\tif (hdr->len > entry->len) {",
        "\t\tdev_dbg(&qp->ndev->pdev->dev,",
        "\t\t\t\"receive buffer overflow! Wanted %d got %d\\n\",",
        "\t\t\thdr->len, entry->len);",
        "\t\tqp->rx_err_oflow++;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\nvmem\\sprd-efuse.c",
      "line": 352,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double, lock",
      "context": [
        "\telse",
        "\t\tlock = true;",
        "",
        "\tret = sprd_efuse_raw_prog(efuse, offset, blk_double, lock, val);",
        "",
        "\tclk_disable_unprepare(efuse->clk);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\of\\dynamic.c",
      "line": 358,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t\tif (!IS_ENABLED(CONFIG_OF_UNITTEST) ||",
        "\t\t    strcmp(node->parent->full_name, \"testcase-data\")) {",
        "\t\t\tdump_stack();",
        "\t\t\tpr_err(\"ERROR: next of_node_put() on this node will result in a kobject warning 'refcount_t: underflow; use-after-free.'\\n\");",
        "\t\t}",
        "",
        "\t\treturn;"
      ]
    },
    {
      "file": "linux\\drivers\\of\\dynamic.c",
      "line": 370,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "",
        "\t\tif (!of_node_check_flag(node, OF_OVERLAY_FREE_CSET)) {",
        "\t\t\t/* premature refcount of zero, do not free memory */",
        "\t\t\tpr_err(\"ERROR: memory leak before free overlay changeset,  %pOF\\n\",",
        "\t\t\t       node);",
        "\t\t\treturn;",
        "\t\t}"
      ]
    },
    {
      "file": "linux\\drivers\\of\\dynamic.c",
      "line": 527,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tif (ce->action == OF_RECONFIG_ATTACH_NODE &&",
        "\t    of_node_check_flag(ce->np, OF_OVERLAY)) {",
        "\t\tif (kref_read(&ce->np->kobj.kref) > 1) {",
        "\t\t\tpr_err(\"ERROR: memory leak, expected refcount 1 instead of %d, of_node_get()/of_node_put() unbalanced - destroy cset entry: attach overlay node %pOF\\n\",",
        "\t\t\t       kref_read(&ce->np->kobj.kref), ce->np);",
        "\t\t} else {",
        "\t\t\tof_node_set_flag(ce->np, OF_OVERLAY_FREE_CSET);"
      ]
    },
    {
      "file": "linux\\drivers\\of\\irq.c",
      "line": 228,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer doesn't overflow",
      "context": [
        "",
        "\tpr_debug(\" -> addrsize=%d\\n\", addrsize);",
        "",
        "\t/* Range check so that the temporary buffer doesn't overflow */",
        "\tif (WARN_ON(addrsize + intsize > MAX_PHANDLE_ARGS)) {",
        "\t\trc = -EFAULT;",
        "\t\tgoto fail;"
      ]
    },
    {
      "file": "linux\\drivers\\of\\overlay.c",
      "line": 364,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\t}",
        "",
        "\tif (!of_node_check_flag(target->np, OF_OVERLAY))",
        "\t\tpr_err(\"WARNING: memory leak will occur if overlay removed, property: %pOF/%s\\n\",",
        "\t\t       target->np, new_prop->name);",
        "",
        "\tif (ret)"
      ]
    },
    {
      "file": "linux\\drivers\\of\\overlay.c",
      "line": 877,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\t * than during the window from OF_OVERLAY_PRE_APPLY overlay",
        "\t * notifiers until the OF_OVERLAY_POST_REMOVE overlay notifiers.",
        "\t *",
        "\t * A memory leak will occur here if within the window.",
        "\t */",
        "",
        "\tif (ovcs->notify_state == OF_OVERLAY_INIT ||"
      ]
    },
    {
      "file": "linux\\drivers\\of\\overlay.c",
      "line": 1060,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tret = of_overlay_apply(ovcs, base);",
        "\t/*",
        "\t * If of_overlay_apply() error, calling free_overlay_changeset() may",
        "\t * result in a memory leak if the apply partly succeeded, so do NOT",
        "\t * goto err_free_ovcs.  Instead, the caller of of_overlay_fdt_apply()",
        "\t * can call of_overlay_remove();",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\of\\overlay.c",
      "line": 1247,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory.  This is a memory leak",
      "context": [
        "err_unlock:",
        "\t/*",
        "\t * If jumped over free_overlay_changeset(), then did not kfree()",
        "\t * overlay related memory.  This is a memory leak unless a subsequent",
        "\t * of_overlay_remove() of this overlay is successful.",
        "\t */",
        "\tmutex_unlock(&of_mutex);"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 3580,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t */",
        "\tEXPECT_BEGIN(KERN_INFO, \"------------[ cut here ]------------\");",
        "\tEXPECT_BEGIN(KERN_INFO, \"WARNING: <<all>>\");",
        "\tEXPECT_BEGIN(KERN_INFO, \"refcount_t: underflow; use-after-free.\");",
        "\tEXPECT_BEGIN(KERN_INFO, \"---[ end trace <<int>> ]---\");",
        "",
        "\t/* refcount is now zero, this should fail */"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 3588,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\tof_node_put(np);",
        "",
        "\tEXPECT_END(KERN_INFO, \"---[ end trace <<int>> ]---\");",
        "\tEXPECT_END(KERN_INFO, \"refcount_t: underflow; use-after-free.\");",
        "\tEXPECT_END(KERN_INFO, \"WARNING: <<all>>\");",
        "\tEXPECT_END(KERN_INFO, \"------------[ cut here ]------------\");",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 3598,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t */",
        "\tEXPECT_NOT_BEGIN(KERN_INFO, \"------------[ cut here ]------------\");",
        "\tEXPECT_NOT_BEGIN(KERN_INFO, \"WARNING: <<all>>\");",
        "\tEXPECT_NOT_BEGIN(KERN_INFO, \"refcount_t: underflow; use-after-free.\");",
        "\tEXPECT_NOT_BEGIN(KERN_INFO, \"---[ end trace <<int>> ]---\");",
        "",
        "\tunittest(1, \"/testcase-data/refcount-node is zero, second time\");"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 3605,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\tof_node_put(np);",
        "",
        "\tEXPECT_NOT_END(KERN_INFO, \"---[ end trace <<int>> ]---\");",
        "\tEXPECT_NOT_END(KERN_INFO, \"refcount_t: underflow; use-after-free.\");",
        "\tEXPECT_NOT_END(KERN_INFO, \"WARNING: <<all>>\");",
        "\tEXPECT_NOT_END(KERN_INFO, \"------------[ cut here ]------------\");",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 2601,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tint ret;",
        "",
        "\tEXPECT_BEGIN(KERN_INFO,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest0/status\");",
        "",
        "\t/* device should enable */",
        "\tret = of_unittest_apply_overlay_check(0, 0, 0, 1, PDEV_OVERLAY);"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 2607,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tret = of_unittest_apply_overlay_check(0, 0, 0, 1, PDEV_OVERLAY);",
        "",
        "\tEXPECT_END(KERN_INFO,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest0/status\");",
        "",
        "\tif (ret)",
        "\t\treturn;"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 2621,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tint ret;",
        "",
        "\tEXPECT_BEGIN(KERN_INFO,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest1/status\");",
        "",
        "\t/* device should disable */",
        "\tret = of_unittest_apply_overlay_check(1, 1, 1, 0, PDEV_OVERLAY);"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 2627,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tret = of_unittest_apply_overlay_check(1, 1, 1, 0, PDEV_OVERLAY);",
        "",
        "\tEXPECT_END(KERN_INFO,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest1/status\");",
        "",
        "\tif (ret)",
        "\t\treturn;"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 2642,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tint ret;",
        "",
        "\tEXPECT_BEGIN(KERN_INFO,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest2/status\");",
        "",
        "\t/* device should enable */",
        "\tret = of_unittest_apply_overlay_check(2, 2, 0, 1, PDEV_OVERLAY);"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 2648,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tret = of_unittest_apply_overlay_check(2, 2, 0, 1, PDEV_OVERLAY);",
        "",
        "\tEXPECT_END(KERN_INFO,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest2/status\");",
        "",
        "\tif (ret)",
        "\t\treturn;"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 2661,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tint ret;",
        "",
        "\tEXPECT_BEGIN(KERN_INFO,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest3/status\");",
        "",
        "\t/* device should disable */",
        "\tret = of_unittest_apply_overlay_check(3, 3, 1, 0, PDEV_OVERLAY);"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 2667,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tret = of_unittest_apply_overlay_check(3, 3, 1, 0, PDEV_OVERLAY);",
        "",
        "\tEXPECT_END(KERN_INFO,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest3/status\");",
        "",
        "\tif (ret)",
        "\t\treturn;"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 2691,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tint ret;",
        "",
        "\tEXPECT_BEGIN(KERN_INFO,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest5/status\");",
        "",
        "\t/* device should disable */",
        "\tret = of_unittest_apply_revert_overlay_check(5, 5, 0, 1, PDEV_OVERLAY);"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 2697,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tret = of_unittest_apply_revert_overlay_check(5, 5, 0, 1, PDEV_OVERLAY);",
        "",
        "\tEXPECT_END(KERN_INFO,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest5/status\");",
        "",
        "\tif (ret)",
        "\t\treturn;"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 2731,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\t/* apply the overlays */",
        "",
        "\tEXPECT_BEGIN(KERN_INFO,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest6/status\");",
        "",
        "\toverlay_name = overlay_name_from_nr(overlay_nr + 0);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 2745,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tof_unittest_track_overlay(ovcs_id, overlay_nr + 0);",
        "",
        "\tEXPECT_END(KERN_INFO,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest6/status\");",
        "",
        "\tEXPECT_BEGIN(KERN_INFO,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest7/status\");"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 2748,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest6/status\");",
        "",
        "\tEXPECT_BEGIN(KERN_INFO,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest7/status\");",
        "",
        "\toverlay_name = overlay_name_from_nr(overlay_nr + 1);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 2762,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tof_unittest_track_overlay(ovcs_id, overlay_nr + 1);",
        "",
        "\tEXPECT_END(KERN_INFO,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest7/status\");",
        "",
        "",
        "\tfor (i = 0; i < 2; i++) {"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 2818,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\t/* we don't care about device state in this test */",
        "",
        "\tEXPECT_BEGIN(KERN_INFO,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest8/status\");",
        "",
        "\toverlay_name = overlay_name_from_nr(overlay_nr + 0);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 2827,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\t\tunittest(0, \"could not apply overlay \\\"%s\\\"\\n\", overlay_name);",
        "",
        "\tEXPECT_END(KERN_INFO,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest8/status\");",
        "",
        "\tif (!ret)",
        "\t\treturn;"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 2838,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\toverlay_name = overlay_name_from_nr(overlay_nr + 1);",
        "",
        "\tEXPECT_BEGIN(KERN_INFO,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest8/property-foo\");",
        "",
        "\t/* apply the overlays */",
        "\tret = overlay_data_apply(overlay_name, &ovcs_id);"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 2844,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tret = overlay_data_apply(overlay_name, &ovcs_id);",
        "",
        "\tEXPECT_END(KERN_INFO,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/test-unittest8/property-foo\");",
        "",
        "\tif (!ret) {",
        "\t\tunittest(0, \"could not apply overlay \\\"%s\\\"\\n\", overlay_name);"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 3194,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "",
        "\t/* device should enable */",
        "\tEXPECT_BEGIN(KERN_INFO,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/i2c-test-bus/test-unittest12/status\");",
        "",
        "\tret = of_unittest_apply_overlay_check(12, 12, 0, 1, I2C_OVERLAY);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 3199,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tret = of_unittest_apply_overlay_check(12, 12, 0, 1, I2C_OVERLAY);",
        "",
        "\tEXPECT_END(KERN_INFO,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/i2c-test-bus/test-unittest12/status\");",
        "",
        "\tif (ret)",
        "\t\treturn;"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 3213,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tint ret;",
        "",
        "\tEXPECT_BEGIN(KERN_INFO,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/i2c-test-bus/test-unittest13/status\");",
        "",
        "\t/* device should disable */",
        "\tret = of_unittest_apply_overlay_check(13, 13, 1, 0, I2C_OVERLAY);"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 3219,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tret = of_unittest_apply_overlay_check(13, 13, 1, 0, I2C_OVERLAY);",
        "",
        "\tEXPECT_END(KERN_INFO,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data/overlay-node/test-bus/i2c-test-bus/test-unittest13/status\");",
        "",
        "\tif (ret)",
        "\t\treturn;"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 4029,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\t/* ---  overlay  --- */",
        "",
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/substation@100/status\");",
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/fairway-1/status\");",
        "\tEXPECT_BEGIN(KERN_ERR,"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 4031,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/substation@100/status\");",
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/fairway-1/status\");",
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/fairway-1/ride@100/track@30/incline-up\");",
        "\tEXPECT_BEGIN(KERN_ERR,"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 4033,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/fairway-1/status\");",
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/fairway-1/ride@100/track@30/incline-up\");",
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/fairway-1/ride@100/track@40/incline-up\");",
        "\tEXPECT_BEGIN(KERN_ERR,"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 4035,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/fairway-1/ride@100/track@30/incline-up\");",
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/fairway-1/ride@100/track@40/incline-up\");",
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/lights@40000/status\");",
        "\tEXPECT_BEGIN(KERN_ERR,"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 4037,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/fairway-1/ride@100/track@40/incline-up\");",
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/lights@40000/status\");",
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/lights@40000/color\");",
        "\tEXPECT_BEGIN(KERN_ERR,"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 4039,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/lights@40000/status\");",
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/lights@40000/color\");",
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/lights@40000/rate\");",
        "\tEXPECT_BEGIN(KERN_ERR,"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 4041,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/lights@40000/color\");",
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/lights@40000/rate\");",
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/hvac_2\");",
        "\tEXPECT_BEGIN(KERN_ERR,"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 4043,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/lights@40000/rate\");",
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/hvac_2\");",
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/ride_200\");",
        "\tEXPECT_BEGIN(KERN_ERR,"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 4045,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/hvac_2\");",
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/ride_200\");",
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/ride_200_left\");",
        "\tEXPECT_BEGIN(KERN_ERR,"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 4047,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/ride_200\");",
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/ride_200_left\");",
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/ride_200_right\");",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 4049,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/ride_200_left\");",
        "\tEXPECT_BEGIN(KERN_ERR,",
        "\t\t     \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/ride_200_right\");",
        "",
        "\tret = overlay_data_apply(\"overlay\", NULL);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 4054,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tret = overlay_data_apply(\"overlay\", NULL);",
        "",
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/ride_200_right\");",
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/ride_200_left\");",
        "\tEXPECT_END(KERN_ERR,"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 4056,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/ride_200_right\");",
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/ride_200_left\");",
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/ride_200\");",
        "\tEXPECT_END(KERN_ERR,"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 4058,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/ride_200_left\");",
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/ride_200\");",
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/hvac_2\");",
        "\tEXPECT_END(KERN_ERR,"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 4060,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/ride_200\");",
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/hvac_2\");",
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/lights@40000/rate\");",
        "\tEXPECT_END(KERN_ERR,"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 4062,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/hvac_2\");",
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/lights@40000/rate\");",
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/lights@40000/color\");",
        "\tEXPECT_END(KERN_ERR,"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 4064,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/lights@40000/rate\");",
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/lights@40000/color\");",
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/lights@40000/status\");",
        "\tEXPECT_END(KERN_ERR,"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 4066,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/lights@40000/color\");",
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/lights@40000/status\");",
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/fairway-1/ride@100/track@40/incline-up\");",
        "\tEXPECT_END(KERN_ERR,"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 4068,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/lights@40000/status\");",
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/fairway-1/ride@100/track@40/incline-up\");",
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/fairway-1/ride@100/track@30/incline-up\");",
        "\tEXPECT_END(KERN_ERR,"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 4070,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/fairway-1/ride@100/track@40/incline-up\");",
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/fairway-1/ride@100/track@30/incline-up\");",
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/fairway-1/status\");",
        "\tEXPECT_END(KERN_ERR,"
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 4072,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/fairway-1/ride@100/track@30/incline-up\");",
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/fairway-1/status\");",
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/substation@100/status\");",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\of\\unittest.c",
      "line": 4074,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/fairway-1/status\");",
        "\tEXPECT_END(KERN_ERR,",
        "\t\t   \"OF: overlay: WARNING: memory leak will occur if overlay removed, property: /testcase-data-2/substation@100/status\");",
        "",
        "\tunittest(ret, \"Adding overlay 'overlay' failed\\n\");",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\parisc\\iosapic.c",
      "line": 642,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t/*",
        "\t * Issuing I/O SAPIC an EOI causes an interrupt IFF IRQ line is",
        "\t * asserted.  IRQ generally should not be asserted when a driver",
        "\t * enables their IRQ. It can lead to \"interesting\" race conditions",
        "\t * in the driver initialization sequence.",
        "\t */",
        "\tDBG(KERN_DEBUG \"enable_irq(%d): eoi(%p, 0x%x)\\n\", d->irq,"
      ]
    },
    {
      "file": "linux\\drivers\\parisc\\lba_pci.c",
      "line": 276,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " *\t\tlive with this during our initial bus walk",
        " *\t\tuntil rev 4.0 (no driver activity during",
        " *\t\tinitial bus walk).  The initial bus walk",
        " *\t\thas race conditions concerning the use of",
        " *\t\tsmart mode as well.",
        " */",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\parisc\\power.c",
      "line": 160,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * the soft-power switch and allows the user to switch off",
        " * the system. We rely in pdc_soft_power_button_panic()",
        " * since this version spin_trylocks (instead of regular",
        " * spinlock), preventing deadlocks on panic path.",
        " */",
        "static int parisc_panic_event(struct notifier_block *this,",
        "\t\tunsigned long event, void *ptr)"
      ]
    },
    {
      "file": "linux\\drivers\\pci\\access.c",
      "line": 338,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double-block",
      "context": [
        "",
        "\t/*",
        "\t * This indicates a problem in the caller, but we don't need",
        "\t * to kill them, unlike a double-block above.",
        "\t */",
        "\tWARN_ON(!dev->block_cfg_access);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\parport\\share.c",
      "line": 980,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t\tif (port->cad != oldcad) {",
        "\t\t\t/*",
        "\t\t\t * I think we'll actually deadlock rather than",
        "\t\t\t * get here, but just in case..",
        "\t\t\t */",
        "\t\t\tpr_warn(\"%s: %s released port when preempted!\\n\","
      ]
    },
    {
      "file": "linux\\drivers\\parport\\share.c",
      "line": 1098,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t\t/*",
        "\t\t * If dev->waiting is clear now, an interrupt",
        "\t\t * gave us the port and we would deadlock if we slept.",
        "\t\t */",
        "\t\tif (dev->waiting) {",
        "\t\t\twait_event_interruptible(dev->wait_q,"
      ]
    },
    {
      "file": "linux\\drivers\\pci\\quirks.c",
      "line": 1964,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * Normally stalling must not be enabled for PCI devices, since it would",
        " * break the PCI requirement for free-flowing writes and may lead to",
        " * deadlock.  We expect PCI devices to support ATS and PRI if they want to",
        " * be fault-tolerant, so there's no ACPI binding to describe anything else,",
        " * even when a \"PCI\" device turns out to be a regular old SoC device",
        " * dressed up as a RCiEP and normal rules don't apply."
      ]
    },
    {
      "file": "linux\\drivers\\pci\\vgaarb.c",
      "line": 82,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "{",
        "\t/*",
        "\t * In theory, we could hand out locks on IO and MEM separately to",
        "\t * userspace, but this can cause deadlocks.",
        "\t */",
        "\tif (strncmp(buf, \"none\", 4) == 0) {",
        "\t\t*io_state = VGA_RSRC_NONE;"
      ]
    },
    {
      "file": "linux\\drivers\\pcmcia\\cs.c",
      "line": 719,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * @events:\tevents to pass to pccardd",
        " *",
        " * userspace-issued insert, eject, suspend and resume commands must be",
        " * handled by pccardd to avoid any sysfs-related deadlocks. Valid events",
        " * are PCMCIA_UEVENT_EJECT (for eject), PCMCIA_UEVENT__INSERT (for insert),",
        " * PCMCIA_UEVENT_RESUME (for resume), PCMCIA_UEVENT_SUSPEND (for suspend)",
        " * and PCMCIA_UEVENT_REQUERY (for re-querying the PCMCIA card)."
      ]
    },
    {
      "file": "linux\\drivers\\pcmcia\\yenta_socket.c",
      "line": 1060,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "MAGIC NUMBERS",
      "context": [
        "\t\t\tPCI_COMMAND_MASTER |",
        "\t\t\tPCI_COMMAND_WAIT);",
        "",
        "\t/* MAGIC NUMBERS! Fixme */",
        "\tconfig_writeb(socket, PCI_CACHE_LINE_SIZE, L1_CACHE_BYTES / 4);",
        "\tconfig_writeb(socket, PCI_LATENCY_TIMER, 168);",
        "\tconfig_writel(socket, PCI_PRIMARY_BUS,"
      ]
    },
    {
      "file": "linux\\drivers\\perf\\arm_dmc620_pmu.c",
      "line": 380,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\t\t/*",
        "\t\t * HW doesn't provide a control to atomically disable all counters.",
        "\t\t * To prevent race condition (overflow happens while clearing status register),",
        "\t\t * disable all events before continuing",
        "\t\t */",
        "\t\tfor (idx = 0; idx < DMC620_PMU_MAX_COUNTERS; idx++) {"
      ]
    },
    {
      "file": "linux\\drivers\\perf\\arm_pmu_acpi.c",
      "line": 371,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Initialise and register the set of PMUs which we know about right",
        "\t * now. Ideally we'd do this in arm_pmu_acpi_cpu_starting() so that we",
        "\t * could handle late hotplug, but this may lead to deadlock since we",
        "\t * might try to register a hotplug notifier instance from within a",
        "\t * hotplug notifier.",
        "\t *"
      ]
    },
    {
      "file": "linux\\drivers\\perf\\riscv_pmu_sbi.c",
      "line": 993,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\t/*",
        "\t * Overflow interrupt pending bit should only be cleared after stopping",
        "\t * all the counters to avoid any race condition.",
        "\t */",
        "\tALT_SBI_PMU_OVF_CLEAR_PENDING(riscv_pmu_irq_mask);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\pinctrl\\core.c",
      "line": 418,
      "pattern": "deprecated.*function",
      "rule": "api_usage",
      "severity": "medium",
      "match": "DEPRECATED: Don't use this function",
      "context": [
        " * @pctldev: pin controller device to add the range to",
        " * @range: the GPIO range to add",
        " *",
        " * DEPRECATED: Don't use this function in new code.  See section 2 of",
        " * Documentation/devicetree/bindings/gpio/gpio.txt on how to bind pinctrl and",
        " * gpio drivers.",
        " *"
      ]
    },
    {
      "file": "linux\\drivers\\powercap\\idle_inject.c",
      "line": 35,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * kthread activity after its completion is guaranteed.",
        " *",
        " * It is up to the user of this framework to provide a lock for higher-level",
        " * synchronization to prevent race conditions like starting idle injection",
        " * while unregistering from the framework.",
        " */",
        "#define pr_fmt(fmt) \"ii_dev: \" fmt"
      ]
    },
    {
      "file": "linux\\drivers\\regulator\\core.c",
      "line": 235,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\tret = regulator_lock_nested(rdev1, ww_ctx);",
        "\tWARN_ON(ret);",
        "\tret = regulator_lock_nested(rdev2, ww_ctx);",
        "\tif (ret != -EDEADLOCK) {",
        "\t\tWARN_ON(ret);",
        "\t\tgoto exit;",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\regulator\\core.c",
      "line": 251,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t\tswap(held, contended);",
        "\t\tret = regulator_lock_nested(contended, ww_ctx);",
        "",
        "\t\tif (ret != -EDEADLOCK) {",
        "\t\t\tWARN_ON(ret);",
        "\t\t\tbreak;",
        "\t\t}"
      ]
    },
    {
      "file": "linux\\drivers\\regulator\\irq_helpers.c",
      "line": 33,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "};",
        "",
        "/*",
        " * Should only be called from threaded handler to prevent potential deadlock",
        " */",
        "static void rdev_flag_err(struct regulator_dev *rdev, int err)",
        "{"
      ]
    },
    {
      "file": "linux\\drivers\\remoteproc\\xlnx_r5_remoteproc.c",
      "line": 112,
      "pattern": "hardcoded.*values",
      "rule": "code_quality",
      "severity": "low",
      "match": "Hardcoded TCM bank values",
      "context": [
        "} __packed;",
        "",
        "/*",
        " * Hardcoded TCM bank values. This will stay in driver to maintain backward",
        " * compatibility with device-tree that does not have TCM information.",
        " */",
        "static const struct mem_bank_data zynqmp_tcm_banks_split[] = {"
      ]
    },
    {
      "file": "linux\\drivers\\rpmsg\\virtio_rpmsg_bus.c",
      "line": 631,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory won't leak",
      "context": [
        "\tif (err) {",
        "\t\t/*",
        "\t\t * need to reclaim the buffer here, otherwise it's lost",
        "\t\t * (memory won't leak, but rpmsg won't use it again for TX).",
        "\t\t * this will wait for a buffer management overhaul.",
        "\t\t */",
        "\t\tdev_err(dev, \"virtqueue_add_outbuf failed: %d\\n\", err);"
      ]
    },
    {
      "file": "linux\\drivers\\rtc\\interface.c",
      "line": 243,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * of the -1 fields.",
        "\t *",
        "\t * Reading the alarm and timestamp in the reverse sequence",
        "\t * would have the same race condition, and not solve the issue.",
        "\t *",
        "\t * So, we must first read the RTC timestamp,",
        "\t * then read the RTC alarm value,"
      ]
    },
    {
      "file": "linux\\drivers\\rtc\\rtc-ac100.c",
      "line": 187,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing clock",
      "context": [
        "\t\t * properly declare and reference in the devicetree and is",
        "\t\t * not implemented in any driver right now.",
        "\t\t * If the clock core looks for the parent of that second",
        "\t\t * missing clock, it can't find one that is registered and",
        "\t\t * returns NULL.",
        "\t\t * So we end up in a situation where clk_hw_get_num_parents",
        "\t\t * returns the amount of clocks we can be parented to, but"
      ]
    },
    {
      "file": "linux\\drivers\\rtc\\rtc-mt6397.c",
      "line": 231,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t}",
        "",
        "\t/* All alarm time register write to hardware after calling",
        "\t * mtk_rtc_write_trigger. This can avoid race condition if alarm",
        "\t * occur happen during writing alarm time register.",
        "\t */",
        "\tret = mtk_rtc_write_trigger(rtc);"
      ]
    },
    {
      "file": "linux\\drivers\\rtc\\rtc-rzn1.c",
      "line": 68,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tvoid __iomem *base;",
        "\t/*",
        "\t * Protects access to RZN1_RTC_CTL1 reg. rtc_lock with threaded_irqs",
        "\t * would introduce race conditions when switching interrupts because",
        "\t * of potential sleeps",
        "\t */",
        "\tspinlock_t ctl1_access_lock;"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\3w-xxxx.c",
      "line": 73,
      "pattern": "null.*pointer.*dereference",
      "rule": "memory_management",
      "severity": "high",
      "match": "null pointer dereference",
      "context": [
        "   1.02.00.003 - Fix tw_interrupt() to report error to scsi layer when",
        "                 controller status is non-zero.",
        "                 Added handling of request_sense opcode.",
        "\t\t Fix possible null pointer dereference in",
        "                 tw_reset_device_extension()",
        "   1.02.00.004 - Add support for device id of 3ware 7000 series controllers.",
        "                 Make tw_setfeature() call with interrupts disabled."
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\3w-xxxx.c",
      "line": 88,
      "pattern": "null.*pointer.*dereference",
      "rule": "memory_management",
      "severity": "high",
      "match": "null pointer dereference",
      "context": [
        "                 Remove aen code unit masking in tw_aen_complete().",
        "   1.02.00.006 - Remove unit from printk in tw_scsi_eh_abort(), causing",
        "                 possible oops.",
        "                 Fix possible null pointer dereference in tw_scsi_queue()",
        "                 if done function pointer was invalid.",
        "   1.02.00.007 - Fix possible null pointer dereferences in tw_ioctl().",
        "                 Remove check for invalid done function pointer from"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\3w-xxxx.c",
      "line": 90,
      "pattern": "null.*pointer.*dereference",
      "rule": "memory_management",
      "severity": "high",
      "match": "null pointer dereference",
      "context": [
        "                 possible oops.",
        "                 Fix possible null pointer dereference in tw_scsi_queue()",
        "                 if done function pointer was invalid.",
        "   1.02.00.007 - Fix possible null pointer dereferences in tw_ioctl().",
        "                 Remove check for invalid done function pointer from",
        "                 tw_scsi_queue().",
        "   1.02.00.008 - Set max sectors per io to TW_MAX_SECTORS in tw_findcards()."
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\3w-xxxx.c",
      "line": 100,
      "pattern": "null.*pointer.*dereference",
      "rule": "memory_management",
      "severity": "high",
      "match": "null pointer dereference",
      "context": [
        "                 Make scsi_set_pci_device() for kernels >= 2.4.4",
        "                 Fix bug where aen's could be lost before a reset.",
        "                 Re-add spinlocks in tw_scsi_detect().",
        "                 Fix possible null pointer dereference in tw_aen_drain_queue()",
        "                 during initialization.",
        "                 Clear pci parity errors during initialization and during io.",
        "   1.02.00.009 - Remove redundant increment in tw_state_request_start()."
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\3w-xxxx.c",
      "line": 143,
      "pattern": "null.*pointer.*dereference",
      "rule": "memory_management",
      "severity": "high",
      "match": "null pointer dereference",
      "context": [
        "                 Empty stale responses before draining aen queue.",
        "                 Fix tw_scsi_eh_abort() to not reset on every io abort.",
        "                 Set can_queue in SHT to 255 to prevent hang from AEN.",
        "   1.02.00.022 - Fix possible null pointer dereference in tw_scsi_release().",
        "   1.02.00.023 - Fix bug in tw_aen_drain_queue() where unit # was always zero.",
        "   1.02.00.024 - Add severity levels to AEN strings.",
        "   1.02.00.025 - Fix command interrupt spurious error messages."
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\53c700.c",
      "line": 1567,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t\tfree_slot(slot, hostdata);",
        "\t\t\t\tSCp->host_scribble = NULL;",
        "\t\t\t\tNCR_700_set_depth(SCp->device, 0);",
        "\t\t\t\t/* NOTE: deadlock potential here: we",
        "\t\t\t\t * rely on mid-layer guarantees that",
        "\t\t\t\t * scsi_done won't try to issue the",
        "\t\t\t\t * command again otherwise we'll"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\53c700.c",
      "line": 1571,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t\t * rely on mid-layer guarantees that",
        "\t\t\t\t * scsi_done won't try to issue the",
        "\t\t\t\t * command again otherwise we'll",
        "\t\t\t\t * deadlock on the",
        "\t\t\t\t * hostdata->state_lock */",
        "\t\t\t\tSCp->result = DID_RESET << 16;",
        "\t\t\t\tscsi_done(SCp);"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\a100u2w.c",
      "line": 49,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        " *          - Remove limit on number of controllers",
        " *          - Port to DMA mapping API",
        " *          - Clean up interrupt handler registration",
        " *          - Fix memory leaks",
        " *          - Fix allocation of scsi host structs and private data",
        " * 11/18/03 Christoph Hellwig <hch@lst.de>",
        " *\t    - Port to new probing API"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\advansys.c",
      "line": 4259,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\t/*",
        "\t * Write the idle command value after the idle command parameter",
        "\t * has been written to avoid a race condition. If the order is not",
        "\t * followed, the microcode may process the idle command before the",
        "\t * parameters have been written to LRAM.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\aha1740.c",
      "line": 463,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "           can do then anyhow). */",
        "",
        "#define LOOPCNT_WARN 10\t\t/* excessive mbxout wait -> syslog-msg */",
        "#define LOOPCNT_MAX 1000000\t/* mbxout deadlock -> panic() after ~ 2 sec. */",
        "\t\tint loopcnt;",
        "\t\tunsigned int base = SCpnt->device->host->io_port;",
        "\t\tDEB(printk(\"aha1740[%d] critical section\\n\",ecbno));"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\BusLogic.c",
      "line": 241,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        "  blogic_create_addlccbs allocates Additional CCBs for Host Adapter.  If",
        "  allocation fails and there are no remaining CCBs available, the Driver Queue",
        "  Depth is decreased to a known safe value to avoid potential deadlocks when",
        "  multiple host adapters share the same IRQ Channel.",
        "*/",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\g_NCR5380.c",
      "line": 167,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "}",
        "",
        "/*",
        " * Configure I/O address of 53C400A or DTC436 by writing magic numbers",
        " * to ports 0x779 and 0x379.",
        " */",
        "static void magic_configure(int idx, u8 irq, u8 magic[])"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\initio.c",
      "line": 52,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *\t\t  spinlocks to serialize access to the pSRB_head and",
        " *\t\t  pSRB_tail members of the HCS structure.",
        " * 09/01/99 bv\t- v1.03d",
        " *\t\t- Fixed a deadlock problem in SMP.",
        " * 21/01/99 bv\t- v1.03e",
        " *\t\t- Add support for the Domex 3192U PCI SCSI",
        " *\t\t  This is a slightly modified patch by"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\ips.c",
      "line": 64,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "/*            SCBs                                                           */",
        "/*          - Send all of the commands on the queue at once rather than      */",
        "/*            one at a time since the card will support it.                  */",
        "/* 0.99.04  - Fix race condition in the passthru mechanism -- this required  */",
        "/*            the interface to the utilities to change                       */",
        "/*          - Fix error recovery code                                        */",
        "/* 0.99.05  - Fix an oops when we get certain passthru commands              */"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\scsi_scan.c",
      "line": 1680,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Bail out if the device or its queue are not running. Otherwise,",
        "\t * the rescan may block waiting for commands to be executed, with us",
        "\t * holding the device lock. This can result in a potential deadlock",
        "\t * in the power management core code when system resume is on-going.",
        "\t */",
        "\tif (sdev->sdev_state != SDEV_RUNNING ||"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\scsi_scan.c",
      "line": 1714,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Bail out if the device or its queue are not running. Otherwise,",
        "\t * the rescan may block waiting for commands to be executed, with us",
        "\t * holding the device lock. This can result in a potential deadlock",
        "\t * in the power management core code when system resume is on-going.",
        "\t */",
        "\tif (sdev->sdev_state != SDEV_RUNNING ||"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\scsi_transport_spi.c",
      "line": 995,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *\tPerforms the domain validation on the given device in the",
        " *\tcurrent execution thread.  Since DV operations may sleep,",
        " *\tthe current thread must have user context.  Also no SCSI",
        " *\trelated locks that would deadlock I/O issued by the DV may",
        " *\tbe held.",
        " */",
        "void"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\scsi_transport_sas.c",
      "line": 359,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "Magic numbers",
      "context": [
        "\t\tgoto out;",
        "",
        "\t/*",
        "\t * Magic numbers: the VPD Protocol page (0x90)",
        "\t * has a 4 byte header and then one entry per device port",
        "\t * the TLR bit is at offset 8 on each port entry",
        "\t * if we take the first port, that's at total offset 12"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\sd.c",
      "line": 678,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "};",
        "",
        "/*",
        " * Don't request a new module, as that could deadlock in multipath",
        " * environment.",
        " */",
        "static void sd_default_probe(dev_t devt)"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\sd.c",
      "line": 3809,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Query concurrent positioning ranges after",
        "\t * queue_limits_commit_update() unlocked q->limits_lock to avoid",
        "\t * deadlock with q->sysfs_dir_lock and q->sysfs_lock.",
        "\t */",
        "\tif (sdkp->media_present && scsi_device_supports_vpd(sdp))",
        "\t\tsd_read_cpr(sdkp);"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\sg.c",
      "line": 2059,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\treq_schp->page_order = 0;",
        "\treq_schp->sglist_len = 0;",
        "\tsrp->res_used = 0;",
        "\t/* Called without mutex lock to avoid deadlock */",
        "\tsfp->res_in_use = 0;",
        "}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\sg.c",
      "line": 217,
      "pattern": "privilege.*escalation",
      "rule": "security",
      "severity": "critical",
      "match": "privilege escalation",
      "context": [
        " * ioctl(..., SG_IO, ...) are fundamentally unsafe, since there are lots of ways",
        " * to trigger read() and write() calls from various contexts with elevated",
        " * privileges. This can lead to kernel memory corruption (e.g. if these",
        " * interfaces are called through splice()) and privilege escalation inside",
        " * userspace (e.g. if a process with access to such a device passes a file",
        " * descriptor to a SUID binary as stdin/stdout/stderr).",
        " *"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\storvsc_drv.c",
      "line": 549,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * We can get incoming messages from the host that are not in response to",
        " * messages that we have sent out. An example of this would be messages",
        " * received by the guest to notify dynamic addition/removal of LUNs. To",
        " * deal with potential race conditions where the driver may be in the",
        " * midst of being unloaded when we might receive an unsolicited message",
        " * from the host, we have implemented a mechanism to gurantee sequential",
        " * consistency:"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\st.c",
      "line": 4053,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer offset overflow",
      "context": [
        "\t     i < st_bp->frp_segs && offset >= length; i++)",
        "\t\toffset -= length;",
        "\tif (i == st_bp->frp_segs) {\t/* Should never happen */",
        "\t\tprintk(KERN_WARNING \"st: append_to_buffer offset overflow.\\n\");",
        "\t\treturn (-EIO);",
        "\t}",
        "\tfor (; i < st_bp->frp_segs && do_count > 0; i++) {"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\st.c",
      "line": 4085,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer offset overflow",
      "context": [
        "\t     i < st_bp->frp_segs && offset >= length; i++)",
        "\t\toffset -= length;",
        "\tif (i == st_bp->frp_segs) {\t/* Should never happen */",
        "\t\tprintk(KERN_WARNING \"st: from_buffer offset overflow.\\n\");",
        "\t\treturn (-EIO);",
        "\t}",
        "\tfor (; i < st_bp->frp_segs && do_count > 0; i++) {"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\wd33c93.c",
      "line": 1684,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * Case 4 : If we reached this point, the command was not found in any of",
        " *     the queues.",
        " *",
        " * We probably reached this point because of an unlikely race condition",
        " * between the command completing successfully and the abortion code,",
        " * so we won't panic, but we will notify the user in case something really",
        " * broke."
      ]
    },
    {
      "file": "linux\\drivers\\soundwire\\bus.c",
      "line": 81,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Give each bus_lock and msg_lock a unique key so that lockdep won't",
        "\t * trigger a deadlock warning when the locks of several buses are",
        "\t * grabbed during configuration of a multi-bus stream.",
        "\t */",
        "\tlockdep_register_key(&bus->msg_lock_key);"
      ]
    },
    {
      "file": "linux\\drivers\\soundwire\\cadence_master.c",
      "line": 984,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\tint_status &= ~CDNS_MCP_INT_SLAVE_MASK;",
        "",
        "\t\t/*",
        "\t\t * Deal with possible race condition between interrupt",
        "\t\t * handling and disabling interrupts on suspend.",
        "\t\t *",
        "\t\t * If the master is in the process of disabling"
      ]
    },
    {
      "file": "linux\\drivers\\soundwire\\cadence_master.c",
      "line": 1074,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * the deviceB never being detected - until a change of status",
        "\t * is observed on the bus.",
        "\t *",
        "\t * To avoid this race condition, re-check if any device0 needs",
        "\t * attention with PING commands. There is no need to check for",
        "\t * ALERTS since they are not allowed until a non-zero",
        "\t * device_number is assigned."
      ]
    },
    {
      "file": "linux\\drivers\\soundwire\\stream.c",
      "line": 1255,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Add in order of bus id so that when taking the bus_lock",
        "\t * of multiple buses they will always be taken in the same",
        "\t * order to prevent a mutex deadlock.",
        "\t */",
        "\tinsert_after = &stream->master_list;",
        "\tlist_for_each_entry_reverse(walk_m_rt, &stream->master_list, stream_node) {"
      ]
    },
    {
      "file": "linux\\drivers\\spi\\atmel-quadspi.c",
      "line": 1400,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing peripheral clock",
      "context": [
        "",
        "\tif (IS_ERR(aq->pclk))",
        "\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(aq->pclk),",
        "\t\t\t\t     \"missing peripheral clock\\n\");",
        "",
        "\tif (aq->caps->has_qspick) {",
        "\t\t/* Get the QSPI system clock */"
      ]
    },
    {
      "file": "linux\\drivers\\spi\\atmel-quadspi.c",
      "line": 1406,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing system clock",
      "context": [
        "\t\t/* Get the QSPI system clock */",
        "\t\taq->qspick = devm_clk_get_enabled(&pdev->dev, \"qspick\");",
        "\t\tif (IS_ERR(aq->qspick)) {",
        "\t\t\tdev_err(&pdev->dev, \"missing system clock\\n\");",
        "\t\t\terr = PTR_ERR(aq->qspick);",
        "\t\t\treturn err;",
        "\t\t}"
      ]
    },
    {
      "file": "linux\\drivers\\spi\\atmel-quadspi.c",
      "line": 1415,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing Generic clock",
      "context": [
        "\t\t/* Get the QSPI generic clock */",
        "\t\taq->gclk = devm_clk_get(&pdev->dev, \"gclk\");",
        "\t\tif (IS_ERR(aq->gclk)) {",
        "\t\t\tdev_err(&pdev->dev, \"missing Generic clock\\n\");",
        "\t\t\terr = PTR_ERR(aq->gclk);",
        "\t\t\treturn err;",
        "\t\t}"
      ]
    },
    {
      "file": "linux\\drivers\\spi\\spi-aspeed-smc.c",
      "line": 748,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing clock",
      "context": [
        "",
        "\taspi->clk = devm_clk_get_enabled(&pdev->dev, NULL);",
        "\tif (IS_ERR(aspi->clk)) {",
        "\t\tdev_err(dev, \"missing clock\\n\");",
        "\t\treturn PTR_ERR(aspi->clk);",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\spi\\spi-meson-spifc.c",
      "line": 317,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing clock",
      "context": [
        "",
        "\tspifc->clk = devm_clk_get_enabled(spifc->dev, NULL);",
        "\tif (IS_ERR(spifc->clk)) {",
        "\t\tdev_err(spifc->dev, \"missing clock\\n\");",
        "\t\tret = PTR_ERR(spifc->clk);",
        "\t\tgoto out_err;",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\spi\\spi-synquacer.c",
      "line": 662,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing clock",
      "context": [
        "\t}",
        "",
        "\tif (!host->max_speed_hz) {",
        "\t\tdev_err(&pdev->dev, \"missing clock source\\n\");",
        "\t\tret = -EINVAL;",
        "\t\tgoto disable_clk;",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\target\\target_core_iblock.c",
      "line": 102,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Missing udev_path= parameters for IBLOCK",
      "context": [
        "\tint ret;",
        "",
        "\tif (!(ib_dev->ibd_flags & IBDF_HAS_UDEV_PATH)) {",
        "\t\tpr_err(\"Missing udev_path= parameters for IBLOCK\\n\");",
        "\t\treturn -EINVAL;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\target\\target_core_user.c",
      "line": 1675,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\txa_erase(&udev->data_pages, dpi);",
        "\t\t/*",
        "\t\t * While reaching here there may be page faults occurring on",
        "\t\t * the to-be-released pages. A race condition may occur if",
        "\t\t * unmap_mapping_range() is called before page faults on these",
        "\t\t * pages have completed; a valid but stale map is created.",
        "\t\t *"
      ]
    },
    {
      "file": "linux\\drivers\\thermal\\imx_sc_thermal.c",
      "line": 100,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t\t\t/*",
        "\t\t\t * Save the error value before freeing the",
        "\t\t\t * sensor pointer, otherwise we endup with a",
        "\t\t\t * use-after-free error",
        "\t\t\t */",
        "\t\t\tret = PTR_ERR(sensor->tzd);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\thunderbolt\\dma_test.c",
      "line": 84,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer_overflow_errors: Number of buffer overflow",
      "context": [
        " * @link_speed: Expected link speed (Gb/s), %0 to use whatever is negotiated",
        " * @link_width: Expected link width (Gb/s), %0 to use whatever is negotiated",
        " * @crc_errors: Number of CRC errors during the test run",
        " * @buffer_overflow_errors: Number of buffer overflow errors during the test",
        " *\t\t\t    run",
        " * @result: Result of the last run",
        " * @error_code: Error code of the last run"
      ]
    },
    {
      "file": "linux\\drivers\\thunderbolt\\dma_test.c",
      "line": 106,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer_overflow",
      "context": [
        "\tunsigned int link_speed;",
        "\tenum tb_link_width link_width;",
        "\tunsigned int crc_errors;",
        "\tunsigned int buffer_overflow_errors;",
        "\tenum dma_test_result result;",
        "\tenum dma_test_test_error error_code;",
        "\tstruct completion complete;"
      ]
    },
    {
      "file": "linux\\drivers\\thunderbolt\\dma_test.c",
      "line": 253,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer_overflow",
      "context": [
        "\tif (tf->frame.flags & RING_DESC_CRC_ERROR)",
        "\t\tdt->crc_errors++;",
        "\tif (tf->frame.flags & RING_DESC_BUFFER_OVERRUN)",
        "\t\tdt->buffer_overflow_errors++;",
        "",
        "\tkfree(tf);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\thunderbolt\\dma_test.c",
      "line": 497,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer_overflow",
      "context": [
        "\t\t\tdt->error_code = DMA_TEST_WIDTH_ERROR;",
        "\t\t} else if (dt->packets_to_send != dt->packets_sent ||",
        "\t\t\t dt->packets_to_receive != dt->packets_received ||",
        "\t\t\t dt->crc_errors || dt->buffer_overflow_errors) {",
        "\t\t\tdt->error_code = DMA_TEST_PACKET_ERROR;",
        "\t\t} else {",
        "\t\t\treturn;"
      ]
    },
    {
      "file": "linux\\drivers\\thunderbolt\\dma_test.c",
      "line": 523,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer_overflow",
      "context": [
        "\tdt->packets_sent = 0;",
        "\tdt->packets_received = 0;",
        "\tdt->crc_errors = 0;",
        "\tdt->buffer_overflow_errors = 0;",
        "\tdt->result = DMA_TEST_SUCCESS;",
        "\tdt->error_code = DMA_TEST_NO_ERROR;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\thunderbolt\\dma_test.c",
      "line": 610,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\tseq_printf(s, \"packets received: %u\\n\", dt->packets_received);",
        "\tseq_printf(s, \"packets sent: %u\\n\", dt->packets_sent);",
        "\tseq_printf(s, \"CRC errors: %u\\n\", dt->crc_errors);",
        "\tseq_printf(s, \"buffer overflow errors: %u\\n\",",
        "\t\t   dt->buffer_overflow_errors);",
        "\tseq_printf(s, \"error: %s\\n\", dma_test_error_names[dt->error_code]);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\thunderbolt\\dma_test.c",
      "line": 611,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer_overflow",
      "context": [
        "\tseq_printf(s, \"packets sent: %u\\n\", dt->packets_sent);",
        "\tseq_printf(s, \"CRC errors: %u\\n\", dt->crc_errors);",
        "\tseq_printf(s, \"buffer overflow errors: %u\\n\",",
        "\t\t   dt->buffer_overflow_errors);",
        "\tseq_printf(s, \"error: %s\\n\", dma_test_error_names[dt->error_code]);",
        "",
        "out_unlock:"
      ]
    },
    {
      "file": "linux\\drivers\\thunderbolt\\tb.c",
      "line": 2476,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t/*",
        "\t\t\t * Service drivers are unbound during",
        "\t\t\t * tb_xdomain_remove() so setting XDomain as",
        "\t\t\t * unplugged here prevents deadlock if they call",
        "\t\t\t * tb_xdomain_disable_paths(). We will tear down",
        "\t\t\t * all the tunnels below.",
        "\t\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\thunderbolt\\tb.c",
      "line": 3265,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Schedule cleanup of any unplugged devices. Run this in a",
        "\t * separate thread to avoid possible deadlock if the device",
        "\t * removal runtime resumes the unplugged device.",
        "\t */",
        "\tqueue_delayed_work(tb->wq, &tcm->remove_work, msecs_to_jiffies(50));"
      ]
    },
    {
      "file": "linux\\drivers\\tty\\tty_io.c",
      "line": 1713,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double free",
      "context": [
        " * might otherwise get the wrong pointers.",
        " *",
        " * WSH 09/09/97: rewritten to avoid some nasty race conditions that could",
        " * lead to double frees or releasing memory still in use.",
        " */",
        "int tty_release(struct inode *inode, struct file *filp)",
        "{"
      ]
    },
    {
      "file": "linux\\drivers\\tty\\tty_io.c",
      "line": 1712,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * careful that the structures are all released at the same time, as interrupts",
        " * might otherwise get the wrong pointers.",
        " *",
        " * WSH 09/09/97: rewritten to avoid some nasty race conditions that could",
        " * lead to double frees or releasing memory still in use.",
        " */",
        "int tty_release(struct inode *inode, struct file *filp)"
      ]
    },
    {
      "file": "linux\\drivers\\tty\\tty_io.c",
      "line": 3014,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * via AF_UNIX socket, close it and later fetch from socket. FIXME.",
        " *",
        " * Nasty bug: do_SAK is being called in interrupt context.  This can",
        " * deadlock.  We punt it up to process context.  AKPM - 16Mar2001",
        " */",
        "void __do_SAK(struct tty_struct *tty)",
        "{"
      ]
    },
    {
      "file": "linux\\drivers\\tty\\tty_ioctl.c",
      "line": 118,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " *",
        " * Indicate that a @tty should stop transmitting data down the stack.",
        " * tty_throttle_safe() will only attempt throttle if @tty->flow_change is",
        " * %TTY_THROTTLE_SAFE. Prevents an accidental throttle due to race conditions",
        " * when throttling is conditional on factors evaluated prior to throttling.",
        " *",
        " * Returns: %true if @tty is throttled (or was already throttled)"
      ]
    },
    {
      "file": "linux\\drivers\\tty\\tty_ioctl.c",
      "line": 146,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race conditions when unthrottling is condition",
      "context": [
        " *",
        " * Similar to tty_unthrottle() but will only attempt unthrottle if",
        " * @tty->flow_change is %TTY_UNTHROTTLE_SAFE. Prevents an accidental unthrottle",
        " * due to race conditions when unthrottling is conditional on factors evaluated",
        " * prior to unthrottling.",
        " *",
        " * Returns: %true if @tty is unthrottled (or was already unthrottled)"
      ]
    },
    {
      "file": "linux\\drivers\\tty\\tty_jobctrl.c",
      "line": 319,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t}",
        "",
        "\t/* If tty->ctrl.pgrp is not NULL, it may be assigned to",
        "\t * current->signal->tty_old_pgrp in a race condition, and",
        "\t * cause pid memleak. Release current->signal->tty_old_pgrp",
        "\t * after tty->ctrl.pgrp set to NULL.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\tty\\tty_ldisc.c",
      "line": 233,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * descriptor, otherwise valid ldisc reference",
        " *",
        " * Note 1: Must not be called from an IRQ/timer context. The caller must also",
        " * be careful not to hold other locks that will deadlock against a discipline",
        " * change, such as an existing ldisc reference (which we check for).",
        " *",
        " * Note 2: a file_operations routine (read/poll/write) should use this function"
      ]
    },
    {
      "file": "linux\\drivers\\uio\\uio_sercos3.c",
      "line": 18,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "Race condition",
      "context": [
        "   a logical OR to make more controlled changes (rather than blindly",
        "   overwriting previous values).",
        "",
        "   Race conditions exist if the userspace-part directly modifies the",
        "   Interrupt Enable Register while in operation. The consequences are",
        "   that certain interrupts would fail to be enabled or disabled. For",
        "   this reason, the userspace-part should only directly modify the"
      ]
    },
    {
      "file": "linux\\drivers\\vhost\\vhost.c",
      "line": 599,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t} else {",
        "\t\t/* vDPA device does not use worker thead, so there's",
        "\t\t * no need to hold the address space for mm. This help",
        "\t\t * to avoid deadlock in the case of mmap() which may",
        "\t\t * held the refcnt of the file and depends on release",
        "\t\t * method to remove vma.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\virtio\\virtio_mem.c",
      "line": 631,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * Try adding memory to Linux. Will usually only fail if out of memory.",
        " *",
        " * Must not be called with the vm->hotplug_mutex held (possible deadlock with",
        " * onlining code).",
        " *",
        " * Will not modify the state of memory blocks in virtio-mem."
      ]
    },
    {
      "file": "linux\\drivers\\virtio\\virtio_mem.c",
      "line": 695,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * Try removing memory from Linux. Will only fail if memory blocks aren't",
        " * offline.",
        " *",
        " * Must not be called with the vm->hotplug_mutex held (possible deadlock with",
        " * onlining code).",
        " *",
        " * Will not modify the state of memory blocks in virtio-mem."
      ]
    },
    {
      "file": "linux\\drivers\\virtio\\virtio_mem.c",
      "line": 735,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * Try offlining and removing memory from Linux.",
        " *",
        " * Must not be called with the vm->hotplug_mutex held (possible deadlock with",
        " * onlining code).",
        " *",
        " * Will not modify the state of memory blocks in virtio-mem."
      ]
    },
    {
      "file": "linux\\drivers\\watchdog\\mei_wdt.c",
      "line": 448,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/* Run the unregistration in a worker as this can be",
        "\t * run only after ping completion, otherwise the flow will",
        "\t * deadlock on watchdog core mutex.",
        "\t */",
        "\tif (wdt->state == MEI_WDT_RUNNING) {",
        "\t\tif (res.wdstate & MEI_WDT_WDSTATE_NOT_REQUIRED) {"
      ]
    },
    {
      "file": "linux\\drivers\\watchdog\\sc520_wdt.c",
      "line": 18,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *\tAdditional fixes Alan Cox",
        " *\t-\tFixed formatting",
        " *\t-\tRemoved debug printks",
        " *\t-\tFixed SMP built kernel deadlock",
        " *\t-\tSwitched to private locks not lock_kernel",
        " *\t-\tUsed ioremap/writew/readw",
        " *\t-\tAdded NOWAYOUT support"
      ]
    },
    {
      "file": "linux\\drivers\\watchdog\\smsc37b787_wdt.c",
      "line": 494,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race-condition",
      "context": [
        "\t\t\t\t\tunsigned long code, void *unused)",
        "{",
        "\tif (code == SYS_DOWN || code == SYS_HALT) {",
        "\t\t/* set timeout to 0, to avoid possible race-condition */",
        "\t\ttimeout = 0;",
        "\t\twb_smsc_wdt_disable();",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\xen\\balloon.c",
      "line": 320,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * add_memory_resource() will call online_pages() which in its turn",
        "\t * will call xen_online_page() callback causing deadlock if we don't",
        "\t * release balloon_mutex here. Unlocking here is safe because the",
        "\t * callers drop the mutex before trying again.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\xen\\time.c",
      "line": 94,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tswitch (action) {",
        "\tcase -1: /* backup runstate time before suspend */",
        "\t\tif (unlikely(runstate_delta))",
        "\t\t\tpr_warn_once(\"%s: memory leak as runstate_delta is not NULL\\n\",",
        "\t\t\t\t\t__func__);",
        "",
        "\t\trunstate_delta = kmalloc_array(num_possible_cpus(),"
      ]
    },
    {
      "file": "linux\\drivers\\accel\\ivpu\\ivpu_jsm_msg.c",
      "line": 494,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t}",
        "",
        "\tif (buffer_size && resp.payload.metric_streamer_done.bytes_written > buffer_size) {",
        "\t\tivpu_warn_ratelimited(vdev, \"MS buffer overflow: bytes_written %#llx > buffer_size %#llx\\n\",",
        "\t\t\t\t      resp.payload.metric_streamer_done.bytes_written, buffer_size);",
        "\t\treturn -EOVERFLOW;",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\accel\\qaic\\qaic_control.c",
      "line": 1074,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\t\t/*",
        "\t\t * we lost a buffer because we queued a recv buf, but then",
        "\t\t * queuing the corresponding tx buf failed. To try to avoid",
        "\t\t * a memory leak, lets reclaim it and use it for this",
        "\t\t * transaction.",
        "\t\t */",
        "\t\tqdev->cntl_lost_buf = false;"
      ]
    },
    {
      "file": "linux\\drivers\\accel\\qaic\\qaic_timesync.c",
      "line": 259,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tint ret;",
        "",
        "\tmhi_dev = qdev->qts_ch;",
        "\t/* Queue the response message beforehand to avoid race conditions */",
        "\tret = mhi_queue_buf(mhi_dev, DMA_FROM_DEVICE, &resp->data, sizeof(resp->data), MHI_EOT);",
        "\tif (ret) {",
        "\t\tkfree(resp);"
      ]
    },
    {
      "file": "linux\\drivers\\accel\\qaic\\qaic_drv.c",
      "line": 290,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * Need to sync carefully with users calling close(). The",
        "\t * list of users can be modified elsewhere when the lock isn't",
        "\t * held here, but the sync'ing the srcu with the mutex held",
        "\t * could deadlock. Grab the mutex so that the list will be",
        "\t * unmodified. The user we get will exist as long as the",
        "\t * lock is held. Signal that the qcdev is going away, and",
        "\t * grab a reference to the user so they don't go away for"
      ]
    },
    {
      "file": "linux\\drivers\\accel\\qaic\\qaic_drv.c",
      "line": 295,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * lock is held. Signal that the qcdev is going away, and",
        "\t * grab a reference to the user so they don't go away for",
        "\t * synchronize_srcu(). Then release the mutex to avoid",
        "\t * deadlock and make sure the user has observed the signal.",
        "\t * With the lock released, we cannot maintain any state of the",
        "\t * user list.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\accel\\habanalabs\\common\\command_submission.c",
      "line": 979,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * a point in which only part of the staged submission was",
        "\t\t * submitted and we don't have enough room in the 'cs_pending'",
        "\t\t * array for the rest of the submission.",
        "\t\t * This causes a deadlock because this CS will never be",
        "\t\t * completed as it depends on future CS's for completion.",
        "\t\t */",
        "\t\tif (other->cs_sequence == user_sequence)"
      ]
    },
    {
      "file": "linux\\drivers\\accel\\habanalabs\\common\\command_submission.c",
      "line": 984,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t */",
        "\t\tif (other->cs_sequence == user_sequence)",
        "\t\t\tdev_crit_ratelimited(hdev->dev,",
        "\t\t\t\t\"Staged CS %llu deadlock due to lack of resources\",",
        "\t\t\t\tuser_sequence);",
        "",
        "\t\tdev_dbg_ratelimited(hdev->dev,"
      ]
    },
    {
      "file": "linux\\drivers\\accel\\habanalabs\\common\\command_submission.c",
      "line": 1716,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t\t * while we want to do context-switch (-EBUSY),",
        "\t\t\t\t * we need to soft-reset because QMAN is",
        "\t\t\t\t * probably stuck. However, we can't call to",
        "\t\t\t\t * reset here directly because of deadlock, so",
        "\t\t\t\t * need to do it at the very end of this",
        "\t\t\t\t * function",
        "\t\t\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\accel\\habanalabs\\common\\device.c",
      "line": 605,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "Memory leak",
      "context": [
        "\tstruct hl_mem_mgr_fini_stats mm_fini_stats;",
        "",
        "\tif (!hdev) {",
        "\t\tpr_crit(\"Closing FD after device was removed. Memory leak will occur and it is advised to reboot.\\n\");",
        "\t\tput_pid(hpriv->taskpid);",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\accel\\habanalabs\\gaudi\\gaudi_coresight.c",
      "line": 549,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer size %llu overflow",
      "context": [
        "",
        "\tif (addr > (addr + size)) {",
        "\t\tdev_err(hdev->dev,",
        "\t\t\t\"ETR buffer size %llu overflow\\n\", size);",
        "\t\treturn false;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\accel\\habanalabs\\gaudi2\\gaudi2_coresight.c",
      "line": 2155,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer size %llu overflow",
      "context": [
        "\tstruct gaudi2_device *gaudi2 = hdev->asic_specific;",
        "",
        "\tif (addr > (addr + size)) {",
        "\t\tdev_err(hdev->dev, \"ETR buffer size %llu overflow\\n\", size);",
        "\t\treturn false;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\accel\\habanalabs\\goya\\goya_coresight.c",
      "line": 375,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer size %llu overflow",
      "context": [
        "",
        "\tif (addr > (addr + size)) {",
        "\t\tdev_err(hdev->dev,",
        "\t\t\t\"ETR buffer size %llu overflow\\n\", size);",
        "\t\treturn false;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\dbexec.c",
      "line": 167,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "\t\t\t\t\"while executing %s from AML Debugger\",",
        "\t\t\t\tinfo->pathname));",
        "",
        "\t\tif (status == AE_BUFFER_OVERFLOW) {",
        "\t\t\tACPI_ERROR((AE_INFO,",
        "\t\t\t\t    \"Possible buffer overflow within AML Debugger \"",
        "\t\t\t\t    \"buffer (size 0x%X needed 0x%X)\","
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\dbexec.c",
      "line": 169,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "",
        "\t\tif (status == AE_BUFFER_OVERFLOW) {",
        "\t\t\tACPI_ERROR((AE_INFO,",
        "\t\t\t\t    \"Possible buffer overflow within AML Debugger \"",
        "\t\t\t\t    \"buffer (size 0x%X needed 0x%X)\",",
        "\t\t\t\t    ACPI_DEBUG_BUFFER_SIZE,",
        "\t\t\t\t    (u32)return_obj->length));"
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\dbexec.c",
      "line": 205,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "\tif ((info->name[0] != '\\\\') && (info->name[0] != '/')) {",
        "\t\tif (acpi_ut_safe_strcat(info->pathname, sizeof(info->pathname),",
        "\t\t\t\t\tacpi_gbl_db_scope_buf)) {",
        "\t\t\tstatus = AE_BUFFER_OVERFLOW;",
        "\t\t\tgoto error_exit;",
        "\t\t}",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\dbexec.c",
      "line": 212,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "",
        "\tif (acpi_ut_safe_strcat(info->pathname, sizeof(info->pathname),",
        "\t\t\t\tinfo->name)) {",
        "\t\tstatus = AE_BUFFER_OVERFLOW;",
        "\t\tgoto error_exit;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\dbinput.c",
      "line": 618,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "Buffer overflow",
      "context": [
        "\t    (acpi_gbl_db_parsed_buf, sizeof(acpi_gbl_db_parsed_buf),",
        "\t     input_buffer)) {",
        "\t\tacpi_os_printf",
        "\t\t    (\"Buffer overflow while parsing input line (max %u characters)\\n\",",
        "\t\t     (u32)sizeof(acpi_gbl_db_parsed_buf));",
        "\t\treturn (0);",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\dbnames.c",
      "line": 138,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "",
        "\tif (acpi_ut_safe_strcat",
        "\t    (acpi_gbl_db_scope_buf, sizeof(acpi_gbl_db_scope_buf), name)) {",
        "\t\tstatus = AE_BUFFER_OVERFLOW;",
        "\t\tgoto error_exit;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\dbnames.c",
      "line": 144,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "",
        "\tif (acpi_ut_safe_strcat",
        "\t    (acpi_gbl_db_scope_buf, sizeof(acpi_gbl_db_scope_buf), \"\\\\\")) {",
        "\t\tstatus = AE_BUFFER_OVERFLOW;",
        "\t\tgoto error_exit;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\dsmethod.c",
      "line": 333,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t/*",
        "\t\t * The current_sync_level (per-thread) must be less than or equal to",
        "\t\t * the sync level of the method. This mechanism provides some",
        "\t\t * deadlock prevention.",
        "\t\t *",
        "\t\t * If the method was auto-serialized, we just ignore the sync level",
        "\t\t * mechanism, because auto-serialization of methods can interfere"
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\dswstate.c",
      "line": 189,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "stack overflow",
      "context": [
        "",
        "\tACPI_FUNCTION_NAME(ds_result_stack_push);",
        "",
        "\t/* Check for stack overflow */",
        "",
        "\tif (((u32) walk_state->result_size + ACPI_RESULTS_FRAME_OBJ_NUM) >",
        "\t    ACPI_RESULTS_OBJ_NUM_MAX) {"
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\dswstate.c",
      "line": 193,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "stack overflow",
      "context": [
        "",
        "\tif (((u32) walk_state->result_size + ACPI_RESULTS_FRAME_OBJ_NUM) >",
        "\t    ACPI_RESULTS_OBJ_NUM_MAX) {",
        "\t\tACPI_ERROR((AE_INFO, \"Result stack overflow: State=%p Num=%u\",",
        "\t\t\t    walk_state, walk_state->result_size));",
        "\t\treturn (AE_STACK_OVERFLOW);",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\dswstate.c",
      "line": 195,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "STACK_OVERFLOW",
      "context": [
        "\t    ACPI_RESULTS_OBJ_NUM_MAX) {",
        "\t\tACPI_ERROR((AE_INFO, \"Result stack overflow: State=%p Num=%u\",",
        "\t\t\t    walk_state, walk_state->result_size));",
        "\t\treturn (AE_STACK_OVERFLOW);",
        "\t}",
        "",
        "\tstate = acpi_ut_create_generic_state();"
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\dswstate.c",
      "line": 280,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "stack overflow",
      "context": [
        "{",
        "\tACPI_FUNCTION_NAME(ds_obj_stack_push);",
        "",
        "\t/* Check for stack overflow */",
        "",
        "\tif (walk_state->num_operands >= ACPI_OBJ_NUM_OPERANDS) {",
        "\t\tACPI_ERROR((AE_INFO,"
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\dswstate.c",
      "line": 284,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "stack overflow",
      "context": [
        "",
        "\tif (walk_state->num_operands >= ACPI_OBJ_NUM_OPERANDS) {",
        "\t\tACPI_ERROR((AE_INFO,",
        "\t\t\t    \"Object stack overflow! Obj=%p State=%p #Ops=%u\",",
        "\t\t\t    object, walk_state, walk_state->num_operands));",
        "\t\treturn (AE_STACK_OVERFLOW);",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\dswstate.c",
      "line": 286,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "STACK_OVERFLOW",
      "context": [
        "\t\tACPI_ERROR((AE_INFO,",
        "\t\t\t    \"Object stack overflow! Obj=%p State=%p #Ops=%u\",",
        "\t\t\t    object, walk_state, walk_state->num_operands));",
        "\t\treturn (AE_STACK_OVERFLOW);",
        "\t}",
        "",
        "\t/* Put the object onto the stack */"
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\evxface.c",
      "line": 1034,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\treturn (AE_BAD_PARAMETER);",
        "\t}",
        "",
        "\t/* Must lock interpreter to prevent race conditions */",
        "",
        "\tacpi_ex_enter_interpreter();",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\exfldio.c",
      "line": 672,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "\t\t\t    \"Field size %u (bits) is too large for buffer (%u)\",",
        "\t\t\t    obj_desc->common_field.bit_length, buffer_length));",
        "",
        "\t\treturn_ACPI_STATUS(AE_BUFFER_OVERFLOW);",
        "\t}",
        "",
        "\tmemset(buffer, 0, buffer_length);"
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\exmutex.c",
      "line": 214,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Current sync level must be less than or equal to the sync level",
        "\t * of the mutex. This mechanism provides some deadlock prevention.",
        "\t */",
        "\tif (walk_state->thread->current_sync_level > obj_desc->mutex.sync_level) {",
        "\t\tACPI_ERROR((AE_INFO,"
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\nswalk.c",
      "line": 201,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t/*",
        "\t\t * Ignore all temporary namespace nodes (created during control",
        "\t\t * method execution) unless told otherwise. These temporary nodes",
        "\t\t * can cause a race condition because they can be deleted during",
        "\t\t * the execution of the user function (if the namespace is",
        "\t\t * unlocked before invocation of the user function.) Only the",
        "\t\t * debugger namespace dump will examine the temporary nodes."
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\nsxfeval.c",
      "line": 425,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tif (info->return_object) {",
        "\t\t/*",
        "\t\t * Delete the internal return object. NOTE: Interpreter must be",
        "\t\t * locked to avoid race condition.",
        "\t\t */",
        "\t\tacpi_ex_enter_interpreter();",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\rscreate.c",
      "line": 167,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        " *",
        " * RETURN:      Status  AE_OK if okay, else a valid acpi_status code.",
        " *              If the output_buffer is too small, the error will be",
        " *              AE_BUFFER_OVERFLOW and output_buffer->Length will point",
        " *              to the size buffer needed.",
        " *",
        " * DESCRIPTION: Takes the union acpi_operand_object package and creates a"
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\rscreate.c",
      "line": 395,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        " *",
        " * RETURN:      Status  AE_OK if okay, else a valid acpi_status code.",
        " *              If the output_buffer is too small, the error will be",
        " *              AE_BUFFER_OVERFLOW and output_buffer->Length will point",
        " *              to the size buffer needed.",
        " *",
        " * DESCRIPTION: Converts a list of device resources to an AML bytestream"
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\utalloc.c",
      "line": 317,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "",
        "\t\t/* Return the exception (and the required buffer length) */",
        "",
        "\t\treturn (AE_BUFFER_OVERFLOW);",
        "",
        "\tcase ACPI_ALLOCATE_BUFFER:",
        "\t\t/*"
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\utalloc.c",
      "line": 342,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "\t\t/* Existing buffer: Validate the size of the buffer */",
        "",
        "\t\tif (input_buffer_length < required_length) {",
        "\t\t\treturn (AE_BUFFER_OVERFLOW);",
        "\t\t}",
        "\t\tbreak;",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\utcache.c",
      "line": 264,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t}",
        "#endif",
        "",
        "\t\t/* Avoid deadlock with ACPI_ALLOCATE_ZEROED */",
        "",
        "\t\tstatus = acpi_ut_release_mutex(ACPI_MTX_CACHES);",
        "\t\tif (ACPI_FAILURE(status)) {"
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\utmutex.c",
      "line": 206,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Deadlock",
      "context": [
        "\t\t/*",
        "\t\t * Mutex debug code, for internal debugging only.",
        "\t\t *",
        "\t\t * Deadlock prevention. Check if this thread owns any mutexes of value",
        "\t\t * greater than or equal to this one. If so, the thread has violated",
        "\t\t * the mutex ordering rule. This indicates a coding error somewhere in",
        "\t\t * the ACPI subsystem code."
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\utmutex.c",
      "line": 229,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t\t\t\t\t    acpi_ut_get_mutex_name(i),",
        "\t\t\t\t\t    acpi_ut_get_mutex_name(mutex_id)));",
        "",
        "\t\t\t\treturn (AE_ACQUIRE_DEADLOCK);",
        "\t\t\t}",
        "\t\t}",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\utmutex.c",
      "line": 301,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Deadlock",
      "context": [
        "\t\t/*",
        "\t\t * Mutex debug code, for internal debugging only.",
        "\t\t *",
        "\t\t * Deadlock prevention. Check if this thread owns any mutexes of value",
        "\t\t * greater than this one. If so, the thread has violated the mutex",
        "\t\t * ordering rule. This indicates a coding error somewhere in",
        "\t\t * the ACPI subsystem code."
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\utmutex.c",
      "line": 318,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t\t\t\t\t    acpi_ut_get_mutex_name(i),",
        "\t\t\t\t\t    acpi_ut_get_mutex_name(mutex_id)));",
        "",
        "\t\t\t\treturn (AE_RELEASE_DEADLOCK);",
        "\t\t\t}",
        "\t\t}",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\uttrack.c",
      "line": 11,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        " *****************************************************************************/",
        "",
        "/*",
        " * These procedures are used for tracking memory leaks in the subsystem, and",
        " * they get compiled out when the ACPI_DBG_TRACK_ALLOCATIONS is not set.",
        " *",
        " * Each memory allocation is tracked via a doubly linked list. Each"
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\uttrack.c",
      "line": 268,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        " *",
        " *              Note: The list is ordered by larger-to-smaller addresses.",
        " *",
        " *              This global list is used to detect memory leaks in ACPICA as",
        " *              well as other issues such as an attempt to release the same",
        " *              internal object more than once. Although expensive as far",
        " *              as cpu time, this list is much more helpful for finding these"
      ]
    },
    {
      "file": "linux\\drivers\\acpi\\acpica\\uttrack.c",
      "line": 272,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        " *              well as other issues such as an attempt to release the same",
        " *              internal object more than once. Although expensive as far",
        " *              as cpu time, this list is much more helpful for finding these",
        " *              types of issues than using memory leak detectors outside of",
        " *              the ACPICA code.",
        " *",
        " ******************************************************************************/"
      ]
    },
    {
      "file": "linux\\drivers\\base\\firmware_loader\\main.c",
      "line": 1657,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "{",
        "\t/*",
        "\t * Kill all pending fallback requests to avoid both stalling shutdown,",
        "\t * and avoid a deadlock with the usermode_lock.",
        "\t */",
        "\tkill_pending_fw_fallback_reqs(true);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\base\\power\\runtime.c",
      "line": 201,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * the flag for devices in the path whose siblings don't set the flag.",
        " *",
        " * The function should only be called by block device, or network",
        " * device driver for solving the deadlock problem during runtime",
        " * resume/suspend:",
        " *",
        " *     If memory allocation with GFP_KERNEL is called inside runtime"
      ]
    },
    {
      "file": "linux\\drivers\\base\\power\\runtime.c",
      "line": 206,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " *     If memory allocation with GFP_KERNEL is called inside runtime",
        " *     resume/suspend callback of any one of its ancestors(or the",
        " *     block device itself), the deadlock may be triggered inside the",
        " *     memory allocation since it might not complete until the block",
        " *     device becomes active and the involed page I/O finishes. The",
        " *     situation is pointed out first by Alan Stern. Network device"
      ]
    },
    {
      "file": "linux\\drivers\\base\\power\\runtime.c",
      "line": 436,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Deadlock",
      "context": [
        "\t\tunsigned int noio_flag;",
        "",
        "\t\t/*",
        "\t\t * Deadlock might be caused if memory allocation with",
        "\t\t * GFP_KERNEL happens inside runtime_suspend and",
        "\t\t * runtime_resume callbacks of one block device's",
        "\t\t * ancestor or the block device itself. Network"
      ]
    },
    {
      "file": "linux\\drivers\\block\\aoe\\aoedev.c",
      "line": 429,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\t\tprintk(KERN_ERR",
        "\t\t\t\"aoe: %s holds ref: %s\\n\",",
        "\t\t\tskb->dev ? skb->dev->name : \"netif\",",
        "\t\t\t\"cannot free skb -- memory leaked.\");",
        "\t\treturn;",
        "\t}",
        "\tskb->truesize -= skb->data_len;"
      ]
    },
    {
      "file": "linux\\drivers\\block\\drbd\\drbd_bitmap.c",
      "line": 69,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " *\tWe plan to reduce the amount of in-core bitmap pages by paging them in",
        " *\tand out against their on-disk location as necessary, but need to make",
        " *\tsure we don't cause too much meta data IO, and must not deadlock in",
        " *\ttight memory situations. This needs some more work.",
        " */",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\block\\drbd\\drbd_nl.c",
      "line": 887,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\treturn buf;",
        "}",
        "",
        "/* there is still a theoretical deadlock when called from receiver",
        " * on an D_INCONSISTENT R_PRIMARY:",
        " *  remote READ does inc_ap_bio, receiver would need to receive answer",
        " *  packet from remote to dec_ap_bio again."
      ]
    },
    {
      "file": "linux\\drivers\\block\\drbd\\drbd_nl.c",
      "line": 892,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *  remote READ does inc_ap_bio, receiver would need to receive answer",
        " *  packet from remote to dec_ap_bio again.",
        " *  receiver receive_sizes(), comes here,",
        " *  waits for ap_bio_cnt == 0. -> deadlock.",
        " * but this cannot happen, actually, because:",
        " *  R_PRIMARY D_INCONSISTENT, and peer's disk is unreachable",
        " *  (not connected, or bad/no disk on peer):"
      ]
    },
    {
      "file": "linux\\drivers\\block\\drbd\\drbd_receiver.c",
      "line": 256,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * allocation (schedule_timeout) to give the system some room to breathe.",
        " *",
        " * We do not use max-buffers as hard limit, because it could lead to",
        " * congestion and further to a distributed deadlock during online-verify or",
        " * (checksum based) resync, if the max-buffers, socket buffer sizes and",
        " * resync-rate settings are mis-configured.",
        " *"
      ]
    },
    {
      "file": "linux\\drivers\\block\\drbd\\drbd_receiver.c",
      "line": 313,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\treturn page;",
        "}",
        "",
        "/* Must not be used from irq, as that may deadlock: see drbd_alloc_pages.",
        " * Is also used from inside an other spin_lock_irq(&resource->req_lock);",
        " * Either links the page chain back to the global pool,",
        " * or returns all pages to the system. */"
      ]
    },
    {
      "file": "linux\\drivers\\block\\drbd\\drbd_receiver.c",
      "line": 1782,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\treturn 0;",
        "",
        "\t\t/* receiver context, in the writeout path of the other node.",
        "\t\t * avoid potential distributed deadlock */",
        "\t\tepoch = kmalloc(sizeof(struct drbd_epoch), GFP_NOIO);",
        "\t\tif (epoch)",
        "\t\t\tbreak;"
      ]
    },
    {
      "file": "linux\\drivers\\block\\drbd\\drbd_receiver.c",
      "line": 4885,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\terr = drbd_send_bitmap(device, peer_device);",
        "\t\tif (err)",
        "\t\t\tgoto out;",
        "\t\t/* Omit CS_ORDERED with this state transition to avoid deadlocks. */",
        "\t\trv = _drbd_request_state(device, NS(conn, C_WF_SYNC_UUID), CS_VERBOSE);",
        "\t\tD_ASSERT(device, rv == SS_SUCCESS);",
        "\t} else if (device->state.conn != C_WF_BITMAP_S) {"
      ]
    },
    {
      "file": "linux\\drivers\\block\\drbd\\drbd_state.c",
      "line": 668,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * We wrap it all into wait_event(), to retry in case the drbd_req_state()",
        " * returns SS_IN_TRANSIENT_STATE.",
        " *",
        " * To avoid potential deadlock with e.g. the receiver thread trying to grab",
        " * drbd_md_get_buffer() while trying to get out of the \"transient state\", we",
        " * need to grab and release the meta data buffer inside of that wait_event loop.",
        " */"
      ]
    },
    {
      "file": "linux\\drivers\\block\\drbd\\drbd_worker.c",
      "line": 361,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tdrbd_csum_ee(peer_device->connection->csums_tfm, peer_req, digest);",
        "\t\t/* Free peer_req and pages before send.",
        "\t\t * In case we block on congestion, we could otherwise run into",
        "\t\t * some distributed deadlock, if the other side blocks on",
        "\t\t * congestion as well, because our receiver blocks in",
        "\t\t * drbd_alloc_pages due to pp_in_use > max_buffers. */",
        "\t\tdrbd_free_peer_req(device, peer_req);"
      ]
    },
    {
      "file": "linux\\drivers\\block\\drbd\\drbd_worker.c",
      "line": 572,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/* Don't have more than \"max-buffers\"/2 in-flight.",
        "\t * Otherwise we may cause the remote site to stall on drbd_alloc_pages(),",
        "\t * potentially causing a distributed deadlock on congestion during",
        "\t * online-verify or (checksum-based) resync, if max-buffers,",
        "\t * socket buffer sizes and resync rate settings are mis-configured. */",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\block\\drbd\\drbd_worker.c",
      "line": 1260,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/* Free e and pages before send.",
        "\t * In case we block on congestion, we could otherwise run into",
        "\t * some distributed deadlock, if the other side blocks on",
        "\t * congestion as well, because our receiver blocks in",
        "\t * drbd_alloc_pages due to pp_in_use > max_buffers. */",
        "\tdrbd_free_peer_req(device, peer_req);"
      ]
    },
    {
      "file": "linux\\drivers\\block\\drbd\\drbd_worker.c",
      "line": 1332,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/* Free peer_req and pages before send.",
        "\t * In case we block on congestion, we could otherwise run into",
        "\t * some distributed deadlock, if the other side blocks on",
        "\t * congestion as well, because our receiver blocks in",
        "\t * drbd_alloc_pages due to pp_in_use > max_buffers. */",
        "\tdrbd_free_peer_req(device, peer_req);"
      ]
    },
    {
      "file": "linux\\drivers\\block\\rnbd\\rnbd-clt.c",
      "line": 663,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * if something goes wrong (failing of outstanding requests",
        "\t * happens exactly from the context where we are blocking now).",
        "\t *",
        "\t * So to avoid deadlocks each usr message sent from here must",
        "\t * be asynchronous.",
        "\t */",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\block\\rnbd\\rnbd-clt.c",
      "line": 845,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tmutex_unlock(&sess_lock);",
        "\t/* loop in caller, see __find_and_get_sess().",
        "\t * You can't leave mutex locked and call schedule(), you will catch a",
        "\t * deadlock with a caller of free_sess(), which has just put the last",
        "\t * reference and is about to take the sess_lock in order to delete",
        "\t * the session from the list.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\block\\rnbd\\rnbd-clt.c",
      "line": 1659,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\trnbd_clt_remove_dev_symlink(dev);",
        "\tif (dev->kobj.state_initialized) {",
        "\t\tif (sysfs_self)",
        "\t\t\t/* To avoid deadlock firstly remove itself */",
        "\t\t\tsysfs_remove_file_self(&dev->kobj, sysfs_self);",
        "\t\tkobject_del(&dev->kobj);",
        "\t\tkobject_put(&dev->kobj);"
      ]
    },
    {
      "file": "linux\\drivers\\block\\rnbd\\rnbd-srv.c",
      "line": 331,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\treturn;",
        "",
        "\tsess_dev->keep_id = true;",
        "\t/* first remove sysfs itself to avoid deadlock */",
        "\tsysfs_remove_file_self(&sess_dev->kobj, &attr->attr);",
        "\trnbd_srv_destroy_dev_session_sysfs(sess_dev);",
        "\tmutex_unlock(&sess->lock);"
      ]
    },
    {
      "file": "linux\\drivers\\block\\zram\\zram_drv.c",
      "line": 1075,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "/*",
        " * Block layer want one ->submit_bio to be active at a time, so if we use",
        " * chained IO with parent IO in same context, it's a deadlock. To avoid that,",
        " * use a worker thread context.",
        " */",
        "static int read_from_bdev_sync(struct zram *zram, struct page *page,"
      ]
    },
    {
      "file": "linux\\drivers\\char\\hw_random\\stm32-rng.c",
      "line": 582,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Missing clock",
      "context": [
        "\t\tstruct clk *clk = priv->clk_bulk[1].clk;",
        "",
        "\t\tif (!priv->clk_bulk[0].id || !priv->clk_bulk[1].id)",
        "\t\t\treturn dev_err_probe(dev, -EINVAL, \"Missing clock name\\n\");",
        "",
        "\t\tif (strcmp(priv->clk_bulk[0].id, \"core\")) {",
        "\t\t\tpriv->clk_bulk[1].id = priv->clk_bulk[0].id;"
      ]
    },
    {
      "file": "linux\\drivers\\char\\ipmi\\ipmi_msghandler.c",
      "line": 2085,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t * We don't unlock until here, because we need",
        "\t\t * to copy the completed message into the",
        "\t\t * recv_msg before we release the lock.",
        "\t\t * Otherwise, race conditions may bite us.  I",
        "\t\t * know that's pretty paranoid, but I prefer",
        "\t\t * to be correct.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\char\\ipmi\\ipmi_msghandler.c",
      "line": 2255,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t * We don't unlock until here, because we need",
        "\t\t * to copy the completed message into the",
        "\t\t * recv_msg before we release the lock.",
        "\t\t * Otherwise, race conditions may bite us.  I",
        "\t\t * know that's pretty paranoid, but I prefer",
        "\t\t * to be correct.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\char\\ipmi\\ipmi_msghandler.c",
      "line": 5577,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\t\t/*",
        "\t\t * Tell the timer to stop, then wait for it to stop.  This",
        "\t\t * avoids problems with race conditions removing the timer",
        "\t\t * here.",
        "\t\t */",
        "\t\tatomic_set(&stop_operation, 1);"
      ]
    },
    {
      "file": "linux\\drivers\\char\\ipmi\\ipmi_msghandler.c",
      "line": 954,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t} else if (oops_in_progress) {",
        "\t\t/*",
        "\t\t * If we are running in the panic context, calling the",
        "\t\t * receive handler doesn't much meaning and has a deadlock",
        "\t\t * risk.  At this moment, simply skip it in that case.",
        "\t\t */",
        "\t\tipmi_free_recv_msg(msg);"
      ]
    },
    {
      "file": "linux\\drivers\\char\\ipmi\\ipmi_msghandler.c",
      "line": 4808,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Start the next message if available.",
        "\t *",
        "\t * Do this here, not in the actual receiver, because we may deadlock",
        "\t * because the lower layer is allowed to hold locks while calling",
        "\t * message delivery.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\char\\ipmi\\ipmi_watchdog.c",
      "line": 565,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * to restore the timer's info.  Note that we still hold",
        "\t\t * the heartbeat lock, to keep a heartbeat from happening",
        "\t\t * in this process, so must say no heartbeat to avoid a",
        "\t\t * deadlock on this mutex",
        "\t\t */",
        "\t\trv = _ipmi_set_timeout(IPMI_SET_TIMEOUT_NO_HB);",
        "\t\tif (rv) {"
      ]
    },
    {
      "file": "linux\\drivers\\char\\mwave\\mwavedd.c",
      "line": 344,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t\t\tset_current_state(TASK_INTERRUPTIBLE);",
        "\t\t\t\t/* check whether an event was signalled by */",
        "\t\t\t\t/* the interrupt handler while we were gone */",
        "\t\t\t\tif (pDrvData->IPCs[ipcnum].usIntCount == 1) {\t/* first int has occurred (race condition) */",
        "\t\t\t\t\tpDrvData->IPCs[ipcnum].usIntCount = 2;\t/* first int has been handled */",
        "\t\t\t\t\tPRINTK_2(TRACE_MWAVE,",
        "\t\t\t\t\t\t\"mwavedd::mwave_ioctl\""
      ]
    },
    {
      "file": "linux\\drivers\\char\\xilinx_hwicap\\buffer_icap.c",
      "line": 42,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "/* File access and error constants */",
        "#define XHI_DEVICE_READ_ERROR       -1",
        "#define XHI_DEVICE_WRITE_ERROR      -2",
        "#define XHI_BUFFER_OVERFLOW_ERROR   -3",
        "",
        "#define XHI_DEVICE_READ             0x1",
        "#define XHI_DEVICE_WRITE            0x0"
      ]
    },
    {
      "file": "linux\\drivers\\char\\xillybus\\xillyusb.c",
      "line": 789,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "Race condition",
      "context": [
        "\t\tspin_lock_irqsave(&ep->buffers_lock, flags);",
        "",
        "\t\t/*",
        "\t\t * Race conditions might have the FIFO filled while the",
        "\t\t * endpoint is marked as drained here. That doesn't matter,",
        "\t\t * because the sole purpose of @drained is to ensure that",
        "\t\t * certain data has been sent on the USB channel before"
      ]
    },
    {
      "file": "linux\\drivers\\clk\\davinci\\da8xx-cfgchip.c",
      "line": 516,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Missing fck clock",
      "context": [
        "",
        "\tfck_clk = devm_clk_get(dev, \"fck\");",
        "\tif (IS_ERR(fck_clk)) {",
        "\t\treturn dev_err_cast_probe(dev, fck_clk, \"Missing fck clock\\n\");",
        "\t}",
        "",
        "\tusb0 = devm_kzalloc(dev, sizeof(*usb0), GFP_KERNEL);"
      ]
    },
    {
      "file": "linux\\drivers\\clk\\keystone\\pll.c",
      "line": 265,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing parent clock",
      "context": [
        "",
        "\tparent_name = of_clk_get_parent_name(node, 0);",
        "\tif (!parent_name) {",
        "\t\tpr_err(\"%s: missing parent clock\\n\", __func__);",
        "\t\tiounmap(reg);",
        "\t\treturn;",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\clk\\keystone\\pll.c",
      "line": 315,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing parent clock",
      "context": [
        "",
        "\tof_clk_parent_fill(node, parents, 2);",
        "\tif (!parents[0] || !parents[1]) {",
        "\t\tpr_err(\"%s: missing parent clocks\\n\", __func__);",
        "\t\treturn;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\clk\\mediatek\\clk-mt6765.c",
      "line": 630,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tGATE_IFR5(CLK_IFR_CCIF3_MD, \"ifr_ccif3_md\", \"axi_ck\", 21),",
        "};",
        "",
        "/* additional CCF control for mipi26M race condition(disp/camera) */",
        "static const struct mtk_gate_regs apmixed_cg_regs = {",
        "\t.set_ofs = 0x14,",
        "\t.clr_ofs = 0x14,"
      ]
    },
    {
      "file": "linux\\drivers\\clk\\mediatek\\clk-mtk.c",
      "line": 503,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tdevm_pm_runtime_enable(&pdev->dev);",
        "\t\t/*",
        "\t\t * Do a pm_runtime_resume_and_get() to workaround a possible",
        "\t\t * deadlock between clk_register() and the genpd framework.",
        "\t\t */",
        "\t\tr = pm_runtime_resume_and_get(&pdev->dev);",
        "\t\tif (r)"
      ]
    },
    {
      "file": "linux\\drivers\\clk\\rockchip\\clk-rk3188.c",
      "line": 856,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing clock",
      "context": [
        "",
        "\t\tclk_set_rate(clk1, rate);",
        "\t} else {",
        "\t\tpr_warn(\"%s: missing clocks to reparent aclk_cpu_pre to gpll\\n\",",
        "\t\t\t__func__);",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\clk\\tegra\\clk-dfll.c",
      "line": 1428,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing ref clock",
      "context": [
        "{",
        "\ttd->ref_clk = devm_clk_get(td->dev, \"ref\");",
        "\tif (IS_ERR(td->ref_clk)) {",
        "\t\tdev_err(td->dev, \"missing ref clock\\n\");",
        "\t\treturn PTR_ERR(td->ref_clk);",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\clk\\tegra\\clk-dfll.c",
      "line": 1434,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing soc clock",
      "context": [
        "",
        "\ttd->soc_clk = devm_clk_get(td->dev, \"soc\");",
        "\tif (IS_ERR(td->soc_clk)) {",
        "\t\tdev_err(td->dev, \"missing soc clock\\n\");",
        "\t\treturn PTR_ERR(td->soc_clk);",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\clk\\tegra\\clk-dfll.c",
      "line": 1440,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing i2c clock",
      "context": [
        "",
        "\ttd->i2c_clk = devm_clk_get(td->dev, \"i2c\");",
        "\tif (IS_ERR(td->i2c_clk)) {",
        "\t\tdev_err(td->dev, \"missing i2c clock\\n\");",
        "\t\treturn PTR_ERR(td->i2c_clk);",
        "\t}",
        "\ttd->i2c_clk_rate = clk_get_rate(td->i2c_clk);"
      ]
    },
    {
      "file": "linux\\drivers\\clk\\tegra\\clk-dfll.c",
      "line": 1919,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing clock",
      "context": [
        "",
        "\tif (of_property_read_string(td->dev->of_node, \"clock-output-names\",",
        "\t\t\t\t    &td->output_clock_name)) {",
        "\t\tdev_err(td->dev, \"missing clock-output-names property\\n\");",
        "\t\tok = false;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\clk\\tegra\\clk-tegra-audio.c",
      "line": 82,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "doubler_lock",
      "context": [
        "\t\t.div_offset\t= _offset,\\",
        "\t}",
        "",
        "static DEFINE_SPINLOCK(clk_doubler_lock);",
        "",
        "static const char * const mux_audio_sync_clk[] = { \"spdif_in_sync\",",
        "\t\"i2s0_sync\", \"i2s1_sync\", \"i2s2_sync\", \"i2s3_sync\", \"i2s4_sync\","
      ]
    },
    {
      "file": "linux\\drivers\\clk\\tegra\\clk-tegra-audio.c",
      "line": 240,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "doubler_lock",
      "context": [
        "\t\tclk = tegra_clk_register_divider(data->div_name,",
        "\t\t\t\tdata->name_2x, clk_base + AUDIO_SYNC_DOUBLER,",
        "\t\t\t\t0, 0, data->div_offset, 1, 0,",
        "\t\t\t\t&clk_doubler_lock);",
        "\t\tclk = tegra_clk_register_periph_gate(data->gate_name,",
        "\t\t\t\tdata->div_name, TEGRA_PERIPH_NO_RESET,",
        "\t\t\t\tclk_base, CLK_SET_RATE_PARENT, data->clk_num,"
      ]
    },
    {
      "file": "linux\\drivers\\clk\\ti\\apll.c",
      "line": 374,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing clock",
      "context": [
        "\tinit->parent_names = &parent_name;",
        "",
        "\tif (of_property_read_u32(node, \"ti,clock-frequency\", &val)) {",
        "\t\tpr_err(\"%pOFn missing clock-frequency\\n\", node);",
        "\t\tgoto cleanup;",
        "\t}",
        "\tclk_hw->fixed_rate = val;"
      ]
    },
    {
      "file": "linux\\drivers\\clk\\ti\\clk.c",
      "line": 422,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing 'clock",
      "context": [
        "\t/* get clocks for this parent */",
        "\tclocks = of_get_child_by_name(parent, \"clocks\");",
        "\tif (!clocks) {",
        "\t\tpr_err(\"%pOFn missing 'clocks' child node.\\n\", parent);",
        "\t\treturn -EINVAL;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\clk\\ti\\clk.c",
      "line": 511,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing clock",
      "context": [
        "/**",
        " * ti_clk_add_aliases - setup clock aliases",
        " *",
        " * Sets up any missing clock aliases. No return value.",
        " */",
        "void __init ti_clk_add_aliases(void)",
        "{"
      ]
    },
    {
      "file": "linux\\drivers\\clk\\ti\\dpll.c",
      "line": 148,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing), the clock",
      "context": [
        " * @node: device node for the clock",
        " *",
        " * Finalizes DPLL registration process. In case a failure (clk-ref or",
        " * clk-bypass is missing), the clock is added to retry list and",
        " * the initialization is retried on later stage.",
        " */",
        "static void __init _register_dpll(void *user,"
      ]
    },
    {
      "file": "linux\\drivers\\comedi\\drivers\\quatech_daqp_cs.c",
      "line": 548,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * = 3^3 * 2).  Hmmm... a one-line while loop or prime",
        "\t * decomposition of integers... I'll leave it the way it is.",
        "\t *",
        "\t * I'll also note a mini-race condition before ignoring it in",
        "\t * the code.  Let's say we're taking 4000 samples, as before.",
        "\t * After 1000 samples, we get an interrupt.  But before that",
        "\t * interrupt is completely serviced, another sample is taken"
      ]
    },
    {
      "file": "linux\\drivers\\comedi\\drivers\\usbduxfast.c",
      "line": 27,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "Buffer overflow",
      "context": [
        " * Revision history:",
        " * 1.0: Fixed a rounding error in usbduxfast_ai_cmdtest",
        " * 0.9: Dropping the first data packet which seems to be from the last transfer.",
        " *      Buffer overflows in the FX2 are handed over to comedi.",
        " * 0.92: Dropping now 4 packets. The quad buffer has to be emptied.",
        " *       Added insn command basically for testing. Sample rate is",
        " *       1MHz/16ch=62.5kHz"
      ]
    },
    {
      "file": "linux\\drivers\\crypto\\caam\\caampkc.c",
      "line": 39,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double free",
      "context": [
        "static u8 *zero_buffer;",
        "",
        "/*",
        " * variable used to avoid double free of resources in case",
        " * algorithm registration was unsuccessful",
        " */",
        "static bool init_done;"
      ]
    },
    {
      "file": "linux\\drivers\\crypto\\hisilicon\\debugfs.c",
      "line": 823,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double free",
      "context": [
        "\tif (!dregs)",
        "\t\treturn;",
        "",
        "\t/* Setting the pointer is NULL to prevent double free */",
        "\tfor (i = 0; i < reg_len; i++) {",
        "\t\tif (!dregs[i].regs)",
        "\t\t\tcontinue;"
      ]
    },
    {
      "file": "linux\\drivers\\crypto\\inside-secure\\safexcel.c",
      "line": 906,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer_overflow",
      "context": [
        "",
        "\tif (likely((!rdesc->last_seg) || /* Rest only valid if last seg! */",
        "\t\t   ((!rdesc->descriptor_overflow) &&",
        "\t\t    (!rdesc->buffer_overflow) &&",
        "\t\t    (!result_data->error_code))))",
        "\t\treturn 0;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\crypto\\inside-secure\\safexcel.c",
      "line": 913,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer_overflow",
      "context": [
        "\tif (rdesc->descriptor_overflow)",
        "\t\tdev_err(priv->dev, \"Descriptor overflow detected\");",
        "",
        "\tif (rdesc->buffer_overflow)",
        "\t\tdev_err(priv->dev, \"Buffer overflow detected\");",
        "",
        "\tif (result_data->error_code & 0x4066) {"
      ]
    },
    {
      "file": "linux\\drivers\\crypto\\inside-secure\\safexcel.c",
      "line": 914,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "Buffer overflow",
      "context": [
        "\t\tdev_err(priv->dev, \"Descriptor overflow detected\");",
        "",
        "\tif (rdesc->buffer_overflow)",
        "\t\tdev_err(priv->dev, \"Buffer overflow detected\");",
        "",
        "\tif (result_data->error_code & 0x4066) {",
        "\t\t/* Fatal error (bits 1,2,5,6 & 14) */"
      ]
    },
    {
      "file": "linux\\drivers\\crypto\\inside-secure\\safexcel_ring.c",
      "line": 240,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer_overflow",
      "context": [
        "\trdesc->particle_size = len;",
        "\trdesc->rsvd0 = 0;",
        "\trdesc->descriptor_overflow = 1; /* assume error */",
        "\trdesc->buffer_overflow = 1;     /* assume error */",
        "\trdesc->last_seg = last;",
        "\trdesc->first_seg = first;",
        "\trdesc->result_size = EIP197_RD64_RESULT_SIZE;"
      ]
    },
    {
      "file": "linux\\drivers\\crypto\\rockchip\\rk3288_crypto.c",
      "line": 68,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Missing clock",
      "context": [
        "",
        "\tdev->num_clks = devm_clk_bulk_get_all(dev->dev, &dev->clks);",
        "\tif (dev->num_clks < dev->variant->num_clks) {",
        "\t\tdev_err(dev->dev, \"Missing clocks, got %d instead of %d\\n\",",
        "\t\t\tdev->num_clks, dev->variant->num_clks);",
        "\t\treturn -EINVAL;",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\crypto\\intel\\keembay\\keembay-ocs-hcu-core.c",
      "line": 81,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double the block",
      "context": [
        "\tstruct ocs_hcu_dma_list\t*dma_list;",
        "\tstruct ocs_hcu_hash_ctx\thash_ctx;",
        "\t/*",
        "\t * Buffer is double the block size because we need space for SW HMAC",
        "\t * artifacts, i.e:",
        "\t * - ipad (1 block) + a possible partial block of data.",
        "\t * - opad (1 block) + digest of H(k ^ ipad || m)"
      ]
    },
    {
      "file": "linux\\drivers\\crypto\\intel\\qat\\qat_common\\qat_comp_algs.c",
      "line": 103,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t\tmemset(inst->dc_data->ovf_buff, 0,",
        "\t\t\t       inst->dc_data->ovf_buff_sz);",
        "\t\t\tdev_dbg(&GET_DEV(accel_dev),",
        "\t\t\t\t\"Actual buffer overflow: produced=%d, dlen=%d\\n\",",
        "\t\t\t\tproduced, qat_req->actual_dlen);",
        "\t\t\tgoto end;",
        "\t\t}"
      ]
    },
    {
      "file": "linux\\drivers\\crypto\\marvell\\cesa\\hash.c",
      "line": 1162,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory region to 0 to avoid any leak",
      "context": [
        "\t\tret = crypto_ahash_digest(req);",
        "\t\tret = crypto_wait_req(ret, &result);",
        "",
        "\t\t/* Set the memory region to 0 to avoid any leak. */",
        "\t\tkfree_sensitive(keydup);",
        "",
        "\t\tif (ret)"
      ]
    },
    {
      "file": "linux\\drivers\\cxl\\core\\hdm.c",
      "line": 1139,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double it to be tolerant of any clock",
      "context": [
        "\t * Since the register resource was recently claimed via request_region()",
        "\t * be careful about trusting the \"not-committed\" status until the commit",
        "\t * timeout has elapsed.  The commit timeout is 10ms (CXL 2.0",
        "\t * 8.2.5.12.20), but double it to be tolerant of any clock skew between",
        "\t * host and target.",
        "\t */",
        "\tfor (i = 0, committed = 0; i < cxlhdm->decoder_count; i++) {"
      ]
    },
    {
      "file": "linux\\drivers\\dma\\mediatek\\mtk-cqdma.c",
      "line": 640,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t\tmtk_dma_set(pc, MTK_CQDMA_INT_EN, MTK_CQDMA_INT_EN_BIT);",
        "",
        "\t\t/*",
        "\t\t * refcount_inc would complain increment on 0; use-after-free.",
        "\t\t * Thus, we need to explicitly set it as 1 initially.",
        "\t\t */",
        "\t\trefcount_set(&pc->refcnt, 1);"
      ]
    },
    {
      "file": "linux\\drivers\\dma\\mediatek\\mtk-hsdma.c",
      "line": 822,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t\tif (err)",
        "\t\t\treturn err;",
        "\t\t/*",
        "\t\t * refcount_inc would complain increment on 0; use-after-free.",
        "\t\t * Thus, we need to explicitly set it as 1 initially.",
        "\t\t */",
        "\t\trefcount_set(&hsdma->pc_refcnt, 1);"
      ]
    },
    {
      "file": "linux\\drivers\\dma\\stm32\\stm32-dmamux.c",
      "line": 251,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Missing clock",
      "context": [
        "\tstm32_dmamux->clk = devm_clk_get(&pdev->dev, NULL);",
        "\tif (IS_ERR(stm32_dmamux->clk))",
        "\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(stm32_dmamux->clk),",
        "\t\t\t\t     \"Missing clock controller\\n\");",
        "",
        "\tret = clk_prepare_enable(stm32_dmamux->clk);",
        "\tif (ret < 0) {"
      ]
    },
    {
      "file": "linux\\drivers\\dma\\stm32\\stm32-dma.c",
      "line": 1371,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * - the sg_req currently transferred",
        "\t * - the Hardware remaining position in this sg (NDTR bits field).",
        "\t *",
        "\t * A race condition may occur if DMA is running in cyclic or double",
        "\t * buffer mode, since the DMA register are automatically reloaded at end",
        "\t * of period transfer. The hardware may have switched to the next",
        "\t * transfer (CT bit updated) just before the position (SxNDTR reg) is"
      ]
    },
    {
      "file": "linux\\drivers\\dma\\stm32\\stm32-dma.c",
      "line": 1385,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * the next transfer. So we approximate the residue in consequence, by",
        "\t * pointing on the beginning of next transfer.",
        "\t *",
        "\t * This race condition doesn't apply for none cyclic mode, as double",
        "\t * buffer is not used. In such situation registers are updated by the",
        "\t * software.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\dma\\stm32\\stm32-mdma.c",
      "line": 1644,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Missing clock",
      "context": [
        "\tdmadev->clk = devm_clk_get(&pdev->dev, NULL);",
        "\tif (IS_ERR(dmadev->clk))",
        "\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(dmadev->clk),",
        "\t\t\t\t     \"Missing clock controller\\n\");",
        "",
        "\tret = clk_prepare_enable(dmadev->clk);",
        "\tif (ret < 0) {"
      ]
    },
    {
      "file": "linux\\drivers\\firmware\\arm_scmi\\raw_mode.c",
      "line": 1399,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * msg_q.",
        "\t *",
        "\t * Note that nowhere else these locks are taken together, so no risk of",
        "\t * deadlocks du eto inversion.",
        "\t */",
        "\tspin_lock_irqsave(&q->msg_q_lock, flags);",
        "\trb = scmi_raw_buffer_get(q);"
      ]
    },
    {
      "file": "linux\\drivers\\firmware\\arm_scmi\\scmi_power_control.c",
      "line": 192,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\tdev_dbg(sc->dev, \"Graceful request timed out...forcing !\\n\");",
        "\tmutex_lock(&sc->state_mtx);",
        "\t/* avoid deadlock by unregistering reboot notifier first */",
        "\tunregister_reboot_notifier(&sc->reboot_nb);",
        "\tif (sc->state == SCMI_SYSPOWER_IN_PROGRESS)",
        "\t\tscmi_request_forceful_transition(sc);"
      ]
    },
    {
      "file": "linux\\drivers\\firmware\\efi\\unaccepted_memory.c",
      "line": 137,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t\t/*",
        "\t\t * Keep interrupts disabled until the accept operation is",
        "\t\t * complete in order to prevent deadlocks.",
        "\t\t *",
        "\t\t * Enabling interrupts before calling arch_accept_memory()",
        "\t\t * creates an opportunity for an interrupt handler to request"
      ]
    },
    {
      "file": "linux\\drivers\\firmware\\google\\memconsole-coreboot.c",
      "line": 36,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "/*",
        " * The cbmem_console structure is read again on every access because it may",
        " * change at any time if runtime firmware logs new messages. This may rarely",
        " * lead to race conditions where the firmware overwrites the beginning of the",
        " * ring buffer with more lines after we have already read |cursor|. It should be",
        " * rare and harmless enough that we don't spend extra effort working around it.",
        " */"
      ]
    },
    {
      "file": "linux\\drivers\\firmware\\arm_scmi\\transports\\mailbox.c",
      "line": 63,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * the ownership of the channel, because the platform at first releases",
        "\t * the SMT channel and then sends the completion interrupt.",
        "\t *",
        "\t * This addresses a possible race condition in which a spurious IRQ from",
        "\t * a previous timed-out reply which arrived late could be wrongly",
        "\t * associated with the next pending transaction.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\firmware\\cirrus\\test\\cs_dsp_test_wmfw_error.c",
      "line": 464,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t/*",
        "\t * The alg name isn't stored, but cs_dsp parses the name field.",
        "\t * It should load the file successfully and create the control.",
        "\t * If FORTIFY_STRING is enabled it will detect a buffer overflow",
        "\t * if cs_dsp string length walks past end of alg name array.",
        "\t */",
        "\tKUNIT_EXPECT_EQ(test,"
      ]
    },
    {
      "file": "linux\\drivers\\firmware\\cirrus\\test\\cs_dsp_test_wmfw_error.c",
      "line": 820,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t * V1 controls do not have names, but cs_dsp parses the name",
        "\t * field. It should load the file successfully and create the",
        "\t * control.",
        "\t * If FORTIFY_STRING is enabled it will detect a buffer overflow",
        "\t * if cs_dsp string length walks past end of coeff name array.",
        "\t */",
        "\tKUNIT_EXPECT_EQ(test,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\drm_atomic.c",
      "line": 275,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * drm_atomic_state_clear - clear state object",
        " * @state: atomic state",
        " *",
        " * When the w/w mutex algorithm detects a deadlock we need to back off and drop",
        " * all locks. So someone else could sneak in and change the current modeset",
        " * configuration. Which means that all the state assembled in @state is no",
        " * longer an atomic update to the current state, but to some arbitrary earlier"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\drm_atomic.c",
      "line": 340,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * Returns:",
        " * Either the allocated state or the error code encoded into the pointer. When",
        " * the error is EDEADLK then the w/w mutex code has detected a deadlock and the",
        " * entire atomic sequence must be restarted. All other errors are fatal.",
        " */",
        "struct drm_crtc_state *"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\drm_atomic.c",
      "line": 520,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * Returns:",
        " * Either the allocated state or the error code encoded into the pointer. When",
        " * the error is EDEADLK then the w/w mutex code has detected a deadlock and the",
        " * entire atomic sequence must be restarted. All other errors are fatal.",
        " */",
        "struct drm_plane_state *"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\drm_atomic.c",
      "line": 1014,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * Returns:",
        " * The connector connected to @encoder, or an error pointer otherwise.",
        " * When the error is EDEADLK, a deadlock has been detected and the",
        " * sequence must be restarted.",
        " */",
        "struct drm_connector *"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\drm_atomic.c",
      "line": 1120,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * Returns:",
        " * Either the allocated state or the error code encoded into the pointer. When",
        " * the error is EDEADLK then the w/w mutex code has detected a deadlock and the",
        " * entire atomic sequence must be restarted. All other errors are fatal.",
        " */",
        "struct drm_connector_state *"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\drm_atomic.c",
      "line": 1229,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * Returns:",
        " * Either the allocated state or the error code encoded into the pointer. When",
        " * the error is EDEADLK then the w/w mutex code has detected a deadlock and the",
        " * entire atomic sequence must be restarted.",
        " */",
        "struct drm_bridge_state *"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\drm_atomic.c",
      "line": 1303,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * Returns:",
        " * 0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK",
        " * then the w/w mutex code has detected a deadlock and the entire atomic",
        " * sequence must be restarted. All other errors are fatal.",
        " */",
        "int"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\drm_atomic.c",
      "line": 1348,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * Returns:",
        " * 0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK",
        " * then the w/w mutex code has detected a deadlock and the entire atomic",
        " * sequence must be restarted. All other errors are fatal.",
        " */",
        "int"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\drm_atomic.c",
      "line": 1412,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * Returns:",
        " * 0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK",
        " * then the w/w mutex code has detected a deadlock and the entire atomic",
        " * sequence must be restarted. All other errors are fatal.",
        " */",
        "int"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\drm_atomic.c",
      "line": 1445,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * @state: atomic configuration to check",
        " *",
        " * Note that this function can return -EDEADLK if the driver needed to acquire",
        " * more locks but encountered a deadlock. The caller must then do the usual w/w",
        " * backoff dance and restart. All other errors are fatal.",
        " *",
        " * Returns:"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\drm_atomic.c",
      "line": 1553,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * @state: atomic configuration to check",
        " *",
        " * Note that this function can return -EDEADLK if the driver needed to acquire",
        " * more locks but encountered a deadlock. The caller must then do the usual w/w",
        " * backoff dance and restart. All other errors are fatal.",
        " *",
        " * This function will take its own reference on @state."
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\drm_atomic.c",
      "line": 1586,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * @state: atomic configuration to check",
        " *",
        " * Note that this function can return -EDEADLK if the driver needed to acquire",
        " * more locks but encountered a deadlock. The caller must then do the usual w/w",
        " * backoff dance and restart. All other errors are fatal.",
        " *",
        " * This function will take its own reference on @state."
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\drm_atomic_uapi.c",
      "line": 1344,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double free",
      "context": [
        "\t\t/*",
        "\t\t * Free the allocated event. drm_atomic_helper_setup_commit",
        "\t\t * can allocate an event too, so only free it if it's ours",
        "\t\t * to prevent a double free in drm_atomic_state_clear.",
        "\t\t */",
        "\t\tif (event && (event->base.fence || event->base.file_priv)) {",
        "\t\t\tdrm_event_cancel_free(dev, &event->base);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\drm_atomic_uapi.c",
      "line": 184,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * Returns:",
        " * 0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK",
        " * then the w/w mutex code has detected a deadlock and the entire atomic",
        " * sequence must be restarted. All other errors are fatal.",
        " */",
        "int"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\drm_atomic_uapi.c",
      "line": 270,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * Returns:",
        " * 0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK",
        " * then the w/w mutex code has detected a deadlock and the entire atomic",
        " * sequence must be restarted. All other errors are fatal.",
        " */",
        "int"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\drm_bridge.c",
      "line": 156,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *   and attach it.",
        " *",
        " * At this point, we're now certain that both the upstream driver and",
        " * the bridge driver are functional and we can't have a deadlock-like",
        " * situation when probing.",
        " */",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\drm_drv.c",
      "line": 680,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\tput_device(dev->dma_dev);",
        "\tdev->dma_dev = NULL;",
        "\tput_device(dev->dev);",
        "\t/* Prevent use-after-free in drm_managed_release when debugging is",
        "\t * enabled. Slightly awkward, but can't really be helped. */",
        "\tdev->dev = NULL;",
        "\tmutex_destroy(&dev->master_mutex);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\drm_drv.c",
      "line": 1040,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " *",
        " * NOTE: To ensure backward compatibility with existing drivers method this",
        " * function calls the &drm_driver.load method after registering the device",
        " * nodes, creating race conditions. Usage of the &drm_driver.load methods is",
        " * therefore deprecated, drivers must perform all initialization before calling",
        " * drm_dev_register().",
        " *"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\drm_edid.c",
      "line": 2475,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "",
        "\t/*",
        "\t * Do not return pointers where relying on EDID extension count would",
        "\t * lead to buffer overflow.",
        "\t */",
        "\tif (WARN_ON(edid_size(drm_edid->edid) > drm_edid->size))",
        "\t\treturn NULL;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\drm_exec.c",
      "line": 318,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        " * Prepares all GEM objects in an array, aborts on first error.",
        " * Reserves @num_fences on each GEM object after locking it.",
        " *",
        " * Returns: -EDEADLOCK on contention, -EALREADY when object is already locked,",
        " * -ENOMEM when memory allocation failed and zero for success.",
        " */",
        "int drm_exec_prepare_array(struct drm_exec *exec,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\drm_fb_helper.c",
      "line": 1846,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tinfo = fb_helper->info;",
        "\tinfo->var.pixclock = 0;",
        "",
        "\t/* Need to drop locks to avoid recursive deadlock in",
        "\t * register_framebuffer. This is ok because the only thing left to do is",
        "\t * register the fbdev emulation instance in kernel_fb_helper_list. */",
        "\tmutex_unlock(&fb_helper->lock);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\drm_framebuffer.c",
      "line": 802,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * avoid upsetting lockdep since the universal cursor code adds a",
        "\t * framebuffer while holding mutex locks.",
        "\t *",
        "\t * Note that a real deadlock between fpriv->fbs_lock and the modeset",
        "\t * locks is impossible here since no one else but this function can get",
        "\t * at it any more.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\drm_modeset_lock.c",
      "line": 35,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * As KMS moves toward more fine grained locking, and atomic ioctl where",
        " * userspace can indirectly control locking order, it becomes necessary",
        " * to use &ww_mutex and acquire-contexts to avoid deadlocks.  But because",
        " * the locking is more distributed around the driver code, we want a bit",
        " * of extra utility/tracking out of our acquire-ctx.  This is provided",
        " * by &struct drm_modeset_lock and &struct drm_modeset_acquire_ctx."
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\drm_modeset_lock.c",
      "line": 335,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "}",
        "",
        "/**",
        " * drm_modeset_backoff - deadlock avoidance backoff",
        " * @ctx: the acquire context",
        " *",
        " * If deadlock is detected (ie. drm_modeset_lock() returns -EDEADLK),"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\drm_modeset_lock.c",
      "line": 338,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * drm_modeset_backoff - deadlock avoidance backoff",
        " * @ctx: the acquire context",
        " *",
        " * If deadlock is detected (ie. drm_modeset_lock() returns -EDEADLK),",
        " * you must call this function to drop all currently held locks and",
        " * block until the contended lock becomes available.",
        " *"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\drm_modeset_lock.c",
      "line": 382,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * If @ctx is not NULL, then its ww acquire context is used and the",
        " * lock will be tracked by the context and can be released by calling",
        " * drm_modeset_drop_locks().  If -EDEADLK is returned, this means a",
        " * deadlock scenario has been detected and it is an error to attempt",
        " * to take any more locks without first calling drm_modeset_backoff().",
        " *",
        " * If the @ctx is not NULL and initialized with"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\drm_mode_config.c",
      "line": 565,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Single-threaded teardown context, so it's not required to grab the",
        "\t * fb_lock to protect against concurrent fb_list access. Contrary, it",
        "\t * would actually deadlock with the drm_framebuffer_cleanup function.",
        "\t *",
        "\t * Also, if there are any framebuffers left, that's a driver leak now,",
        "\t * so politely WARN about this."
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\drm_panic.c",
      "line": 382,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer. The text is truncated if it overflow",
      "context": [
        "}",
        "",
        "/*",
        " * Draw a text in a rectangle on a framebuffer. The text is truncated if it overflows the rectangle",
        " */",
        "static void draw_txt_rectangle(struct drm_scanout_buffer *sb,",
        "\t\t\t       const struct font_desc *font,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\drm_probe_helper.c",
      "line": 859,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * Determine if %current task is an output poll worker.  This can be used",
        " * to select distinct code paths for output polling versus other contexts.",
        " *",
        " * One use case is to avoid a deadlock between the output poll worker and",
        " * the autosuspend worker wherein the latter waits for polling to finish",
        " * upon calling drm_kms_helper_poll_disable(), while the former waits for",
        " * runtime suspend to finish upon calling pm_runtime_get_sync() in a"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\drm_syncobj.c",
      "line": 451,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\treturn -ENOENT;",
        "",
        "\t/* Waiting for userspace with locks help is illegal cause that can",
        "\t * trivial deadlock with page faults for example. Make lockdep complain",
        "\t * about it early on.",
        "\t */",
        "\tif (flags & DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT) {"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\ast\\ast_post.c",
      "line": 2037,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * If \"Fast restet\" is enabled for ARM-ICE debugger,",
        "\t\t * then WDT needs to enable, that",
        "\t\t * WDT04 is WDT#1 Reload reg.",
        "\t\t * WDT08 is WDT#1 counter restart reg to avoid system deadlock",
        "\t\t * WDT0C is WDT#1 control reg",
        "\t\t *\t[6:5]:= 01:Full chip",
        "\t\t *\t[4]:= 1:1MHz clock source"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\bridge\\tda998x_drv.c",
      "line": 1524,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double-clock",
      "context": [
        "\t}",
        "",
        "\t/*",
        "\t * Select pixel repeat depending on the double-clock flag",
        "\t * (which means we have to repeat each pixel once.)",
        "\t */",
        "\trep = mode->flags & DRM_MODE_FLAG_DBLCLK ? 1 : 0;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\bridge\\ti-sn65dsi86.c",
      "line": 317,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\tif (refclk_lut[i] == refclk_rate)",
        "\t\t\tbreak;",
        "",
        "\t/* avoid buffer overflow and \"1\" is the default rate in the datasheet. */",
        "\tif (i >= refclk_lut_size)",
        "\t\ti = 1;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\display\\drm_dp_mst_topology.c",
      "line": 3790,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * drm_atomic_helper_resume()) this function should be called beforehand with",
        " * @sync set to true. In contexts like runtime resume where the driver is not",
        " * expected to be calling drm_atomic_helper_resume(), this function should be",
        " * called with @sync set to false in order to avoid deadlocking.",
        " *",
        " * Returns: -1 if the MST topology was removed while we were suspended, 0",
        " * otherwise."
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\i915_perf.c",
      "line": 234,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "/**",
        " * DOC: OA Tail Pointer Race",
        " *",
        " * There's a HW race condition between OA unit tail pointer register updates and",
        " * writes to memory whereby the tail pointer can sometimes get ahead of what's",
        " * been written out to the OA buffer so far (in terms of what's visible to the",
        " * CPU)."
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\i915_perf.c",
      "line": 3438,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/* To ensure it's handled consistently we simply treat all reads of a",
        "\t * disabled stream as an error. In particular it might otherwise lead",
        "\t * to a deadlock for blocking file descriptors...",
        "\t */",
        "\tif (!stream->enabled || !(stream->sample_flags & SAMPLE_OA_REPORT))",
        "\t\treturn -EIO;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\i915_perf.c",
      "line": 966,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "\toastatus = intel_uncore_read(uncore, oastatus_reg);",
        "",
        "\t/*",
        "\t * We treat OABUFFER_OVERFLOW as a significant error:",
        "\t *",
        "\t * Although theoretically we could handle this more gracefully",
        "\t * sometimes, some Gens don't correctly suppress certain"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\i915_perf.c",
      "line": 976,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer, then a buffer overflow",
      "context": [
        "\t *",
        "\t * Considering how we don't currently give userspace control",
        "\t * over the OA buffer size and always configure a large 16MB",
        "\t * buffer, then a buffer overflow does anyway likely indicate",
        "\t * that something has gone quite badly wrong.",
        "\t */",
        "\tif (oastatus & GEN8_OASTATUS_OABUFFER_OVERFLOW) {"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\i915_perf.c",
      "line": 979,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "\t * buffer, then a buffer overflow does anyway likely indicate",
        "\t * that something has gone quite badly wrong.",
        "\t */",
        "\tif (oastatus & GEN8_OASTATUS_OABUFFER_OVERFLOW) {",
        "\t\tret = append_oa_status(stream, buf, count, offset,",
        "\t\t\t\t       DRM_I915_PERF_RECORD_OA_BUFFER_LOST);",
        "\t\tif (ret)"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\i915_perf.c",
      "line": 986,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t\treturn ret;",
        "",
        "\t\tdrm_dbg(&stream->perf->i915->drm,",
        "\t\t\t\"OA buffer overflow (exponent = %d): force restart\\n\",",
        "\t\t\tstream->period_exponent);",
        "",
        "\t\tstream->perf->ops.oa_disable(stream);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\i915_perf.c",
      "line": 1172,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "\t */",
        "\toastatus1 &= ~stream->perf->gen7_latched_oastatus1;",
        "",
        "\t/* We treat OABUFFER_OVERFLOW as a significant error:",
        "\t *",
        "\t * - The status can be interpreted to mean that the buffer is",
        "\t *   currently full (with a higher precedence than OA_TAKEN()"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\i915_perf.c",
      "line": 1192,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "\t *   condition, but we avoid the added driver complexity for",
        "\t *   now.",
        "\t */",
        "\tif (unlikely(oastatus1 & GEN7_OASTATUS1_OABUFFER_OVERFLOW)) {",
        "\t\tret = append_oa_status(stream, buf, count, offset,",
        "\t\t\t\t       DRM_I915_PERF_RECORD_OA_BUFFER_LOST);",
        "\t\tif (ret)"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\i915_perf.c",
      "line": 1199,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t\treturn ret;",
        "",
        "\t\tdrm_dbg(&stream->perf->i915->drm,",
        "\t\t\t\"OA buffer overflow (exponent = %d): force restart\\n\",",
        "\t\t\tstream->period_exponent);",
        "",
        "\t\tstream->perf->ops.oa_disable(stream);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\i915_request.c",
      "line": 628,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t * request has *not* yet been retired and we can safely move",
        "\t * the request into the engine->active.list where it will be",
        "\t * dropped upon retiring. (Otherwise if resubmit a *retired*",
        "\t * request, this would be a horrible use-after-free.)",
        "\t */",
        "\tif (__i915_request_is_complete(request)) {",
        "\t\tlist_del_init(&request->sched.link);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\intel_region_ttm.c",
      "line": 137,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use after free",
      "context": [
        "\t\tdrain_workqueue(mem->i915->bdev.wq);",
        "\t}",
        "",
        "\t/* If we leaked objects, Don't free the region causing use after free */",
        "\tif (ret || !man)",
        "\t\treturn ret;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\intel_runtime_pm.c",
      "line": 183,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * @rpm: the intel_runtime_pm structure",
        " *",
        " * This is the unlocked version of intel_display_power_is_enabled() and should",
        " * only be used from error capture and recovery code where deadlocks are",
        " * possible.",
        " * This function grabs a device-level runtime pm reference (mostly used for",
        " * asynchronous PM management from display code) and ensures that it is powered"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\lima\\lima_sched.c",
      "line": 435,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\t/*",
        "\t * The task might still finish while this timeout handler runs.",
        "\t * To prevent a race condition on its completion, mask all irqs",
        "\t * on the running core until the next hard reset completes.",
        "\t */",
        "\tpipe->task_mask_irq(pipe);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\logicvc\\logicvc_drm.c",
      "line": 189,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Missing non-optional clock",
      "context": [
        "\t\t\tif (PTR_ERR(clk) == -ENOENT && clocks_map[i].optional)",
        "\t\t\t\tcontinue;",
        "",
        "\t\t\tdrm_err(drm_dev, \"Missing non-optional clock %s\\n\",",
        "\t\t\t\tclocks_map[i].name);",
        "",
        "\t\t\tret = PTR_ERR(clk);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\msm\\msm_gem_submit.c",
      "line": 332,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * the LRU lock for each individual bo, while (b) avoiding holding the",
        "\t * LRU lock while calling msm_gem_pin_vma_locked() (which could trigger",
        "\t * get_pages() which could trigger reclaim.. and if we held the LRU lock",
        "\t * could trigger deadlock with the shrinker).",
        "\t */",
        "\tmutex_lock(&priv->lru.lock);",
        "\tfor (i = 0; i < submit->nr_bos; i++) {"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\msm\\msm_gem_vma.c",
      "line": 78,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * NOTE: iommu/io-pgtable can allocate pages, so we cannot hold",
        "\t * a lock across map/unmap which is also used in the job_run()",
        "\t * path, as this can cause deadlock in job_run() vs shrinker/",
        "\t * reclaim.",
        "\t *",
        "\t * Revisit this if we can come up with a scheme to pre-alloc pages"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\nouveau\\nouveau_backlight.c",
      "line": 130,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "retry:",
        "\tret = drm_modeset_lock(&dev->mode_config.connection_mutex, &ctx);",
        "\tif (ret == -EDEADLK)",
        "\t\tgoto deadlock;",
        "\telse if (ret < 0)",
        "\t\tgoto out;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\nouveau\\nouveau_backlight.c",
      "line": 140,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\tret = drm_modeset_lock(&crtc->mutex, &ctx);",
        "\tif (ret == -EDEADLK)",
        "\t\tgoto deadlock;",
        "\telse if (ret < 0)",
        "\t\tgoto out;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\nouveau\\nouveau_backlight.c",
      "line": 152,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tdrm_modeset_drop_locks(&ctx);",
        "\tdrm_modeset_acquire_fini(&ctx);",
        "\treturn ret;",
        "deadlock:",
        "\tdrm_modeset_backoff(&ctx);",
        "\tgoto retry;",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\nouveau\\nouveau_backlight.c",
      "line": 173,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "retry:",
        "\tret = drm_modeset_lock(&dev->mode_config.connection_mutex, &ctx);",
        "\tif (ret == -EDEADLK)",
        "\t\tgoto deadlock;",
        "\telse if (ret < 0)",
        "\t\tgoto out;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\nouveau\\nouveau_backlight.c",
      "line": 183,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\tret = drm_modeset_lock(&crtc->mutex, &ctx);",
        "\tif (ret == -EDEADLK)",
        "\t\tgoto deadlock;",
        "\telse if (ret < 0)",
        "\t\tgoto out;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\nouveau\\nouveau_backlight.c",
      "line": 194,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tdrm_modeset_drop_locks(&ctx);",
        "\tdrm_modeset_acquire_fini(&ctx);",
        "\treturn ret;",
        "deadlock:",
        "\tdrm_modeset_backoff(&ctx);",
        "\tgoto retry;",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\nouveau\\nouveau_connector.c",
      "line": 575,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tenum drm_connector_status conn_status = connector_status_disconnected;",
        "",
        "\t/* Outputs are only polled while runtime active, so resuming the",
        "\t * device here is unnecessary (and would deadlock upon runtime suspend",
        "\t * because it waits for polling to finish). We do however, want to",
        "\t * prevent the autosuspend timer from elapsing during this operation",
        "\t * if possible."
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\nouveau\\nouveau_drm.c",
      "line": 1243,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double-free",
      "context": [
        "\t * The device is gone, and as it currently stands all clients are",
        "\t * cleaned up in the removal codepath. In the future this may change",
        "\t * so that we can support hot-unplugging, but for now we immediately",
        "\t * return to avoid a double-free situation.",
        "\t */",
        "\tif (!drm_dev_enter(dev, &dev_index))",
        "\t\treturn;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\omapdrm\\omap_dmm_tiler.c",
      "line": 472,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * Asynchronous fill does not work reliably, as the driver does not",
        "\t * handle errors in the async code paths. The fill operation may",
        "\t * silently fail, leading to leaking DMM engines, which may eventually",
        "\t * lead to deadlock if we run out of DMM engines.",
        "\t *",
        "\t * For now, always set 'wait' so that we only use sync fills. Async",
        "\t * fills should be fixed, or alternatively we could decide to only"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\panfrost\\panfrost_gem.c",
      "line": 25,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t/*",
        "\t * Make sure the BO is no longer inserted in the shrinker list before",
        "\t * taking care of the destruction itself. If we don't do that we have a",
        "\t * race condition between this function and what's done in",
        "\t * panfrost_gem_shrinker_scan().",
        "\t */",
        "\tmutex_lock(&pfdev->shrinker_lock);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\panthor\\panthor_device.c",
      "line": 317,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "STACK_OVERFLOW",
      "context": [
        "\tPANTHOR_EXCEPTION(CS_ENDPOINT_FAULT),",
        "\tPANTHOR_EXCEPTION(CS_BUS_FAULT),",
        "\tPANTHOR_EXCEPTION(CS_INSTR_INVALID),",
        "\tPANTHOR_EXCEPTION(CS_CALL_STACK_OVERFLOW),",
        "\tPANTHOR_EXCEPTION(CS_INHERIT_FAULT),",
        "\tPANTHOR_EXCEPTION(INSTR_INVALID_PC),",
        "\tPANTHOR_EXCEPTION(INSTR_INVALID_ENC),"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\panthor\\panthor_sched.c",
      "line": 682,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/**",
        "\t * @release_work: Work used to release group resources.",
        "\t *",
        "\t * We need to postpone the group release to avoid a deadlock when",
        "\t * the last ref is released in the tick work.",
        "\t */",
        "\tstruct work_struct release_work;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\panthor\\panthor_sched.c",
      "line": 3882,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t */",
        "\tnum_groups = min_t(u32, MAX_CSGS, glb_iface->control->group_num);",
        "",
        "\t/* The FW-side scheduler might deadlock if two groups with the same",
        "\t * priority try to access a set of resources that overlaps, with part",
        "\t * of the resources being allocated to one group and the other part to",
        "\t * the other group, both groups waiting for the remaining resources to"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\radeon\\atombios_crtc.c",
      "line": 339,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DOUBLE_CLOCK",
      "context": [
        "\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)",
        "\t\tmisc |= ATOM_INTERLACE;",
        "\tif (mode->flags & DRM_MODE_FLAG_DBLCLK)",
        "\t\tmisc |= ATOM_DOUBLE_CLOCK_MODE;",
        "\tif (mode->flags & DRM_MODE_FLAG_DBLSCAN)",
        "\t\tmisc |= ATOM_H_REPLICATIONBY2 | ATOM_V_REPLICATIONBY2;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\radeon\\atombios_crtc.c",
      "line": 385,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DOUBLE_CLOCK",
      "context": [
        "\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)",
        "\t\tmisc |= ATOM_INTERLACE;",
        "\tif (mode->flags & DRM_MODE_FLAG_DBLCLK)",
        "\t\tmisc |= ATOM_DOUBLE_CLOCK_MODE;",
        "\tif (mode->flags & DRM_MODE_FLAG_DBLSCAN)",
        "\t\tmisc |= ATOM_H_REPLICATIONBY2 | ATOM_V_REPLICATIONBY2;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\radeon\\cik.c",
      "line": 7477,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        " *",
        " * Get the IH ring buffer wptr from either the register",
        " * or the writeback memory buffer (CIK).  Also check for",
        " * ring buffer overflow and deal with it.",
        " * Used by cik_irq_process().",
        " * Returns the value of the wptr.",
        " */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\radeon\\cik.c",
      "line": 7492,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "",
        "\tif (wptr & RB_OVERFLOW) {",
        "\t\twptr &= ~RB_OVERFLOW;",
        "\t\t/* When a ring buffer overflow happen start parsing interrupt",
        "\t\t * from the last not overwritten vector (wptr + 16). Hopefully",
        "\t\t * this should allow us to catchup.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\radeon\\cik.c",
      "line": 7496,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t * from the last not overwritten vector (wptr + 16). Hopefully",
        "\t\t * this should allow us to catchup.",
        "\t\t */",
        "\t\tdev_warn(rdev->dev, \"IH ring buffer overflow (0x%08X, 0x%08X, 0x%08X)\\n\",",
        "\t\t\t wptr, rdev->ih.rptr, (wptr + 16) & rdev->ih.ptr_mask);",
        "\t\trdev->ih.rptr = (wptr + 16) & rdev->ih.ptr_mask;",
        "\t\ttmp = RREG32(IH_RB_CNTL);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\radeon\\evergreen.c",
      "line": 4686,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "",
        "\tif (wptr & RB_OVERFLOW) {",
        "\t\twptr &= ~RB_OVERFLOW;",
        "\t\t/* When a ring buffer overflow happen start parsing interrupt",
        "\t\t * from the last not overwritten vector (wptr + 16). Hopefully",
        "\t\t * this should allow us to catchup.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\radeon\\evergreen.c",
      "line": 4690,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t * from the last not overwritten vector (wptr + 16). Hopefully",
        "\t\t * this should allow us to catchup.",
        "\t\t */",
        "\t\tdev_warn(rdev->dev, \"IH ring buffer overflow (0x%08X, 0x%08X, 0x%08X)\\n\",",
        "\t\t\t wptr, rdev->ih.rptr, (wptr + 16) & rdev->ih.ptr_mask);",
        "\t\trdev->ih.rptr = (wptr + 16) & rdev->ih.ptr_mask;",
        "\t\ttmp = RREG32(IH_RB_CNTL);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\radeon\\r300.c",
      "line": 325,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t\t\t   (6 << R300_MS_Y5_SHIFT) |",
        "\t\t\t   (6 << R300_MSBD1_SHIFT)));",
        "\tradeon_ring_write(ring, PACKET0(R300_GA_ENHANCE, 0));",
        "\tradeon_ring_write(ring, R300_GA_DEADLOCK_CNTL | R300_GA_FASTSYNC_CNTL);",
        "\tradeon_ring_write(ring, PACKET0(R300_GA_POLY_MODE, 0));",
        "\tradeon_ring_write(ring,",
        "\t\t\t  R300_FRONT_PTYPE_TRIANGE | R300_BACK_PTYPE_TRIANGE);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\radeon\\r420.c",
      "line": 96,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tunsigned gb_pipe_select;",
        "\tunsigned num_pipes;",
        "",
        "\t/* GA_ENHANCE workaround TCL deadlock issue */",
        "\tWREG32(R300_GA_ENHANCE, R300_GA_DEADLOCK_CNTL | R300_GA_FASTSYNC_CNTL |",
        "\t       (1 << 2) | (1 << 3));",
        "\t/* add idle wait as per freedesktop.org bug 24041 */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\radeon\\r420.c",
      "line": 97,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\tunsigned num_pipes;",
        "",
        "\t/* GA_ENHANCE workaround TCL deadlock issue */",
        "\tWREG32(R300_GA_ENHANCE, R300_GA_DEADLOCK_CNTL | R300_GA_FASTSYNC_CNTL |",
        "\t       (1 << 2) | (1 << 3));",
        "\t/* add idle wait as per freedesktop.org bug 24041 */",
        "\tif (r100_gui_wait_for_idle(rdev)) {"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\radeon\\r600.c",
      "line": 4048,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "",
        "\tif (wptr & RB_OVERFLOW) {",
        "\t\twptr &= ~RB_OVERFLOW;",
        "\t\t/* When a ring buffer overflow happen start parsing interrupt",
        "\t\t * from the last not overwritten vector (wptr + 16). Hopefully",
        "\t\t * this should allow us to catchup.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\radeon\\r600.c",
      "line": 4052,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t * from the last not overwritten vector (wptr + 16). Hopefully",
        "\t\t * this should allow us to catchup.",
        "\t\t */",
        "\t\tdev_warn(rdev->dev, \"IH ring buffer overflow (0x%08X, 0x%08X, 0x%08X)\\n\",",
        "\t\t\t wptr, rdev->ih.rptr, (wptr + 16) & rdev->ih.ptr_mask);",
        "\t\trdev->ih.rptr = (wptr + 16) & rdev->ih.ptr_mask;",
        "\t\ttmp = RREG32(IH_RB_CNTL);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\radeon\\radeon_atombios.c",
      "line": 2127,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\t\treturn state_index;",
        "\t/* last mode is usually default, array is low to high */",
        "\tfor (i = 0; i < num_modes; i++) {",
        "\t\t/* avoid memory leaks from invalid modes or unknown frev. */",
        "\t\tif (!rdev->pm.power_state[state_index].clock_info) {",
        "\t\t\trdev->pm.power_state[state_index].clock_info =",
        "\t\t\t\tkzalloc(sizeof(struct radeon_pm_clock_info),"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\radeon\\radeon_atombios.c",
      "line": 1671,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DOUBLE_CLOCK",
      "context": [
        "\t\t\tlvds->native_mode.flags |= DRM_MODE_FLAG_CSYNC;",
        "\t\tif (misc & ATOM_INTERLACE)",
        "\t\t\tlvds->native_mode.flags |= DRM_MODE_FLAG_INTERLACE;",
        "\t\tif (misc & ATOM_DOUBLE_CLOCK_MODE)",
        "\t\t\tlvds->native_mode.flags |= DRM_MODE_FLAG_DBLSCAN;",
        "",
        "\t\tlvds->native_mode.width_mm = le16_to_cpu(lvds_info->info.sLCDTiming.usImageHSize);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\radeon\\radeon_atombios.c",
      "line": 1832,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DOUBLE_CLOCK",
      "context": [
        "\t\t\tmode->flags |= DRM_MODE_FLAG_CSYNC;",
        "\t\tif (misc & ATOM_INTERLACE)",
        "\t\t\tmode->flags |= DRM_MODE_FLAG_INTERLACE;",
        "\t\tif (misc & ATOM_DOUBLE_CLOCK_MODE)",
        "\t\t\tmode->flags |= DRM_MODE_FLAG_DBLSCAN;",
        "",
        "\t\tmode->crtc_clock = mode->clock ="
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\radeon\\radeon_atombios.c",
      "line": 1876,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DOUBLE_CLOCK",
      "context": [
        "\t\t\tmode->flags |= DRM_MODE_FLAG_CSYNC;",
        "\t\tif (misc & ATOM_INTERLACE)",
        "\t\t\tmode->flags |= DRM_MODE_FLAG_INTERLACE;",
        "\t\tif (misc & ATOM_DOUBLE_CLOCK_MODE)",
        "\t\t\tmode->flags |= DRM_MODE_FLAG_DBLSCAN;",
        "",
        "\t\tmode->crtc_clock = mode->clock ="
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\radeon\\radeon_sync.c",
      "line": 136,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tif (!radeon_fence_need_sync(fence, ring))",
        "\t\t\tcontinue;",
        "",
        "\t\t/* prevent GPU deadlocks */",
        "\t\tif (!rdev->ring[i].ready) {",
        "\t\t\tdev_err(rdev->dev, \"Syncing to a disabled ring!\");",
        "\t\t\treturn -EINVAL;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\radeon\\radeon_ttm.c",
      "line": 394,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double check that we don't free",
      "context": [
        "\tenum dma_data_direction direction = write ?",
        "\t\tDMA_BIDIRECTIONAL : DMA_TO_DEVICE;",
        "",
        "\t/* double check that we don't free the table twice */",
        "\tif (!ttm->sg || !ttm->sg->sgl)",
        "\t\treturn;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\radeon\\rv515.c",
      "line": 109,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t\t\t   (6 << MS_Y5_SHIFT) |",
        "\t\t\t   (6 << MSBD1_SHIFT)));",
        "\tradeon_ring_write(ring, PACKET0(GA_ENHANCE, 0));",
        "\tradeon_ring_write(ring, GA_DEADLOCK_CNTL | GA_FASTSYNC_CNTL);",
        "\tradeon_ring_write(ring, PACKET0(GA_POLY_MODE, 0));",
        "\tradeon_ring_write(ring, FRONT_PTYPE_TRIANGE | BACK_PTYPE_TRIANGE);",
        "\tradeon_ring_write(ring, PACKET0(GA_ROUND_MODE, 0));"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\radeon\\si.c",
      "line": 6201,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "",
        "\tif (wptr & RB_OVERFLOW) {",
        "\t\twptr &= ~RB_OVERFLOW;",
        "\t\t/* When a ring buffer overflow happens, start parsing interrupts",
        "\t\t * from the last not overwritten vector (wptr + 16). Hopefully",
        "\t\t * this should allow us to catchup.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\radeon\\si.c",
      "line": 6205,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t * from the last not overwritten vector (wptr + 16). Hopefully",
        "\t\t * this should allow us to catchup.",
        "\t\t */",
        "\t\tdev_warn(rdev->dev, \"IH ring buffer overflow (0x%08X, 0x%08X, 0x%08X)\\n\",",
        "\t\t\t wptr, rdev->ih.rptr, (wptr + 16) & rdev->ih.ptr_mask);",
        "\t\trdev->ih.rptr = (wptr + 16) & rdev->ih.ptr_mask;",
        "\t\ttmp = RREG32(IH_RB_CNTL);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\rockchip\\inno_hdmi.c",
      "line": 502,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double-clock",
      "context": [
        "\tunsigned long mpixelclk, max_tolerance;",
        "\tlong rounded_refclk;",
        "",
        "\t/* No support for double-clock modes */",
        "\tif (mode->flags & DRM_MODE_FLAG_DBLCLK)",
        "\t\treturn MODE_BAD;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\scheduler\\sched_main.c",
      "line": 717,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * This turned out to be not working very well. First of all there are many",
        " * problem with the dma_fence implementation and requirements. Either the",
        " * implementation is risking deadlocks with core memory management or violating",
        " * documented implementation details of the dma_fence object.",
        " *",
        " * Drivers can still save and restore their state for recovery operations, but"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\tests\\drm_connector_test.c",
      "line": 1609,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double the mode pixel clock",
      "context": [
        "",
        "/*",
        " * Test that for a mode with the pixel repetition flag, the TMDS",
        " * character rate is indeed double the mode pixel clock.",
        " */",
        "static void drm_test_drm_hdmi_compute_mode_clock_rgb_double(struct kunit *test)",
        "{"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\ttm\\ttm_backup.c",
      "line": 81,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * Context: If called from reclaim context, the caller needs to",
        " * assert that the shrinker gfp has __GFP_FS set, to avoid",
        " * deadlocking on lock_page(). If @writeback is set to true and",
        " * called from reclaim context, the caller also needs to assert",
        " * that the shrinker gfp has __GFP_IO set, since without it,",
        " * we're not allowed to start backup IO."
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\ttm\\ttm_execbuf_util.c",
      "line": 70,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * If a buffer is reserved for another validation, the validator with",
        " * the highest validation sequence backs off and waits for that buffer",
        " * to become unreserved. This prevents deadlocks when validating multiple",
        " * buffers in different orders.",
        " */",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\vboxvideo\\vbva_base.c",
      "line": 71,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer_overflow",
      "context": [
        "\tvbva = vbva_ctx->vbva;",
        "\trecord = vbva_ctx->record;",
        "",
        "\tif (!vbva || vbva_ctx->buffer_overflow ||",
        "\t    !record || !(record->len_and_flags & VBVA_F_RECORD_PARTIAL))",
        "\t\treturn false;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\vboxvideo\\vbva_base.c",
      "line": 87,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer_overflow",
      "context": [
        "",
        "\t\tif (chunk >= available) {",
        "\t\t\tif (WARN_ON(available <= vbva->partial_write_tresh)) {",
        "\t\t\t\tvbva_ctx->buffer_overflow = true;",
        "\t\t\t\treturn false;",
        "\t\t\t}",
        "\t\t\tchunk = available - vbva->partial_write_tresh;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\vboxvideo\\vbva_base.c",
      "line": 157,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer_overflow",
      "context": [
        "void vbva_disable(struct vbva_buf_ctx *vbva_ctx, struct gen_pool *ctx,",
        "\t\t  s32 screen)",
        "{",
        "\tvbva_ctx->buffer_overflow = false;",
        "\tvbva_ctx->record = NULL;",
        "\tvbva_ctx->vbva = NULL;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\vboxvideo\\vbva_base.c",
      "line": 174,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer_overflow",
      "context": [
        "\t    !(vbva_ctx->vbva->host_flags.host_events & VBVA_F_MODE_ENABLED))",
        "\t\treturn false;",
        "",
        "\tWARN_ON(vbva_ctx->buffer_overflow || vbva_ctx->record);",
        "",
        "\tnext = (vbva_ctx->vbva->record_free_index + 1) % VBVA_MAX_RECORDS;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\vboxvideo\\vbva_base.c",
      "line": 205,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer_overflow",
      "context": [
        "\t/* Mark the record completed. */",
        "\trecord->len_and_flags &= ~VBVA_F_RECORD_PARTIAL;",
        "",
        "\tvbva_ctx->buffer_overflow = false;",
        "\tvbva_ctx->record = NULL;",
        "}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\vc4\\vc4_hdmi.c",
      "line": 2826,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t * case, our vc4_hdmi structure will be freed, but the",
        "\t * cec_adapter structure will have a dangling pointer to what",
        "\t * used to be our HDMI controller. If we get a CEC call at that",
        "\t * moment, we could end up with a use-after-free. Fortunately,",
        "\t * the CEC framework already handles this too, by calling",
        "\t * cec_is_registered() in cec_ioctl() and cec_poll().",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\vc4\\vc4_v3d.c",
      "line": 220,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer that point into the tile alloc buffer or binner overflow",
      "context": [
        " * tile binning.",
        " *",
        " * The binner has a limitation that the addresses in the tile state",
        " * buffer that point into the tile alloc buffer or binner overflow",
        " * memory only have 28 bits (256MB), and the top 4 on the bus for",
        " * tile alloc references end up coming from the tile state buffer's",
        " * address."
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\vc4\\vc4_validate.c",
      "line": 849,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "",
        "\t\tif (validated_shader->uniforms_src_size >",
        "\t\t    exec->uniforms_size) {",
        "\t\t\tDRM_DEBUG(\"Uniforms src buffer overflow\\n\");",
        "\t\t\treturn -EINVAL;",
        "\t\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\vmwgfx\\vmwgfx_binding.c",
      "line": 46,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * Note that a resource can be pointed to by bindings from multiple contexts,",
        " * Therefore we can't easily protect this data by a per context mutex",
        " * (unless we use deadlock-safe WW mutexes). So we use a global binding_mutex",
        " * to protect all binding manager data.",
        " *",
        " * Finally, any association between a context and a global resource"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\vmwgfx\\vmwgfx_cmdbuf.c",
      "line": 1267,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * For now, set the default size to VMW_CMDBUF_INLINE_SIZE to",
        "\t * prevent deadlocks from happening when vmw_cmdbuf_space_pool()",
        "\t * needs to wait for space and we block on further command",
        "\t * submissions to be able to free up space.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\vmwgfx\\vmwgfx_execbuf.c",
      "line": 574,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * @sw_context: Pointer to the software context.",
        " *",
        " * Note that since vmware's command submission currently is protected by the",
        " * cmdbuf mutex, no fancy deadlock avoidance is required for resources, since",
        " * only a single thread at once will attempt this.",
        " */",
        "static int vmw_resources_reserve(struct vmw_sw_context *sw_context)"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\vmwgfx\\vmwgfx_execbuf.c",
      "line": 4292,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tmutex_unlock(&dev_priv->cmdbuf_mutex);",
        "",
        "\t/*",
        "\t * Unreference resources outside of the cmdbuf_mutex to avoid deadlocks",
        "\t * in resource destruction paths.",
        "\t */",
        "\tvmw_validation_unref_lists(&val_ctx);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\vmwgfx\\vmwgfx_execbuf.c",
      "line": 4317,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tmutex_unlock(&dev_priv->cmdbuf_mutex);",
        "",
        "\t/*",
        "\t * Unreference resources outside of the cmdbuf_mutex to avoid deadlocks",
        "\t * in resource destruction paths.",
        "\t */",
        "\tvmw_validation_unref_lists(&val_ctx);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\vmwgfx\\vmwgfx_kms.c",
      "line": 1192,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Docs says we should take the lock before calling this function",
        "\t * but since it destroys encoders and our destructor calls",
        "\t * drm_encoder_cleanup which takes the lock we deadlock.",
        "\t */",
        "\tdrm_mode_config_cleanup(&dev_priv->drm);",
        "\tif (dev_priv->active_display_unit == vmw_du_legacy)"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\vmwgfx\\vmwgfx_validation.c",
      "line": 618,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * @ctx: The validation context.",
        " *",
        " * The hash table used for duplicate finding is an expensive resource and",
        " * may be protected by mutexes that may cause deadlocks during resource",
        " * unreferencing if held. After resource- and buffer object registering,",
        " * there is no longer any use for this hash table, so allow freeing it",
        " * either to shorten any mutex locking time, or before resources- and"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\xe\\xe_exec_queue.c",
      "line": 231,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * Normalize bind exec queue creation. Bind exec queue is tied to migration VM",
        " * for access to physical memory required for page table programming. On a",
        " * faulting devices the reserved copy engine instance must be used to avoid",
        " * deadlocking (user binds cannot get stuck behind faults as kernel binds which",
        " * resolve faults depend on user binds). On non-faulting devices any copy engine",
        " * can be used.",
        " *"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\xe\\xe_guc_capture.c",
      "line": 1384,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer in case of overflow",
      "context": [
        "",
        "\t/* Now copy the actual logs. */",
        "\tif (unlikely(new_overflow)) {",
        "\t\t/* copy the whole buffer in case of overflow */",
        "\t\tread_offset = 0;",
        "\t\twrite_offset = buffer_size;",
        "\t} else if (unlikely((read_offset > buffer_size) ||"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\xe\\xe_guc_ct.c",
      "line": 55,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\tCT_DEAD_G2H_READ,\t\t\t/* 0x0020 */",
        "\tCT_DEAD_G2H_RECV,\t\t\t/* 0x0040 */",
        "\tCT_DEAD_G2H_RELEASE,\t\t\t/* 0x0080 */",
        "\tCT_DEAD_DEADLOCK,\t\t\t/* 0x0100 */",
        "\tCT_DEAD_PROCESS_FAILED,\t\t\t/* 0x0200 */",
        "\tCT_DEAD_FAST_G2H,\t\t\t/* 0x0400 */",
        "\tCT_DEAD_PARSE_G2H_RESPONSE,\t\t/* 0x0800 */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\xe\\xe_guc_ct.c",
      "line": 913,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "",
        "broken:",
        "\txe_gt_err(gt, \"No forward process on H2G, reset required\\n\");",
        "\tCT_DEAD(ct, &ct->ctbs.h2g, DEADLOCK);",
        "",
        "\treturn -EDEADLK;",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\xe\\xe_guc_ct.c",
      "line": 1603,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * here. If we ever need something stronger than get_if_ongoing() then",
        "\t * we need to be careful with blocking the pm callbacks from getting CT",
        "\t * responses, if the worker here is blocked on those callbacks",
        "\t * completing, creating a deadlock.",
        "\t */",
        "\tongoing = xe_pm_runtime_get_if_active(ct_to_xe(ct));",
        "\tif (!ongoing && xe_pm_read_callback_task(ct_to_xe(ct)) == NULL)"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\xe\\xe_guc_log.c",
      "line": 343,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "}",
        "",
        "/**",
        " * xe_guc_check_log_buf_overflow - Check if log buffer overflowed",
        " * @log: The log object.",
        " * @type: The log buffer type",
        " * @full_cnt: The count of buffer full"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\xe\\xe_guc_log.c",
      "line": 371,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t\t/* buffer_full_cnt is a 4 bit counter */",
        "\t\t\tlog->stats[type].sampled_overflow += 16;",
        "\t\t}",
        "\t\txe_gt_notice(log_to_gt(log), \"log buffer overflow\\n\");",
        "\t}",
        "",
        "\treturn overflow;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\xe\\xe_migrate.c",
      "line": 364,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "}",
        "",
        "/*",
        " * Including the reserved copy engine is required to avoid deadlocks due to",
        " * migrate jobs servicing the faults gets stuck behind the job that faulted.",
        " */",
        "static u32 xe_migrate_usm_logical_mask(struct xe_gt *gt)"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\xe\\xe_oa.c",
      "line": 514,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "}",
        "",
        "#define OASTATUS_RELEVANT_BITS (OASTATUS_MMIO_TRG_Q_FULL | OASTATUS_COUNTER_OVERFLOW | \\",
        "\t\t\t\tOASTATUS_BUFFER_OVERFLOW | OASTATUS_REPORT_LOST)",
        "",
        "static int __xe_oa_read(struct xe_oa_stream *stream, char __user *buf,",
        "\t\t\tsize_t count, size_t *offset)"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\xe\\xe_oa.c",
      "line": 1538,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "\t/* Map from register to uapi bits */",
        "\tif (stream->oa_status & OASTATUS_REPORT_LOST)",
        "\t\tstatus.oa_status |= DRM_XE_OASTATUS_REPORT_LOST;",
        "\tif (stream->oa_status & OASTATUS_BUFFER_OVERFLOW)",
        "\t\tstatus.oa_status |= DRM_XE_OASTATUS_BUFFER_OVERFLOW;",
        "\tif (stream->oa_status & OASTATUS_COUNTER_OVERFLOW)",
        "\t\tstatus.oa_status |= DRM_XE_OASTATUS_COUNTER_OVERFLOW;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\xe\\xe_oa.c",
      "line": 1539,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "\tif (stream->oa_status & OASTATUS_REPORT_LOST)",
        "\t\tstatus.oa_status |= DRM_XE_OASTATUS_REPORT_LOST;",
        "\tif (stream->oa_status & OASTATUS_BUFFER_OVERFLOW)",
        "\t\tstatus.oa_status |= DRM_XE_OASTATUS_BUFFER_OVERFLOW;",
        "\tif (stream->oa_status & OASTATUS_COUNTER_OVERFLOW)",
        "\t\tstatus.oa_status |= DRM_XE_OASTATUS_COUNTER_OVERFLOW;",
        "\tif (stream->oa_status & OASTATUS_MMIO_TRG_Q_FULL)"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\xe\\xe_pm.c",
      "line": 451,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t *                               |      lock(A)",
        "\t * xe_pm_runtime_get()           |",
        "\t *",
        "\t * This will clearly deadlock since rpm core needs to wait for",
        "\t * xe_pm_runtime_suspend() to complete, but here we are holding lock(A)",
        "\t * on CPU0 which prevents CPU1 making forward progress.  With the",
        "\t * annotation here and in xe_pm_runtime_get() lockdep will see"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\xe\\xe_pm.c",
      "line": 560,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "}",
        "",
        "/*",
        " * For places where resume is synchronous it can be quite easy to deadlock",
        " * if we are not careful. Also in practice it might be quite timing",
        " * sensitive to ever see the 0 -> 1 transition with the callers locks",
        " * held, so deadlocks might exist but are hard for lockdep to ever see."
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\xe\\xe_pm.c",
      "line": 563,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * For places where resume is synchronous it can be quite easy to deadlock",
        " * if we are not careful. Also in practice it might be quite timing",
        " * sensitive to ever see the 0 -> 1 transition with the callers locks",
        " * held, so deadlocks might exist but are hard for lockdep to ever see.",
        " * With this in mind, help lockdep learn about the potentially scary",
        " * stuff that can happen inside the runtime_resume callback by acquiring",
        " * a dummy lock (it doesn't protect anything and gets compiled out on"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\xe\\xe_vm.c",
      "line": 1644,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * manipulated under the PXP mutex. However, the PXP mutex can be taken",
        "\t * under a user-VM lock when the PXP session is started at exec_queue",
        "\t * creation time. Those are different VMs and therefore there is no risk",
        "\t * of deadlock, but we need to tell lockdep that this is the case or it",
        "\t * will print a warning.",
        "\t */",
        "\tif (flags & XE_VM_FLAG_GSC) {"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\xen\\xen_drm_front_kms.c",
      "line": 274,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t/*",
        "\t * Send page flip request to the backend *after* we have event cached",
        "\t * above, so on page flip done event from the backend we can",
        "\t * deliver it and there is no race condition between this code and",
        "\t * event from the backend.",
        "\t * If this is not a page flip, e.g. no flip done event from the backend",
        "\t * is expected, then send now."
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\xlnx\\zynqmp_dpsub.c",
      "line": 98,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Missing audio clock",
      "context": [
        "",
        "\t/*",
        "\t * Try the live PL audio clock, and fall back to the PS clock if the",
        "\t * live PL audio clock isn't valid. Missing audio clock disables audio",
        "\t * but isn't an error.",
        "\t */",
        "\tdpsub->aud_clk = devm_clk_get(dpsub->dev, \"dp_live_audio_aclk\");"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\xlnx\\zynqmp_dpsub.c",
      "line": 113,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing clock",
      "context": [
        "\t\treturn 0;",
        "\t}",
        "",
        "\tdev_info(dpsub->dev, \"audio disabled due to missing clock\\n\");",
        "\treturn 0;",
        "}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\amdgpu_amdkfd_gpuvm.c",
      "line": 1106,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "}",
        "",
        "/* Reserving a BO and its page table BOs must happen atomically to",
        " * avoid deadlocks. Some operations update multiple VMs at once. Track",
        " * all the reservation info in a context structure. Optionally a sync",
        " * object can track VM updates.",
        " */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\amdgpu_cper.c",
      "line": 491,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer is overflow",
      "context": [
        "\tif (ring->count_dw < rec_cnt_dw)",
        "\t\tring->count_dw = 0;",
        "",
        "\t/* the buffer is overflow, adjust rptr */",
        "\tif (((wptr_old < rptr) && (rptr <= ring->wptr)) ||",
        "\t    ((ring->wptr < wptr_old) && (wptr_old < rptr)) ||",
        "\t    ((rptr <= ring->wptr) && (ring->wptr < wptr_old))) {"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\amdgpu_device.c",
      "line": 5180,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * Most of the connector probing functions try to acquire runtime pm",
        "\t\t * refs to ensure that the GPU is powered on when connector polling is",
        "\t\t * performed. Since we're calling this from a runtime PM callback,",
        "\t\t * trying to acquire rpm refs will cause us to deadlock.",
        "\t\t *",
        "\t\t * Since we're guaranteed to be holding the rpm lock, it's safe to",
        "\t\t * temporarily disable the rpm helpers so this doesn't deadlock us."
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\amdgpu_device.c",
      "line": 5183,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * trying to acquire rpm refs will cause us to deadlock.",
        "\t\t *",
        "\t\t * Since we're guaranteed to be holding the rpm lock, it's safe to",
        "\t\t * temporarily disable the rpm helpers so this doesn't deadlock us.",
        "\t\t */",
        "#ifdef CONFIG_PM",
        "\t\tdev->dev->power.disable_depth++;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\amdgpu_device.c",
      "line": 7229,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t\t/*",
        "\t\t * Wait for any gang to be assembled before switching to a",
        "\t\t * different owner or otherwise we could deadlock the",
        "\t\t * submissions.",
        "\t\t */",
        "\t\tif (!job->gang_submit) {"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\amdgpu_fence.c",
      "line": 425,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * @timestamp: the start timestamp to update.",
        " *",
        " * The function called at the time the fence and related ib is about to",
        " * resubmit to gpu in MCBP scenario. Thus we do not consider race condition",
        " * with amdgpu_fence_process to modify the same fence.",
        " */",
        "void amdgpu_fence_update_start_timestamp(struct amdgpu_ring *ring, uint32_t seq, ktime_t timestamp)"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\amdgpu_ih.c",
      "line": 167,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\twmb();",
        "\t\tWRITE_ONCE(*ih->wptr_cpu, cpu_to_le32(wptr));",
        "\t} else if (adev->irq.retry_cam_enabled) {",
        "\t\tdev_warn_once(adev->dev, \"IH soft ring buffer overflow 0x%X, 0x%X\\n\",",
        "\t\t\t      wptr, ih->rptr);",
        "\t}",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\amdgpu_ttm.c",
      "line": 847,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double check that we don't free",
      "context": [
        "\tenum dma_data_direction direction = write ?",
        "\t\tDMA_BIDIRECTIONAL : DMA_TO_DEVICE;",
        "",
        "\t/* double check that we don't free the table twice */",
        "\tif (!ttm->sg || !ttm->sg->sgl)",
        "\t\treturn;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\amdgpu_ttm.c",
      "line": 1435,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * driver (pages, VRAM, GART space). They point to resources",
        "\t * owned by someone else (e.g. pageable memory in user mode",
        "\t * or a DMABuf). They are used in a preemptible context so we",
        "\t * can guarantee no deadlocks and good QoS in case of MMU",
        "\t * notifiers or DMABuf move notifiers from the resource owner.",
        "\t */",
        "\tif (bo->resource->mem_type == AMDGPU_PL_PREEMPT)"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\amdgpu_ucode.c",
      "line": 1477,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\tr = vsnprintf(fname, sizeof(fname), fmt, ap);",
        "\tva_end(ap);",
        "\tif (r == sizeof(fname)) {",
        "\t\tdev_warn(adev->dev, \"amdgpu firmware name buffer overflow\\n\");",
        "\t\treturn -EOVERFLOW;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\atombios_crtc.c",
      "line": 226,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DOUBLE_CLOCK",
      "context": [
        "\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)",
        "\t\tmisc |= ATOM_INTERLACE;",
        "\tif (mode->flags & DRM_MODE_FLAG_DBLSCAN)",
        "\t\tmisc |= ATOM_DOUBLE_CLOCK_MODE;",
        "",
        "\targs.susModeMiscInfo.usAccess = cpu_to_le16(misc);",
        "\targs.ucCRTC = amdgpu_crtc->crtc_id;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\atombios_encoders.c",
      "line": 2019,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DOUBLE_CLOCK",
      "context": [
        "\t\t\tlvds->native_mode.flags |= DRM_MODE_FLAG_CSYNC;",
        "\t\tif (misc & ATOM_INTERLACE)",
        "\t\t\tlvds->native_mode.flags |= DRM_MODE_FLAG_INTERLACE;",
        "\t\tif (misc & ATOM_DOUBLE_CLOCK_MODE)",
        "\t\t\tlvds->native_mode.flags |= DRM_MODE_FLAG_DBLSCAN;",
        "",
        "\t\tlvds->native_mode.width_mm = le16_to_cpu(lvds_info->info.sLCDTiming.usImageHSize);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\cik_ih.c",
      "line": 184,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        " *",
        " * Get the IH ring buffer wptr from either the register",
        " * or the writeback memory buffer (CIK).  Also check for",
        " * ring buffer overflow and deal with it.",
        " * Used by cik_irq_process().",
        " * Returns the value of the wptr.",
        " */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\cik_ih.c",
      "line": 197,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "",
        "\tif (wptr & IH_RB_WPTR__RB_OVERFLOW_MASK) {",
        "\t\twptr &= ~IH_RB_WPTR__RB_OVERFLOW_MASK;",
        "\t\t/* When a ring buffer overflow happen start parsing interrupt",
        "\t\t * from the last not overwritten vector (wptr + 16). Hopefully",
        "\t\t * this should allow us to catchup.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\cik_ih.c",
      "line": 201,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t * from the last not overwritten vector (wptr + 16). Hopefully",
        "\t\t * this should allow us to catchup.",
        "\t\t */",
        "\t\tdev_warn(adev->dev, \"IH ring buffer overflow (0x%08X, 0x%08X, 0x%08X)\\n\",",
        "\t\t\t wptr, ih->rptr, (wptr + 16) & ih->ptr_mask);",
        "\t\tih->rptr = (wptr + 16) & ih->ptr_mask;",
        "\t\ttmp = RREG32(mmIH_RB_CNTL);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\cz_ih.c",
      "line": 186,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        " *",
        " * Get the IH ring buffer wptr from either the register",
        " * or the writeback memory buffer (VI).  Also check for",
        " * ring buffer overflow and deal with it.",
        " * Used by cz_irq_process(VI).",
        " * Returns the value of the wptr.",
        " */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\cz_ih.c",
      "line": 208,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "",
        "\twptr = REG_SET_FIELD(wptr, IH_RB_WPTR, RB_OVERFLOW, 0);",
        "",
        "\t/* When a ring buffer overflow happen start parsing interrupt",
        "\t * from the last not overwritten vector (wptr + 16). Hopefully",
        "\t * this should allow us to catchup.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\cz_ih.c",
      "line": 212,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t * from the last not overwritten vector (wptr + 16). Hopefully",
        "\t * this should allow us to catchup.",
        "\t */",
        "\tdev_warn(adev->dev, \"IH ring buffer overflow (0x%08X, 0x%08X, 0x%08X)\\n\",",
        "\t\twptr, ih->rptr, (wptr + 16) & ih->ptr_mask);",
        "\tih->rptr = (wptr + 16) & ih->ptr_mask;",
        "\ttmp = RREG32(mmIH_RB_CNTL);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\gfx_v11_0.c",
      "line": 5880,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tu32 control = INDIRECT_BUFFER_VALID | ib->length_dw | (vmid << 24);",
        "",
        "\t/* Currently, there is a high possibility to get wave ID mismatch",
        "\t * between ME and GDS, leading to a hw deadlock, because ME generates",
        "\t * different wave IDs than the GDS expects. This situation happens",
        "\t * randomly when at least 5 compute pipes use GDS ordered append.",
        "\t * The wave IDs generated by ME are also wrong after suspend/resume."
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\gfx_v10_0.c",
      "line": 8685,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tu32 control = INDIRECT_BUFFER_VALID | ib->length_dw | (vmid << 24);",
        "",
        "\t/* Currently, there is a high possibility to get wave ID mismatch",
        "\t * between ME and GDS, leading to a hw deadlock, because ME generates",
        "\t * different wave IDs than the GDS expects. This situation happens",
        "\t * randomly when at least 5 compute pipes use GDS ordered append.",
        "\t * The wave IDs generated by ME are also wrong after suspend/resume."
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\gfx_v8_0.c",
      "line": 6079,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tu32 control = INDIRECT_BUFFER_VALID | ib->length_dw | (vmid << 24);",
        "",
        "\t/* Currently, there is a high possibility to get wave ID mismatch",
        "\t * between ME and GDS, leading to a hw deadlock, because ME generates",
        "\t * different wave IDs than the GDS expects. This situation happens",
        "\t * randomly when at least 5 compute pipes use GDS ordered append.",
        "\t * The wave IDs generated by ME are also wrong after suspend/resume."
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\gfx_v7_0.c",
      "line": 2244,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tu32 control = INDIRECT_BUFFER_VALID | ib->length_dw | (vmid << 24);",
        "",
        "\t/* Currently, there is a high possibility to get wave ID mismatch",
        "\t * between ME and GDS, leading to a hw deadlock, because ME generates",
        "\t * different wave IDs than the GDS expects. This situation happens",
        "\t * randomly when at least 5 compute pipes use GDS ordered append.",
        "\t * The wave IDs generated by ME are also wrong after suspend/resume."
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\gfx_v9_0.c",
      "line": 5515,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tu32 control = INDIRECT_BUFFER_VALID | ib->length_dw | (vmid << 24);",
        "",
        "\t/* Currently, there is a high possibility to get wave ID mismatch",
        "\t * between ME and GDS, leading to a hw deadlock, because ME generates",
        "\t * different wave IDs than the GDS expects. This situation happens",
        "\t * randomly when at least 5 compute pipes use GDS ordered append.",
        "\t * The wave IDs generated by ME are also wrong after suspend/resume."
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\gfx_v9_4_3.c",
      "line": 2852,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tu32 control = INDIRECT_BUFFER_VALID | ib->length_dw | (vmid << 24);",
        "",
        "\t/* Currently, there is a high possibility to get wave ID mismatch",
        "\t * between ME and GDS, leading to a hw deadlock, because ME generates",
        "\t * different wave IDs than the GDS expects. This situation happens",
        "\t * randomly when at least 5 compute pipes use GDS ordered append.",
        "\t * The wave IDs generated by ME are also wrong after suspend/resume."
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\gmc_v9_0.c",
      "line": 2406,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tadev->gmc.flush_pasid_uses_kiq = true;",
        "",
        "\t/* Vega20+XGMI caches PTEs in TC and TLB. Add a heavy-weight TLB flush",
        "\t * (type 2), which flushes both. Due to a race condition with",
        "\t * concurrent memory accesses using the same TLB cache line, we still",
        "\t * need a second TLB flush after this.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\ih_v6_0.c",
      "line": 432,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        " *",
        " * Get the IH ring buffer wptr from either the register",
        " * or the writeback memory buffer.  Also check for",
        " * ring buffer overflow and deal with it.",
        " * Returns the value of the wptr.",
        " */",
        "static u32 ih_v6_0_get_wptr(struct amdgpu_device *adev,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\ih_v6_0.c",
      "line": 455,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\telse",
        "\t\tih->overflow = true;",
        "",
        "\t/* When a ring buffer overflow happen start parsing interrupt",
        "\t * from the last not overwritten vector (wptr + 32). Hopefully",
        "\t * this should allow us to catch up.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\ih_v6_0.c",
      "line": 460,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t * this should allow us to catch up.",
        "\t */",
        "\ttmp = (wptr + 32) & ih->ptr_mask;",
        "\tdev_warn(adev->dev, \"IH ring buffer overflow \"",
        "\t\t \"(0x%08X, 0x%08X, 0x%08X)\\n\",",
        "\t\t wptr, ih->rptr, tmp);",
        "\tih->rptr = tmp;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\iceland_ih.c",
      "line": 186,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        " *",
        " * Get the IH ring buffer wptr from either the register",
        " * or the writeback memory buffer (VI).  Also check for",
        " * ring buffer overflow and deal with it.",
        " * Used by cz_irq_process(VI).",
        " * Returns the value of the wptr.",
        " */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\iceland_ih.c",
      "line": 207,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\tgoto out;",
        "",
        "\twptr = REG_SET_FIELD(wptr, IH_RB_WPTR, RB_OVERFLOW, 0);",
        "\t/* When a ring buffer overflow happen start parsing interrupt",
        "\t * from the last not overwritten vector (wptr + 16). Hopefully",
        "\t * this should allow us to catchup.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\iceland_ih.c",
      "line": 211,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t * from the last not overwritten vector (wptr + 16). Hopefully",
        "\t * this should allow us to catchup.",
        "\t */",
        "\tdev_warn(adev->dev, \"IH ring buffer overflow (0x%08X, 0x%08X, 0x%08X)\\n\",",
        "\t\twptr, ih->rptr, (wptr + 16) & ih->ptr_mask);",
        "\tih->rptr = (wptr + 16) & ih->ptr_mask;",
        "\ttmp = RREG32(mmIH_RB_CNTL);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\ih_v7_0.c",
      "line": 403,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        " *",
        " * Get the IH ring buffer wptr from either the register",
        " * or the writeback memory buffer.  Also check for",
        " * ring buffer overflow and deal with it.",
        " * Returns the value of the wptr.",
        " */",
        "static u32 ih_v7_0_get_wptr(struct amdgpu_device *adev,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\ih_v7_0.c",
      "line": 423,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\tgoto out;",
        "\twptr = REG_SET_FIELD(wptr, IH_RB_WPTR, RB_OVERFLOW, 0);",
        "",
        "\t/* When a ring buffer overflow happen start parsing interrupt",
        "\t * from the last not overwritten vector (wptr + 32). Hopefully",
        "\t * this should allow us to catch up.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\ih_v7_0.c",
      "line": 428,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t * this should allow us to catch up.",
        "\t */",
        "\ttmp = (wptr + 32) & ih->ptr_mask;",
        "\tdev_warn(adev->dev, \"IH ring buffer overflow \"",
        "\t\t \"(0x%08X, 0x%08X, 0x%08X)\\n\",",
        "\t\t wptr, ih->rptr, tmp);",
        "\tih->rptr = tmp;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\ih_v6_1.c",
      "line": 403,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        " *",
        " * Get the IH ring buffer wptr from either the register",
        " * or the writeback memory buffer.  Also check for",
        " * ring buffer overflow and deal with it.",
        " * Returns the value of the wptr.",
        " */",
        "static u32 ih_v6_1_get_wptr(struct amdgpu_device *adev,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\ih_v6_1.c",
      "line": 423,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\tgoto out;",
        "\twptr = REG_SET_FIELD(wptr, IH_RB_WPTR, RB_OVERFLOW, 0);",
        "",
        "\t/* When a ring buffer overflow happen start parsing interrupt",
        "\t * from the last not overwritten vector (wptr + 32). Hopefully",
        "\t * this should allow us to catch up.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\ih_v6_1.c",
      "line": 428,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t * this should allow us to catch up.",
        "\t */",
        "\ttmp = (wptr + 32) & ih->ptr_mask;",
        "\tdev_warn(adev->dev, \"IH ring buffer overflow \"",
        "\t\t \"(0x%08X, 0x%08X, 0x%08X)\\n\",",
        "\t\t wptr, ih->rptr, tmp);",
        "\tih->rptr = tmp;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\navi10_ih.c",
      "line": 403,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        " *",
        " * Get the IH ring buffer wptr from either the register",
        " * or the writeback memory buffer (NAVI10).  Also check for",
        " * ring buffer overflow and deal with it.",
        " * Returns the value of the wptr.",
        " */",
        "static u32 navi10_ih_get_wptr(struct amdgpu_device *adev,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\navi10_ih.c",
      "line": 432,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\tgoto out;",
        "\twptr = REG_SET_FIELD(wptr, IH_RB_WPTR, RB_OVERFLOW, 0);",
        "",
        "\t/* When a ring buffer overflow happen start parsing interrupt",
        "\t * from the last not overwritten vector (wptr + 32). Hopefully",
        "\t * this should allow us to catch up.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\navi10_ih.c",
      "line": 437,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t * this should allow us to catch up.",
        "\t */",
        "\ttmp = (wptr + 32) & ih->ptr_mask;",
        "\tdev_warn(adev->dev, \"%s ring buffer overflow (0x%08X, 0x%08X, 0x%08X)\\n\",",
        "\t\t amdgpu_ih_ring_name(adev, ih), wptr, ih->rptr, tmp);",
        "\tih->rptr = tmp;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\si_ih.c",
      "line": 117,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "",
        "\tif (wptr & IH_RB_WPTR__RB_OVERFLOW_MASK) {",
        "\t\twptr &= ~IH_RB_WPTR__RB_OVERFLOW_MASK;",
        "\t\tdev_warn(adev->dev, \"IH ring buffer overflow (0x%08X, 0x%08X, 0x%08X)\\n\",",
        "\t\t\twptr, ih->rptr, (wptr + 16) & ih->ptr_mask);",
        "\t\tih->rptr = (wptr + 16) & ih->ptr_mask;",
        "\t\ttmp = RREG32(IH_RB_CNTL);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\tonga_ih.c",
      "line": 188,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        " *",
        " * Get the IH ring buffer wptr from either the register",
        " * or the writeback memory buffer (VI).  Also check for",
        " * ring buffer overflow and deal with it.",
        " * Used by cz_irq_process(VI).",
        " * Returns the value of the wptr.",
        " */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\tonga_ih.c",
      "line": 210,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "",
        "\twptr = REG_SET_FIELD(wptr, IH_RB_WPTR, RB_OVERFLOW, 0);",
        "",
        "\t/* When a ring buffer overflow happen start parsing interrupt",
        "\t * from the last not overwritten vector (wptr + 16). Hopefully",
        "\t * this should allow us to catchup.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\tonga_ih.c",
      "line": 215,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t * this should allow us to catchup.",
        "\t */",
        "",
        "\tdev_warn(adev->dev, \"IH ring buffer overflow (0x%08X, 0x%08X, 0x%08X)\\n\",",
        "\t\twptr, ih->rptr, (wptr + 16) & ih->ptr_mask);",
        "\tih->rptr = (wptr + 16) & ih->ptr_mask;",
        "\ttmp = RREG32(mmIH_RB_CNTL);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v1_0.c",
      "line": 1013,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tjpeg_v1_0_start(adev, 0);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(UVD, 0, mmUVD_STATUS);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v1_0.c",
      "line": 1163,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tjpeg_v1_0_start(adev, 1);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(UVD, 0, mmUVD_STATUS);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v1_0.c",
      "line": 1231,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tvcn_1_0_enable_static_power_gating(vinst);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(UVD, 0, mmUVD_STATUS);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v1_0.c",
      "line": 1270,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t\t~UVD_POWER_STATUS__UVD_PG_MODE_MASK);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(UVD, 0, mmUVD_STATUS);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v2_0.c",
      "line": 983,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t0, ~UVD_POWER_STATUS__STALL_DPG_POWER_UP_MASK);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(UVD, 0, mmUVD_STATUS);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v2_0.c",
      "line": 1162,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tfw_shared->multi_queue.encode_lowlatency_queue_mode &= ~FW_QUEUE_RING_RESET;",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(UVD, 0, mmUVD_STATUS);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v2_0.c",
      "line": 1198,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t\t~UVD_POWER_STATUS__UVD_PG_MODE_MASK);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(UVD, 0, mmUVD_STATUS);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v2_0.c",
      "line": 1268,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tvcn_v2_0_enable_static_power_gating(vinst);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(VCN, 0, mmUVD_STATUS);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v2_5.c",
      "line": 1162,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t0, ~UVD_POWER_STATUS__STALL_DPG_POWER_UP_MASK);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(VCN, inst_idx, mmUVD_STATUS);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v2_5.c",
      "line": 1352,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tfw_shared->multi_queue.encode_lowlatency_queue_mode &= ~FW_QUEUE_RING_RESET;",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(VCN, i, mmUVD_STATUS);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v2_5.c",
      "line": 1583,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t\t~UVD_POWER_STATUS__UVD_PG_MODE_MASK);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(VCN, inst_idx, mmUVD_STATUS);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v2_5.c",
      "line": 1654,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t ~UVD_POWER_STATUS__UVD_POWER_STATUS_MASK);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(VCN, i, mmUVD_STATUS);",
        "done:"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v3_0.c",
      "line": 1177,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t0, ~UVD_POWER_STATUS__STALL_DPG_POWER_UP_MASK);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(VCN, inst_idx, mmUVD_STATUS);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v3_0.c",
      "line": 1369,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t}",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(VCN, i, mmUVD_STATUS);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v3_0.c",
      "line": 1616,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t~UVD_POWER_STATUS__UVD_PG_MODE_MASK);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(VCN, inst_idx, mmUVD_STATUS);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v3_0.c",
      "line": 1693,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tvcn_v3_0_enable_static_power_gating(vinst);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(VCN, i, mmUVD_STATUS);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0.c",
      "line": 1126,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t\tVCN_RB1_DB_CTRL__EN_MASK);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(VCN, inst_idx, regUVD_STATUS);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0.c",
      "line": 1312,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tfw_shared->sq.queue_mode &= ~(FW_QUEUE_RING_RESET | FW_QUEUE_DPG_HOLD_OFF);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(VCN, i, regUVD_STATUS);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0.c",
      "line": 1598,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t~UVD_POWER_STATUS__UVD_PG_MODE_MASK);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(VCN, inst_idx, regUVD_STATUS);",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0.c",
      "line": 1685,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tvcn_v4_0_enable_static_power_gating(vinst);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(VCN, i, regUVD_STATUS);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0_5.c",
      "line": 1038,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t\tVCN_RB1_DB_CTRL__EN_MASK);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done, otherwise",
        "\t * it may introduce race conditions */",
        "\tRREG32_SOC15(VCN, inst_idx, regVCN_RB1_DB_CTRL);",
        "",
        "\treturn 0;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0_5.c",
      "line": 1224,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tfw_shared->sq.queue_mode &= ~(FW_QUEUE_RING_RESET | FW_QUEUE_DPG_HOLD_OFF);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done, otherwise",
        "\t * it may introduce race conditions */",
        "\tRREG32_SOC15(VCN, i, regVCN_RB_ENABLE);",
        "",
        "\treturn 0;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0_5.c",
      "line": 1259,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t~UVD_POWER_STATUS__UVD_PG_MODE_MASK);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(VCN, inst_idx, regUVD_STATUS);",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0_5.c",
      "line": 1346,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tvcn_v4_0_5_enable_static_power_gating(vinst);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(VCN, i, regUVD_STATUS);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0_3.c",
      "line": 981,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tfw_shared->sq.queue_mode &= cpu_to_le32(~FW_QUEUE_RING_RESET);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(VCN, vcn_inst, regUVD_STATUS);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0_3.c",
      "line": 1380,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t ~UVD_POWER_STATUS__UVD_PG_MODE_MASK);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(VCN, vcn_inst, regUVD_STATUS);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0_3.c",
      "line": 1468,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tvcn_v4_0_3_enable_clock_gating(vinst);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(VCN, vcn_inst, regUVD_STATUS);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v5_0_1.c",
      "line": 1046,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tfw_shared->sq.queue_mode &= ~(FW_QUEUE_RING_RESET | FW_QUEUE_DPG_HOLD_OFF);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(VCN, vcn_inst, regUVD_STATUS);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v5_0_1.c",
      "line": 1086,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t~UVD_POWER_STATUS__UVD_PG_MODE_MASK);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(VCN, vcn_inst, regUVD_STATUS);",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v5_0_1.c",
      "line": 1165,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tWREG32_SOC15(VCN, vcn_inst, regUVD_STATUS, 0);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(VCN, vcn_inst, regUVD_STATUS);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vega10_ih.c",
      "line": 332,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        " *",
        " * Get the IH ring buffer wptr from either the register",
        " * or the writeback memory buffer (VEGA10).  Also check for",
        " * ring buffer overflow and deal with it.",
        " * Returns the value of the wptr.",
        " */",
        "static u32 vega10_ih_get_wptr(struct amdgpu_device *adev,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vega10_ih.c",
      "line": 362,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "",
        "\twptr = REG_SET_FIELD(wptr, IH_RB_WPTR, RB_OVERFLOW, 0);",
        "",
        "\t/* When a ring buffer overflow happen start parsing interrupt",
        "\t * from the last not overwritten vector (wptr + 32). Hopefully",
        "\t * this should allow us to catchup.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vega10_ih.c",
      "line": 367,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t * this should allow us to catchup.",
        "\t */",
        "\ttmp = (wptr + 32) & ih->ptr_mask;",
        "\tdev_warn_ratelimited(adev->dev, \"%s ring buffer overflow (0x%08X, 0x%08X, 0x%08X)\\n\",",
        "\t\t\t     amdgpu_ih_ring_name(adev, ih), wptr, ih->rptr, tmp);",
        "\tih->rptr = tmp;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v5_0_0.c",
      "line": 798,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\tVCN_RB1_DB_CTRL__EN_MASK);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(VCN, inst_idx, regUVD_STATUS);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v5_0_0.c",
      "line": 955,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tfw_shared->sq.queue_mode &= ~(FW_QUEUE_RING_RESET | FW_QUEUE_DPG_HOLD_OFF);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(VCN, i, regUVD_STATUS);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v5_0_0.c",
      "line": 991,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t~UVD_POWER_STATUS__UVD_PG_MODE_MASK);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(VCN, inst_idx, regUVD_STATUS);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v5_0_0.c",
      "line": 1077,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tvcn_v5_0_0_enable_static_power_gating(vinst);",
        "",
        "\t/* Keeping one read-back to ensure all register writes are done,",
        "\t * otherwise it may introduce race conditions.",
        "\t */",
        "\tRREG32_SOC15(VCN, i, regUVD_STATUS);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vega20_ih.c",
      "line": 413,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        " *",
        " * Get the IH ring buffer wptr from either the register",
        " * or the writeback memory buffer (VEGA20).  Also check for",
        " * ring buffer overflow and deal with it.",
        " * Returns the value of the wptr.",
        " */",
        "static u32 vega20_ih_get_wptr(struct amdgpu_device *adev,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vega20_ih.c",
      "line": 446,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\telse",
        "\t\tih->overflow = true;",
        "",
        "\t/* When a ring buffer overflow happen start parsing interrupt",
        "\t * from the last not overwritten vector (wptr + 32). Hopefully",
        "\t * this should allow us to catchup.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vega20_ih.c",
      "line": 451,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t * this should allow us to catchup.",
        "\t */",
        "\ttmp = (wptr + 32) & ih->ptr_mask;",
        "\tdev_warn_ratelimited(adev->dev, \"%s ring buffer overflow (0x%08X, 0x%08X, 0x%08X)\\n\",",
        "\t\t\t     amdgpu_ih_ring_name(adev, ih), wptr, ih->rptr, tmp);",
        "\tih->rptr = tmp;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdkfd\\kfd_events.c",
      "line": 1024,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t * case schedule_timeout will not put the task to",
        "\t\t * sleep and we'll get a chance to re-check the",
        "\t\t * updated conditions almost immediately. Otherwise,",
        "\t\t * this race condition would lead to a soft hang or a",
        "\t\t * very long sleep.",
        "\t\t */",
        "\t\tset_current_state(TASK_INTERRUPTIBLE);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdkfd\\kfd_process.c",
      "line": 1315,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double free",
      "context": [
        "\t * Move all remaining kfd_process from the process table to a",
        "\t * temp list for processing.   Once done, callback from mmu_notifier",
        "\t * release will not see the kfd_process in the table and do early return,",
        "\t * avoiding double free issues.",
        "\t */",
        "\tmutex_lock(&kfd_processes_mutex);",
        "\thash_for_each_safe(kfd_processes_table, temp, p_temp, p, kfd_processes) {"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdkfd\\kfd_process.c",
      "line": 1301,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "/*",
        " * This code handles the case when driver is being unloaded before all",
        " * mm_struct are released.  We need to safely free the kfd_process and",
        " * avoid race conditions with mmu_notifier that might try to free them.",
        " *",
        " */",
        "void kfd_cleanup_processes(void)"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdkfd\\kfd_process.c",
      "line": 1487,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t/* GFXv10 and later GPUs do not support shader preemption",
        "\t\t * during page faults. This can lead to poor QoS for queue",
        "\t\t * management and memory-manager-related preemptions or",
        "\t\t * even deadlocks.",
        "\t\t */",
        "\t\tif (KFD_GC_VERSION(dev) >= IP_VERSION(10, 1, 1))",
        "\t\t\treturn false;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdkfd\\kfd_svm.c",
      "line": 2346,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use use after free",
      "context": [
        "\t\t/* Remove from deferred_list must be inside mmap write lock, for",
        "\t\t * two race cases:",
        "\t\t * 1. unmap_from_cpu may change work_item.op and add the range",
        "\t\t *    to deferred_list again, cause use after free bug.",
        "\t\t * 2. svm_range_list_lock_and_flush_work may hold mmap write",
        "\t\t *    lock and continue because deferred_list is empty, but",
        "\t\t *    deferred_list work is actually waiting for mmap lock."
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdkfd\\kfd_svm.c",
      "line": 3776,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t/* Flush pending deferred work to avoid racing with deferred actions from",
        "\t * previous memory map changes (e.g. munmap). Concurrent memory map changes",
        "\t * can still race with get_attr because we don't hold the mmap lock. But that",
        "\t * would be a race condition in the application anyway, and undefined",
        "\t * behaviour is acceptable in that case.",
        "\t */",
        "\tflush_work(&p->svms.deferred_list_work);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\amdkfd\\kfd_svm.c",
      "line": 1597,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * To prevent concurrent destruction or change of range attributes, the",
        " * svm_read_lock must be held. The caller must not hold the svm_write_lock",
        " * because that would block concurrent evictions and lead to deadlocks. To",
        " * serialize concurrent migrations or validations of the same range, the",
        " * prange->migrate_mutex must be held.",
        " *"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\amdgpu_dm\\amdgpu_dm.c",
      "line": 12176,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t\t * Furthermore, since the DM atomic state only contains the DC",
        "\t\t * context and can safely be annulled, we can free the state",
        "\t\t * and clear the associated private object now to free",
        "\t\t * some memory and avoid a possible use-after-free later.",
        "\t\t */",
        "",
        "\t\tfor (i = 0; i < state->num_private_objs; i++) {"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\amdgpu_dm\\amdgpu_dm.c",
      "line": 697,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * pending pageflip events from here if a flip is still pending.",
        "\t *",
        "\t * If any planes are enabled, use dm_pflip_high_irq() instead, to",
        "\t * avoid race conditions between flip programming and completion,",
        "\t * which could cause too early flip completion events.",
        "\t */",
        "\tif (adev->family >= AMDGPU_FAMILY_RV &&"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\amdgpu_dm\\amdgpu_dm.c",
      "line": 12239,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "fail:",
        "\tif (ret == -EDEADLK)",
        "\t\tdrm_dbg_atomic(dev, \"Atomic check stopped to avoid deadlock.\\n\");",
        "\telse if (ret == -EINTR || ret == -EAGAIN || ret == -ERESTARTSYS)",
        "\t\tdrm_dbg_atomic(dev, \"Atomic check stopped due to signal.\\n\");",
        "\telse"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\bios\\bios_parser.c",
      "line": 1294,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DOUBLE_CLOCK",
      "context": [
        "\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.CompositeSync;",
        "\tinfo->lcd_timing.misc_info.INTERLACE =",
        "\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.Interlace;",
        "\tinfo->lcd_timing.misc_info.DOUBLE_CLOCK =",
        "\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.DoubleClock;",
        "\tinfo->ss_id = lvds->ucSS_Id;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\bios\\bios_parser.c",
      "line": 1295,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DoubleClock",
      "context": [
        "\tinfo->lcd_timing.misc_info.INTERLACE =",
        "\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.Interlace;",
        "\tinfo->lcd_timing.misc_info.DOUBLE_CLOCK =",
        "\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.DoubleClock;",
        "\tinfo->ss_id = lvds->ucSS_Id;",
        "",
        "\t{"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\bios\\bios_parser.c",
      "line": 1319,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DOUBLE_CLOCK",
      "context": [
        "\t\tinfo->drr_enabled = 1;",
        "",
        "\tif (ATOM_PANEL_MISC_DUAL & lvds->ucLVDS_Misc)",
        "\t\tinfo->lcd_timing.misc_info.DOUBLE_CLOCK = true;",
        "",
        "\tif (ATOM_PANEL_MISC_888RGB & lvds->ucLVDS_Misc)",
        "\t\tinfo->lcd_timing.misc_info.RGB888 = true;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\bios\\bios_parser.c",
      "line": 1412,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DOUBLE_CLOCK",
      "context": [
        "\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.CompositeSync;",
        "\tinfo->lcd_timing.misc_info.INTERLACE =",
        "\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.Interlace;",
        "\tinfo->lcd_timing.misc_info.DOUBLE_CLOCK =",
        "\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.DoubleClock;",
        "\tinfo->ss_id = lvds->ucSS_Id;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\bios\\bios_parser.c",
      "line": 1413,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DoubleClock",
      "context": [
        "\tinfo->lcd_timing.misc_info.INTERLACE =",
        "\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.Interlace;",
        "\tinfo->lcd_timing.misc_info.DOUBLE_CLOCK =",
        "\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.DoubleClock;",
        "\tinfo->ss_id = lvds->ucSS_Id;",
        "",
        "\t/* Drr panel support can be reported by VBIOS*/"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\bios\\bios_parser.c",
      "line": 1453,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DOUBLE_CLOCK",
      "context": [
        "\t}",
        "",
        "\tif (ATOM_PANEL_MISC_V13_DUAL & lvds->ucLCD_Misc)",
        "\t\tinfo->lcd_timing.misc_info.DOUBLE_CLOCK = true;",
        "",
        "\tif (ATOM_PANEL_MISC_V13_8BIT_PER_COLOR & lvds->ucLCD_Misc)",
        "\t\tinfo->lcd_timing.misc_info.RGB888 = true;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\bios\\bios_parser2.c",
      "line": 1500,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DOUBLE_CLOCK",
      "context": [
        "\tinfo->lcd_timing.misc_info.INTERLACE = !!(lvds->lcd_timing.miscinfo & ATOM_INTERLACE);",
        "",
        "\t/* not provided by VBIOS*/",
        "\tinfo->lcd_timing.misc_info.DOUBLE_CLOCK = 0;",
        "\t/* not provided by VBIOS*/",
        "\tinfo->ss_id = 0;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\bios\\command_table.c",
      "line": 1888,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DOUBLE_CLOCK",
      "context": [
        "",
        "\tif (bp_params->flags.HORZ_COUNT_BY_TWO)",
        "\t\tparams.susModeMiscInfo.usAccess =",
        "\t\t\t\tcpu_to_le16(le16_to_cpu(params.susModeMiscInfo.usAccess) | ATOM_DOUBLE_CLOCK_MODE);",
        "",
        "\tif (EXEC_BIOS_CMD_TABLE(SetCRTC_Timing, params))",
        "\t\tresult = BP_RESULT_OK;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\bios\\command_table.c",
      "line": 1969,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DOUBLE_CLOCK",
      "context": [
        "",
        "\tif (bp_params->flags.HORZ_COUNT_BY_TWO)",
        "\t\tparams.susModeMiscInfo.usAccess =",
        "\t\t\t\tcpu_to_le16(le16_to_cpu(params.susModeMiscInfo.usAccess) | ATOM_DOUBLE_CLOCK_MODE);",
        "",
        "\tif (EXEC_BIOS_CMD_TABLE(SetCRTC_UsingDTDTiming, params))",
        "\t\tresult = BP_RESULT_OK;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\bios\\command_table2.c",
      "line": 687,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DOUBLE_CLOCK",
      "context": [
        "\tif (bp_params->flags.HORZ_COUNT_BY_TWO)",
        "\t\tparams.modemiscinfo =",
        "\t\t\tcpu_to_le16(le16_to_cpu(params.modemiscinfo) |",
        "\t\t\t\t\t0x100); /* ATOM_DOUBLE_CLOCK_MODE */",
        "",
        "\tif (EXEC_BIOS_CMD_TABLE(setcrtc_usingdtdtiming, params))",
        "\t\tresult = BP_RESULT_OK;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\display_mode_vba.c",
      "line": 1119,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "",
        "double CalculateWriteBackDISPCLK(",
        "\t\tenum source_format_class WritebackPixelFormat,",
        "\t\tdouble PixelClock,",
        "\t\tdouble WritebackHRatio,",
        "\t\tdouble WritebackVRatio,",
        "\t\tunsigned int WritebackLumaHTaps,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\display_mode_vba.c",
      "line": 1130,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double CalculateWriteBackDISPCLK = 1.01 * PixelClock",
      "context": [
        "\t\tunsigned int HTotal,",
        "\t\tunsigned int WritebackChromaLineBufferWidth)",
        "{",
        "\tdouble CalculateWriteBackDISPCLK = 1.01 * PixelClock * dml_max(",
        "\t\tdml_ceil(WritebackLumaHTaps / 4.0, 1) / WritebackHRatio,",
        "\t\tdml_max((WritebackLumaVTaps * dml_ceil(1.0 / WritebackVRatio, 1) * dml_ceil(WritebackDestinationWidth / 4.0, 1)",
        "\t\t\t+ dml_ceil(WritebackDestinationWidth / 4.0, 1)) / (double) HTotal + dml_ceil(1.0 / WritebackVRatio, 1)"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dml1_display_rq_dlg_calc.c",
      "line": 1323,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double) mode_lib->soc.dram_clock",
      "context": [
        "\tDTRACE(",
        "\t\t\t\"DLG: %s: soc.dram_clock_change_latency_us   = %3.2f\",",
        "\t\t\t__func__,",
        "\t\t\t(double) mode_lib->soc.dram_clock_change_latency_us);",
        "\tDTRACE(",
        "\t\t\t\"DLG: %s: soc.urgent_latency_us              = %3.2f\",",
        "\t\t\t__func__,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml2_translation_helper.c",
      "line": 40,
      "pattern": "hardcoded.*values",
      "rule": "code_quality",
      "severity": "low",
      "match": "Hardcoded values",
      "context": [
        "\tcase dml_project_dcn32:",
        "\tcase dml_project_dcn321:",
        "\tdefault:",
        "\t\t// Hardcoded values for DCN32x",
        "\t\tout->vblank_nom_default_us = 600;",
        "\t\tout->rob_buffer_size_kbytes = 128;",
        "\t\tout->config_return_buffer_size_in_kbytes = 1280;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml2_translation_helper.c",
      "line": 180,
      "pattern": "hardcoded.*values",
      "rule": "code_quality",
      "severity": "low",
      "match": "Hardcoded values",
      "context": [
        "\t\tbreak;",
        "",
        "\tcase dml_project_dcn401:",
        "\t\t// Hardcoded values for DCN4m",
        "\t\tout->vblank_nom_default_us = 668;\t//600;",
        "\t\tout->rob_buffer_size_kbytes = 192;\t//128;",
        "\t\tout->config_return_buffer_size_in_kbytes = 1344;\t//1280;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml2_translation_helper.c",
      "line": 352,
      "pattern": "hardcoded.*values",
      "rule": "code_quality",
      "severity": "low",
      "match": "hardcoded values",
      "context": [
        "\tp->in_states = &dml2->v20.scratch.create_scratch.in_states;",
        "",
        "",
        "\t/* Initial hardcoded values */",
        "\tswitch (dml2->v20.dml_core_ctx.project) {",
        "",
        "\tcase dml_project_dcn32:"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\link\\link_dpms.c",
      "line": 2546,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tif (pipe_ctx->stream->dpms_off)",
        "\t\treturn;",
        "",
        "\t/* For Dp tunneling link, a pending HPD means that we have a race condition between processing",
        "\t * current link and processing the pending HPD. If we enable the link now, we may end up with a",
        "\t * link that is not actually connected to a sink. So we skip enabling the link in this case.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\dcn20_fpu.c",
      "line": 2214,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double dram_clock_change_latency_cached = dml->soc.dram_clock",
      "context": [
        "\t\t\t\t\tdisplay_e2e_pipe_params_st *pipes,",
        "\t\t\t\t\tint pipe_cnt)",
        "{",
        "\tdouble dram_clock_change_latency_cached = dml->soc.dram_clock_change_latency_us;",
        "",
        "\tASSERT(vlevel < dml->soc.num_states);",
        "\t/* only pipe 0 is read for voltage and dcf/soc clocks */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
      "line": 60,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tstruct display_mode_lib *mode_lib,",
        "\t\tdouble DPPCLK,",
        "\t\tdouble DISPCLK,",
        "\t\tdouble PixelClock,",
        "\t\tdouble DCFCLKDeepSleep,",
        "\t\tunsigned int DSCDelay,",
        "\t\tunsigned int DPPPerPlane,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
      "line": 120,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double RoundToDFSGranularityUp(double Clock",
      "context": [
        "\t\tunsigned int *VUpdateOffsetPix,",
        "\t\tdouble *VUpdateWidthPix,",
        "\t\tdouble *VReadyOffsetPix);",
        "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed);",
        "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed);",
        "static double CalculatePrefetchSourceLines(",
        "\t\tstruct display_mode_lib *mode_lib,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
      "line": 121,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double RoundToDFSGranularityDown(double Clock",
      "context": [
        "\t\tdouble *VUpdateWidthPix,",
        "\t\tdouble *VReadyOffsetPix);",
        "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed);",
        "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed);",
        "static double CalculatePrefetchSourceLines(",
        "\t\tstruct display_mode_lib *mode_lib,",
        "\t\tdouble VRatio,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
      "line": 158,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double DRAMClock",
      "context": [
        "\t\tunsigned int *meta_row_height);",
        "static double CalculateTWait(",
        "\t\tunsigned int PrefetchMode,",
        "\t\tdouble DRAMClockChangeLatency,",
        "\t\tdouble UrgentLatencyPixelDataOnly,",
        "\t\tdouble SREnterPlusExitTime);",
        "static double CalculateRemoteSurfaceFlipDelay("
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
      "line": 443,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tstruct display_mode_lib *mode_lib,",
        "\t\tdouble DPPCLK,",
        "\t\tdouble DISPCLK,",
        "\t\tdouble PixelClock,",
        "\t\tdouble DCFCLKDeepSleep,",
        "\t\tunsigned int DSCDelay,",
        "\t\tunsigned int DPPPerPlane,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
      "line": 556,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double) (*VUpdateOffsetPix + *VUpdateWidthPix + *VReadyOffsetPix) / PixelClock",
      "context": [
        "\t\t\tTotalRepeaterDelayTime + 20.0 / DCFCLKDeepSleep + 10.0 / DPPCLK)",
        "\t\t\t* PixelClock;",
        "",
        "\tTsetup = (double) (*VUpdateOffsetPix + *VUpdateWidthPix + *VReadyOffsetPix) / PixelClock;",
        "",
        "\tLineTime = (double) HTotal / PixelClock;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
      "line": 558,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double) HTotal / PixelClock",
      "context": [
        "",
        "\tTsetup = (double) (*VUpdateOffsetPix + *VUpdateWidthPix + *VReadyOffsetPix) / PixelClock;",
        "",
        "\tLineTime = (double) HTotal / PixelClock;",
        "",
        "\tif (DynamicMetadataEnable) {",
        "\t\tdouble Tdmbf, Tdmec, Tdmsks;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
      "line": 799,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double RoundToDFSGranularityUp(double Clock",
      "context": [
        "\treturn MyError;",
        "}",
        "",
        "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed)",
        "{",
        "\treturn VCOSpeed * 4 / dml_floor(VCOSpeed * 4 / Clock, 1);",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
      "line": 804,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double RoundToDFSGranularityDown(double Clock",
      "context": [
        "\treturn VCOSpeed * 4 / dml_floor(VCOSpeed * 4 / Clock, 1);",
        "}",
        "",
        "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed)",
        "{",
        "\treturn VCOSpeed * 4 / dml_ceil(VCOSpeed * 4 / Clock, 1);",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
      "line": 2407,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double ActiveDRAMClock",
      "context": [
        "\t\tdouble DPPOutputBufferLinesC;",
        "\t\tdouble DPPOPPBufferingY;",
        "\t\tdouble MaxDETBufferingTimeY;",
        "\t\tdouble ActiveDRAMClockChangeLatencyMarginY;",
        "",
        "\t\tmode_lib->vba.LBLatencyHidingSourceLinesY =",
        "\t\t\t\tdml_min("
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
      "line": 2495,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double ActiveDRAMClock",
      "context": [
        "\t\t\t\t\t\t\t\t\t/ mode_lib->vba.SwathHeightC[k]",
        "\t\t\t\t\t\t\t\t\t* (mode_lib->vba.HTotal[k]",
        "\t\t\t\t\t\t\t\t\t\t\t/ mode_lib->vba.PixelClock[k]);",
        "\t\t\tdouble ActiveDRAMClockChangeLatencyMarginC = DPPOPPBufferingC",
        "\t\t\t\t\t+ EffectiveLBLatencyHidingC + MaxDETBufferingTimeC",
        "\t\t\t\t\t- mode_lib->vba.DRAMClockChangeWatermark;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
      "line": 2519,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double WritebackDRAMClock",
      "context": [
        "\t\t}",
        "",
        "\t\tif (mode_lib->vba.WritebackEnable[k]) {",
        "\t\t\tdouble WritebackDRAMClockChangeLatencyMargin;",
        "",
        "\t\t\tif (mode_lib->vba.WritebackPixelFormat[k] == dm_444_32) {",
        "\t\t\t\tWritebackDRAMClockChangeLatencyMargin ="
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
      "line": 2715,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double Read256BytesBlock",
      "context": [
        "{",
        "\tdouble BytePerPixDETY;",
        "\tdouble BytePerPixDETC;",
        "\tdouble Read256BytesBlockHeightY;",
        "\tdouble Read256BytesBlockHeightC;",
        "\tdouble Read256BytesBlockWidthY;",
        "\tdouble Read256BytesBlockWidthC;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
      "line": 2716,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double Read256BytesBlock",
      "context": [
        "\tdouble BytePerPixDETY;",
        "\tdouble BytePerPixDETC;",
        "\tdouble Read256BytesBlockHeightY;",
        "\tdouble Read256BytesBlockHeightC;",
        "\tdouble Read256BytesBlockWidthY;",
        "\tdouble Read256BytesBlockWidthC;",
        "\tdouble MaximumSwathHeightY;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
      "line": 2717,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double Read256BytesBlock",
      "context": [
        "\tdouble BytePerPixDETC;",
        "\tdouble Read256BytesBlockHeightY;",
        "\tdouble Read256BytesBlockHeightC;",
        "\tdouble Read256BytesBlockWidthY;",
        "\tdouble Read256BytesBlockWidthC;",
        "\tdouble MaximumSwathHeightY;",
        "\tdouble MaximumSwathHeightC;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
      "line": 2718,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double Read256BytesBlock",
      "context": [
        "\tdouble Read256BytesBlockHeightY;",
        "\tdouble Read256BytesBlockHeightC;",
        "\tdouble Read256BytesBlockWidthY;",
        "\tdouble Read256BytesBlockWidthC;",
        "\tdouble MaximumSwathHeightY;",
        "\tdouble MaximumSwathHeightC;",
        "\tdouble MinimumSwathHeightY;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
      "line": 2922,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double DRAMClock",
      "context": [
        "",
        "static double CalculateTWait(",
        "\t\tunsigned int PrefetchMode,",
        "\t\tdouble DRAMClockChangeLatency,",
        "\t\tdouble UrgentLatencyPixelDataOnly,",
        "\t\tdouble SREnterPlusExitTime)",
        "{"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
      "line": 66,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble DisplayPipeLineDeliveryTimeChroma,",
        "\t\tdouble DPPCLK,",
        "\t\tdouble DISPCLK,",
        "\t\tdouble PixelClock,",
        "\t\tunsigned int DSCDelay,",
        "\t\tunsigned int DPPPerPlane,",
        "\t\tbool ScalerEnabled,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
      "line": 95,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tstruct display_mode_lib *mode_lib,",
        "\t\tdouble DPPCLK,",
        "\t\tdouble DISPCLK,",
        "\t\tdouble PixelClock,",
        "\t\tdouble DCFCLKDeepSleep,",
        "\t\tunsigned int DPPPerPlane,",
        "\t\tunsigned int NumberOfCursors,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
      "line": 144,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double RoundToDFSGranularityUp(double Clock",
      "context": [
        "\t\tunsigned int *VUpdateOffsetPix,",
        "\t\tdouble *VUpdateWidthPix,",
        "\t\tdouble *VReadyOffsetPix);",
        "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed);",
        "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed);",
        "static double CalculatePrefetchSourceLines(",
        "\t\tstruct display_mode_lib *mode_lib,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
      "line": 145,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double RoundToDFSGranularityDown(double Clock",
      "context": [
        "\t\tdouble *VUpdateWidthPix,",
        "\t\tdouble *VReadyOffsetPix);",
        "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed);",
        "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed);",
        "static double CalculatePrefetchSourceLines(",
        "\t\tstruct display_mode_lib *mode_lib,",
        "\t\tdouble VRatio,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
      "line": 182,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double DRAMClock",
      "context": [
        "\t\tunsigned int *meta_row_height);",
        "static double CalculateTWait(",
        "\t\tunsigned int PrefetchMode,",
        "\t\tdouble DRAMClockChangeLatency,",
        "\t\tdouble UrgentLatencyPixelDataOnly,",
        "\t\tdouble SREnterPlusExitTime);",
        "static double CalculateRemoteSurfaceFlipDelay("
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
      "line": 473,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble DisplayPipeLineDeliveryTimeChroma,",
        "\t\tdouble DPPCLK,",
        "\t\tdouble DISPCLK,",
        "\t\tdouble PixelClock,",
        "\t\tunsigned int DSCDelay,",
        "\t\tunsigned int DPPPerPlane,",
        "\t\tbool ScalerEnabled,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
      "line": 545,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tstruct display_mode_lib *mode_lib,",
        "\t\tdouble DPPCLK,",
        "\t\tdouble DISPCLK,",
        "\t\tdouble PixelClock,",
        "\t\tdouble DCFCLKDeepSleep,",
        "\t\tunsigned int DPPPerPlane,",
        "\t\tunsigned int NumberOfCursors,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
      "line": 619,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double) (*VUpdateOffsetPix + *VUpdateWidthPix + *VReadyOffsetPix) / PixelClock",
      "context": [
        "\t\t\tTotalRepeaterDelayTime + 20.0 / DCFCLKDeepSleep + 10.0 / DPPCLK)",
        "\t\t\t* PixelClock;",
        "",
        "\tTsetup = (double) (*VUpdateOffsetPix + *VUpdateWidthPix + *VReadyOffsetPix) / PixelClock;",
        "",
        "\tLineTime = (double) HTotal / PixelClock;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
      "line": 621,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double) HTotal / PixelClock",
      "context": [
        "",
        "\tTsetup = (double) (*VUpdateOffsetPix + *VUpdateWidthPix + *VReadyOffsetPix) / PixelClock;",
        "",
        "\tLineTime = (double) HTotal / PixelClock;",
        "",
        "\tif (DynamicMetadataEnable) {",
        "\t\tdouble Tdmbf, Tdmec, Tdmsks;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
      "line": 859,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double RoundToDFSGranularityUp(double Clock",
      "context": [
        "\treturn MyError;",
        "}",
        "",
        "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed)",
        "{",
        "\treturn VCOSpeed * 4 / dml_floor(VCOSpeed * 4 / Clock, 1);",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
      "line": 864,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double RoundToDFSGranularityDown(double Clock",
      "context": [
        "\treturn VCOSpeed * 4 / dml_floor(VCOSpeed * 4 / Clock, 1);",
        "}",
        "",
        "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed)",
        "{",
        "\treturn VCOSpeed * 4 / dml_ceil(VCOSpeed * 4 / Clock, 1);",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
      "line": 2441,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double ActiveDRAMClock",
      "context": [
        "\t\tdouble DPPOutputBufferLinesC;",
        "\t\tdouble DPPOPPBufferingY;",
        "\t\tdouble MaxDETBufferingTimeY;",
        "\t\tdouble ActiveDRAMClockChangeLatencyMarginY;",
        "",
        "\t\tmode_lib->vba.LBLatencyHidingSourceLinesY =",
        "\t\t\t\tdml_min("
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
      "line": 2529,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double ActiveDRAMClock",
      "context": [
        "\t\t\t\t\t\t\t\t\t/ mode_lib->vba.SwathHeightC[k]",
        "\t\t\t\t\t\t\t\t\t* (mode_lib->vba.HTotal[k]",
        "\t\t\t\t\t\t\t\t\t\t\t/ mode_lib->vba.PixelClock[k]);",
        "\t\t\tdouble ActiveDRAMClockChangeLatencyMarginC = DPPOPPBufferingC",
        "\t\t\t\t\t+ EffectiveLBLatencyHidingC + MaxDETBufferingTimeC",
        "\t\t\t\t\t- mode_lib->vba.DRAMClockChangeWatermark;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
      "line": 2553,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double WritebackDRAMClock",
      "context": [
        "\t\t}",
        "",
        "\t\tif (mode_lib->vba.WritebackEnable[k]) {",
        "\t\t\tdouble WritebackDRAMClockChangeLatencyMargin;",
        "",
        "\t\t\tif (mode_lib->vba.WritebackPixelFormat[k] == dm_444_32) {",
        "\t\t\t\tWritebackDRAMClockChangeLatencyMargin ="
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
      "line": 2788,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double Read256BytesBlock",
      "context": [
        "{",
        "\tdouble BytePerPixDETY;",
        "\tdouble BytePerPixDETC;",
        "\tdouble Read256BytesBlockHeightY;",
        "\tdouble Read256BytesBlockHeightC;",
        "\tdouble Read256BytesBlockWidthY;",
        "\tdouble Read256BytesBlockWidthC;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
      "line": 2789,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double Read256BytesBlock",
      "context": [
        "\tdouble BytePerPixDETY;",
        "\tdouble BytePerPixDETC;",
        "\tdouble Read256BytesBlockHeightY;",
        "\tdouble Read256BytesBlockHeightC;",
        "\tdouble Read256BytesBlockWidthY;",
        "\tdouble Read256BytesBlockWidthC;",
        "\tdouble MaximumSwathHeightY;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
      "line": 2790,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double Read256BytesBlock",
      "context": [
        "\tdouble BytePerPixDETC;",
        "\tdouble Read256BytesBlockHeightY;",
        "\tdouble Read256BytesBlockHeightC;",
        "\tdouble Read256BytesBlockWidthY;",
        "\tdouble Read256BytesBlockWidthC;",
        "\tdouble MaximumSwathHeightY;",
        "\tdouble MaximumSwathHeightC;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
      "line": 2791,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double Read256BytesBlock",
      "context": [
        "\tdouble Read256BytesBlockHeightY;",
        "\tdouble Read256BytesBlockHeightC;",
        "\tdouble Read256BytesBlockWidthY;",
        "\tdouble Read256BytesBlockWidthC;",
        "\tdouble MaximumSwathHeightY;",
        "\tdouble MaximumSwathHeightC;",
        "\tdouble MinimumSwathHeightY;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
      "line": 2995,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double DRAMClock",
      "context": [
        "",
        "static double CalculateTWait(",
        "\t\tunsigned int PrefetchMode,",
        "\t\tdouble DRAMClockChangeLatency,",
        "\t\tdouble UrgentLatencyPixelDataOnly,",
        "\t\tdouble SREnterPlusExitTime)",
        "{"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\dcn30_fpu.c",
      "line": 659,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double pstate_latency_us = base->ctx->dc->dml.soc.dram_clock",
      "context": [
        "void dcn3_fpu_build_wm_range_table(struct clk_mgr *base)",
        "{",
        "\t/* defaults */",
        "\tdouble pstate_latency_us = base->ctx->dc->dml.soc.dram_clock_change_latency_us;",
        "\tdouble sr_exit_time_us = base->ctx->dc->dml.soc.sr_exit_time_us;",
        "\tdouble sr_enter_plus_exit_time_us = base->ctx->dc->dml.soc.sr_enter_plus_exit_time_us;",
        "\tuint16_t min_uclk_mhz = base->bw_params->clk_table.entries[0].memclk_mhz;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 44,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "typedef struct {",
        "\tdouble DPPCLK;",
        "\tdouble DISPCLK;",
        "\tdouble PixelClock;",
        "\tdouble DCFCLKDeepSleep;",
        "\tunsigned int DPPPerPlane;",
        "\tbool ScalerEnabled;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 144,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double RoundToDFSGranularityUp(double Clock",
      "context": [
        "\t\tunsigned int *VUpdateOffsetPix,",
        "\t\tdouble *VUpdateWidthPix,",
        "\t\tdouble *VReadyOffsetPix);",
        "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed);",
        "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed);",
        "static double CalculateDCCConfiguration(",
        "\t\tbool                 DCCEnabled,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 145,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double RoundToDFSGranularityDown(double Clock",
      "context": [
        "\t\tdouble *VUpdateWidthPix,",
        "\t\tdouble *VReadyOffsetPix);",
        "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed);",
        "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed);",
        "static double CalculateDCCConfiguration(",
        "\t\tbool                 DCCEnabled,",
        "\t\tbool                 DCCProgrammingAssumesScanDirectionUnknown,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 210,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double DRAMClock",
      "context": [
        "",
        "static double CalculateTWait(",
        "\t\tunsigned int PrefetchMode,",
        "\t\tdouble DRAMClockChangeLatency,",
        "\t\tdouble UrgentLatency,",
        "\t\tdouble SREnterPlusExitTime);",
        "static double CalculateRemoteSurfaceFlipDelay("
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 306,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double DRAMClock",
      "context": [
        "\t\tdouble WritebackLatency,",
        "\t\tdouble WritebackChunkSize,",
        "\t\tdouble SOCCLK,",
        "\t\tdouble DRAMClockChangeLatency,",
        "\t\tdouble SRExitTime,",
        "\t\tdouble SREnterPlusExitTime,",
        "\t\tdouble DCFCLKDeepSleep,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 325,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tunsigned int VTAPsChroma[],",
        "\t\tdouble VRatio[],",
        "\t\tunsigned int HTotal[],",
        "\t\tdouble PixelClock[],",
        "\t\tunsigned int BlendingAndTiming[],",
        "\t\tdouble BytePerPixelDETY[],",
        "\t\tdouble BytePerPixelDETC[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 337,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double *DRAMClock",
      "context": [
        "\t\tenum clock_change_support *DRAMClockChangeSupport,",
        "\t\tdouble *UrgentWatermark,",
        "\t\tdouble *WritebackUrgentWatermark,",
        "\t\tdouble *DRAMClockChangeWatermark,",
        "\t\tdouble *WritebackDRAMClockChangeWatermark,",
        "\t\tdouble *StutterExitWatermark,",
        "\t\tdouble *StutterEnterPlusExitWatermark,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 338,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double *WritebackDRAMClock",
      "context": [
        "\t\tdouble *UrgentWatermark,",
        "\t\tdouble *WritebackUrgentWatermark,",
        "\t\tdouble *DRAMClockChangeWatermark,",
        "\t\tdouble *WritebackDRAMClockChangeWatermark,",
        "\t\tdouble *StutterExitWatermark,",
        "\t\tdouble *StutterEnterPlusExitWatermark,",
        "\t\tdouble *MinActiveDRAMClockChangeLatencySupported);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 341,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double *MinActiveDRAMClock",
      "context": [
        "\t\tdouble *WritebackDRAMClockChangeWatermark,",
        "\t\tdouble *StutterExitWatermark,",
        "\t\tdouble *StutterEnterPlusExitWatermark,",
        "\t\tdouble *MinActiveDRAMClockChangeLatencySupported);",
        "static void CalculateDCFCLKDeepSleep(",
        "\t\tstruct display_mode_lib *mode_lib,",
        "\t\tunsigned int NumberOfActivePlanes,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 351,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble SwathWidthY[],",
        "\t\tint DPPPerPlane[],",
        "\t\tdouble HRatio[],",
        "\t\tdouble PixelClock[],",
        "\t\tdouble PSCL_THROUGHPUT[],",
        "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
        "\t\tdouble DPPCLK[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 395,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double                 PixelClock",
      "context": [
        "\t\tunsigned int           swath_width_chroma_ub[],",
        "\t\tint                    DPPPerPlane[],",
        "\t\tdouble                 HRatio[],",
        "\t\tdouble                 PixelClock[],",
        "\t\tdouble                 PSCL_THROUGHPUT[],",
        "\t\tdouble                 PSCL_THROUGHPUT_CHROMA[],",
        "\t\tdouble                 DPPCLK[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 429,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double                 PixelClock",
      "context": [
        "\t\tdouble                 DestinationLinesToRequestVMInVBlank[],",
        "\t\tdouble                 DestinationLinesToRequestVMInImmediateFlip[],",
        "\t\tbool                   DCCEnable[],",
        "\t\tdouble                 PixelClock[],",
        "\t\tdouble                 BytePerPixelDETY[],",
        "\t\tdouble                 BytePerPixelDETC[],",
        "\t\tenum scan_direction_class SourceScan[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 765,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double) (*VUpdateOffsetPix + *VUpdateWidthPix + *VReadyOffsetPix) / myPipe->PixelClock",
      "context": [
        "\t\t\tTotalRepeaterDelayTime + 20.0 / myPipe->DCFCLKDeepSleep + 10.0 / myPipe->DPPCLK)",
        "\t\t\t* myPipe->PixelClock;",
        "",
        "\tTsetup = (double) (*VUpdateOffsetPix + *VUpdateWidthPix + *VReadyOffsetPix) / myPipe->PixelClock;",
        "",
        "\tLineTime = (double) myPipe->HTotal / myPipe->PixelClock;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 767,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double) myPipe->HTotal / myPipe->PixelClock",
      "context": [
        "",
        "\tTsetup = (double) (*VUpdateOffsetPix + *VUpdateWidthPix + *VReadyOffsetPix) / myPipe->PixelClock;",
        "",
        "\tLineTime = (double) myPipe->HTotal / myPipe->PixelClock;",
        "",
        "\tif (DynamicMetadataEnable) {",
        "\t\tdouble Tdmbf, Tdmec, Tdmsks;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 1064,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double RoundToDFSGranularityUp(double Clock",
      "context": [
        "\treturn MyError;",
        "}",
        "",
        "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed)",
        "{",
        "\treturn VCOSpeed * 4 / dml_floor(VCOSpeed * 4 / Clock, 1);",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 1069,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double RoundToDFSGranularityDown(double Clock",
      "context": [
        "\treturn VCOSpeed * 4 / dml_floor(VCOSpeed * 4 / Clock, 1);",
        "}",
        "",
        "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed)",
        "{",
        "\treturn VCOSpeed * 4 / dml_ceil(VCOSpeed * 4 / Clock, 1);",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 2813,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double Read256BytesBlock",
      "context": [
        "\t// Display Pipe Configuration",
        "\tdouble BytePerPixDETY;",
        "\tdouble BytePerPixDETC;",
        "\tdouble Read256BytesBlockHeightY;",
        "\tdouble Read256BytesBlockHeightC;",
        "\tdouble Read256BytesBlockWidthY;",
        "\tdouble Read256BytesBlockWidthC;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 2814,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double Read256BytesBlock",
      "context": [
        "\tdouble BytePerPixDETY;",
        "\tdouble BytePerPixDETC;",
        "\tdouble Read256BytesBlockHeightY;",
        "\tdouble Read256BytesBlockHeightC;",
        "\tdouble Read256BytesBlockWidthY;",
        "\tdouble Read256BytesBlockWidthC;",
        "\tdouble MaximumSwathHeightY;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 2815,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double Read256BytesBlock",
      "context": [
        "\tdouble BytePerPixDETC;",
        "\tdouble Read256BytesBlockHeightY;",
        "\tdouble Read256BytesBlockHeightC;",
        "\tdouble Read256BytesBlockWidthY;",
        "\tdouble Read256BytesBlockWidthC;",
        "\tdouble MaximumSwathHeightY;",
        "\tdouble MaximumSwathHeightC;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 2816,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double Read256BytesBlock",
      "context": [
        "\tdouble Read256BytesBlockHeightY;",
        "\tdouble Read256BytesBlockHeightC;",
        "\tdouble Read256BytesBlockWidthY;",
        "\tdouble Read256BytesBlockWidthC;",
        "\tdouble MaximumSwathHeightY;",
        "\tdouble MaximumSwathHeightC;",
        "\tdouble MinimumSwathHeightY;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 3009,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double DRAMClock",
      "context": [
        "",
        "static double CalculateTWait(",
        "\t\tunsigned int PrefetchMode,",
        "\t\tdouble DRAMClockChangeLatency,",
        "\t\tdouble UrgentLatency,",
        "\t\tdouble SREnterPlusExitTime)",
        "{"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 5260,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double DRAMClock",
      "context": [
        "\t\tdouble WritebackLatency,",
        "\t\tdouble WritebackChunkSize,",
        "\t\tdouble SOCCLK,",
        "\t\tdouble DRAMClockChangeLatency,",
        "\t\tdouble SRExitTime,",
        "\t\tdouble SREnterPlusExitTime,",
        "\t\tdouble DCFCLKDeepSleep,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 5279,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tunsigned int VTAPsChroma[],",
        "\t\tdouble VRatio[],",
        "\t\tunsigned int HTotal[],",
        "\t\tdouble PixelClock[],",
        "\t\tunsigned int BlendingAndTiming[],",
        "\t\tdouble BytePerPixelDETY[],",
        "\t\tdouble BytePerPixelDETC[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 5291,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double *DRAMClock",
      "context": [
        "\t\tenum clock_change_support *DRAMClockChangeSupport,",
        "\t\tdouble *UrgentWatermark,",
        "\t\tdouble *WritebackUrgentWatermark,",
        "\t\tdouble *DRAMClockChangeWatermark,",
        "\t\tdouble *WritebackDRAMClockChangeWatermark,",
        "\t\tdouble *StutterExitWatermark,",
        "\t\tdouble *StutterEnterPlusExitWatermark,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 5292,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double *WritebackDRAMClock",
      "context": [
        "\t\tdouble *UrgentWatermark,",
        "\t\tdouble *WritebackUrgentWatermark,",
        "\t\tdouble *DRAMClockChangeWatermark,",
        "\t\tdouble *WritebackDRAMClockChangeWatermark,",
        "\t\tdouble *StutterExitWatermark,",
        "\t\tdouble *StutterEnterPlusExitWatermark,",
        "\t\tdouble *MinActiveDRAMClockChangeLatencySupported)"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 5295,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double *MinActiveDRAMClock",
      "context": [
        "\t\tdouble *WritebackDRAMClockChangeWatermark,",
        "\t\tdouble *StutterExitWatermark,",
        "\t\tdouble *StutterEnterPlusExitWatermark,",
        "\t\tdouble *MinActiveDRAMClockChangeLatencySupported)",
        "{",
        "\tdouble EffectiveLBLatencyHidingY;",
        "\tdouble EffectiveLBLatencyHidingC;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 5309,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double ActiveDRAMClock",
      "context": [
        "\tunsigned int LinesInDETCRoundedDownToSwath;",
        "\tdouble FullDETBufferingTimeY[DC__NUM_DPP__MAX];",
        "\tdouble FullDETBufferingTimeC;",
        "\tdouble ActiveDRAMClockChangeLatencyMarginY;",
        "\tdouble ActiveDRAMClockChangeLatencyMarginC;",
        "\tdouble WritebackDRAMClockChangeLatencyMargin;",
        "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 5310,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double ActiveDRAMClock",
      "context": [
        "\tdouble FullDETBufferingTimeY[DC__NUM_DPP__MAX];",
        "\tdouble FullDETBufferingTimeC;",
        "\tdouble ActiveDRAMClockChangeLatencyMarginY;",
        "\tdouble ActiveDRAMClockChangeLatencyMarginC;",
        "\tdouble WritebackDRAMClockChangeLatencyMargin;",
        "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;",
        "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 5311,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double WritebackDRAMClock",
      "context": [
        "\tdouble FullDETBufferingTimeC;",
        "\tdouble ActiveDRAMClockChangeLatencyMarginY;",
        "\tdouble ActiveDRAMClockChangeLatencyMarginC;",
        "\tdouble WritebackDRAMClockChangeLatencyMargin;",
        "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;",
        "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank;",
        "\tdouble FullDETBufferingTimeYStutterCriticalPlane = 0;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 5312,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PlaneWithMinActiveDRAMClock",
      "context": [
        "\tdouble ActiveDRAMClockChangeLatencyMarginY;",
        "\tdouble ActiveDRAMClockChangeLatencyMarginC;",
        "\tdouble WritebackDRAMClockChangeLatencyMargin;",
        "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;",
        "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank;",
        "\tdouble FullDETBufferingTimeYStutterCriticalPlane = 0;",
        "\tdouble TimeToFinishSwathTransferStutterCriticalPlane = 0;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 5313,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double SecondMinActiveDRAMClock",
      "context": [
        "\tdouble ActiveDRAMClockChangeLatencyMarginC;",
        "\tdouble WritebackDRAMClockChangeLatencyMargin;",
        "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;",
        "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank;",
        "\tdouble FullDETBufferingTimeYStutterCriticalPlane = 0;",
        "\tdouble TimeToFinishSwathTransferStutterCriticalPlane = 0;",
        "\tunsigned int k, j;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 5532,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble SwathWidthY[],",
        "\t\tint DPPPerPlane[],",
        "\t\tdouble HRatio[],",
        "\t\tdouble PixelClock[],",
        "\t\tdouble PSCL_THROUGHPUT[],",
        "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
        "\t\tdouble DPPCLK[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 5738,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tunsigned int swath_width_chroma_ub[],",
        "\t\tint DPPPerPlane[],",
        "\t\tdouble HRatio[],",
        "\t\tdouble PixelClock[],",
        "\t\tdouble PSCL_THROUGHPUT[],",
        "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
        "\t\tdouble DPPCLK[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
      "line": 5847,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble DestinationLinesToRequestVMInVBlank[],",
        "\t\tdouble DestinationLinesToRequestVMInImmediateFlip[],",
        "\t\tbool DCCEnable[],",
        "\t\tdouble PixelClock[],",
        "\t\tdouble BytePerPixelDETY[],",
        "\t\tdouble BytePerPixelDETC[],",
        "\t\tenum scan_direction_class SourceScan[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn301\\dcn301_fpu.c",
      "line": 299,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double dram_clock_change_latency_cached = dml->soc.dram_clock",
      "context": [
        "\t\tdisplay_e2e_pipe_params_st *pipes,",
        "\t\tint pipe_cnt)",
        "{",
        "\tdouble dram_clock_change_latency_cached = dml->soc.dram_clock_change_latency_us;",
        "",
        "\tASSERT(vlevel < dml->soc.num_states);",
        "\t/* only pipe 0 is read for voltage and dcf/soc clocks */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 45,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "typedef struct {",
        "\tdouble DPPCLK;",
        "\tdouble DISPCLK;",
        "\tdouble PixelClock;",
        "\tdouble DCFCLKDeepSleep;",
        "\tunsigned int DPPPerPlane;",
        "\tbool ScalerEnabled;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 146,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double RoundToDFSGranularityUp(double Clock",
      "context": [
        "\t\tunsigned int *VUpdateOffsetPix,",
        "\t\tdouble *VUpdateWidthPix,",
        "\t\tdouble *VReadyOffsetPix);",
        "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed);",
        "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed);",
        "static void CalculateDCCConfiguration(",
        "\t\tbool DCCEnabled,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 147,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double RoundToDFSGranularityDown(double Clock",
      "context": [
        "\t\tdouble *VUpdateWidthPix,",
        "\t\tdouble *VReadyOffsetPix);",
        "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed);",
        "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed);",
        "static void CalculateDCCConfiguration(",
        "\t\tbool DCCEnabled,",
        "\t\tbool DCCProgrammingAssumesScanDirectionUnknown,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 219,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double DRAMClock",
      "context": [
        "\t\tunsigned int *MetaPTEBytesFrame);",
        "static double CalculateTWait(",
        "\t\tunsigned int PrefetchMode,",
        "\t\tdouble DRAMClockChangeLatency,",
        "\t\tdouble UrgentLatency,",
        "\t\tdouble SREnterPlusExitTime);",
        "static void CalculateRowBandwidth("
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 283,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble DPPCLK,",
        "\t\tdouble DISPCLK,",
        "\t\tdouble DCFClkDeepSleep,",
        "\t\tdouble PixelClock,",
        "\t\tunsigned int HTotal,",
        "\t\tunsigned int VBlank,",
        "\t\tunsigned int DynamicMetadataTransmittedBytes,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 313,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double DRAMClock",
      "context": [
        "\t\tdouble WritebackLatency,",
        "\t\tdouble WritebackChunkSize,",
        "\t\tdouble SOCCLK,",
        "\t\tdouble DRAMClockChangeLatency,",
        "\t\tdouble SRExitTime,",
        "\t\tdouble SREnterPlusExitTime,",
        "\t\tdouble DCFCLKDeepSleep,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 334,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble VRatio[],",
        "\t\tdouble VRatioChroma[],",
        "\t\tunsigned int HTotal[],",
        "\t\tdouble PixelClock[],",
        "\t\tunsigned int BlendingAndTiming[],",
        "\t\tdouble BytePerPixelDETY[],",
        "\t\tdouble BytePerPixelDETC[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 348,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double *DRAMClock",
      "context": [
        "\t\tenum clock_change_support *DRAMClockChangeSupport,",
        "\t\tdouble *UrgentWatermark,",
        "\t\tdouble *WritebackUrgentWatermark,",
        "\t\tdouble *DRAMClockChangeWatermark,",
        "\t\tdouble *WritebackDRAMClockChangeWatermark,",
        "\t\tdouble *StutterExitWatermark,",
        "\t\tdouble *StutterEnterPlusExitWatermark,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 349,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double *WritebackDRAMClock",
      "context": [
        "\t\tdouble *UrgentWatermark,",
        "\t\tdouble *WritebackUrgentWatermark,",
        "\t\tdouble *DRAMClockChangeWatermark,",
        "\t\tdouble *WritebackDRAMClockChangeWatermark,",
        "\t\tdouble *StutterExitWatermark,",
        "\t\tdouble *StutterEnterPlusExitWatermark,",
        "\t\tdouble *MinActiveDRAMClockChangeLatencySupported);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 352,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double *MinActiveDRAMClock",
      "context": [
        "\t\tdouble *WritebackDRAMClockChangeWatermark,",
        "\t\tdouble *StutterExitWatermark,",
        "\t\tdouble *StutterEnterPlusExitWatermark,",
        "\t\tdouble *MinActiveDRAMClockChangeLatencySupported);",
        "static void CalculateDCFCLKDeepSleep(",
        "\t\tstruct display_mode_lib *mode_lib,",
        "\t\tunsigned int NumberOfActivePlanes,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 365,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tunsigned int DPPPerPlane[],",
        "\t\tdouble HRatio[],",
        "\t\tdouble HRatioChroma[],",
        "\t\tdouble PixelClock[],",
        "\t\tdouble PSCL_THROUGHPUT[],",
        "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
        "\t\tdouble DPPCLK[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 412,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tunsigned int DPPPerPlane[],",
        "\t\tdouble HRatio[],",
        "\t\tdouble HRatioChroma[],",
        "\t\tdouble PixelClock[],",
        "\t\tdouble PSCL_THROUGHPUT[],",
        "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
        "\t\tdouble DPPCLK[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 447,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble DestinationLinesToRequestRowInVBlank[],",
        "\t\tdouble DestinationLinesToRequestRowInImmediateFlip[],",
        "\t\tbool DCCEnable[],",
        "\t\tdouble PixelClock[],",
        "\t\tint BytePerPixelY[],",
        "\t\tint BytePerPixelC[],",
        "\t\tenum scan_direction_class SourceScan[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 496,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble DestinationLinesToRequestVMInVBlank[],",
        "\t\tdouble DestinationLinesToRequestVMInImmediateFlip[],",
        "\t\tbool DCCEnable[],",
        "\t\tdouble PixelClock[],",
        "\t\tint dpte_row_width_luma_ub[],",
        "\t\tint dpte_row_width_chroma_ub[],",
        "\t\tint vm_group_bytes[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 528,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble DCCRateChroma[],",
        "\t\tint HTotal[],",
        "\t\tint VTotal[],",
        "\t\tdouble PixelClock[],",
        "\t\tdouble VRatio[],",
        "\t\tenum scan_direction_class SourceScan[],",
        "\t\tint BlockHeight256BytesY[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 655,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double UrgentLatencyAdjustmentFabricClock",
      "context": [
        "\t\tdouble UrgentLatencyPixelMixedWithVMData,",
        "\t\tdouble UrgentLatencyVMDataOnly,",
        "\t\tbool DoUrgentLatencyAdjustment,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
        "\t\tdouble FabricClockSingle);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 656,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double UrgentLatencyAdjustmentFabricClock",
      "context": [
        "\t\tdouble UrgentLatencyVMDataOnly,",
        "\t\tbool DoUrgentLatencyAdjustment,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
        "\t\tdouble FabricClockSingle);",
        "",
        "void dml30_recalculate(struct display_mode_lib *mode_lib)"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 657,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double FabricClock",
      "context": [
        "\t\tbool DoUrgentLatencyAdjustment,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
        "\t\tdouble FabricClockSingle);",
        "",
        "void dml30_recalculate(struct display_mode_lib *mode_lib)",
        "{"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 1296,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double RoundToDFSGranularityUp(double Clock",
      "context": [
        "\treturn MyError;",
        "}",
        "",
        "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed)",
        "{",
        "\treturn VCOSpeed * 4 / dml_floor(VCOSpeed * 4 / Clock, 1);",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 1301,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double RoundToDFSGranularityDown(double Clock",
      "context": [
        "\treturn VCOSpeed * 4 / dml_floor(VCOSpeed * 4 / Clock, 1);",
        "}",
        "",
        "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed)",
        "{",
        "\treturn VCOSpeed * 4 / dml_ceil(VCOSpeed * 4.0 / Clock, 1);",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 2386,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double) v->WritebackDelay[v->VoltageLevel][k] / (v->HTotal[k] / v->PixelClock",
      "context": [
        "\t\t\t\tv->WritebackDelay[v->VoltageLevel][k] = v->WritebackDelay[v->VoltageLevel][j];",
        "",
        "\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {",
        "\t\tv->MaxVStartupLines[k] = v->VTotal[k] - v->VActive[k] - dml_max(1.0, dml_ceil((double) v->WritebackDelay[v->VoltageLevel][k] / (v->HTotal[k] / v->PixelClock[k]), 1));",
        "\t}",
        "",
        "\tv->MaximumMaxVStartupLines = 0;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 3207,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double DRAMClock",
      "context": [
        "",
        "static double CalculateTWait(",
        "\t\tunsigned int PrefetchMode,",
        "\t\tdouble DRAMClockChangeLatency,",
        "\t\tdouble UrgentLatency,",
        "\t\tdouble SREnterPlusExitTime)",
        "{"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 3223,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "",
        "double dml30_CalculateWriteBackDISPCLK(",
        "\t\tenum source_format_class WritebackPixelFormat,",
        "\t\tdouble PixelClock,",
        "\t\tdouble WritebackHRatio,",
        "\t\tdouble WritebackVRatio,",
        "\t\tunsigned int WritebackHTaps,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 3269,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double DCFClkDeepSleep, double PixelClock",
      "context": [
        "",
        "",
        "static void CalculateDynamicMetadataParameters(int MaxInterDCNTileRepeaters, double DPPCLK, double DISPCLK,",
        "\t\tdouble DCFClkDeepSleep, double PixelClock, unsigned int HTotal, unsigned int VBlank, unsigned int DynamicMetadataTransmittedBytes,",
        "\t\tint DynamicMetadataLinesBeforeActiveRequired, int InterlaceEnable, bool ProgressiveToInterlaceUnitInOPP,",
        "\t\tdouble *Tsetup, double *Tdmbf, double *Tdmec, double *Tdmsks)",
        "{"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 3442,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tint Lanes,",
        "\t\tlong HTotal,",
        "\t\tlong HActive,",
        "\t\tdouble PixelClock,",
        "\t\tdouble DesiredBPP,",
        "\t\tbool DSCEnable,",
        "\t\tenum output_encoder_class Output,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 5198,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double DRAMClock",
      "context": [
        "\t\tdouble WritebackLatency,",
        "\t\tdouble WritebackChunkSize,",
        "\t\tdouble SOCCLK,",
        "\t\tdouble DRAMClockChangeLatency,",
        "\t\tdouble SRExitTime,",
        "\t\tdouble SREnterPlusExitTime,",
        "\t\tdouble DCFCLKDeepSleep,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 5219,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble VRatio[],",
        "\t\tdouble VRatioChroma[],",
        "\t\tunsigned int HTotal[],",
        "\t\tdouble PixelClock[],",
        "\t\tunsigned int BlendingAndTiming[],",
        "\t\tdouble BytePerPixelDETY[],",
        "\t\tdouble BytePerPixelDETC[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 5233,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double *DRAMClock",
      "context": [
        "\t\tenum clock_change_support *DRAMClockChangeSupport,",
        "\t\tdouble *UrgentWatermark,",
        "\t\tdouble *WritebackUrgentWatermark,",
        "\t\tdouble *DRAMClockChangeWatermark,",
        "\t\tdouble *WritebackDRAMClockChangeWatermark,",
        "\t\tdouble *StutterExitWatermark,",
        "\t\tdouble *StutterEnterPlusExitWatermark,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 5234,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double *WritebackDRAMClock",
      "context": [
        "\t\tdouble *UrgentWatermark,",
        "\t\tdouble *WritebackUrgentWatermark,",
        "\t\tdouble *DRAMClockChangeWatermark,",
        "\t\tdouble *WritebackDRAMClockChangeWatermark,",
        "\t\tdouble *StutterExitWatermark,",
        "\t\tdouble *StutterEnterPlusExitWatermark,",
        "\t\tdouble *MinActiveDRAMClockChangeLatencySupported)"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 5237,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double *MinActiveDRAMClock",
      "context": [
        "\t\tdouble *WritebackDRAMClockChangeWatermark,",
        "\t\tdouble *StutterExitWatermark,",
        "\t\tdouble *StutterEnterPlusExitWatermark,",
        "\t\tdouble *MinActiveDRAMClockChangeLatencySupported)",
        "{",
        "\tdouble EffectiveLBLatencyHidingY = 0;",
        "\tdouble EffectiveLBLatencyHidingC = 0;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 5247,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double ActiveDRAMClock",
      "context": [
        "\tunsigned int LinesInDETCRoundedDownToSwath = 0;",
        "\tdouble FullDETBufferingTimeY[DC__NUM_DPP__MAX] = { 0 };",
        "\tdouble FullDETBufferingTimeC = 0;",
        "\tdouble ActiveDRAMClockChangeLatencyMarginY = 0;",
        "\tdouble ActiveDRAMClockChangeLatencyMarginC = 0;",
        "\tdouble WritebackDRAMClockChangeLatencyMargin = 0;",
        "\tdouble PlaneWithMinActiveDRAMClockChangeMargin = 0;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 5248,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double ActiveDRAMClock",
      "context": [
        "\tdouble FullDETBufferingTimeY[DC__NUM_DPP__MAX] = { 0 };",
        "\tdouble FullDETBufferingTimeC = 0;",
        "\tdouble ActiveDRAMClockChangeLatencyMarginY = 0;",
        "\tdouble ActiveDRAMClockChangeLatencyMarginC = 0;",
        "\tdouble WritebackDRAMClockChangeLatencyMargin = 0;",
        "\tdouble PlaneWithMinActiveDRAMClockChangeMargin = 0;",
        "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank = 0;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 5249,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double WritebackDRAMClock",
      "context": [
        "\tdouble FullDETBufferingTimeC = 0;",
        "\tdouble ActiveDRAMClockChangeLatencyMarginY = 0;",
        "\tdouble ActiveDRAMClockChangeLatencyMarginC = 0;",
        "\tdouble WritebackDRAMClockChangeLatencyMargin = 0;",
        "\tdouble PlaneWithMinActiveDRAMClockChangeMargin = 0;",
        "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank = 0;",
        "\tdouble FullDETBufferingTimeYStutterCriticalPlane = 0;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 5250,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PlaneWithMinActiveDRAMClock",
      "context": [
        "\tdouble ActiveDRAMClockChangeLatencyMarginY = 0;",
        "\tdouble ActiveDRAMClockChangeLatencyMarginC = 0;",
        "\tdouble WritebackDRAMClockChangeLatencyMargin = 0;",
        "\tdouble PlaneWithMinActiveDRAMClockChangeMargin = 0;",
        "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank = 0;",
        "\tdouble FullDETBufferingTimeYStutterCriticalPlane = 0;",
        "\tdouble TimeToFinishSwathTransferStutterCriticalPlane = 0;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 5251,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double SecondMinActiveDRAMClock",
      "context": [
        "\tdouble ActiveDRAMClockChangeLatencyMarginC = 0;",
        "\tdouble WritebackDRAMClockChangeLatencyMargin = 0;",
        "\tdouble PlaneWithMinActiveDRAMClockChangeMargin = 0;",
        "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank = 0;",
        "\tdouble FullDETBufferingTimeYStutterCriticalPlane = 0;",
        "\tdouble TimeToFinishSwathTransferStutterCriticalPlane = 0;",
        "\tdouble WritebackDRAMClockChangeLatencyHiding = 0;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 5254,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double WritebackDRAMClock",
      "context": [
        "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank = 0;",
        "\tdouble FullDETBufferingTimeYStutterCriticalPlane = 0;",
        "\tdouble TimeToFinishSwathTransferStutterCriticalPlane = 0;",
        "\tdouble WritebackDRAMClockChangeLatencyHiding = 0;",
        "\tunsigned int k, j;",
        "",
        "\tmode_lib->vba.TotalActiveDPP = 0;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 5408,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tunsigned int DPPPerPlane[],",
        "\t\tdouble HRatio[],",
        "\t\tdouble HRatioChroma[],",
        "\t\tdouble PixelClock[],",
        "\t\tdouble PSCL_THROUGHPUT[],",
        "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
        "\t\tdouble DPPCLK[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 5546,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tunsigned int DPPPerPlane[],",
        "\t\tdouble HRatio[],",
        "\t\tdouble HRatioChroma[],",
        "\t\tdouble PixelClock[],",
        "\t\tdouble PSCL_THROUGHPUT[],",
        "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
        "\t\tdouble DPPCLK[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 5661,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble DestinationLinesToRequestRowInVBlank[],",
        "\t\tdouble DestinationLinesToRequestRowInImmediateFlip[],",
        "\t\tbool DCCEnable[],",
        "\t\tdouble PixelClock[],",
        "\t\tint BytePerPixelY[],",
        "\t\tint BytePerPixelC[],",
        "\t\tenum scan_direction_class SourceScan[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 5832,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble DestinationLinesToRequestVMInVBlank[],",
        "\t\tdouble DestinationLinesToRequestVMInImmediateFlip[],",
        "\t\tbool DCCEnable[],",
        "\t\tdouble PixelClock[],",
        "\t\tint dpte_row_width_luma_ub[],",
        "\t\tint dpte_row_width_chroma_ub[],",
        "\t\tint vm_group_bytes[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 5953,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble DCCRateChroma[],",
        "\t\tint HTotal[],",
        "\t\tint VTotal[],",
        "\t\tdouble PixelClock[],",
        "\t\tdouble VRatio[],",
        "\t\tenum scan_direction_class SourceScan[],",
        "\t\tint BlockHeight256BytesY[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 6475,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double UrgentLatencyAdjustmentFabricClock",
      "context": [
        "\t\tdouble UrgentLatencyPixelMixedWithVMData,",
        "\t\tdouble UrgentLatencyVMDataOnly,",
        "\t\tbool DoUrgentLatencyAdjustment,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
        "\t\tdouble FabricClock)",
        "{"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 6476,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double UrgentLatencyAdjustmentFabricClock",
      "context": [
        "\t\tdouble UrgentLatencyVMDataOnly,",
        "\t\tbool DoUrgentLatencyAdjustment,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
        "\t\tdouble FabricClock)",
        "{",
        "\tdouble ret;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
      "line": 6477,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double FabricClock",
      "context": [
        "\t\tbool DoUrgentLatencyAdjustment,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
        "\t\tdouble FabricClock)",
        "{",
        "\tdouble ret;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 63,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "typedef struct {",
        "\tdouble DPPCLK;",
        "\tdouble DISPCLK;",
        "\tdouble PixelClock;",
        "\tdouble DCFCLKDeepSleep;",
        "\tunsigned int DPPPerPlane;",
        "\tbool ScalerEnabled;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 172,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double RoundToDFSGranularityUp(double Clock",
      "context": [
        "\t\tint *VUpdateOffsetPix,",
        "\t\tdouble *VUpdateWidthPix,",
        "\t\tdouble *VReadyOffsetPix);",
        "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed);",
        "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed);",
        "static void CalculateDCCConfiguration(",
        "\t\tbool DCCEnabled,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 173,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double RoundToDFSGranularityDown(double Clock",
      "context": [
        "\t\tdouble *VUpdateWidthPix,",
        "\t\tdouble *VReadyOffsetPix);",
        "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed);",
        "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed);",
        "static void CalculateDCCConfiguration(",
        "\t\tbool DCCEnabled,",
        "\t\tbool DCCProgrammingAssumesScanDirectionUnknown,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 243,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double CalculateTWait(unsigned int PrefetchMode, double DRAMClock",
      "context": [
        "\t\tunsigned int *PTERequestSize,",
        "\t\tint *DPDE0BytesFrame,",
        "\t\tint *MetaPTEBytesFrame);",
        "static double CalculateTWait(unsigned int PrefetchMode, double DRAMClockChangeLatency, double UrgentLatency, double SREnterPlusExitTime);",
        "static void CalculateRowBandwidth(",
        "\t\tbool GPUVMEnable,",
        "\t\tenum source_format_class SourcePixelFormat,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 286,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble DPPCLK,",
        "\t\tdouble DISPCLK,",
        "\t\tdouble DCFClkDeepSleep,",
        "\t\tdouble PixelClock,",
        "\t\tint HTotal,",
        "\t\tint VBlank,",
        "\t\tint DynamicMetadataTransmittedBytes,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 339,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tunsigned int DPPPerPlane[],",
        "\t\tdouble HRatio[],",
        "\t\tdouble HRatioChroma[],",
        "\t\tdouble PixelClock[],",
        "\t\tdouble PSCL_THROUGHPUT[],",
        "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
        "\t\tdouble DPPCLK[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 385,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tunsigned int DPPPerPlane[],",
        "\t\tdouble HRatio[],",
        "\t\tdouble HRatioChroma[],",
        "\t\tdouble PixelClock[],",
        "\t\tdouble PSCL_THROUGHPUT[],",
        "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
        "\t\tdouble DPPCLK[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 420,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble DestinationLinesToRequestRowInVBlank[],",
        "\t\tdouble DestinationLinesToRequestRowInImmediateFlip[],",
        "\t\tbool DCCEnable[],",
        "\t\tdouble PixelClock[],",
        "\t\tint BytePerPixelY[],",
        "\t\tint BytePerPixelC[],",
        "\t\tenum scan_direction_class SourceScan[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 469,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble DestinationLinesToRequestVMInVBlank[],",
        "\t\tdouble DestinationLinesToRequestVMInImmediateFlip[],",
        "\t\tbool DCCEnable[],",
        "\t\tdouble PixelClock[],",
        "\t\tint dpte_row_width_luma_ub[],",
        "\t\tint dpte_row_width_chroma_ub[],",
        "\t\tint vm_group_bytes[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 517,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble DCCFractionOfZeroSizeRequestsChroma[],",
        "\t\tint HTotal[],",
        "\t\tint VTotal[],",
        "\t\tdouble PixelClock[],",
        "\t\tdouble VRatio[],",
        "\t\tenum scan_direction_class SourceScan[],",
        "\t\tint BlockHeight256BytesY[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 649,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double UrgentLatencyAdjustmentFabricClock",
      "context": [
        "\t\tdouble UrgentLatencyPixelMixedWithVMData,",
        "\t\tdouble UrgentLatencyVMDataOnly,",
        "\t\tbool DoUrgentLatencyAdjustment,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
        "\t\tdouble FabricClockSingle);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 650,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double UrgentLatencyAdjustmentFabricClock",
      "context": [
        "\t\tdouble UrgentLatencyVMDataOnly,",
        "\t\tbool DoUrgentLatencyAdjustment,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
        "\t\tdouble FabricClockSingle);",
        "",
        "static void CalculateUnboundedRequestAndCompressedBufferSize("
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 651,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double FabricClock",
      "context": [
        "\t\tbool DoUrgentLatencyAdjustment,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
        "\t\tdouble FabricClockSingle);",
        "",
        "static void CalculateUnboundedRequestAndCompressedBufferSize(",
        "\t\tunsigned int DETBufferSizeInKByte,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 671,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tunsigned int VActive,",
        "\t\tunsigned int VBlankNom,",
        "\t\tunsigned int HTotal,",
        "\t\tdouble PixelClock,",
        "\t\tbool ProgressiveTointerlaceUnitinOPP,",
        "\t\tbool Interlace,",
        "\t\tunsigned int VBlankNomDefaultUS,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 1477,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double RoundToDFSGranularityUp(double Clock",
      "context": [
        "\treturn MyError;",
        "}",
        "",
        "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed)",
        "{",
        "\treturn VCOSpeed * 4 / dml_floor(VCOSpeed * 4 / Clock, 1);",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 1482,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double RoundToDFSGranularityDown(double Clock",
      "context": [
        "\treturn VCOSpeed * 4 / dml_floor(VCOSpeed * 4 / Clock, 1);",
        "}",
        "",
        "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed)",
        "{",
        "\treturn VCOSpeed * 4 / dml_ceil(VCOSpeed * 4.0 / Clock, 1);",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 2605,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double TWait = CalculateTWait(PrefetchMode, v->DRAMClock",
      "context": [
        "\t\tdouble MaxTotalRDBandwidthNoUrgentBurst = 0.0;",
        "\t\tbool DestinationLineTimesForPrefetchLessThan2 = false;",
        "\t\tbool VRatioPrefetchMoreThan4 = false;",
        "\t\tdouble TWait = CalculateTWait(PrefetchMode, v->DRAMClockChangeLatency, v->UrgentLatency, v->SREnterPlusExitTime);",
        "",
        "\t\tMaxTotalRDBandwidth = 0;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 3150,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double Tvstartup_margin = (v->MaxVStartupLines[k] - v->VStartup[k]) * v->HTotal[k] / v->PixelClock",
      "context": [
        "\t// VStartup Adjustment",
        "\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {",
        "\t\tbool isInterlaceTiming;",
        "\t\tdouble Tvstartup_margin = (v->MaxVStartupLines[k] - v->VStartup[k]) * v->HTotal[k] / v->PixelClock[k];",
        "#ifdef __DML_VBA_DEBUG__",
        "\t\tdml_print(\"DML::%s: k=%d, MinTTUVBlank = %f (before margin)\\n\", __func__, k, v->MinTTUVBlank[k]);",
        "#endif"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 3176,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)v->HTotal[k] / v->PixelClock",
      "context": [
        "\t\t} else {",
        "\t\t\tv->MIN_DST_Y_NEXT_START[k] = v->VTotal[k] - v->VFrontPorch[k] + v->VTotal[k] - v->VActive[k] - v->VStartup[k];",
        "\t\t}",
        "\t\tv->MIN_DST_Y_NEXT_START[k] += dml_floor(4.0 * v->TSetup[k] / ((double)v->HTotal[k] / v->PixelClock[k]), 1.0) / 4.0;",
        "\t\tif (((v->VUpdateOffsetPix[k] + v->VUpdateWidthPix[k] + v->VReadyOffsetPix[k]) / v->HTotal[k])",
        "\t\t\t\t<= (isInterlaceTiming ?",
        "\t\t\t\t\t\tdml_floor((v->VTotal[k] - v->VActive[k] - v->VFrontPorch[k] - v->VStartup[k]) / 2.0, 1.0) :"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 3451,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double CalculateTWait(unsigned int PrefetchMode, double DRAMClock",
      "context": [
        "\treturn true;",
        "}",
        "",
        "static double CalculateTWait(unsigned int PrefetchMode, double DRAMClockChangeLatency, double UrgentLatency, double SREnterPlusExitTime)",
        "{",
        "\tif (PrefetchMode == 0) {",
        "\t\treturn dml_max(DRAMClockChangeLatency + UrgentLatency, dml_max(SREnterPlusExitTime, UrgentLatency));"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 3464,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "",
        "double dml314_CalculateWriteBackDISPCLK(",
        "\t\tenum source_format_class WritebackPixelFormat,",
        "\t\tdouble PixelClock,",
        "\t\tdouble WritebackHRatio,",
        "\t\tdouble WritebackVRatio,",
        "\t\tunsigned int WritebackHTaps,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 3513,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble DPPCLK,",
        "\t\tdouble DISPCLK,",
        "\t\tdouble DCFClkDeepSleep,",
        "\t\tdouble PixelClock,",
        "\t\tint HTotal,",
        "\t\tint VBlank,",
        "\t\tint DynamicMetadataTransmittedBytes,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 3604,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double LineTime = v->HTotal[k] / v->PixelClock",
      "context": [
        "\tdouble TimeForFetchingMetaPTEImmediateFlip;",
        "\tdouble TimeForFetchingRowInVBlankImmediateFlip;",
        "\tdouble ImmediateFlipBW = 1.0;",
        "\tdouble LineTime = v->HTotal[k] / v->PixelClock[k];",
        "",
        "\tif (v->GPUVMEnable == true && v->HostVMEnable == true) {",
        "\t\tHostVMDynamicLevelsTrips = v->HostVMMaxNonCachedPageTableLevels;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 3692,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tint Lanes,",
        "\t\tint HTotal,",
        "\t\tint HActive,",
        "\t\tdouble PixelClock,",
        "\t\tdouble DesiredBPP,",
        "\t\tbool DSCEnable,",
        "\t\tenum output_encoder_class Output,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 5672,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double ActiveDRAMClock",
      "context": [
        "\tunsigned int LinesInDETCRoundedDownToSwath;",
        "\tdouble FullDETBufferingTimeY;",
        "\tdouble FullDETBufferingTimeC;",
        "\tdouble ActiveDRAMClockChangeLatencyMarginY;",
        "\tdouble ActiveDRAMClockChangeLatencyMarginC;",
        "\tdouble WritebackDRAMClockChangeLatencyMargin;",
        "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 5673,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double ActiveDRAMClock",
      "context": [
        "\tdouble FullDETBufferingTimeY;",
        "\tdouble FullDETBufferingTimeC;",
        "\tdouble ActiveDRAMClockChangeLatencyMarginY;",
        "\tdouble ActiveDRAMClockChangeLatencyMarginC;",
        "\tdouble WritebackDRAMClockChangeLatencyMargin;",
        "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;",
        "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 5674,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double WritebackDRAMClock",
      "context": [
        "\tdouble FullDETBufferingTimeC;",
        "\tdouble ActiveDRAMClockChangeLatencyMarginY;",
        "\tdouble ActiveDRAMClockChangeLatencyMarginC;",
        "\tdouble WritebackDRAMClockChangeLatencyMargin;",
        "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;",
        "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank;",
        "\tdouble WritebackDRAMClockChangeLatencyHiding;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 5675,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PlaneWithMinActiveDRAMClock",
      "context": [
        "\tdouble ActiveDRAMClockChangeLatencyMarginY;",
        "\tdouble ActiveDRAMClockChangeLatencyMarginC;",
        "\tdouble WritebackDRAMClockChangeLatencyMargin;",
        "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;",
        "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank;",
        "\tdouble WritebackDRAMClockChangeLatencyHiding;",
        "\tdouble TotalPixelBW = 0.0;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 5676,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double SecondMinActiveDRAMClock",
      "context": [
        "\tdouble ActiveDRAMClockChangeLatencyMarginC;",
        "\tdouble WritebackDRAMClockChangeLatencyMargin;",
        "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;",
        "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank;",
        "\tdouble WritebackDRAMClockChangeLatencyHiding;",
        "\tdouble TotalPixelBW = 0.0;",
        "\tint k, j;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 5677,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double WritebackDRAMClock",
      "context": [
        "\tdouble WritebackDRAMClockChangeLatencyMargin;",
        "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;",
        "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank;",
        "\tdouble WritebackDRAMClockChangeLatencyHiding;",
        "\tdouble TotalPixelBW = 0.0;",
        "\tint k, j;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 5754,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double) v->DSTXAfterScaler[k] / v->HTotal[k] + v->DSTYAfterScaler[k]) * v->HTotal[k] / v->PixelClock[k] - v->UrgentWatermark - v->DRAMClock",
      "context": [
        "\t\t}",
        "",
        "\t\tActiveDRAMClockChangeLatencyMarginY = EffectiveLBLatencyHidingY + FullDETBufferingTimeY",
        "\t\t\t\t- ((double) v->DSTXAfterScaler[k] / v->HTotal[k] + v->DSTYAfterScaler[k]) * v->HTotal[k] / v->PixelClock[k] - v->UrgentWatermark - v->DRAMClockChangeWatermark;",
        "",
        "\t\tif (v->NumberOfActivePlanes > 1) {",
        "\t\t\tActiveDRAMClockChangeLatencyMarginY = ActiveDRAMClockChangeLatencyMarginY"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 5763,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double) v->DSTXAfterScaler[k] / v->HTotal[k] + v->DSTYAfterScaler[k]) * v->HTotal[k] / v->PixelClock[k] - v->UrgentWatermark - v->DRAMClock",
      "context": [
        "",
        "\t\tif (BytePerPixelDETC[k] > 0) {",
        "\t\t\tActiveDRAMClockChangeLatencyMarginC = EffectiveLBLatencyHidingC + FullDETBufferingTimeC",
        "\t\t\t\t\t- ((double) v->DSTXAfterScaler[k] / v->HTotal[k] + v->DSTYAfterScaler[k]) * v->HTotal[k] / v->PixelClock[k] - v->UrgentWatermark - v->DRAMClockChangeWatermark;",
        "",
        "\t\t\tif (v->NumberOfActivePlanes > 1) {",
        "\t\t\t\tActiveDRAMClockChangeLatencyMarginC = ActiveDRAMClockChangeLatencyMarginC"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 5854,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tunsigned int DPPPerPlane[],",
        "\t\tdouble HRatio[],",
        "\t\tdouble HRatioChroma[],",
        "\t\tdouble PixelClock[],",
        "\t\tdouble PSCL_THROUGHPUT[],",
        "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
        "\t\tdouble DPPCLK[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 5992,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tunsigned int DPPPerPlane[],",
        "\t\tdouble HRatio[],",
        "\t\tdouble HRatioChroma[],",
        "\t\tdouble PixelClock[],",
        "\t\tdouble PSCL_THROUGHPUT[],",
        "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
        "\t\tdouble DPPCLK[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 6127,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble DestinationLinesToRequestRowInVBlank[],",
        "\t\tdouble DestinationLinesToRequestRowInImmediateFlip[],",
        "\t\tbool DCCEnable[],",
        "\t\tdouble PixelClock[],",
        "\t\tint BytePerPixelY[],",
        "\t\tint BytePerPixelC[],",
        "\t\tenum scan_direction_class SourceScan[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 6298,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble DestinationLinesToRequestVMInVBlank[],",
        "\t\tdouble DestinationLinesToRequestVMInImmediateFlip[],",
        "\t\tbool DCCEnable[],",
        "\t\tdouble PixelClock[],",
        "\t\tint dpte_row_width_luma_ub[],",
        "\t\tint dpte_row_width_chroma_ub[],",
        "\t\tint vm_group_bytes[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 6424,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble DCCFractionOfZeroSizeRequestsChroma[],",
        "\t\tint HTotal[],",
        "\t\tint VTotal[],",
        "\t\tdouble PixelClock[],",
        "\t\tdouble VRatio[],",
        "\t\tenum scan_direction_class SourceScan[],",
        "\t\tint BlockHeight256BytesY[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 7100,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double UrgentLatencyAdjustmentFabricClock",
      "context": [
        "\t\tdouble UrgentLatencyPixelMixedWithVMData,",
        "\t\tdouble UrgentLatencyVMDataOnly,",
        "\t\tbool DoUrgentLatencyAdjustment,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
        "\t\tdouble FabricClock)",
        "{"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 7101,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double UrgentLatencyAdjustmentFabricClock",
      "context": [
        "\t\tdouble UrgentLatencyVMDataOnly,",
        "\t\tbool DoUrgentLatencyAdjustment,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
        "\t\tdouble FabricClock)",
        "{",
        "\tdouble ret;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 7102,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double FabricClock",
      "context": [
        "\t\tbool DoUrgentLatencyAdjustment,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
        "\t\tdouble FabricClock)",
        "{",
        "\tdouble ret;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 7321,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tunsigned int VActive,",
        "\t\tunsigned int VBlankNom,",
        "\t\tunsigned int HTotal,",
        "\t\tdouble PixelClock,",
        "\t\tbool ProgressiveTointerlaceUnitinOPP,",
        "\t\tbool Interlace,",
        "\t\tunsigned int VBlankNomDefaultUS,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
      "line": 7329,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double line_time_us = HTotal / PixelClock",
      "context": [
        "{",
        "\tunsigned int MaxVStartup = 0;",
        "\tunsigned int vblank_size = 0;",
        "\tdouble line_time_us = HTotal / PixelClock;",
        "\tunsigned int vblank_actual = VTotal - VActive;",
        "\tunsigned int vblank_nom_default_in_line = dml_floor(VBlankNomDefaultUS / line_time_us, 1.0);",
        "\tunsigned int vblank_nom_input = VBlankNom; //dml_min(VBlankNom, vblank_nom_default_in_line);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 65,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "typedef struct {",
        "\tdouble DPPCLK;",
        "\tdouble DISPCLK;",
        "\tdouble PixelClock;",
        "\tdouble DCFCLKDeepSleep;",
        "\tunsigned int DPPPerPlane;",
        "\tbool ScalerEnabled;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 163,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double RoundToDFSGranularityUp(double Clock",
      "context": [
        "\t\tint *VUpdateOffsetPix,",
        "\t\tdouble *VUpdateWidthPix,",
        "\t\tdouble *VReadyOffsetPix);",
        "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed);",
        "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed);",
        "static void CalculateDCCConfiguration(",
        "\t\tbool DCCEnabled,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 164,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double RoundToDFSGranularityDown(double Clock",
      "context": [
        "\t\tdouble *VUpdateWidthPix,",
        "\t\tdouble *VReadyOffsetPix);",
        "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed);",
        "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed);",
        "static void CalculateDCCConfiguration(",
        "\t\tbool DCCEnabled,",
        "\t\tbool DCCProgrammingAssumesScanDirectionUnknown,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 234,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double CalculateTWait(unsigned int PrefetchMode, double DRAMClock",
      "context": [
        "\t\tunsigned int *PTERequestSize,",
        "\t\tint *DPDE0BytesFrame,",
        "\t\tint *MetaPTEBytesFrame);",
        "static double CalculateTWait(unsigned int PrefetchMode, double DRAMClockChangeLatency, double UrgentLatency, double SREnterPlusExitTime);",
        "static void CalculateRowBandwidth(",
        "\t\tbool GPUVMEnable,",
        "\t\tenum source_format_class SourcePixelFormat,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 277,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble DPPCLK,",
        "\t\tdouble DISPCLK,",
        "\t\tdouble DCFClkDeepSleep,",
        "\t\tdouble PixelClock,",
        "\t\tint HTotal,",
        "\t\tint VBlank,",
        "\t\tint DynamicMetadataTransmittedBytes,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 330,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tunsigned int DPPPerPlane[],",
        "\t\tdouble HRatio[],",
        "\t\tdouble HRatioChroma[],",
        "\t\tdouble PixelClock[],",
        "\t\tdouble PSCL_THROUGHPUT[],",
        "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
        "\t\tdouble DPPCLK[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 376,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tunsigned int DPPPerPlane[],",
        "\t\tdouble HRatio[],",
        "\t\tdouble HRatioChroma[],",
        "\t\tdouble PixelClock[],",
        "\t\tdouble PSCL_THROUGHPUT[],",
        "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
        "\t\tdouble DPPCLK[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 411,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble DestinationLinesToRequestRowInVBlank[],",
        "\t\tdouble DestinationLinesToRequestRowInImmediateFlip[],",
        "\t\tbool DCCEnable[],",
        "\t\tdouble PixelClock[],",
        "\t\tint BytePerPixelY[],",
        "\t\tint BytePerPixelC[],",
        "\t\tenum scan_direction_class SourceScan[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 460,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble DestinationLinesToRequestVMInVBlank[],",
        "\t\tdouble DestinationLinesToRequestVMInImmediateFlip[],",
        "\t\tbool DCCEnable[],",
        "\t\tdouble PixelClock[],",
        "\t\tint dpte_row_width_luma_ub[],",
        "\t\tint dpte_row_width_chroma_ub[],",
        "\t\tint vm_group_bytes[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 508,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble DCCFractionOfZeroSizeRequestsChroma[],",
        "\t\tint HTotal[],",
        "\t\tint VTotal[],",
        "\t\tdouble PixelClock[],",
        "\t\tdouble VRatio[],",
        "\t\tenum scan_direction_class SourceScan[],",
        "\t\tint BlockHeight256BytesY[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 641,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double UrgentLatencyAdjustmentFabricClock",
      "context": [
        "\t\tdouble UrgentLatencyPixelMixedWithVMData,",
        "\t\tdouble UrgentLatencyVMDataOnly,",
        "\t\tbool DoUrgentLatencyAdjustment,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
        "\t\tdouble FabricClockSingle);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 642,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double UrgentLatencyAdjustmentFabricClock",
      "context": [
        "\t\tdouble UrgentLatencyVMDataOnly,",
        "\t\tbool DoUrgentLatencyAdjustment,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
        "\t\tdouble FabricClockSingle);",
        "",
        "static void CalculateUnboundedRequestAndCompressedBufferSize("
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 643,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double FabricClock",
      "context": [
        "\t\tbool DoUrgentLatencyAdjustment,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
        "\t\tdouble FabricClockSingle);",
        "",
        "static void CalculateUnboundedRequestAndCompressedBufferSize(",
        "\t\tunsigned int DETBufferSizeInKByte,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 1460,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double RoundToDFSGranularityUp(double Clock",
      "context": [
        "\treturn MyError;",
        "}",
        "",
        "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed)",
        "{",
        "\treturn VCOSpeed * 4 / dml_floor(VCOSpeed * 4 / Clock, 1);",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 1465,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double RoundToDFSGranularityDown(double Clock",
      "context": [
        "\treturn VCOSpeed * 4 / dml_floor(VCOSpeed * 4 / Clock, 1);",
        "}",
        "",
        "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed)",
        "{",
        "\treturn VCOSpeed * 4 / dml_ceil(VCOSpeed * 4.0 / Clock, 1);",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 2587,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double TWait = CalculateTWait(PrefetchMode, v->DRAMClock",
      "context": [
        "\t\tdouble MaxTotalRDBandwidthNoUrgentBurst = 0.0;",
        "\t\tbool DestinationLineTimesForPrefetchLessThan2 = false;",
        "\t\tbool VRatioPrefetchMoreThan4 = false;",
        "\t\tdouble TWait = CalculateTWait(PrefetchMode, v->DRAMClockChangeLatency, v->UrgentLatency, v->SREnterPlusExitTime);",
        "\t\tMaxTotalRDBandwidth = 0;",
        "",
        "\t\tdml_print(\"DML::%s: Start loop: VStartup = %d\\n\", __func__, v->VStartupLines);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 3131,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double Tvstartup_margin = (v->MaxVStartupLines[k] - v->VStartup[k]) * v->HTotal[k] / v->PixelClock",
      "context": [
        "\t// VStartup Adjustment",
        "\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {",
        "\t\tbool isInterlaceTiming;",
        "\t\tdouble Tvstartup_margin = (v->MaxVStartupLines[k] - v->VStartup[k]) * v->HTotal[k] / v->PixelClock[k];",
        "#ifdef __DML_VBA_DEBUG__",
        "\t\tdml_print(\"DML::%s: k=%d, MinTTUVBlank = %f (before margin)\\n\", __func__, k, v->MinTTUVBlank[k]);",
        "#endif"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 3345,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double CalculateTWait(unsigned int PrefetchMode, double DRAMClock",
      "context": [
        "\t\t\t&dummysinglestring);",
        "}",
        "",
        "static double CalculateTWait(unsigned int PrefetchMode, double DRAMClockChangeLatency, double UrgentLatency, double SREnterPlusExitTime)",
        "{",
        "\tif (PrefetchMode == 0) {",
        "\t\treturn dml_max(DRAMClockChangeLatency + UrgentLatency, dml_max(SREnterPlusExitTime, UrgentLatency));"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 3358,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "",
        "double dml31_CalculateWriteBackDISPCLK(",
        "\t\tenum source_format_class WritebackPixelFormat,",
        "\t\tdouble PixelClock,",
        "\t\tdouble WritebackHRatio,",
        "\t\tdouble WritebackVRatio,",
        "\t\tunsigned int WritebackHTaps,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 3407,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble DPPCLK,",
        "\t\tdouble DISPCLK,",
        "\t\tdouble DCFClkDeepSleep,",
        "\t\tdouble PixelClock,",
        "\t\tint HTotal,",
        "\t\tint VBlank,",
        "\t\tint DynamicMetadataTransmittedBytes,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 3498,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double LineTime = v->HTotal[k] / v->PixelClock",
      "context": [
        "\tdouble TimeForFetchingMetaPTEImmediateFlip;",
        "\tdouble TimeForFetchingRowInVBlankImmediateFlip;",
        "\tdouble ImmediateFlipBW = 1.0;",
        "\tdouble LineTime = v->HTotal[k] / v->PixelClock[k];",
        "",
        "\tif (v->GPUVMEnable == true && v->HostVMEnable == true) {",
        "\t\tHostVMDynamicLevelsTrips = v->HostVMMaxNonCachedPageTableLevels;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 3586,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tint Lanes,",
        "\t\tint HTotal,",
        "\t\tint HActive,",
        "\t\tdouble PixelClock,",
        "\t\tdouble DesiredBPP,",
        "\t\tbool DSCEnable,",
        "\t\tenum output_encoder_class Output,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 5578,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double ActiveDRAMClock",
      "context": [
        "\tunsigned int LinesInDETCRoundedDownToSwath;",
        "\tdouble FullDETBufferingTimeY;",
        "\tdouble FullDETBufferingTimeC;",
        "\tdouble ActiveDRAMClockChangeLatencyMarginY;",
        "\tdouble ActiveDRAMClockChangeLatencyMarginC;",
        "\tdouble WritebackDRAMClockChangeLatencyMargin;",
        "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 5579,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double ActiveDRAMClock",
      "context": [
        "\tdouble FullDETBufferingTimeY;",
        "\tdouble FullDETBufferingTimeC;",
        "\tdouble ActiveDRAMClockChangeLatencyMarginY;",
        "\tdouble ActiveDRAMClockChangeLatencyMarginC;",
        "\tdouble WritebackDRAMClockChangeLatencyMargin;",
        "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;",
        "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 5580,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double WritebackDRAMClock",
      "context": [
        "\tdouble FullDETBufferingTimeC;",
        "\tdouble ActiveDRAMClockChangeLatencyMarginY;",
        "\tdouble ActiveDRAMClockChangeLatencyMarginC;",
        "\tdouble WritebackDRAMClockChangeLatencyMargin;",
        "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;",
        "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank;",
        "\tdouble WritebackDRAMClockChangeLatencyHiding;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 5581,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PlaneWithMinActiveDRAMClock",
      "context": [
        "\tdouble ActiveDRAMClockChangeLatencyMarginY;",
        "\tdouble ActiveDRAMClockChangeLatencyMarginC;",
        "\tdouble WritebackDRAMClockChangeLatencyMargin;",
        "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;",
        "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank;",
        "\tdouble WritebackDRAMClockChangeLatencyHiding;",
        "\tdouble TotalPixelBW = 0.0;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 5582,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double SecondMinActiveDRAMClock",
      "context": [
        "\tdouble ActiveDRAMClockChangeLatencyMarginC;",
        "\tdouble WritebackDRAMClockChangeLatencyMargin;",
        "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;",
        "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank;",
        "\tdouble WritebackDRAMClockChangeLatencyHiding;",
        "\tdouble TotalPixelBW = 0.0;",
        "\tint k, j;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 5583,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double WritebackDRAMClock",
      "context": [
        "\tdouble WritebackDRAMClockChangeLatencyMargin;",
        "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;",
        "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank;",
        "\tdouble WritebackDRAMClockChangeLatencyHiding;",
        "\tdouble TotalPixelBW = 0.0;",
        "\tint k, j;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 5660,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double) v->DSTXAfterScaler[k] / v->HTotal[k] + v->DSTYAfterScaler[k]) * v->HTotal[k] / v->PixelClock[k] - v->UrgentWatermark - v->DRAMClock",
      "context": [
        "\t\t}",
        "",
        "\t\tActiveDRAMClockChangeLatencyMarginY = EffectiveLBLatencyHidingY + FullDETBufferingTimeY",
        "\t\t\t\t- ((double) v->DSTXAfterScaler[k] / v->HTotal[k] + v->DSTYAfterScaler[k]) * v->HTotal[k] / v->PixelClock[k] - v->UrgentWatermark - v->DRAMClockChangeWatermark;",
        "",
        "\t\tif (v->NumberOfActivePlanes > 1) {",
        "\t\t\tActiveDRAMClockChangeLatencyMarginY = ActiveDRAMClockChangeLatencyMarginY"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 5669,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double) v->DSTXAfterScaler[k] / v->HTotal[k] + v->DSTYAfterScaler[k]) * v->HTotal[k] / v->PixelClock[k] - v->UrgentWatermark - v->DRAMClock",
      "context": [
        "",
        "\t\tif (BytePerPixelDETC[k] > 0) {",
        "\t\t\tActiveDRAMClockChangeLatencyMarginC = EffectiveLBLatencyHidingC + FullDETBufferingTimeC",
        "\t\t\t\t\t- ((double) v->DSTXAfterScaler[k] / v->HTotal[k] + v->DSTYAfterScaler[k]) * v->HTotal[k] / v->PixelClock[k] - v->UrgentWatermark - v->DRAMClockChangeWatermark;",
        "",
        "\t\t\tif (v->NumberOfActivePlanes > 1) {",
        "\t\t\t\tActiveDRAMClockChangeLatencyMarginC = ActiveDRAMClockChangeLatencyMarginC"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 5760,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tunsigned int DPPPerPlane[],",
        "\t\tdouble HRatio[],",
        "\t\tdouble HRatioChroma[],",
        "\t\tdouble PixelClock[],",
        "\t\tdouble PSCL_THROUGHPUT[],",
        "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
        "\t\tdouble DPPCLK[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 5898,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tunsigned int DPPPerPlane[],",
        "\t\tdouble HRatio[],",
        "\t\tdouble HRatioChroma[],",
        "\t\tdouble PixelClock[],",
        "\t\tdouble PSCL_THROUGHPUT[],",
        "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
        "\t\tdouble DPPCLK[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 6032,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble DestinationLinesToRequestRowInVBlank[],",
        "\t\tdouble DestinationLinesToRequestRowInImmediateFlip[],",
        "\t\tbool DCCEnable[],",
        "\t\tdouble PixelClock[],",
        "\t\tint BytePerPixelY[],",
        "\t\tint BytePerPixelC[],",
        "\t\tenum scan_direction_class SourceScan[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 6203,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble DestinationLinesToRequestVMInVBlank[],",
        "\t\tdouble DestinationLinesToRequestVMInImmediateFlip[],",
        "\t\tbool DCCEnable[],",
        "\t\tdouble PixelClock[],",
        "\t\tint dpte_row_width_luma_ub[],",
        "\t\tint dpte_row_width_chroma_ub[],",
        "\t\tint vm_group_bytes[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 6329,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble DCCFractionOfZeroSizeRequestsChroma[],",
        "\t\tint HTotal[],",
        "\t\tint VTotal[],",
        "\t\tdouble PixelClock[],",
        "\t\tdouble VRatio[],",
        "\t\tenum scan_direction_class SourceScan[],",
        "\t\tint BlockHeight256BytesY[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 7012,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double UrgentLatencyAdjustmentFabricClock",
      "context": [
        "\t\tdouble UrgentLatencyPixelMixedWithVMData,",
        "\t\tdouble UrgentLatencyVMDataOnly,",
        "\t\tbool DoUrgentLatencyAdjustment,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
        "\t\tdouble FabricClock)",
        "{"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 7013,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double UrgentLatencyAdjustmentFabricClock",
      "context": [
        "\t\tdouble UrgentLatencyVMDataOnly,",
        "\t\tbool DoUrgentLatencyAdjustment,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
        "\t\tdouble FabricClock)",
        "{",
        "\tdouble ret;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
      "line": 7014,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double FabricClock",
      "context": [
        "\t\tbool DoUrgentLatencyAdjustment,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
        "\t\tdouble FabricClock)",
        "{",
        "\tdouble ret;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\dcn32_fpu.c",
      "line": 189,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double pstate_latency_us = clk_mgr->base.ctx->dc->dml.soc.dram_clock",
      "context": [
        "void dcn32_build_wm_range_table_fpu(struct clk_mgr_internal *clk_mgr)",
        "{",
        "\t/* defaults */",
        "\tdouble pstate_latency_us = clk_mgr->base.ctx->dc->dml.soc.dram_clock_change_latency_us;",
        "\tdouble fclk_change_latency_us = clk_mgr->base.ctx->dc->dml.soc.fclk_change_latency_us;",
        "\tdouble sr_exit_time_us = clk_mgr->base.ctx->dc->dml.soc.sr_exit_time_us;",
        "\tdouble sr_enter_plus_exit_time_us = clk_mgr->base.ctx->dc->dml.soc.sr_enter_plus_exit_time_us;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\dcn32_fpu.c",
      "line": 2306,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double dcfclk = dcn3_2_soc.clock",
      "context": [
        "\t\t\t\tint vlevel)",
        "{",
        "\tint i, pipe_idx, vlevel_temp = 0;",
        "\tdouble dcfclk = dcn3_2_soc.clock_limits[0].dcfclk_mhz;",
        "\tdouble dcfclk_from_validation = context->bw_ctx.dml.vba.DCFCLKState[vlevel][context->bw_ctx.dml.vba.maxMpcComb];",
        "\tdouble dram_speed_from_validation = context->bw_ctx.dml.vba.DRAMSpeed;",
        "\tdouble dcfclk_from_fw_based_mclk_switching = dcfclk_from_validation;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 205,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble VRatioChroma,",
        "\t\tdouble MaxDCHUBToPSCLThroughput,",
        "\t\tdouble MaxPSCLToLBThroughput,",
        "\t\tdouble PixelClock,",
        "\t\tenum source_format_class SourcePixelFormat,",
        "\t\tunsigned int HTaps,",
        "\t\tunsigned int HTapsChroma,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 1192,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tbool DSCEnable,",
        "\t\tunsigned int TotalNumberOfActiveDPP,",
        "\t\tunsigned int MaxNumDPP,",
        "\t\tdouble PixelClock,",
        "\t\tdouble DISPCLKDPPCLKDSCCLKDownSpreading,",
        "\t\tdouble DISPCLKRampingMargin,",
        "\t\tdouble DISPCLKDPPCLKVCOSpeed,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 1286,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "",
        "double dml32_CalculateRequiredDispclk(",
        "\t\tenum odm_combine_mode ODMMode,",
        "\t\tdouble PixelClock,",
        "\t\tdouble DISPCLKDPPCLKDSCCLKDownSpreading,",
        "\t\tdouble DISPCLKRampingMargin,",
        "\t\tdouble DISPCLKDPPCLKVCOSpeed,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 1293,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble MaxDispclk)",
        "{",
        "\tdouble RequiredDispclk = 0.;",
        "\tdouble PixelClockAfterODM;",
        "\tdouble DISPCLKWithRampingRoundedToDFSGranularity;",
        "\tdouble DISPCLKWithoutRampingRoundedToDFSGranularity;",
        "\tdouble MaxDispclkRoundedDownToDFSGranularity;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 1325,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double dml32_RoundToDFSGranularity(double Clock",
      "context": [
        "\treturn RequiredDispclk;",
        "}",
        "",
        "double dml32_RoundToDFSGranularity(double Clock, bool round_up, double VCOSpeed)",
        "{",
        "\tif (Clock <= 0.0)",
        "\t\treturn 0.0;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 1346,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tenum output_format_class OutputFormat,",
        "\t\tunsigned int HTotal,",
        "\t\tunsigned int HActive,",
        "\t\tdouble PixelClockBackEnd,",
        "\t\tdouble ForcedOutputLinkBPP,",
        "\t\tunsigned int DSCInputBitPerComponent,",
        "\t\tunsigned int NumberOfDSCSlices,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 1578,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tunsigned int Lanes,",
        "\t\tunsigned int HTotal,",
        "\t\tunsigned int HActive,",
        "\t\tdouble PixelClock,",
        "\t\tdouble DesiredBPP,",
        "\t\tbool DSCEnable,",
        "\t\tenum output_encoder_class Output,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 1689,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double               PixelClock",
      "context": [
        "",
        "double dml32_RequiredDTBCLK(",
        "\t\tbool              DSCEnable,",
        "\t\tdouble               PixelClock,",
        "\t\tenum output_format_class  OutputFormat,",
        "\t\tdouble               OutputBpp,",
        "\t\tunsigned int              DSCSlices,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 1726,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tunsigned int NumberOfDSCSlices,",
        "\t\tenum output_format_class  OutputFormat,",
        "\t\tenum output_encoder_class Output,",
        "\t\tdouble PixelClock,",
        "\t\tdouble PixelClockBackEnd,",
        "\t\tdouble dsc_delay_factor_wa)",
        "{"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 1727,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tenum output_format_class  OutputFormat,",
        "\t\tenum output_encoder_class Output,",
        "\t\tdouble PixelClock,",
        "\t\tdouble PixelClockBackEnd,",
        "\t\tdouble dsc_delay_factor_wa)",
        "{",
        "\tunsigned int DSCDelayRequirement_val;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 2711,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double UrgentLatencyAdjustmentFabricClock",
      "context": [
        "\t\tdouble UrgentLatencyPixelMixedWithVMData,",
        "\t\tdouble UrgentLatencyVMDataOnly,",
        "\t\tbool   DoUrgentLatencyAdjustment,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
        "\t\tdouble FabricClock)",
        "{"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 2712,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double UrgentLatencyAdjustmentFabricClock",
      "context": [
        "\t\tdouble UrgentLatencyVMDataOnly,",
        "\t\tbool   DoUrgentLatencyAdjustment,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
        "\t\tdouble FabricClock)",
        "{",
        "\tdouble   ret;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 2713,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double FabricClock",
      "context": [
        "\t\tbool   DoUrgentLatencyAdjustment,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
        "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
        "\t\tdouble FabricClock)",
        "{",
        "\tdouble   ret;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 2820,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tunsigned int DPPPerSurface[],",
        "\t\tdouble HRatio[],",
        "\t\tdouble HRatioChroma[],",
        "\t\tdouble PixelClock[],",
        "\t\tdouble PSCL_THROUGHPUT[],",
        "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
        "\t\tdouble Dppclk[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 2929,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double DRAMClock",
      "context": [
        "\t\tbool SynchronizeDRRDisplaysForUCLKPStateChangeFinal,",
        "\t\tunsigned int MaxInterDCNTileRepeaters,",
        "\t\tunsigned int MaxPrefetchMode,",
        "\t\tdouble DRAMClockChangeLatencyFinal,",
        "\t\tdouble FCLKChangeLatency,",
        "\t\tdouble SREnterPlusExitTime,",
        "\t\tunsigned int ReturnBusWidth,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 2969,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tunsigned int BytePerPixelY[],",
        "\t\tunsigned int BytePerPixelC[],",
        "\t\tunsigned int HTotal[],",
        "\t\tdouble PixelClock[],",
        "\t\tdouble PDEAndMetaPTEBytesPerFrame[][2][DC__NUM_DPP__MAX],",
        "\t\tdouble DPTEBytesPerRow[][2][DC__NUM_DPP__MAX],",
        "\t\tdouble MetaRowBytes[][2][DC__NUM_DPP__MAX],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 3198,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\t\tdouble Dppclk,",
        "\t\tdouble Dispclk,",
        "\t\tdouble DCFClkDeepSleep,",
        "\t\tdouble PixelClock,",
        "\t\tunsigned int HTotal,",
        "\t\tunsigned int VBlank,",
        "\t\tunsigned int DynamicMetadataTransmittedBytes,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 3253,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double DRAMClock",
      "context": [
        "\t\tenum dm_use_mall_for_pstate_change_mode UseMALLForPStateChange,",
        "\t\tbool SynchronizeDRRDisplaysForUCLKPStateChangeFinal,",
        "\t\tbool DRRDisplay,",
        "\t\tdouble DRAMClockChangeLatency,",
        "\t\tdouble FCLKChangeLatency,",
        "\t\tdouble UrgentLatency,",
        "\t\tdouble SREnterPlusExitTime)"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 3287,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double FabricClock",
      "context": [
        "\t\tconst int VoltageLevel,",
        "\t\tconst bool HostVMEnable,",
        "\t\tconst double DCFCLK,",
        "\t\tconst double FabricClock,",
        "\t\tconst double DRAMSpeed)",
        "{",
        "\tdouble ReturnBW = 0.;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 3292,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double IdealFabricBandwidth     = FabricClock",
      "context": [
        "{",
        "\tdouble ReturnBW = 0.;",
        "\tdouble IdealSDPPortBandwidth    = soc->return_bus_width_bytes /*mode_lib->vba.ReturnBusWidth*/ * DCFCLK;",
        "\tdouble IdealFabricBandwidth     = FabricClock * soc->fabric_datapath_to_dcn_data_return_bytes;",
        "\tdouble IdealDRAMBandwidth       = DRAMSpeed * soc->num_chans * soc->dram_channel_width_bytes;",
        "\tdouble PixelDataOnlyReturnBW    = dml_min3(IdealSDPPortBandwidth * soc->pct_ideal_sdp_bw_after_urgent / 100,",
        "\t\t\tIdealFabricBandwidth * soc->pct_ideal_fabric_bw_after_urgent / 100,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 3329,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double FabricClock",
      "context": [
        "double dml32_get_return_bw_mbps_vm_only(const soc_bounding_box_st *soc,",
        "\t\tconst int VoltageLevel,",
        "\t\tconst double DCFCLK,",
        "\t\tconst double FabricClock,",
        "\t\tconst double DRAMSpeed)",
        "{",
        "\tdouble VMDataOnlyReturnBW = dml_min3("
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 4283,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double MaxActiveDRAMClock",
      "context": [
        "",
        "\t\t/* Output */",
        "\t\tenum clock_change_support *DRAMClockChangeSupport,",
        "\t\tdouble MaxActiveDRAMClockChangeLatencySupported[],",
        "\t\tunsigned int SubViewportLinesNeededInMALL[],",
        "\t\tenum dm_fclock_change_support *FCLKChangeSupport,",
        "\t\tdouble *MinActiveFCLKChangeLatencySupported,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 4288,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double ActiveDRAMClock",
      "context": [
        "\t\tenum dm_fclock_change_support *FCLKChangeSupport,",
        "\t\tdouble *MinActiveFCLKChangeLatencySupported,",
        "\t\tbool *USRRetrainingSupport,",
        "\t\tdouble ActiveDRAMClockChangeLatencyMargin[])",
        "{",
        "\tunsigned int i, j, k;",
        "\tunsigned int SurfaceWithMinActiveFCLKChangeMargin = 0;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 4298,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double ActiveClock",
      "context": [
        "\tbool FoundFirstSurfaceWithMinActiveFCLKChangeMargin = false;",
        "\tdouble MinActiveFCLKChangeMargin = 0.;",
        "\tdouble SecondMinActiveFCLKChangeMarginOneDisplayInVBLank = 0.;",
        "\tdouble ActiveClockChangeLatencyHidingY;",
        "\tdouble ActiveClockChangeLatencyHidingC;",
        "\tdouble ActiveClockChangeLatencyHiding;",
        "\tdouble EffectiveDETBufferSizeY;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 4299,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double ActiveClock",
      "context": [
        "\tdouble MinActiveFCLKChangeMargin = 0.;",
        "\tdouble SecondMinActiveFCLKChangeMarginOneDisplayInVBLank = 0.;",
        "\tdouble ActiveClockChangeLatencyHidingY;",
        "\tdouble ActiveClockChangeLatencyHidingC;",
        "\tdouble ActiveClockChangeLatencyHiding;",
        "\tdouble EffectiveDETBufferSizeY;",
        "\tdouble     ActiveFCLKChangeLatencyMargin[DC__NUM_DPP__MAX];"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 4300,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double ActiveClock",
      "context": [
        "\tdouble SecondMinActiveFCLKChangeMarginOneDisplayInVBLank = 0.;",
        "\tdouble ActiveClockChangeLatencyHidingY;",
        "\tdouble ActiveClockChangeLatencyHidingC;",
        "\tdouble ActiveClockChangeLatencyHiding;",
        "\tdouble EffectiveDETBufferSizeY;",
        "\tdouble     ActiveFCLKChangeLatencyMargin[DC__NUM_DPP__MAX];",
        "\tdouble     USRRetrainingLatencyMargin[DC__NUM_DPP__MAX];"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 4314,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double     WritebackDRAMClock",
      "context": [
        "\tunsigned int    LinesInDETCRoundedDownToSwath[DC__NUM_DPP__MAX];",
        "\tdouble     FullDETBufferingTimeY;",
        "\tdouble     FullDETBufferingTimeC;",
        "\tdouble     WritebackDRAMClockChangeLatencyMargin;",
        "\tdouble     WritebackFCLKChangeLatencyMargin;",
        "\tdouble     WritebackLatencyHiding;",
        "\tbool    SameTimingForFCLKChange;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 4647,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "",
        "double dml32_CalculateWriteBackDISPCLK(",
        "\t\tenum source_format_class WritebackPixelFormat,",
        "\t\tdouble PixelClock,",
        "\t\tdouble WritebackHRatio,",
        "\t\tdouble WritebackVRatio,",
        "\t\tunsigned int WritebackHTaps,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 4701,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double              PixelClock",
      "context": [
        "\t\tunsigned int             DPPPerSurface[],",
        "\t\tdouble              HRatio[],",
        "\t\tdouble              HRatioChroma[],",
        "\t\tdouble              PixelClock[],",
        "\t\tdouble              PSCL_THROUGHPUT[],",
        "\t\tdouble              PSCL_THROUGHPUT_CHROMA[],",
        "\t\tdouble              Dppclk[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 4883,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double  PixelClock",
      "context": [
        "\t\tdouble  DestinationLinesToRequestRowInVBlank[],",
        "\t\tdouble  DestinationLinesToRequestRowInImmediateFlip[],",
        "\t\tbool DCCEnable[],",
        "\t\tdouble  PixelClock[],",
        "\t\tunsigned int BytePerPixelY[],",
        "\t\tunsigned int BytePerPixelC[],",
        "\t\tenum dm_rotation_angle SourceRotation[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 5154,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double      PixelClock",
      "context": [
        "\t\tdouble      DestinationLinesToRequestVMInVBlank[],",
        "\t\tdouble      DestinationLinesToRequestVMInImmediateFlip[],",
        "\t\tbool     DCCEnable[],",
        "\t\tdouble      PixelClock[],",
        "\t\tunsigned int        dpte_row_width_luma_ub[],",
        "\t\tunsigned int        dpte_row_width_chroma_ub[],",
        "\t\tunsigned int     vm_group_bytes[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 5623,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double    PixelClock",
      "context": [
        "\t\tdouble    DCCFractionOfZeroSizeRequestsChroma[],",
        "\t\tunsigned int      HTotal[],",
        "\t\tunsigned int      VTotal[],",
        "\t\tdouble    PixelClock[],",
        "\t\tdouble    VRatio[],",
        "\t\tenum dm_rotation_angle SourceRotation[],",
        "\t\tunsigned int   BlockHeight256BytesY[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 5658,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double doublePixelClock",
      "context": [
        "\tdouble LastZ8StutterPeriod = 0.0;",
        "\tdouble LastStutterPeriod = 0.0;",
        "\tunsigned int TotalNumberOfActiveOTG = 0;",
        "\tdouble doublePixelClock = 0;",
        "\tunsigned int doubleHTotal = 0;",
        "\tunsigned int doubleVTotal = 0;",
        "\tbool SameTiming = true;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 5842,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double) HTotal[k] / PixelClock",
      "context": [
        "\t\t\t\t\t\t\t* ReadBandwidthSurfaceLuma[k] / TotalDataReadBandwidth)",
        "\t\t\t\t\t/ BytePerPixelDETY[k] / SwathWidthY[k];",
        "\t\t\tLinesInDETYRoundedDownToSwath = dml_floor(LinesInDETY, SwathHeightY[k]);",
        "\t\t\tDETBufferingTimeY = LinesInDETYRoundedDownToSwath * ((double) HTotal[k] / PixelClock[k])",
        "\t\t\t\t\t/ VRatio[k];",
        "#ifdef __DML_VBA_DEBUG__",
        "\t\t\tdml_print(\"DML::%s: k=%0d, DETBufferSizeY = %d\\n\", __func__, k, DETBufferSizeY[k]);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 5869,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double) HTotal[k] / PixelClock",
      "context": [
        "\t\t\t\tFrameTimeCriticalSurface = (",
        "\t\t\t\t\t\tisInterlaceTiming ?",
        "\t\t\t\t\t\t\t\tdml_floor((double) VTotal[k] / 2.0, 1.0) : VTotal[k])",
        "\t\t\t\t\t\t* (double) HTotal[k] / PixelClock[k];",
        "\t\t\t\tVActiveTimeCriticalSurface = (",
        "\t\t\t\t\t\tisInterlaceTiming ?",
        "\t\t\t\t\t\t\t\tdml_floor((double) VActive[k] / 2.0, 1.0) : VActive[k])"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 5873,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double) HTotal[k] / PixelClock",
      "context": [
        "\t\t\t\tVActiveTimeCriticalSurface = (",
        "\t\t\t\t\t\tisInterlaceTiming ?",
        "\t\t\t\t\t\t\t\tdml_floor((double) VActive[k] / 2.0, 1.0) : VActive[k])",
        "\t\t\t\t\t\t* (double) HTotal[k] / PixelClock[k];",
        "\t\t\t\tBytePerPixelYCriticalSurface = BytePerPixelY[k];",
        "\t\t\t\tSwathWidthYCriticalSurface = SwathWidthY[k];",
        "\t\t\t\tSwathHeightYCriticalSurface = SwathHeightY[k];"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 6000,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "doublePixelClock = PixelClock",
      "context": [
        "\t\tif (UseMALLForPStateChange[k] != dm_use_mall_pstate_change_phantom_pipe) {",
        "\t\t\tif (BlendingAndTiming[k] == k) {",
        "\t\t\t\tif (TotalNumberOfActiveOTG == 0) {",
        "\t\t\t\t\tdoublePixelClock = PixelClock[k];",
        "\t\t\t\t\tdoubleHTotal = HTotal[k];",
        "\t\t\t\t\tdoubleVTotal = VTotal[k];",
        "\t\t\t\t} else if (doublePixelClock != PixelClock[k] || doubleHTotal != HTotal[k]"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 6003,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "doublePixelClock != PixelClock",
      "context": [
        "\t\t\t\t\tdoublePixelClock = PixelClock[k];",
        "\t\t\t\t\tdoubleHTotal = HTotal[k];",
        "\t\t\t\t\tdoubleVTotal = VTotal[k];",
        "\t\t\t\t} else if (doublePixelClock != PixelClock[k] || doubleHTotal != HTotal[k]",
        "\t\t\t\t\t\t|| doubleVTotal != VTotal[k]) {",
        "\t\t\t\t\tSameTiming = false;",
        "\t\t\t\t}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 6292,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double\tPixelClock",
      "context": [
        "\t\tunsigned int    DETBufferSizeC[],",
        "\t\tunsigned int\tNumOfDPP[],",
        "\t\tunsigned int\tHTotal[],",
        "\t\tdouble\tPixelClock[],",
        "\t\tdouble\tVRatioY[],",
        "\t\tdouble\tVRatioC[],",
        "\t\tenum dm_use_mall_for_pstate_change_mode UsesMALLForPStateChange[],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
      "line": 6327,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double LineTime = HTotal[k] / PixelClock",
      "context": [
        "",
        "\t/* ensure all DET - 1 swath can hide a fetch for all surfaces */",
        "\tfor (k = 0; k < NumberOfActiveSurfaces; k++) {",
        "\t\tdouble LineTime = HTotal[k] / PixelClock[k];",
        "",
        "\t\t/* only care if surface is not phantom */",
        "\t\tif (UsesMALLForPStateChange[k] != dm_use_mall_pstate_change_phantom_pipe) {"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_32.c",
      "line": 2869,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double) mode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock",
      "context": [
        "\t\t\t\t\t\tmode_lib->vba.swath_width_chroma_ub_this_state[k],",
        "\t\t\t\t\t\tmode_lib->vba.SwathHeightYThisState[k],",
        "\t\t\t\t\t\tmode_lib->vba.SwathHeightCThisState[k],",
        "\t\t\t\t\t\t(double) mode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k],",
        "\t\t\t\t\t\tmode_lib->vba.UrgLatency[i],",
        "\t\t\t\t\t\tmode_lib->vba.CursorBufferSize,",
        "\t\t\t\t\t\tmode_lib->vba.CursorWidth[k][0],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_32.c",
      "line": 3609,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double *MaxActiveDRAMClock",
      "context": [
        "",
        "\t\t\t\t\t\t/* Output */",
        "\t\t\t\t\t\t&v->DRAMClockChangeSupport[i][j],",
        "\t\t\t\t\t\t&v->dummy_vars.dml32_ModeSupportAndSystemConfigurationFull.dummy_single2[0], // double *MaxActiveDRAMClockChangeLatencySupported",
        "\t\t\t\t\t\t&v->dummy_vars.dml32_ModeSupportAndSystemConfigurationFull.dummy_integer[0], // Long SubViewportLinesNeededInMALL[]",
        "\t\t\t\t\t\t&v->FCLKChangeSupport[i][j],",
        "\t\t\t\t\t\t&v->dummy_vars.dml32_ModeSupportAndSystemConfigurationFull.dummy_single2[1], // double *MinActiveFCLKChangeLatencySupported"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn401\\dcn401_fpu.c",
      "line": 16,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double pstate_latency_us = clk_mgr->ctx->dc->dml.soc.dram_clock",
      "context": [
        "void dcn401_build_wm_range_table_fpu(struct clk_mgr *clk_mgr)",
        "{",
        "\t/* defaults */",
        "\tdouble pstate_latency_us = clk_mgr->ctx->dc->dml.soc.dram_clock_change_latency_us;",
        "\tdouble fclk_change_latency_us = clk_mgr->ctx->dc->dml.soc.fclk_change_latency_us;",
        "\tdouble sr_exit_time_us = clk_mgr->ctx->dc->dml.soc.sr_exit_time_us;",
        "\tdouble sr_enter_plus_exit_time_us = clk_mgr->ctx->dc->dml.soc.sr_enter_plus_exit_time_us;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4.c",
      "line": 13,
      "pattern": "hardcoded.*values",
      "rule": "code_quality",
      "severity": "low",
      "match": "Hardcoded values",
      "context": [
        "#include \"lib_float_math.h\"",
        "",
        "struct dml2_core_ip_params core_dcn4_ip_caps_base = {",
        "\t// Hardcoded values for DCN3x",
        "\t.vblank_nom_default_us = 668,",
        "\t.remote_iommu_outstanding_translations = 256,",
        "\t.rob_buffer_size_kbytes = 128,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_dpmm\\dml2_dpmm_dcn4.c",
      "line": 186,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double clock",
      "context": [
        "\tin_out->programming->min_clocks.dcn4x.idle.dcfclk_khz = dml_round_up(min_dcfclk_avg > min_dcfclk_latency ? min_dcfclk_avg : min_dcfclk_latency);",
        "}",
        "",
        "static bool add_margin_and_round_to_dfs_grainularity(double clock_khz, double margin, unsigned long vco_freq_khz, unsigned long *rounded_khz, uint32_t *divider_id)",
        "{",
        "\tenum dentist_divider_range {",
        "\t\tDFS_DIVIDER_RANGE_1_START = 8, /* 2.00 */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 319,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double, mode_lib->mp.Watermark.DRAMClock",
      "context": [
        "dml_get_var_func(wm_fclk_change, double, mode_lib->mp.Watermark.FCLKChangeWatermark);",
        "dml_get_var_func(wm_usr_retraining, double, mode_lib->mp.Watermark.USRRetrainingWatermark);",
        "dml_get_var_func(wm_temp_read_or_ppt, double, mode_lib->mp.Watermark.temp_read_or_ppt_watermark_us);",
        "dml_get_var_func(wm_dram_clock_change, double, mode_lib->mp.Watermark.DRAMClockChangeWatermark);",
        "dml_get_var_func(fraction_of_urgent_bandwidth, double, mode_lib->mp.FractionOfUrgentBandwidth);",
        "dml_get_var_func(fraction_of_urgent_bandwidth_imm_flip, double, mode_lib->mp.FractionOfUrgentBandwidthImmediateFlip);",
        "dml_get_var_func(fraction_of_urgent_bandwidth_mall, double, mode_lib->mp.FractionOfUrgentBandwidthMALL);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 323,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double, mode_lib->mp.Watermark.WritebackDRAMClock",
      "context": [
        "dml_get_var_func(fraction_of_urgent_bandwidth, double, mode_lib->mp.FractionOfUrgentBandwidth);",
        "dml_get_var_func(fraction_of_urgent_bandwidth_imm_flip, double, mode_lib->mp.FractionOfUrgentBandwidthImmediateFlip);",
        "dml_get_var_func(fraction_of_urgent_bandwidth_mall, double, mode_lib->mp.FractionOfUrgentBandwidthMALL);",
        "dml_get_var_func(wm_writeback_dram_clock_change, double, mode_lib->mp.Watermark.WritebackDRAMClockChangeWatermark);",
        "dml_get_var_func(wm_writeback_fclk_change, double, mode_lib->mp.Watermark.WritebackFCLKChangeWatermark);",
        "dml_get_var_func(stutter_efficiency, double, mode_lib->mp.StutterEfficiency);",
        "dml_get_var_func(stutter_efficiency_no_vblank, double, mode_lib->mp.StutterEfficiencyNotIncludingVBlank);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 428,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double *PixelClock",
      "context": [
        "\t}",
        "}",
        "",
        "static void PixelClockAdjustmentForProgressiveToInterlaceUnit(const struct dml2_display_cfg *display_cfg, bool ptoi_supported, double *PixelClockBackEnd)",
        "{",
        "\t//unsigned int num_active_planes = display_cfg->num_planes;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 434,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "",
        "\t//Progressive To Interlace Unit Effect",
        "\tfor (unsigned int k = 0; k < display_cfg->num_planes; ++k) {",
        "\t\tPixelClockBackEnd[k] = ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
        "\t\tif (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.interlaced == 1 && ptoi_supported == true) {",
        "\t\t\t// FIXME_STAGE2... can sw pass the pixel rate for interlaced directly",
        "\t\t\t//display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz = 2 * display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 772,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\tdouble VRatioChroma,",
        "\tdouble MaxDCHUBToPSCLThroughput,",
        "\tdouble MaxPSCLToLBThroughput,",
        "\tdouble PixelClock,",
        "\tenum dml2_source_format_class SourcePixelFormat,",
        "\tunsigned int HTaps,",
        "\tunsigned int HTapsChroma,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 915,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->plane_descriptors[k].surface.plane0.height, Read256BytesBlock",
      "context": [
        "\t\t\treq_width_horz_c = req_width_horz_c / 2;",
        "",
        "\t\tsurface_width_ub_l = (unsigned int)math_ceil2((double)display_cfg->plane_descriptors[k].surface.plane0.width, req_width_horz_y);",
        "\t\tsurface_height_ub_l = (unsigned int)math_ceil2((double)display_cfg->plane_descriptors[k].surface.plane0.height, Read256BytesBlockHeightY[k]);",
        "\t\tsurface_width_ub_c = (unsigned int)math_ceil2((double)display_cfg->plane_descriptors[k].surface.plane1.width, req_width_horz_c);",
        "\t\tsurface_height_ub_c = (unsigned int)math_ceil2((double)display_cfg->plane_descriptors[k].surface.plane1.height, Read256BytesBlockHeightC[k]);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 917,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->plane_descriptors[k].surface.plane1.height, Read256BytesBlock",
      "context": [
        "\t\tsurface_width_ub_l = (unsigned int)math_ceil2((double)display_cfg->plane_descriptors[k].surface.plane0.width, req_width_horz_y);",
        "\t\tsurface_height_ub_l = (unsigned int)math_ceil2((double)display_cfg->plane_descriptors[k].surface.plane0.height, Read256BytesBlockHeightY[k]);",
        "\t\tsurface_width_ub_c = (unsigned int)math_ceil2((double)display_cfg->plane_descriptors[k].surface.plane1.width, req_width_horz_c);",
        "\t\tsurface_height_ub_c = (unsigned int)math_ceil2((double)display_cfg->plane_descriptors[k].surface.plane1.height, Read256BytesBlockHeightC[k]);",
        "",
        "\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u surface_width_ub_l=%u\\n\", __func__, k, surface_width_ub_l);",
        "\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u surface_height_ub_l=%u\\n\", __func__, k, surface_height_ub_l);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 963,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)SwathWidthY[k] - 1, Read256BytesBlockHeightY[k]) + Read256BytesBlock",
      "context": [
        "\t\t\tif (display_cfg->plane_descriptors[k].composition.viewport.stationary && DPPPerSurface[k] == 1) {",
        "\t\t\t\tswath_width_luma_ub[k] = (unsigned int)(math_min2(surface_height_ub_l, math_floor2(display_cfg->plane_descriptors[k].composition.viewport.plane0.y_start + SwathWidthY[k] + Read256BytesBlockHeightY[k] - 1, Read256BytesBlockHeightY[k]) - math_floor2(display_cfg->plane_descriptors[k].composition.viewport.plane0.y_start, Read256BytesBlockHeightY[k])));",
        "\t\t\t} else {",
        "\t\t\t\tswath_width_luma_ub[k] = (unsigned int)(math_min2(surface_height_ub_l, math_ceil2((double)SwathWidthY[k] - 1, Read256BytesBlockHeightY[k]) + Read256BytesBlockHeightY[k]));",
        "\t\t\t}",
        "\t\t\treq_per_swath_ub_l[k] = swath_width_luma_ub[k] / Read256BytesBlockHeightY[k];",
        "\t\t\tif (BytePerPixC[k] > 0) {"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 970,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)SwathWidthC[k] - 1, Read256BytesBlockHeightC[k]) + Read256BytesBlock",
      "context": [
        "\t\t\t\tif (display_cfg->plane_descriptors[k].composition.viewport.stationary && DPPPerSurface[k] == 1) {",
        "\t\t\t\t\tswath_width_chroma_ub[k] = (unsigned int)(math_min2(surface_height_ub_c, math_floor2(display_cfg->plane_descriptors[k].composition.viewport.plane1.y_start + SwathWidthC[k] + Read256BytesBlockHeightC[k] - 1, Read256BytesBlockHeightC[k]) - math_floor2(display_cfg->plane_descriptors[k].composition.viewport.plane1.y_start, Read256BytesBlockHeightC[k])));",
        "\t\t\t\t} else {",
        "\t\t\t\t\tswath_width_chroma_ub[k] = (unsigned int)(math_min2(surface_height_ub_c, math_ceil2((double)SwathWidthC[k] - 1, Read256BytesBlockHeightC[k]) + Read256BytesBlockHeightC[k]));",
        "\t\t\t\t}",
        "\t\t\t\treq_per_swath_ub_c[k] = swath_width_chroma_ub[k] / Read256BytesBlockHeightC[k];",
        "\t\t\t} else {"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 1109,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double) display_cfg->stream_descriptors[k].timing.pixel_clock",
      "context": [
        "",
        "\t\t\t// Calculate per stream DET budget",
        "\t\t\tfor (unsigned int k = 0; k < display_cfg->num_streams; ++k) {",
        "\t\t\t\tl->DETBudgetPerStream[k] = (unsigned int)((double) display_cfg->stream_descriptors[k].timing.pixel_clock_khz * MaxTotalDETInKByte / l->TotalPixelRate);",
        "\t\t\t\tl->RemainingDETBudgetPerStream[k] = l->DETBudgetPerStream[k];",
        "\t\t\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 1241,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "",
        "static double CalculateRequiredDispclk(",
        "\tenum dml2_odm_mode ODMMode,",
        "\tdouble PixelClock)",
        "{",
        "",
        "\tif (ODMMode == dml2_odm_mode_combine_4to1) {"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 1261,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\tunsigned int Lanes,",
        "\tunsigned int HTotal,",
        "\tunsigned int HActive,",
        "\tdouble PixelClock,",
        "\tdouble DesiredBPP,",
        "\tbool DSCEnable,",
        "\tenum dml2_output_encoder_class Output,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 3176,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double UrgentLatencyAdjustmentFabricClock",
      "context": [
        "\tdouble UrgentLatencyPixelMixedWithVMData,",
        "\tdouble UrgentLatencyVMDataOnly,",
        "\tbool DoUrgentLatencyAdjustment,",
        "\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
        "\tdouble UrgentLatencyAdjustmentFabricClockReference,",
        "\tdouble FabricClock,",
        "\tdouble uclk_freq_mhz,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 3177,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double UrgentLatencyAdjustmentFabricClock",
      "context": [
        "\tdouble UrgentLatencyVMDataOnly,",
        "\tbool DoUrgentLatencyAdjustment,",
        "\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
        "\tdouble UrgentLatencyAdjustmentFabricClockReference,",
        "\tdouble FabricClock,",
        "\tdouble uclk_freq_mhz,",
        "\tenum dml2_qos_param_type qos_type,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 3178,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double FabricClock",
      "context": [
        "\tbool DoUrgentLatencyAdjustment,",
        "\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
        "\tdouble UrgentLatencyAdjustmentFabricClockReference,",
        "\tdouble FabricClock,",
        "\tdouble uclk_freq_mhz,",
        "\tenum dml2_qos_param_type qos_type,",
        "\tunsigned int urgent_ramp_uclk_cycles,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 3220,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double FabricClock",
      "context": [
        "",
        "static double CalculateTripToMemory(",
        "\tdouble UrgLatency,",
        "\tdouble FabricClock,",
        "\tdouble uclk_freq_mhz,",
        "\tenum dml2_qos_param_type qos_type,",
        "\tunsigned int trip_to_memory_uclk_cycles,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 3260,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double FabricClock",
      "context": [
        "",
        "static double CalculateMetaTripToMemory(",
        "\tdouble UrgLatency,",
        "\tdouble FabricClock,",
        "\tdouble uclk_freq_mhz,",
        "\tenum dml2_qos_param_type qos_type,",
        "\tunsigned int meta_trip_to_memory_uclk_cycles,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 3510,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double pixel_rate_mhz = ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\tdouble ReadBandwidth = 0.0;",
        "",
        "\tfor (unsigned int k = 0; k < NumberOfActiveSurfaces; ++k) {",
        "\t\tdouble pixel_rate_mhz = ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
        "",
        "\t\tif (display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio <= 1) {",
        "\t\t\tDisplayPipeLineDeliveryTimeLuma = SwathWidthY[k] * DPPPerSurface[k] / display_cfg->plane_descriptors[k].composition.scaler_info.plane0.h_ratio / pixel_rate_mhz;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 3658,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double line_time_us = (double)timing->h_total / ((double)timing->pixel_clock",
      "context": [
        "\tunsigned int vblank_size = 0;",
        "\tunsigned int max_vstartup_lines = 0;",
        "",
        "\tdouble line_time_us = (double)timing->h_total / ((double)timing->pixel_clock_khz / 1000);",
        "\tunsigned int vblank_actual = timing->v_total - timing->v_active;",
        "\tunsigned int vblank_nom_default_in_line = (unsigned int)math_floor2((double)vblank_nom_default_us / line_time_us, 1.0);",
        "\tunsigned int vblank_avail = (timing->vblank_nom == 0) ? vblank_nom_default_in_line : (unsigned int)timing->vblank_nom;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 4104,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\tbool DSCEnable,",
        "\tunsigned int TotalNumberOfActiveDPP,",
        "\tunsigned int MaxNumDPP,",
        "\tdouble PixelClock,",
        "\tunsigned int NumberOfDSCSlices,",
        "",
        "\t// Output"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 4201,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\tenum dml2_output_format_class OutputFormat,",
        "\tunsigned int HTotal,",
        "\tunsigned int HActive,",
        "\tdouble PixelClockBackEnd,",
        "\tdouble ForcedOutputLinkBPP,",
        "\tunsigned int DSCInputBitPerComponent,",
        "\tunsigned int NumberOfDSCSlices,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 4434,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "",
        "static double CalculateWriteBackDISPCLK(",
        "\tenum dml2_source_format_class WritebackPixelFormat,",
        "\tdouble PixelClock,",
        "\tdouble WritebackHRatio,",
        "\tdouble WritebackVRatio,",
        "\tunsigned int WritebackHTaps,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 4454,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "",
        "static double RequiredDTBCLK(",
        "\tbool DSCEnable,",
        "\tdouble PixelClock,",
        "\tenum dml2_output_format_class OutputFormat,",
        "\tdouble OutputBpp,",
        "\tunsigned int DSCSlices,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 4466,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelWordRate = PixelClock",
      "context": [
        "\tif (DSCEnable != true) {",
        "\t\treturn math_max2(PixelClock / 4.0 * OutputBpp / 24.0, 25.0);",
        "\t} else {",
        "\t\tdouble PixelWordRate = PixelClock / (OutputFormat == dml2_444 ? 1 : 2);",
        "\t\tdouble HCActive = math_ceil2(DSCSlices * math_ceil2(OutputBpp * math_ceil2(HActive / DSCSlices, 1) / 8.0, 1) / 3.0, 1);",
        "\t\tdouble HCBlank = 64 + 32 * math_ceil2(AudioRate * (AudioLayout == 1 ? 1 : 0.25) * HTotal / (PixelClock * 1000), 1);",
        "\t\tdouble AverageTribyteRate = PixelWordRate * (HCActive + HCBlank) / HTotal;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 4468,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double HCBlank = 64 + 32 * math_ceil2(AudioRate * (AudioLayout == 1 ? 1 : 0.25) * HTotal / (PixelClock",
      "context": [
        "\t} else {",
        "\t\tdouble PixelWordRate = PixelClock / (OutputFormat == dml2_444 ? 1 : 2);",
        "\t\tdouble HCActive = math_ceil2(DSCSlices * math_ceil2(OutputBpp * math_ceil2(HActive / DSCSlices, 1) / 8.0, 1) / 3.0, 1);",
        "\t\tdouble HCBlank = 64 + 32 * math_ceil2(AudioRate * (AudioLayout == 1 ? 1 : 0.25) * HTotal / (PixelClock * 1000), 1);",
        "\t\tdouble AverageTribyteRate = PixelWordRate * (HCActive + HCBlank) / HTotal;",
        "\t\tdouble HActiveTribyteRate = PixelWordRate * HCActive / HActive;",
        "\t\treturn math_max4(PixelWordRate / 4.0, AverageTribyteRate / 4.0, HActiveTribyteRate / 4.0, 25.0) * 1.002;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 4485,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\tunsigned int NumberOfDSCSlices,",
        "\tenum dml2_output_format_class OutputFormat,",
        "\tenum dml2_output_encoder_class Output,",
        "\tdouble PixelClock,",
        "\tdouble PixelClockBackEnd)",
        "{",
        "\tunsigned int DSCDelayRequirement_val = 0;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 4486,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\tenum dml2_output_format_class OutputFormat,",
        "\tenum dml2_output_encoder_class Output,",
        "\tdouble PixelClock,",
        "\tdouble PixelClockBackEnd)",
        "{",
        "\tunsigned int DSCDelayRequirement_val = 0;",
        "\tunsigned int NumberOfDSCSlicesFactor = 1;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 4554,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)surface->plane0.width, ReadBlock",
      "context": [
        "\t\tconst struct dml2_surface_cfg *surface = &display_cfg->plane_descriptors[k].surface;",
        "",
        "\t\tif (composition->viewport.stationary) {",
        "\t\t\tSurfaceSizeInMALL[k] = (unsigned int)(math_min2(math_ceil2((double)surface->plane0.width, ReadBlockWidthY[k]),",
        "\t\t\t\tmath_floor2(composition->viewport.plane0.x_start + composition->viewport.plane0.width + ReadBlockWidthY[k] - 1, ReadBlockWidthY[k]) -",
        "\t\t\t\tmath_floor2((double)composition->viewport.plane0.x_start, ReadBlockWidthY[k])) *",
        "\t\t\t\tmath_min2(math_ceil2((double)surface->plane0.height, ReadBlockHeightY[k]),"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 4556,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)composition->viewport.plane0.x_start, ReadBlock",
      "context": [
        "\t\tif (composition->viewport.stationary) {",
        "\t\t\tSurfaceSizeInMALL[k] = (unsigned int)(math_min2(math_ceil2((double)surface->plane0.width, ReadBlockWidthY[k]),",
        "\t\t\t\tmath_floor2(composition->viewport.plane0.x_start + composition->viewport.plane0.width + ReadBlockWidthY[k] - 1, ReadBlockWidthY[k]) -",
        "\t\t\t\tmath_floor2((double)composition->viewport.plane0.x_start, ReadBlockWidthY[k])) *",
        "\t\t\t\tmath_min2(math_ceil2((double)surface->plane0.height, ReadBlockHeightY[k]),",
        "\t\t\t\t\tmath_floor2((double)composition->viewport.plane0.y_start + composition->viewport.plane0.height + ReadBlockHeightY[k] - 1, ReadBlockHeightY[k]) -",
        "\t\t\t\t\tmath_floor2((double)composition->viewport.plane0.y_start, ReadBlockHeightY[k])) * BytesPerPixelY[k]);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 4557,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)surface->plane0.height, ReadBlock",
      "context": [
        "\t\t\tSurfaceSizeInMALL[k] = (unsigned int)(math_min2(math_ceil2((double)surface->plane0.width, ReadBlockWidthY[k]),",
        "\t\t\t\tmath_floor2(composition->viewport.plane0.x_start + composition->viewport.plane0.width + ReadBlockWidthY[k] - 1, ReadBlockWidthY[k]) -",
        "\t\t\t\tmath_floor2((double)composition->viewport.plane0.x_start, ReadBlockWidthY[k])) *",
        "\t\t\t\tmath_min2(math_ceil2((double)surface->plane0.height, ReadBlockHeightY[k]),",
        "\t\t\t\t\tmath_floor2((double)composition->viewport.plane0.y_start + composition->viewport.plane0.height + ReadBlockHeightY[k] - 1, ReadBlockHeightY[k]) -",
        "\t\t\t\t\tmath_floor2((double)composition->viewport.plane0.y_start, ReadBlockHeightY[k])) * BytesPerPixelY[k]);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 4558,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)composition->viewport.plane0.y_start + composition->viewport.plane0.height + ReadBlockHeightY[k] - 1, ReadBlock",
      "context": [
        "\t\t\t\tmath_floor2(composition->viewport.plane0.x_start + composition->viewport.plane0.width + ReadBlockWidthY[k] - 1, ReadBlockWidthY[k]) -",
        "\t\t\t\tmath_floor2((double)composition->viewport.plane0.x_start, ReadBlockWidthY[k])) *",
        "\t\t\t\tmath_min2(math_ceil2((double)surface->plane0.height, ReadBlockHeightY[k]),",
        "\t\t\t\t\tmath_floor2((double)composition->viewport.plane0.y_start + composition->viewport.plane0.height + ReadBlockHeightY[k] - 1, ReadBlockHeightY[k]) -",
        "\t\t\t\t\tmath_floor2((double)composition->viewport.plane0.y_start, ReadBlockHeightY[k])) * BytesPerPixelY[k]);",
        "",
        "\t\t\tif (ReadBlockWidthC[k] > 0) {"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 4559,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)composition->viewport.plane0.y_start, ReadBlock",
      "context": [
        "\t\t\t\tmath_floor2((double)composition->viewport.plane0.x_start, ReadBlockWidthY[k])) *",
        "\t\t\t\tmath_min2(math_ceil2((double)surface->plane0.height, ReadBlockHeightY[k]),",
        "\t\t\t\t\tmath_floor2((double)composition->viewport.plane0.y_start + composition->viewport.plane0.height + ReadBlockHeightY[k] - 1, ReadBlockHeightY[k]) -",
        "\t\t\t\t\tmath_floor2((double)composition->viewport.plane0.y_start, ReadBlockHeightY[k])) * BytesPerPixelY[k]);",
        "",
        "\t\t\tif (ReadBlockWidthC[k] > 0) {",
        "\t\t\t\tSurfaceSizeInMALL[k] = (unsigned int)(SurfaceSizeInMALL[k] +"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 4563,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)surface->plane1.width, ReadBlock",
      "context": [
        "",
        "\t\t\tif (ReadBlockWidthC[k] > 0) {",
        "\t\t\t\tSurfaceSizeInMALL[k] = (unsigned int)(SurfaceSizeInMALL[k] +",
        "\t\t\t\t\tmath_min2(math_ceil2((double)surface->plane1.width, ReadBlockWidthC[k]),",
        "\t\t\t\t\t\tmath_floor2((double)composition->viewport.plane1.y_start + composition->viewport.plane1.width + ReadBlockWidthC[k] - 1, ReadBlockWidthC[k]) -",
        "\t\t\t\t\t\tmath_floor2((double)composition->viewport.plane1.y_start, ReadBlockWidthC[k])) *",
        "\t\t\t\t\tmath_min2(math_ceil2((double)surface->plane1.height, ReadBlockHeightC[k]),"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 4564,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)composition->viewport.plane1.y_start + composition->viewport.plane1.width + ReadBlockWidthC[k] - 1, ReadBlock",
      "context": [
        "\t\t\tif (ReadBlockWidthC[k] > 0) {",
        "\t\t\t\tSurfaceSizeInMALL[k] = (unsigned int)(SurfaceSizeInMALL[k] +",
        "\t\t\t\t\tmath_min2(math_ceil2((double)surface->plane1.width, ReadBlockWidthC[k]),",
        "\t\t\t\t\t\tmath_floor2((double)composition->viewport.plane1.y_start + composition->viewport.plane1.width + ReadBlockWidthC[k] - 1, ReadBlockWidthC[k]) -",
        "\t\t\t\t\t\tmath_floor2((double)composition->viewport.plane1.y_start, ReadBlockWidthC[k])) *",
        "\t\t\t\t\tmath_min2(math_ceil2((double)surface->plane1.height, ReadBlockHeightC[k]),",
        "\t\t\t\t\t\tmath_floor2((double)composition->viewport.plane1.y_start + composition->viewport.plane1.height + ReadBlockHeightC[k] - 1, ReadBlockHeightC[k]) -"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 4565,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)composition->viewport.plane1.y_start, ReadBlock",
      "context": [
        "\t\t\t\tSurfaceSizeInMALL[k] = (unsigned int)(SurfaceSizeInMALL[k] +",
        "\t\t\t\t\tmath_min2(math_ceil2((double)surface->plane1.width, ReadBlockWidthC[k]),",
        "\t\t\t\t\t\tmath_floor2((double)composition->viewport.plane1.y_start + composition->viewport.plane1.width + ReadBlockWidthC[k] - 1, ReadBlockWidthC[k]) -",
        "\t\t\t\t\t\tmath_floor2((double)composition->viewport.plane1.y_start, ReadBlockWidthC[k])) *",
        "\t\t\t\t\tmath_min2(math_ceil2((double)surface->plane1.height, ReadBlockHeightC[k]),",
        "\t\t\t\t\t\tmath_floor2((double)composition->viewport.plane1.y_start + composition->viewport.plane1.height + ReadBlockHeightC[k] - 1, ReadBlockHeightC[k]) -",
        "\t\t\t\t\t\tmath_floor2(composition->viewport.plane1.y_start, ReadBlockHeightC[k])) * BytesPerPixelC[k]);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 4566,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)surface->plane1.height, ReadBlock",
      "context": [
        "\t\t\t\t\tmath_min2(math_ceil2((double)surface->plane1.width, ReadBlockWidthC[k]),",
        "\t\t\t\t\t\tmath_floor2((double)composition->viewport.plane1.y_start + composition->viewport.plane1.width + ReadBlockWidthC[k] - 1, ReadBlockWidthC[k]) -",
        "\t\t\t\t\t\tmath_floor2((double)composition->viewport.plane1.y_start, ReadBlockWidthC[k])) *",
        "\t\t\t\t\tmath_min2(math_ceil2((double)surface->plane1.height, ReadBlockHeightC[k]),",
        "\t\t\t\t\t\tmath_floor2((double)composition->viewport.plane1.y_start + composition->viewport.plane1.height + ReadBlockHeightC[k] - 1, ReadBlockHeightC[k]) -",
        "\t\t\t\t\t\tmath_floor2(composition->viewport.plane1.y_start, ReadBlockHeightC[k])) * BytesPerPixelC[k]);",
        "\t\t\t}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 4567,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)composition->viewport.plane1.y_start + composition->viewport.plane1.height + ReadBlockHeightC[k] - 1, ReadBlock",
      "context": [
        "\t\t\t\t\t\tmath_floor2((double)composition->viewport.plane1.y_start + composition->viewport.plane1.width + ReadBlockWidthC[k] - 1, ReadBlockWidthC[k]) -",
        "\t\t\t\t\t\tmath_floor2((double)composition->viewport.plane1.y_start, ReadBlockWidthC[k])) *",
        "\t\t\t\t\tmath_min2(math_ceil2((double)surface->plane1.height, ReadBlockHeightC[k]),",
        "\t\t\t\t\t\tmath_floor2((double)composition->viewport.plane1.y_start + composition->viewport.plane1.height + ReadBlockHeightC[k] - 1, ReadBlockHeightC[k]) -",
        "\t\t\t\t\t\tmath_floor2(composition->viewport.plane1.y_start, ReadBlockHeightC[k])) * BytesPerPixelC[k]);",
        "\t\t\t}",
        "\t\t} else {"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 4793,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double PixelClock",
      "context": [
        "\tdouble Dppclk,",
        "\tdouble Dispclk,",
        "\tdouble DCFClkDeepSleep,",
        "\tdouble PixelClock,",
        "\tunsigned int HTotal,",
        "\tunsigned int VBlank,",
        "\tunsigned int DynamicMetadataTransmittedBytes,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 4990,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double FabricClock",
      "context": [
        "\tunsigned int RoundTripPingLatencyCycles,",
        "\tunsigned int ReorderingBytes,",
        "\tdouble DCFCLK,",
        "\tdouble FabricClock,",
        "\tunsigned int PixelChunkSizeInKByte,",
        "\tdouble ReturnBW,",
        "\tunsigned int NumberOfActiveSurfaces,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 6748,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double pixel_clock_mhz = p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\ts->TotalPixelBW = 0.0;",
        "\tfor (unsigned int k = 0; k < p->NumberOfActiveSurfaces; ++k) {",
        "\t\tdouble h_total = (double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.h_total;",
        "\t\tdouble pixel_clock_mhz = p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000.0;",
        "\t\tdouble v_ratio = p->display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio;",
        "\t\tdouble v_ratio_c = p->display_cfg->plane_descriptors[k].composition.scaler_info.plane1.v_ratio;",
        "\t\ts->TotalPixelBW = s->TotalPixelBW + p->DPPPerSurface[k]"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 6760,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double pixel_clock_mhz = p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "",
        "\tfor (unsigned int k = 0; k < p->NumberOfActiveSurfaces; ++k) {",
        "\t\tdouble h_total = (double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.h_total;",
        "\t\tdouble pixel_clock_mhz = p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000.0;",
        "\t\tdouble v_ratio = p->display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio;",
        "\t\tdouble v_ratio_c = p->display_cfg->plane_descriptors[k].composition.scaler_info.plane1.v_ratio;",
        "\t\tdouble v_taps = p->display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_taps;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 6792,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)p->DSTXAfterScaler[k] / h_total + (double)p->DSTYAfterScaler[k]) * h_total / pixel_clock",
      "context": [
        "\t\ts->LinesInDETYRoundedDownToSwath[k] = (unsigned int)(math_floor2(s->LinesInDETY[k], p->SwathHeightY[k]));",
        "\t\ts->FullDETBufferingTimeY = s->LinesInDETYRoundedDownToSwath[k] * (h_total / pixel_clock_mhz) / v_ratio;",
        "",
        "\t\ts->ActiveClockChangeLatencyHidingY = s->EffectiveLBLatencyHidingY + s->FullDETBufferingTimeY - ((double)p->DSTXAfterScaler[k] / h_total + (double)p->DSTYAfterScaler[k]) * h_total / pixel_clock_mhz;",
        "",
        "\t\tif (p->NumberOfActiveSurfaces > 1) {",
        "\t\t\ts->ActiveClockChangeLatencyHidingY = s->ActiveClockChangeLatencyHidingY - (1.0 - 1.0 / (double)p->NumberOfActiveSurfaces) * (double)p->SwathHeightY[k] * (double)h_total / pixel_clock_mhz / v_ratio;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 6795,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)p->NumberOfActiveSurfaces) * (double)p->SwathHeightY[k] * (double)h_total / pixel_clock",
      "context": [
        "\t\ts->ActiveClockChangeLatencyHidingY = s->EffectiveLBLatencyHidingY + s->FullDETBufferingTimeY - ((double)p->DSTXAfterScaler[k] / h_total + (double)p->DSTYAfterScaler[k]) * h_total / pixel_clock_mhz;",
        "",
        "\t\tif (p->NumberOfActiveSurfaces > 1) {",
        "\t\t\ts->ActiveClockChangeLatencyHidingY = s->ActiveClockChangeLatencyHidingY - (1.0 - 1.0 / (double)p->NumberOfActiveSurfaces) * (double)p->SwathHeightY[k] * (double)h_total / pixel_clock_mhz / v_ratio;",
        "\t\t}",
        "",
        "\t\tif (p->BytePerPixelDETC[k] > 0) {"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 6802,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)p->DSTXAfterScaler[k] / (double)h_total + (double)p->DSTYAfterScaler[k]) * (double)h_total / pixel_clock",
      "context": [
        "\t\t\ts->LinesInDETC[k] = p->DETBufferSizeC[k] / p->BytePerPixelDETC[k] / p->SwathWidthC[k];",
        "\t\t\ts->LinesInDETCRoundedDownToSwath[k] = (unsigned int)(math_floor2(s->LinesInDETC[k], p->SwathHeightC[k]));",
        "\t\t\ts->FullDETBufferingTimeC = s->LinesInDETCRoundedDownToSwath[k] * (h_total / pixel_clock_mhz) / v_ratio_c;",
        "\t\t\ts->ActiveClockChangeLatencyHidingC = s->EffectiveLBLatencyHidingC + s->FullDETBufferingTimeC - ((double)p->DSTXAfterScaler[k] / (double)h_total + (double)p->DSTYAfterScaler[k]) * (double)h_total / pixel_clock_mhz;",
        "\t\t\tif (p->NumberOfActiveSurfaces > 1) {",
        "\t\t\t\ts->ActiveClockChangeLatencyHidingC = s->ActiveClockChangeLatencyHidingC - (1.0 - 1.0 / (double)p->NumberOfActiveSurfaces) * (double)p->SwathHeightC[k] * (double)h_total / pixel_clock_mhz / v_ratio_c;",
        "\t\t\t}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 6804,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)p->NumberOfActiveSurfaces) * (double)p->SwathHeightC[k] * (double)h_total / pixel_clock",
      "context": [
        "\t\t\ts->FullDETBufferingTimeC = s->LinesInDETCRoundedDownToSwath[k] * (h_total / pixel_clock_mhz) / v_ratio_c;",
        "\t\t\ts->ActiveClockChangeLatencyHidingC = s->EffectiveLBLatencyHidingC + s->FullDETBufferingTimeC - ((double)p->DSTXAfterScaler[k] / (double)h_total + (double)p->DSTYAfterScaler[k]) * (double)h_total / pixel_clock_mhz;",
        "\t\t\tif (p->NumberOfActiveSurfaces > 1) {",
        "\t\t\t\ts->ActiveClockChangeLatencyHidingC = s->ActiveClockChangeLatencyHidingC - (1.0 - 1.0 / (double)p->NumberOfActiveSurfaces) * (double)p->SwathHeightC[k] * (double)h_total / pixel_clock_mhz / v_ratio_c;",
        "\t\t\t}",
        "\t\t\ts->ActiveClockChangeLatencyHiding = math_min2(s->ActiveClockChangeLatencyHidingY, s->ActiveClockChangeLatencyHidingC);",
        "\t\t} else {"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 6826,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].writeback.writeback_stream[0].input_height * (double)h_total / pixel_clock",
      "context": [
        "\t\t\ts->WritebackLatencyHiding = (double)p->WritebackInterfaceBufferSize * 1024.0",
        "\t\t\t\t/ ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].writeback.writeback_stream[0].output_height",
        "\t\t\t\t\t* (double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].writeback.writeback_stream[0].output_width",
        "\t\t\t\t\t/ ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].writeback.writeback_stream[0].input_height * (double)h_total / pixel_clock_mhz) * 4.0);",
        "\t\t\tif (p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].writeback.writeback_stream[0].pixel_format == dml2_444_64) {",
        "\t\t\t\ts->WritebackLatencyHiding = s->WritebackLatencyHiding / 2;",
        "\t\t\t}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 6953,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)p->display_cfg->stream_descriptors[stream_index].timing.pixel_clock",
      "context": [
        "",
        "\t\tdst_lines_to_hide = (unsigned int)math_ceil(p->latency_to_hide_us /",
        "\t\t\t((double)p->display_cfg->stream_descriptors[stream_index].timing.h_total /",
        "\t\t\t\t(double)p->display_cfg->stream_descriptors[stream_index].timing.pixel_clock_khz * 1000.0));",
        "",
        "\t\tsrc_lines_to_hide_l = (unsigned int)math_ceil2(p->display_cfg->plane_descriptors[plane_index].composition.scaler_info.plane0.v_ratio * dst_lines_to_hide,",
        "\t\t\tp->swath_height_l[plane_index]);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 7058,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)uclk_khz * dram_config->channel_count * dram_config->channel_width_bytes * dram_config->transactions_per_clock",
      "context": [
        "static double uclk_khz_to_dram_bw_mbps(unsigned long uclk_khz, const struct dml2_dram_params *dram_config)",
        "{",
        "\tdouble bw_mbps = 0;",
        "\tbw_mbps = ((double)uclk_khz * dram_config->channel_count * dram_config->channel_width_bytes * dram_config->transactions_per_clock) / 1000.0;",
        "",
        "\treturn bw_mbps;",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 7067,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)bw_kbps / (dram_config->channel_count * dram_config->channel_width_bytes * dram_config->transactions_per_clock",
      "context": [
        "{",
        "\tdouble uclk_mhz = 0;",
        "",
        "\tuclk_mhz = (double)bw_kbps / (dram_config->channel_count * dram_config->channel_width_bytes * dram_config->transactions_per_clock) / 1000.0;",
        "",
        "\treturn uclk_mhz;",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 7236,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double FabricClock",
      "context": [
        "static double get_max_urgent_latency_us(",
        "\tstruct dml2_dcn4x_soc_qos_params *dcn4x,",
        "\tdouble uclk_freq_mhz,",
        "\tdouble FabricClock,",
        "\tunsigned int min_clk_index)",
        "{",
        "\tdouble latency;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 7261,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)stream_descriptor->timing.h_total * 1000.0 / (double)stream_descriptor->timing.pixel_clock",
      "context": [
        "\t\t\tstream_descriptor = &display_cfg->stream_descriptors[display_cfg->plane_descriptors[i].stream_index];",
        "",
        "\t\t\tpstate_keepout_dst_lines[i] =",
        "\t\t\t\t\t(unsigned int)math_ceil(watermarks->DRAMClockChangeWatermark / ((double)stream_descriptor->timing.h_total * 1000.0 / (double)stream_descriptor->timing.pixel_clock_khz));",
        "",
        "\t\t\tif (pstate_keepout_dst_lines[i] > stream_descriptor->timing.v_total - 1) {",
        "\t\t\t\tpstate_keepout_dst_lines[i] = stream_descriptor->timing.v_total - 1;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 7373,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\t\tmode_lib->ms.support.PrefetchSupported = true;",
        "",
        "\t\tfor (k = 0; k < mode_lib->ms.num_active_planes; k++) {",
        "\t\t\ts->line_times[k] = display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
        "\t\t\ts->pixel_format[k] = display_cfg->plane_descriptors[k].pixel_format;",
        "",
        "\t\t\ts->lb_source_lines_l[k] = get_num_lb_source_lines(mode_lib->ip.max_line_buffer_lines, mode_lib->ip.line_buffer_size_bits,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 7401,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "",
        "\t\t\tmyPipe->Dppclk = mode_lib->ms.RequiredDPPCLK[k];",
        "\t\t\tmyPipe->Dispclk = mode_lib->ms.RequiredDISPCLK;",
        "\t\t\tmyPipe->PixelClock = ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
        "\t\t\tmyPipe->DCFClkDeepSleep = mode_lib->ms.dcfclk_deepsleep;",
        "\t\t\tmyPipe->DPPPerSurface = mode_lib->ms.NoOfDPP[k];",
        "\t\t\tmyPipe->ScalerEnabled = display_cfg->plane_descriptors[k].composition.scaler_info.enabled;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 7761,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\t\t\t\tmode_lib->ms.BandwidthAvailableForImmediateFlip,",
        "\t\t\t\tmode_lib->ms.TotImmediateFlipBytes,",
        "\t\t\t\tdisplay_cfg->plane_descriptors[k].pixel_format,",
        "\t\t\t\t(display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)),",
        "\t\t\t\tdisplay_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio,",
        "\t\t\t\tdisplay_cfg->plane_descriptors[k].composition.scaler_info.plane1.v_ratio,",
        "\t\t\t\tmode_lib->ms.Tno_bw_flip[k],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 7894,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double *MaxActiveDRAMClock",
      "context": [
        "\tCalculateWatermarks_params->Watermark = &mode_lib->ms.support.watermarks; // Watermarks *Watermark",
        "\tCalculateWatermarks_params->DRAMClockChangeSupport = mode_lib->ms.support.DRAMClockChangeSupport;",
        "\tCalculateWatermarks_params->global_dram_clock_change_supported = &mode_lib->ms.support.global_dram_clock_change_supported;",
        "\tCalculateWatermarks_params->MaxActiveDRAMClockChangeLatencySupported = &s->dummy_single_array[0]; // double *MaxActiveDRAMClockChangeLatencySupported[]",
        "\tCalculateWatermarks_params->SubViewportLinesNeededInMALL = mode_lib->ms.SubViewportLinesNeededInMALL; // unsigned int SubViewportLinesNeededInMALL[]",
        "\tCalculateWatermarks_params->FCLKChangeSupport = mode_lib->ms.support.FCLKChangeSupport;",
        "\tCalculateWatermarks_params->global_fclk_change_supported = &mode_lib->ms.support.global_fclk_change_supported;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 7936,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)min_clk_table->max_clock",
      "context": [
        "\tmode_lib->ms.SOCCLK = ((double)mode_lib->soc.clk_table.socclk.clk_values_khz[0] / 1000);",
        "\tmode_lib->ms.DCFCLK = ((double)min_clk_table->dram_bw_table.entries[in_out_params->min_clk_index].min_dcfclk_khz / 1000);",
        "\tmode_lib->ms.FabricClock = ((double)min_clk_table->dram_bw_table.entries[in_out_params->min_clk_index].min_fclk_khz / 1000);",
        "\tmode_lib->ms.MaxDCFCLK = (double)min_clk_table->max_clocks_khz.dcfclk / 1000;",
        "\tmode_lib->ms.MaxFabricClock = (double)min_clk_table->max_clocks_khz.fclk / 1000;",
        "\tmode_lib->ms.max_dispclk_freq_mhz = (double)min_clk_table->max_ss_clocks_khz.dispclk / 1000;",
        "\tmode_lib->ms.max_dscclk_freq_mhz = (double)min_clk_table->max_clocks_khz.dscclk / 1000;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 7937,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)min_clk_table->max_clock",
      "context": [
        "\tmode_lib->ms.DCFCLK = ((double)min_clk_table->dram_bw_table.entries[in_out_params->min_clk_index].min_dcfclk_khz / 1000);",
        "\tmode_lib->ms.FabricClock = ((double)min_clk_table->dram_bw_table.entries[in_out_params->min_clk_index].min_fclk_khz / 1000);",
        "\tmode_lib->ms.MaxDCFCLK = (double)min_clk_table->max_clocks_khz.dcfclk / 1000;",
        "\tmode_lib->ms.MaxFabricClock = (double)min_clk_table->max_clocks_khz.fclk / 1000;",
        "\tmode_lib->ms.max_dispclk_freq_mhz = (double)min_clk_table->max_ss_clocks_khz.dispclk / 1000;",
        "\tmode_lib->ms.max_dscclk_freq_mhz = (double)min_clk_table->max_clocks_khz.dscclk / 1000;",
        "\tmode_lib->ms.max_dppclk_freq_mhz = (double)min_clk_table->max_ss_clocks_khz.dppclk / 1000;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 7938,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)min_clk_table->max_ss_clock",
      "context": [
        "\tmode_lib->ms.FabricClock = ((double)min_clk_table->dram_bw_table.entries[in_out_params->min_clk_index].min_fclk_khz / 1000);",
        "\tmode_lib->ms.MaxDCFCLK = (double)min_clk_table->max_clocks_khz.dcfclk / 1000;",
        "\tmode_lib->ms.MaxFabricClock = (double)min_clk_table->max_clocks_khz.fclk / 1000;",
        "\tmode_lib->ms.max_dispclk_freq_mhz = (double)min_clk_table->max_ss_clocks_khz.dispclk / 1000;",
        "\tmode_lib->ms.max_dscclk_freq_mhz = (double)min_clk_table->max_clocks_khz.dscclk / 1000;",
        "\tmode_lib->ms.max_dppclk_freq_mhz = (double)min_clk_table->max_ss_clocks_khz.dppclk / 1000;",
        "\tmode_lib->ms.uclk_freq_mhz = dram_bw_kbps_to_uclk_mhz(min_clk_table->dram_bw_table.entries[in_out_params->min_clk_index].pre_derate_dram_bw_kbps, &mode_lib->soc.clk_table.dram_config);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 7939,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)min_clk_table->max_clock",
      "context": [
        "\tmode_lib->ms.MaxDCFCLK = (double)min_clk_table->max_clocks_khz.dcfclk / 1000;",
        "\tmode_lib->ms.MaxFabricClock = (double)min_clk_table->max_clocks_khz.fclk / 1000;",
        "\tmode_lib->ms.max_dispclk_freq_mhz = (double)min_clk_table->max_ss_clocks_khz.dispclk / 1000;",
        "\tmode_lib->ms.max_dscclk_freq_mhz = (double)min_clk_table->max_clocks_khz.dscclk / 1000;",
        "\tmode_lib->ms.max_dppclk_freq_mhz = (double)min_clk_table->max_ss_clocks_khz.dppclk / 1000;",
        "\tmode_lib->ms.uclk_freq_mhz = dram_bw_kbps_to_uclk_mhz(min_clk_table->dram_bw_table.entries[in_out_params->min_clk_index].pre_derate_dram_bw_kbps, &mode_lib->soc.clk_table.dram_config);",
        "\tmode_lib->ms.dram_bw_mbps = ((double)min_clk_table->dram_bw_table.entries[in_out_params->min_clk_index].pre_derate_dram_bw_kbps / 1000);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 7940,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)min_clk_table->max_ss_clock",
      "context": [
        "\tmode_lib->ms.MaxFabricClock = (double)min_clk_table->max_clocks_khz.fclk / 1000;",
        "\tmode_lib->ms.max_dispclk_freq_mhz = (double)min_clk_table->max_ss_clocks_khz.dispclk / 1000;",
        "\tmode_lib->ms.max_dscclk_freq_mhz = (double)min_clk_table->max_clocks_khz.dscclk / 1000;",
        "\tmode_lib->ms.max_dppclk_freq_mhz = (double)min_clk_table->max_ss_clocks_khz.dppclk / 1000;",
        "\tmode_lib->ms.uclk_freq_mhz = dram_bw_kbps_to_uclk_mhz(min_clk_table->dram_bw_table.entries[in_out_params->min_clk_index].pre_derate_dram_bw_kbps, &mode_lib->soc.clk_table.dram_config);",
        "\tmode_lib->ms.dram_bw_mbps = ((double)min_clk_table->dram_bw_table.entries[in_out_params->min_clk_index].pre_derate_dram_bw_kbps / 1000);",
        "\tmode_lib->ms.max_dram_bw_mbps = ((double)min_clk_table->dram_bw_table.entries[min_clk_table->dram_bw_table.num_entries - 1].pre_derate_dram_bw_kbps / 1000);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 8061,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\t}",
        "",
        "\tfor (k = 0; k <= mode_lib->ms.num_active_planes - 1; k++) {",
        "\t\tmode_lib->ms.vactive_sw_bw_l[k] = mode_lib->ms.SwathWidthYSingleDPP[k] * math_ceil2(mode_lib->ms.BytePerPixelY[k], 1.0) / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio;",
        "\t\tmode_lib->ms.vactive_sw_bw_c[k] = mode_lib->ms.SwathWidthCSingleDPP[k] * math_ceil2(mode_lib->ms.BytePerPixelC[k], 2.0) / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane1.v_ratio;",
        "",
        "\t\tmode_lib->ms.cursor_bw[k] = display_cfg->plane_descriptors[k].cursor.num_cursors * display_cfg->plane_descriptors[k].cursor.cursor_width *"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 8062,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "",
        "\tfor (k = 0; k <= mode_lib->ms.num_active_planes - 1; k++) {",
        "\t\tmode_lib->ms.vactive_sw_bw_l[k] = mode_lib->ms.SwathWidthYSingleDPP[k] * math_ceil2(mode_lib->ms.BytePerPixelY[k], 1.0) / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio;",
        "\t\tmode_lib->ms.vactive_sw_bw_c[k] = mode_lib->ms.SwathWidthCSingleDPP[k] * math_ceil2(mode_lib->ms.BytePerPixelC[k], 2.0) / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane1.v_ratio;",
        "",
        "\t\tmode_lib->ms.cursor_bw[k] = display_cfg->plane_descriptors[k].cursor.num_cursors * display_cfg->plane_descriptors[k].cursor.cursor_width *",
        "\t\t\tdisplay_cfg->plane_descriptors[k].cursor.cursor_bpp / 8.0 / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000));"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 8065,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\t\tmode_lib->ms.vactive_sw_bw_c[k] = mode_lib->ms.SwathWidthCSingleDPP[k] * math_ceil2(mode_lib->ms.BytePerPixelC[k], 2.0) / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane1.v_ratio;",
        "",
        "\t\tmode_lib->ms.cursor_bw[k] = display_cfg->plane_descriptors[k].cursor.num_cursors * display_cfg->plane_descriptors[k].cursor.cursor_width *",
        "\t\t\tdisplay_cfg->plane_descriptors[k].cursor.cursor_bpp / 8.0 / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000));",
        "",
        "#ifdef __DML_VBA_DEBUG__",
        "\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u, old_ReadBandwidthLuma = %f\\n\", __func__, k, mode_lib->ms.SwathWidthYSingleDPP[k] * math_ceil2(mode_lib->ms.BytePerPixelInDETY[k], 1.0) / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 8068,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\t\t\tdisplay_cfg->plane_descriptors[k].cursor.cursor_bpp / 8.0 / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000));",
        "",
        "#ifdef __DML_VBA_DEBUG__",
        "\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u, old_ReadBandwidthLuma = %f\\n\", __func__, k, mode_lib->ms.SwathWidthYSingleDPP[k] * math_ceil2(mode_lib->ms.BytePerPixelInDETY[k], 1.0) / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio);",
        "\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u, old_ReadBandwidthChroma = %f\\n\", __func__, k, mode_lib->ms.SwathWidthYSingleDPP[k] / 2 * math_ceil2(mode_lib->ms.BytePerPixelInDETC[k], 2.0) / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio / 2.0);",
        "\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u, vactive_sw_bw_l = %f\\n\", __func__, k, mode_lib->ms.vactive_sw_bw_l[k]);",
        "\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u, vactive_sw_bw_c = %f\\n\", __func__, k, mode_lib->ms.vactive_sw_bw_c[k]);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 8069,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "",
        "#ifdef __DML_VBA_DEBUG__",
        "\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u, old_ReadBandwidthLuma = %f\\n\", __func__, k, mode_lib->ms.SwathWidthYSingleDPP[k] * math_ceil2(mode_lib->ms.BytePerPixelInDETY[k], 1.0) / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio);",
        "\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u, old_ReadBandwidthChroma = %f\\n\", __func__, k, mode_lib->ms.SwathWidthYSingleDPP[k] / 2 * math_ceil2(mode_lib->ms.BytePerPixelInDETC[k], 2.0) / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio / 2.0);",
        "\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u, vactive_sw_bw_l = %f\\n\", __func__, k, mode_lib->ms.vactive_sw_bw_l[k]);",
        "\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u, vactive_sw_bw_c = %f\\n\", __func__, k, mode_lib->ms.vactive_sw_bw_c[k]);",
        "#endif"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 8082,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\t\t\t\t* display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].writeback.writeback_stream[0].output_width",
        "\t\t\t\t/ (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].writeback.writeback_stream[0].input_height",
        "\t\t\t\t\t* display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total",
        "\t\t\t\t\t/ ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * 8.0;",
        "\t\t} else if (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].writeback.active_writebacks_per_stream > 0) {",
        "\t\t\tmode_lib->ms.WriteBandwidth[k][0] = display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].writeback.writeback_stream[0].output_height",
        "\t\t\t\t* display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].writeback.writeback_stream[0].output_width"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 8088,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\t\t\t\t* display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].writeback.writeback_stream[0].output_width",
        "\t\t\t\t/ (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].writeback.writeback_stream[0].input_height",
        "\t\t\t\t\t* display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total",
        "\t\t\t\t\t/ ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * 4.0;",
        "\t\t} else {",
        "\t\t\tmode_lib->ms.WriteBandwidth[k][0] = 0.0;",
        "\t\t}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 8133,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\t\t\tdisplay_cfg->plane_descriptors[k].composition.scaler_info.plane1.v_ratio,",
        "\t\t\tmode_lib->ip.max_dchub_pscl_bw_pix_per_clk,",
        "\t\t\tmode_lib->ip.max_pscl_lb_bw_pix_per_clk,",
        "\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000),",
        "\t\t\tdisplay_cfg->plane_descriptors[k].pixel_format,",
        "\t\t\tdisplay_cfg->plane_descriptors[k].composition.scaler_info.plane0.h_taps,",
        "\t\t\tdisplay_cfg->plane_descriptors[k].composition.scaler_info.plane1.h_taps,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 8380,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\t\t\tfalse, // DSCEnable",
        "\t\t\tmode_lib->ms.TotalNumberOfActiveDPP,",
        "\t\t\tmode_lib->ip.max_num_dpp,",
        "\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000),",
        "\t\t\tmode_lib->ms.support.NumberOfDSCSlices[k],",
        "",
        "\t\t\t/* Output */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 8399,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\t\t\ttrue, // DSCEnable",
        "\t\t\tmode_lib->ms.TotalNumberOfActiveDPP,",
        "\t\t\tmode_lib->ip.max_num_dpp,",
        "\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000),",
        "\t\t\tmode_lib->ms.support.NumberOfDSCSlices[k],",
        "",
        "\t\t\t/* Output */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 8550,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\t\tif (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].writeback.active_writebacks_per_stream > 0) {",
        "\t\t\tmode_lib->ms.WritebackRequiredDISPCLK = math_max2(mode_lib->ms.WritebackRequiredDISPCLK,",
        "\t\t\t\tCalculateWriteBackDISPCLK(display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].writeback.writeback_stream[0].pixel_format,",
        "\t\t\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000),",
        "\t\t\t\t\tdisplay_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].writeback.writeback_stream[0].h_ratio,",
        "\t\t\t\t\tdisplay_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].writeback.writeback_stream[0].v_ratio,",
        "\t\t\t\t\tdisplay_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].writeback.writeback_stream[0].h_taps,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 8700,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)min_clk_table->max_ss_clock",
      "context": [
        "\t\t\t\tdisplay_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].output.audio_sample_rate,",
        "\t\t\t\tdisplay_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].output.audio_sample_layout);",
        "",
        "\t\t\tif (mode_lib->ms.RequiredDTBCLK[k] > ((double)min_clk_table->max_ss_clocks_khz.dtbclk / 1000)) {",
        "\t\t\t\tmode_lib->ms.support.DTBCLKRequiredMoreThanSupported = true;",
        "\t\t\t}",
        "\t\t} else {"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 8799,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\t\t\tmode_lib->ms.support.NumberOfDSCSlices[k],",
        "\t\t\tdisplay_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].output.output_format,",
        "\t\t\tdisplay_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].output.output_encoder,",
        "\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000),",
        "\t\t\ts->PixelClockBackEnd[k]);",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 8865,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\t}",
        "",
        "\tfor (k = 0; k < mode_lib->ms.num_active_planes; ++k) {",
        "\t\ts->SurfParameters[k].PixelClock = ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
        "\t\ts->SurfParameters[k].DPPPerSurface = mode_lib->ms.NoOfDPP[k];",
        "\t\ts->SurfParameters[k].RotationAngle = display_cfg->plane_descriptors[k].composition.rotation_angle;",
        "\t\ts->SurfParameters[k].ViewportHeight = display_cfg->plane_descriptors[k].composition.viewport.plane0.height;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 9063,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double line_time_us = (double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\tmode_lib->ms.TripToMemory = math_max2(mode_lib->ms.UrgLatency, mode_lib->ms.TripToMemory);",
        "",
        "\tfor (k = 0; k < mode_lib->ms.num_active_planes; ++k) {",
        "\t\tdouble line_time_us = (double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
        "\t\tbool cursor_not_enough_urgent_latency_hiding = false;",
        "",
        "\t\tif (display_cfg->plane_descriptors[k].cursor.num_cursors > 0) {"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 9202,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\t\t\ts->SubViewportMALLPStateMethod = true;",
        "\t\t\tif (!display_cfg->overrides.enable_subvp_implicit_pmo) {",
        "\t\t\t\t// For dv, small frame tests will have very high refresh rate",
        "\t\t\t\tunsigned long long refresh_rate = (unsigned long long) ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz * 1000 /",
        "\t\t\t\t\t(double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total /",
        "\t\t\t\t\t(double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.v_total);",
        "\t\t\t\tif (refresh_rate > 120)"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 9619,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double pixel_clock_mhz = ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\tdouble DisplayPipeRequestDeliveryTimeChromaPrefetch[])",
        "{",
        "\tfor (unsigned int k = 0; k < NumberOfActiveSurfaces; ++k) {",
        "\t\tdouble pixel_clock_mhz = ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
        "",
        "#ifdef __DML_VBA_DEBUG__",
        "\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u : HRatio = %f\\n\", __func__, k, display_cfg->plane_descriptors[k].composition.scaler_info.plane0.h_ratio);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 9715,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double pixel_clock",
      "context": [
        "\tunsigned int dpte_groups_per_row_luma_ub;",
        "\tunsigned int dpte_group_width_chroma;",
        "\tunsigned int dpte_groups_per_row_chroma_ub;",
        "\tdouble pixel_clock_mhz;",
        "",
        "\tfor (unsigned int k = 0; k < p->NumberOfActiveSurfaces; ++k) {",
        "\t\tp->DST_Y_PER_PTE_ROW_NOM_L[k] = p->dpte_row_height[k] / p->display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 9809,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\t}",
        "",
        "\tfor (unsigned int k = 0; k < p->NumberOfActiveSurfaces; ++k) {",
        "\t\tpixel_clock_mhz = ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
        "",
        "\t\tif (p->display_cfg->plane_descriptors[k].tdlut.setup_for_tdlut)",
        "\t\t\tp->time_per_tdlut_group[k] = 2 * p->dst_y_per_row_vblank[k] * p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.h_total / pixel_clock_mhz / p->tdlut_groups_per_2row_ub[k];"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 9929,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double pixel_clock_mhz = ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\tDML_LOG_VERBOSE(\"DML::%s: NumberOfActiveSurfaces = %u\\n\", __func__, NumberOfActiveSurfaces);",
        "#endif",
        "\tfor (unsigned int k = 0; k < NumberOfActiveSurfaces; ++k) {",
        "\t\tdouble pixel_clock_mhz = ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
        "\t\tbool dcc_mrq_enable = display_cfg->plane_descriptors[k].surface.dcc.enable && mrq_present;",
        "#ifdef __DML_VBA_DEBUG__",
        "\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u, dcc_mrq_enable = %u\\n\", __func__, k, dcc_mrq_enable);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 10043,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double SinglePixelClock",
      "context": [
        "\tstruct dml2_core_calcs_CalculateStutterEfficiency_locals *l = &scratch->CalculateStutterEfficiency_locals;",
        "",
        "\tunsigned int TotalNumberOfActiveOTG = 0;",
        "\tdouble SinglePixelClock = 0;",
        "\tunsigned int SingleHTotal = 0;",
        "\tunsigned int SingleVTotal = 0;",
        "\tbool SameTiming = true;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 10152,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\t\tif (!dml_is_phantom_pipe(&p->display_cfg->plane_descriptors[k])) {",
        "\t\t\tl->LinesInDETY = ((double)p->DETBufferSizeY[k] + (p->UnboundedRequestEnabled == true ? l->EffectiveCompressedBufferSize : 0) * p->ReadBandwidthSurfaceLuma[k] / p->TotalDataReadBandwidth) / p->BytePerPixelDETY[k] / p->SwathWidthY[k];",
        "\t\t\tl->LinesInDETYRoundedDownToSwath = math_floor2(l->LinesInDETY, p->SwathHeightY[k]);",
        "\t\t\tl->DETBufferingTimeY = l->LinesInDETYRoundedDownToSwath * ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) / p->display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio;",
        "#ifdef __DML_VBA_DEBUG__",
        "\t\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u, DETBufferSizeY = %u (%u kbytes)\\n\", __func__, k, p->DETBufferSizeY[k], p->DETBufferSizeY[k] / 1024);",
        "\t\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u, BytePerPixelDETY = %f\\n\", __func__, k, p->BytePerPixelDETY[k]);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 10170,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.v_total / 2.0, 1.0) : p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.v_total) * (double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "",
        "\t\t\t\tFoundCriticalSurface = true;",
        "\t\t\t\t*p->StutterPeriod = l->DETBufferingTimeY;",
        "\t\t\t\tl->FrameTimeCriticalSurface = (isInterlaceTiming ? math_floor2((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.v_total / 2.0, 1.0) : p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.v_total) * (double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
        "\t\t\t\tl->VActiveTimeCriticalSurface = (isInterlaceTiming ? math_floor2((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.v_active / 2.0, 1.0) : p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.v_active) * (double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
        "\t\t\t\tl->BytePerPixelYCriticalSurface = p->BytePerPixelY[k];",
        "\t\t\t\tl->SwathWidthYCriticalSurface = p->SwathWidthY[k];"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 10171,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.v_active / 2.0, 1.0) : p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.v_active) * (double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\t\t\t\tFoundCriticalSurface = true;",
        "\t\t\t\t*p->StutterPeriod = l->DETBufferingTimeY;",
        "\t\t\t\tl->FrameTimeCriticalSurface = (isInterlaceTiming ? math_floor2((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.v_total / 2.0, 1.0) : p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.v_total) * (double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
        "\t\t\t\tl->VActiveTimeCriticalSurface = (isInterlaceTiming ? math_floor2((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.v_active / 2.0, 1.0) : p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.v_active) * (double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
        "\t\t\t\tl->BytePerPixelYCriticalSurface = p->BytePerPixelY[k];",
        "\t\t\t\tl->SwathWidthYCriticalSurface = p->SwathWidthY[k];",
        "\t\t\t\tl->SwathHeightYCriticalSurface = p->SwathHeightY[k];"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 10242,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\t\t\t\t\tl->TotalActiveWriteback = l->TotalActiveWriteback + 1;",
        "",
        "\t\t\t\tif (TotalNumberOfActiveOTG == 0) { // first otg",
        "\t\t\t\t\tSinglePixelClock = ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
        "\t\t\t\t\tSingleHTotal = p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.h_total;",
        "\t\t\t\t\tSingleVTotal = p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.v_total;",
        "\t\t\t\t} else if (SinglePixelClock != ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000) ||"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 10245,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\t\t\t\t\tSinglePixelClock = ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
        "\t\t\t\t\tSingleHTotal = p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.h_total;",
        "\t\t\t\t\tSingleVTotal = p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.v_total;",
        "\t\t\t\t} else if (SinglePixelClock != ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000) ||",
        "\t\t\t\t\t\t\tSingleHTotal != p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.h_total ||",
        "\t\t\t\t\t\t\tSingleVTotal != p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.v_total) {",
        "\t\t\t\t\tSameTiming = false;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 10351,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double max_fclk_mhz = min_clk_table->max_clock",
      "context": [
        "\tbool must_support_iflip;",
        "\tconst long min_return_uclk_cycles = 83;",
        "\tconst long min_return_fclk_cycles = 75;",
        "\tconst double max_fclk_mhz = min_clk_table->max_clocks_khz.fclk / 1000.0;",
        "\tdouble hard_minimum_dcfclk_mhz = (double)min_clk_table->dram_bw_table.entries[0].min_dcfclk_khz / 1000.0;",
        "\tdouble max_uclk_mhz = 0;",
        "\tdouble min_return_latency_in_DCFCLK_cycles = 0;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 10372,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)programming->min_clock",
      "context": [
        "\tmode_lib->mp.dram_bw_mbps = uclk_khz_to_dram_bw_mbps(programming->min_clocks.dcn4x.active.uclk_khz, &mode_lib->soc.clk_table.dram_config);",
        "\tmode_lib->mp.uclk_freq_mhz = programming->min_clocks.dcn4x.active.uclk_khz / 1000.0;",
        "\tmode_lib->mp.GlobalDPPCLK = programming->min_clocks.dcn4x.dpprefclk_khz / 1000.0;",
        "\ts->SOCCLK = (double)programming->min_clocks.dcn4x.socclk_khz / 1000;",
        "\tmode_lib->mp.qos_param_index = get_qos_param_index(programming->min_clocks.dcn4x.active.uclk_khz, mode_lib->soc.qos_parameters.qos_params.dcn4x.per_uclk_dpm_params);",
        "\tmode_lib->mp.active_min_uclk_dpm_index = get_active_min_uclk_dpm_index(programming->min_clocks.dcn4x.active.uclk_khz, &mode_lib->soc.clk_table);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 10482,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\t\t\tdisplay_cfg->plane_descriptors[k].composition.scaler_info.plane1.v_ratio,",
        "\t\t\tmode_lib->ip.max_dchub_pscl_bw_pix_per_clk,",
        "\t\t\tmode_lib->ip.max_pscl_lb_bw_pix_per_clk,",
        "\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000),",
        "\t\t\tdisplay_cfg->plane_descriptors[k].pixel_format,",
        "\t\t\tdisplay_cfg->plane_descriptors[k].composition.scaler_info.plane0.h_taps,",
        "\t\t\tdisplay_cfg->plane_descriptors[k].composition.scaler_info.plane1.v_taps,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 10548,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "",
        "\tfor (k = 0; k < s->num_active_planes; ++k) {",
        "\t\tmode_lib->mp.cursor_bw[k] = display_cfg->plane_descriptors[k].cursor.num_cursors * display_cfg->plane_descriptors[k].cursor.cursor_width * display_cfg->plane_descriptors[k].cursor.cursor_bpp / 8.0 /",
        "\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000));",
        "\t\tmode_lib->mp.vactive_sw_bw_l[k] = mode_lib->mp.SwathWidthSingleDPPY[k] * mode_lib->mp.BytePerPixelY[k] / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio;",
        "\t\tmode_lib->mp.vactive_sw_bw_c[k] = mode_lib->mp.SwathWidthSingleDPPC[k] * mode_lib->mp.BytePerPixelC[k] / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane1.v_ratio;",
        "\t\tDML_LOG_VERBOSE(\"DML::%s: vactive_sw_bw_l[%i] = %fBps\\n\", __func__, k, mode_lib->mp.vactive_sw_bw_l[k]);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 10549,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\tfor (k = 0; k < s->num_active_planes; ++k) {",
        "\t\tmode_lib->mp.cursor_bw[k] = display_cfg->plane_descriptors[k].cursor.num_cursors * display_cfg->plane_descriptors[k].cursor.cursor_width * display_cfg->plane_descriptors[k].cursor.cursor_bpp / 8.0 /",
        "\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000));",
        "\t\tmode_lib->mp.vactive_sw_bw_l[k] = mode_lib->mp.SwathWidthSingleDPPY[k] * mode_lib->mp.BytePerPixelY[k] / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio;",
        "\t\tmode_lib->mp.vactive_sw_bw_c[k] = mode_lib->mp.SwathWidthSingleDPPC[k] * mode_lib->mp.BytePerPixelC[k] / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane1.v_ratio;",
        "\t\tDML_LOG_VERBOSE(\"DML::%s: vactive_sw_bw_l[%i] = %fBps\\n\", __func__, k, mode_lib->mp.vactive_sw_bw_l[k]);",
        "\t\tDML_LOG_VERBOSE(\"DML::%s: vactive_sw_bw_c[%i] = %fBps\\n\", __func__, k, mode_lib->mp.vactive_sw_bw_c[k]);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 10550,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\t\tmode_lib->mp.cursor_bw[k] = display_cfg->plane_descriptors[k].cursor.num_cursors * display_cfg->plane_descriptors[k].cursor.cursor_width * display_cfg->plane_descriptors[k].cursor.cursor_bpp / 8.0 /",
        "\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000));",
        "\t\tmode_lib->mp.vactive_sw_bw_l[k] = mode_lib->mp.SwathWidthSingleDPPY[k] * mode_lib->mp.BytePerPixelY[k] / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio;",
        "\t\tmode_lib->mp.vactive_sw_bw_c[k] = mode_lib->mp.SwathWidthSingleDPPC[k] * mode_lib->mp.BytePerPixelC[k] / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane1.v_ratio;",
        "\t\tDML_LOG_VERBOSE(\"DML::%s: vactive_sw_bw_l[%i] = %fBps\\n\", __func__, k, mode_lib->mp.vactive_sw_bw_l[k]);",
        "\t\tDML_LOG_VERBOSE(\"DML::%s: vactive_sw_bw_c[%i] = %fBps\\n\", __func__, k, mode_lib->mp.vactive_sw_bw_c[k]);",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 10623,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\t\t\tcfg_support_info->stream_support_info[display_cfg->plane_descriptors[k].stream_index].num_dsc_slices,",
        "\t\t\tdisplay_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].output.output_format,",
        "\t\t\tdisplay_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].output.output_encoder,",
        "\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000),",
        "\t\t\ts->PixelClockBackEnd[k]);",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 10653,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\t}",
        "",
        "\tfor (k = 0; k < s->num_active_planes; ++k) {",
        "\t\ts->SurfaceParameters[k].PixelClock = ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
        "\t\ts->SurfaceParameters[k].DPPPerSurface = mode_lib->mp.NoOfDPP[k];",
        "\t\ts->SurfaceParameters[k].RotationAngle = display_cfg->plane_descriptors[k].composition.rotation_angle;",
        "\t\ts->SurfaceParameters[k].ViewportHeight = display_cfg->plane_descriptors[k].composition.viewport.plane0.height;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 11033,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\tfor (k = 0; k < s->num_active_planes; ++k) {",
        "\t\tbool cursor_not_enough_urgent_latency_hiding = false;",
        "\t\ts->line_times[k] = display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total /",
        "\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
        "",
        "\t\ts->pixel_format[k] = display_cfg->plane_descriptors[k].pixel_format;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 11168,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "",
        "\t\t\tmyPipe->Dppclk = mode_lib->mp.Dppclk[k];",
        "\t\t\tmyPipe->Dispclk = mode_lib->mp.Dispclk;",
        "\t\t\tmyPipe->PixelClock = ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
        "\t\t\tmyPipe->DCFClkDeepSleep = mode_lib->mp.DCFCLKDeepSleep;",
        "\t\t\tmyPipe->DPPPerSurface = mode_lib->mp.NoOfDPP[k];",
        "\t\t\tmyPipe->ScalerEnabled = display_cfg->plane_descriptors[k].composition.scaler_info.enabled;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 11335,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\t\tif (mode_lib->mp.PrefetchModeSupported == true) {",
        "\t\t\tfor (k = 0; k < s->num_active_planes; ++k) {",
        "\t\t\t\tdouble line_time_us = display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total /",
        "\t\t\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
        "\t\t\t\tCalculateUrgentBurstFactor(",
        "\t\t\t\t\t&display_cfg->plane_descriptors[k],",
        "\t\t\t\t\tmode_lib->mp.swath_width_luma_ub[k],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 11491,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\t\t\t\t\tmode_lib->mp.BandwidthAvailableForImmediateFlip,",
        "\t\t\t\t\tmode_lib->mp.TotImmediateFlipBytes,",
        "\t\t\t\t\tdisplay_cfg->plane_descriptors[k].pixel_format,",
        "\t\t\t\t\tdisplay_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000),",
        "\t\t\t\t\tdisplay_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio,",
        "\t\t\t\t\tdisplay_cfg->plane_descriptors[k].composition.scaler_info.plane1.v_ratio,",
        "\t\t\t\t\tmode_lib->mp.Tno_bw[k],"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 11703,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000) - mode_lib->mp.Watermark.WritebackDRAMClock",
      "context": [
        "\t\tfor (k = 0; k < s->num_active_planes; ++k) {",
        "\t\t\tif (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].writeback.active_writebacks_per_stream > 0) {",
        "\t\t\t\tmode_lib->mp.WritebackAllowDRAMClockChangeEndPosition[k] = math_max2(0, mode_lib->mp.VStartupMin[k] * display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total /",
        "\t\t\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000) - mode_lib->mp.Watermark.WritebackDRAMClockChangeWatermark);",
        "\t\t\t\tmode_lib->mp.WritebackAllowFCLKChangeEndPosition[k] = math_max2(0, mode_lib->mp.VStartupMin[k] * display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total /",
        "\t\t\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000) - mode_lib->mp.Watermark.WritebackFCLKChangeWatermark);",
        "\t\t\t} else {"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 11705,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "\t\t\t\tmode_lib->mp.WritebackAllowDRAMClockChangeEndPosition[k] = math_max2(0, mode_lib->mp.VStartupMin[k] * display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total /",
        "\t\t\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000) - mode_lib->mp.Watermark.WritebackDRAMClockChangeWatermark);",
        "\t\t\t\tmode_lib->mp.WritebackAllowFCLKChangeEndPosition[k] = math_max2(0, mode_lib->mp.VStartupMin[k] * display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total /",
        "\t\t\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000) - mode_lib->mp.Watermark.WritebackFCLKChangeWatermark);",
        "\t\t\t} else {",
        "\t\t\t\tmode_lib->mp.WritebackAllowDRAMClockChangeEndPosition[k] = 0;",
        "\t\t\t\tmode_lib->mp.WritebackAllowFCLKChangeEndPosition[k] = 0;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 11829,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "#ifdef __DML_VBA_DEBUG__",
        "\t\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u, MinTTUVBlank = %f (before vstartup margin)\\n\", __func__, k, mode_lib->mp.MinTTUVBlank[k]);",
        "#endif",
        "\t\t\ts->Tvstartup_margin = (s->MaxVStartupLines[k] - mode_lib->mp.VStartupMin[k]) * display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
        "\t\t\tmode_lib->mp.MinTTUVBlank[k] = mode_lib->mp.MinTTUVBlank[k] + s->Tvstartup_margin;",
        "",
        "#ifdef __DML_VBA_DEBUG__"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 11850,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
      "context": [
        "",
        "\t\t\ts->dlg_vblank_start = ((isInterlaceTiming ? math_floor2((display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.v_total - display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.v_front_porch) / 2.0, 1.0) :",
        "\t\t\t\tdisplay_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.v_total) - display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.v_front_porch);",
        "\t\t\ts->LSetup = math_floor2(4.0 * mode_lib->mp.TSetup[k] / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)), 1.0) / 4.0;",
        "\t\t\ts->blank_lines_remaining = (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.v_total - display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.v_active) - mode_lib->mp.VStartup[k];",
        "",
        "\t\t\tif (s->blank_lines_remaining < 0) {"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 11893,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[k].timing.pixel_clock",
      "context": [
        "\t\t\t\ts->WRBandwidth = display_cfg->stream_descriptors[k].writeback.writeback_stream[0].output_height",
        "\t\t\t\t\t* display_cfg->stream_descriptors[k].writeback.writeback_stream[0].output_width /",
        "\t\t\t\t\t(display_cfg->stream_descriptors[k].timing.h_total * display_cfg->stream_descriptors[k].writeback.writeback_stream[0].input_height",
        "\t\t\t\t\t\t/ ((double)display_cfg->stream_descriptors[k].timing.pixel_clock_khz / 1000))",
        "\t\t\t\t\t* (display_cfg->stream_descriptors[k].writeback.writeback_stream[0].pixel_format == dml2_444_32 ? 4.0 : 8.0);",
        "\t\t\t\ts->TotalWRBandwidth = s->TotalWRBandwidth + s->WRBandwidth;",
        "\t\t\t}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 12377,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)l->timing->pixel_clock",
      "context": [
        "\t\tl->hblank_end = l->timing->h_blank_end;",
        "\t\tl->vblank_end = l->timing->v_blank_end;",
        "\t\tl->interlaced = l->timing->interlaced;",
        "\t\tl->pclk_freq_in_mhz = (double)l->timing->pixel_clock_khz / 1000;",
        "\t\tl->ref_freq_to_pix_freq = l->refclk_freq_in_mhz / l->pclk_freq_in_mhz;",
        "",
        "\t\tDML_LOG_VERBOSE(\"DML_DLG::%s: plane_idx = %d\\n\", __func__, l->plane_idx);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 12900,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[plane_idx].stream_index].timing.pixel_clock",
      "context": [
        "",
        "\tout->nominal_vblank_pstate_latency_hiding_us =",
        "\t\t(int)(display_cfg->stream_descriptors[display_cfg->plane_descriptors[plane_idx].stream_index].timing.h_total /",
        "\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[plane_idx].stream_index].timing.pixel_clock_khz / 1000) * mode_lib->ms.TWait[plane_idx]);",
        "",
        "\tout->dram_change_latency_hiding_margin_in_active = (int)mode_lib->ms.VActiveLatencyHidingMargin[plane_idx];",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
      "line": 12921,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[plane_index].stream_index].timing.pixel_clock",
      "context": [
        "\tunsigned int rem;",
        "",
        "\tphantom_processing_delay_pix = (double)((mode_lib->ip.subvp_fw_processing_delay_us + mode_lib->ip.subvp_pstate_allow_width_us) *",
        "\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[plane_index].stream_index].timing.pixel_clock_khz / 1000));",
        "\tphantom_processing_delay_lines = (unsigned int)(phantom_processing_delay_pix / (double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[plane_index].stream_index].timing.h_total);",
        "\tdml2_core_div_rem(phantom_processing_delay_pix,",
        "\t\t\t\tdisplay_cfg->stream_descriptors[display_cfg->plane_descriptors[plane_index].stream_index].timing.h_total,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_mcg\\dml2_mcg_dcn4.c",
      "line": 185,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)min_table->max_clock",
      "context": [
        "\tmin_table->max_clocks_khz.dtbclk = soc_bb->clk_table.dtbclk.clk_values_khz[soc_bb->clk_table.dtbclk.num_clk_values - 1];",
        "\tmin_table->max_clocks_khz.phyclk = soc_bb->clk_table.phyclk.clk_values_khz[soc_bb->clk_table.phyclk.num_clk_values - 1];",
        "",
        "\tmin_table->max_ss_clocks_khz.dispclk = (unsigned int)((double)min_table->max_clocks_khz.dispclk / (1.0 + soc_bb->dcn_downspread_percent / 100.0));",
        "\tmin_table->max_ss_clocks_khz.dppclk = (unsigned int)((double)min_table->max_clocks_khz.dppclk / (1.0 + soc_bb->dcn_downspread_percent / 100.0));",
        "\tmin_table->max_ss_clocks_khz.dtbclk = (unsigned int)((double)min_table->max_clocks_khz.dtbclk / (1.0 + soc_bb->dcn_downspread_percent / 100.0));",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_mcg\\dml2_mcg_dcn4.c",
      "line": 186,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)min_table->max_clock",
      "context": [
        "\tmin_table->max_clocks_khz.phyclk = soc_bb->clk_table.phyclk.clk_values_khz[soc_bb->clk_table.phyclk.num_clk_values - 1];",
        "",
        "\tmin_table->max_ss_clocks_khz.dispclk = (unsigned int)((double)min_table->max_clocks_khz.dispclk / (1.0 + soc_bb->dcn_downspread_percent / 100.0));",
        "\tmin_table->max_ss_clocks_khz.dppclk = (unsigned int)((double)min_table->max_clocks_khz.dppclk / (1.0 + soc_bb->dcn_downspread_percent / 100.0));",
        "\tmin_table->max_ss_clocks_khz.dtbclk = (unsigned int)((double)min_table->max_clocks_khz.dtbclk / (1.0 + soc_bb->dcn_downspread_percent / 100.0));",
        "",
        "\tmin_table->max_clocks_khz.dcfclk = soc_bb->clk_table.dcfclk.clk_values_khz[soc_bb->clk_table.dcfclk.num_clk_values - 1];"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_mcg\\dml2_mcg_dcn4.c",
      "line": 187,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)min_table->max_clock",
      "context": [
        "",
        "\tmin_table->max_ss_clocks_khz.dispclk = (unsigned int)((double)min_table->max_clocks_khz.dispclk / (1.0 + soc_bb->dcn_downspread_percent / 100.0));",
        "\tmin_table->max_ss_clocks_khz.dppclk = (unsigned int)((double)min_table->max_clocks_khz.dppclk / (1.0 + soc_bb->dcn_downspread_percent / 100.0));",
        "\tmin_table->max_ss_clocks_khz.dtbclk = (unsigned int)((double)min_table->max_clocks_khz.dtbclk / (1.0 + soc_bb->dcn_downspread_percent / 100.0));",
        "",
        "\tmin_table->max_clocks_khz.dcfclk = soc_bb->clk_table.dcfclk.clk_values_khz[soc_bb->clk_table.dcfclk.num_clk_values - 1];",
        "\tmin_table->max_clocks_khz.fclk = soc_bb->clk_table.fclk.clk_values_khz[soc_bb->clk_table.fclk.num_clk_values - 1];"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_pmo\\dml2_pmo_dcn4_fams2.c",
      "line": 965,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)master_timing->h_total / master_timing->pixel_clock",
      "context": [
        "",
        "\t\t/* trivially set default timing group to itself */",
        "\t\tset_bit_in_bitfield(&s->pmo_dcn4.synchronized_timing_group_masks[timing_group_idx], i);",
        "\t\ts->pmo_dcn4.group_line_time_us[timing_group_idx] = (double)master_timing->h_total / master_timing->pixel_clock_khz * 1000.0;",
        "",
        "\t\t/* if drr is in use, timing is not sychnronizable */",
        "\t\tif (master_timing->drr_config.enabled) {"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_pmo\\dml2_pmo_dcn4_fams2.c",
      "line": 1681,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)timing->h_total / timing->pixel_clock",
      "context": [
        "",
        "\t/* common */",
        "\tstream_fams2_meta->valid = true;",
        "\tstream_fams2_meta->otg_vline_time_us = (double)timing->h_total / timing->pixel_clock_khz * 1000.0;",
        "\tstream_fams2_meta->nom_vtotal = stream_descriptor->timing.vblank_nom + stream_descriptor->timing.v_active;",
        "\tstream_fams2_meta->nom_refresh_rate_hz = timing->pixel_clock_khz * 1000.0 /",
        "\t\t\t(stream_fams2_meta->nom_vtotal * timing->h_total);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_pmo\\dml2_pmo_dcn4_fams2.c",
      "line": 1691,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)stream_descriptor->timing.pixel_clock",
      "context": [
        "",
        "\tif (stream_descriptor->timing.drr_config.enabled == true) {",
        "\t\tif (stream_descriptor->timing.drr_config.min_refresh_uhz != 0.0) {",
        "\t\t\tstream_fams2_meta->max_vtotal = (unsigned int)math_floor((double)stream_descriptor->timing.pixel_clock_khz /",
        "\t\t\t\t\t((double)stream_descriptor->timing.drr_config.min_refresh_uhz * stream_descriptor->timing.h_total) * 1e9);",
        "\t\t} else {",
        "\t\t\t/* assume min of 48Hz */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_pmo\\dml2_pmo_dcn4_fams2.c",
      "line": 1695,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)stream_descriptor->timing.pixel_clock",
      "context": [
        "\t\t\t\t\t((double)stream_descriptor->timing.drr_config.min_refresh_uhz * stream_descriptor->timing.h_total) * 1e9);",
        "\t\t} else {",
        "\t\t\t/* assume min of 48Hz */",
        "\t\t\tstream_fams2_meta->max_vtotal = (unsigned int)math_floor((double)stream_descriptor->timing.pixel_clock_khz /",
        "\t\t\t\t\t(48000000.0 * stream_descriptor->timing.h_total) * 1e9);",
        "\t\t}",
        "\t} else {"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_pmo\\dml2_pmo_dcn4_fams2.c",
      "line": 2287,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)in_out->base_display_config->display_config.stream_descriptors[i].timing.h_total / (in_out->base_display_config->display_config.stream_descriptors[i].timing.pixel_clock",
      "context": [
        "\t}",
        "",
        "\tfor (i = 0; i < in_out->base_display_config->display_config.num_streams; i++) {",
        "\t\tline_time_us = (double)in_out->base_display_config->display_config.stream_descriptors[i].timing.h_total / (in_out->base_display_config->display_config.stream_descriptors[i].timing.pixel_clock_khz * 1000) * 1000000;",
        "\t\tvblank_nom_time_us = line_time_us * in_out->base_display_config->display_config.stream_descriptors[i].timing.vblank_nom;",
        "",
        "\t\tif (vblank_nom_time_us < pmo->soc_bb->power_management_parameters.z8_stutter_exit_latency_us * MIN_BLANK_STUTTER_FACTOR) {"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dsc\\dcn20\\dcn20_dsc.c",
      "line": 527,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer_model_overflow",
      "context": [
        "\treg_vals->dsc_dbg_en                  = 0;",
        "",
        "\tfor (i = 0; i < 4; i++)",
        "\t\treg_vals->rc_buffer_model_overflow_int_en[i] = 0;",
        "",
        "\t/* PPS values */",
        "\treg_vals->pps.dsc_version_minor           = 2;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dsc\\dcn20\\dcn20_dsc.c",
      "line": 618,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_MODEL0_OVERFLOW_OCCURRED_INT_EN, reg_vals->rc_buffer_model_overflow",
      "context": [
        "\t\tDSCC_DISABLE_ICH, reg_vals->disable_ich);*/",
        "",
        "\tREG_SET_4(DSCC_INTERRUPT_CONTROL_STATUS, 0,",
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL0_OVERFLOW_OCCURRED_INT_EN, reg_vals->rc_buffer_model_overflow_int_en[0],",
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL1_OVERFLOW_OCCURRED_INT_EN, reg_vals->rc_buffer_model_overflow_int_en[1],",
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL2_OVERFLOW_OCCURRED_INT_EN, reg_vals->rc_buffer_model_overflow_int_en[2],",
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL3_OVERFLOW_OCCURRED_INT_EN, reg_vals->rc_buffer_model_overflow_int_en[3]);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dsc\\dcn20\\dcn20_dsc.c",
      "line": 619,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_MODEL1_OVERFLOW_OCCURRED_INT_EN, reg_vals->rc_buffer_model_overflow",
      "context": [
        "",
        "\tREG_SET_4(DSCC_INTERRUPT_CONTROL_STATUS, 0,",
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL0_OVERFLOW_OCCURRED_INT_EN, reg_vals->rc_buffer_model_overflow_int_en[0],",
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL1_OVERFLOW_OCCURRED_INT_EN, reg_vals->rc_buffer_model_overflow_int_en[1],",
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL2_OVERFLOW_OCCURRED_INT_EN, reg_vals->rc_buffer_model_overflow_int_en[2],",
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL3_OVERFLOW_OCCURRED_INT_EN, reg_vals->rc_buffer_model_overflow_int_en[3]);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dsc\\dcn20\\dcn20_dsc.c",
      "line": 620,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_MODEL2_OVERFLOW_OCCURRED_INT_EN, reg_vals->rc_buffer_model_overflow",
      "context": [
        "\tREG_SET_4(DSCC_INTERRUPT_CONTROL_STATUS, 0,",
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL0_OVERFLOW_OCCURRED_INT_EN, reg_vals->rc_buffer_model_overflow_int_en[0],",
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL1_OVERFLOW_OCCURRED_INT_EN, reg_vals->rc_buffer_model_overflow_int_en[1],",
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL2_OVERFLOW_OCCURRED_INT_EN, reg_vals->rc_buffer_model_overflow_int_en[2],",
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL3_OVERFLOW_OCCURRED_INT_EN, reg_vals->rc_buffer_model_overflow_int_en[3]);",
        "",
        "\tREG_SET_3(DSCC_PPS_CONFIG0, 0,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dsc\\dcn20\\dcn20_dsc.c",
      "line": 621,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_MODEL3_OVERFLOW_OCCURRED_INT_EN, reg_vals->rc_buffer_model_overflow",
      "context": [
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL0_OVERFLOW_OCCURRED_INT_EN, reg_vals->rc_buffer_model_overflow_int_en[0],",
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL1_OVERFLOW_OCCURRED_INT_EN, reg_vals->rc_buffer_model_overflow_int_en[1],",
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL2_OVERFLOW_OCCURRED_INT_EN, reg_vals->rc_buffer_model_overflow_int_en[2],",
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL3_OVERFLOW_OCCURRED_INT_EN, reg_vals->rc_buffer_model_overflow_int_en[3]);",
        "",
        "\tREG_SET_3(DSCC_PPS_CONFIG0, 0,",
        "\t\tDSC_VERSION_MINOR, reg_vals->pps.dsc_version_minor,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dsc\\dcn401\\dcn401_dsc.c",
      "line": 252,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_MODEL_OVERFLOW_OCCURRED_INT_EN0, reg_vals->rc_buffer_model_overflow",
      "context": [
        "\t\tDSCC_DISABLE_ICH, reg_vals->disable_ich);*/",
        "",
        "\tREG_SET_4(DSCC_INTERRUPT_CONTROL0, 0,",
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL_OVERFLOW_OCCURRED_INT_EN0, reg_vals->rc_buffer_model_overflow_int_en[0],",
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL_OVERFLOW_OCCURRED_INT_EN1, reg_vals->rc_buffer_model_overflow_int_en[1],",
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL_OVERFLOW_OCCURRED_INT_EN2, reg_vals->rc_buffer_model_overflow_int_en[2],",
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL_OVERFLOW_OCCURRED_INT_EN3, reg_vals->rc_buffer_model_overflow_int_en[3]);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dsc\\dcn401\\dcn401_dsc.c",
      "line": 253,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_MODEL_OVERFLOW_OCCURRED_INT_EN1, reg_vals->rc_buffer_model_overflow",
      "context": [
        "",
        "\tREG_SET_4(DSCC_INTERRUPT_CONTROL0, 0,",
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL_OVERFLOW_OCCURRED_INT_EN0, reg_vals->rc_buffer_model_overflow_int_en[0],",
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL_OVERFLOW_OCCURRED_INT_EN1, reg_vals->rc_buffer_model_overflow_int_en[1],",
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL_OVERFLOW_OCCURRED_INT_EN2, reg_vals->rc_buffer_model_overflow_int_en[2],",
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL_OVERFLOW_OCCURRED_INT_EN3, reg_vals->rc_buffer_model_overflow_int_en[3]);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dsc\\dcn401\\dcn401_dsc.c",
      "line": 254,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_MODEL_OVERFLOW_OCCURRED_INT_EN2, reg_vals->rc_buffer_model_overflow",
      "context": [
        "\tREG_SET_4(DSCC_INTERRUPT_CONTROL0, 0,",
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL_OVERFLOW_OCCURRED_INT_EN0, reg_vals->rc_buffer_model_overflow_int_en[0],",
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL_OVERFLOW_OCCURRED_INT_EN1, reg_vals->rc_buffer_model_overflow_int_en[1],",
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL_OVERFLOW_OCCURRED_INT_EN2, reg_vals->rc_buffer_model_overflow_int_en[2],",
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL_OVERFLOW_OCCURRED_INT_EN3, reg_vals->rc_buffer_model_overflow_int_en[3]);",
        "",
        "\tREG_SET_3(DSCC_PPS_CONFIG0, 0,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dsc\\dcn401\\dcn401_dsc.c",
      "line": 255,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_MODEL_OVERFLOW_OCCURRED_INT_EN3, reg_vals->rc_buffer_model_overflow",
      "context": [
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL_OVERFLOW_OCCURRED_INT_EN0, reg_vals->rc_buffer_model_overflow_int_en[0],",
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL_OVERFLOW_OCCURRED_INT_EN1, reg_vals->rc_buffer_model_overflow_int_en[1],",
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL_OVERFLOW_OCCURRED_INT_EN2, reg_vals->rc_buffer_model_overflow_int_en[2],",
        "\t\tDSCC_RATE_CONTROL_BUFFER_MODEL_OVERFLOW_OCCURRED_INT_EN3, reg_vals->rc_buffer_model_overflow_int_en[3]);",
        "",
        "\tREG_SET_3(DSCC_PPS_CONFIG0, 0,",
        "\t\tDSC_VERSION_MINOR, reg_vals->pps.dsc_version_minor,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\hwss\\dce110\\dce110_hwseq.c",
      "line": 2108,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t */",
        "\tfor (i = 0; i < num_pipes; i++) {",
        "\t\t/* dc_state_destruct() might null the stream resources, so fetch tg",
        "\t\t * here first to avoid a race condition. The lifetime of the pointee",
        "\t\t * itself (the timing_generator object) is not a problem here.",
        "\t\t */",
        "\t\tstruct timing_generator *tg = pipe_ctx[i]->stream_res.tg;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\hwss\\dcn10\\dcn10_hwseq.c",
      "line": 3334,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t */",
        "\tfor (i = 0; i < num_pipes; i++) {",
        "\t\t/* dc_state_destruct() might null the stream resources, so fetch tg",
        "\t\t * here first to avoid a race condition. The lifetime of the pointee",
        "\t\t * itself (the timing_generator object) is not a problem here.",
        "\t\t */",
        "\t\tstruct timing_generator *tg = pipe_ctx[i]->stream_res.tg;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\hwss\\dcn20\\dcn20_hwseq.c",
      "line": 2235,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double buffered DSCCLK disable logic in post unlock",
      "context": [
        "\t\tif (is_dsc_ungated) {",
        "\t\t\t/*",
        "\t\t\t * seamless update specific where we will postpone non",
        "\t\t\t * double buffered DSCCLK disable logic in post unlock",
        "\t\t\t * sequence after DSC is disconnected from OPP but not",
        "\t\t\t * yet power gated.",
        "\t\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\hwss\\dcn35\\dcn35_hwseq.c",
      "line": 1494,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\tfor (i = 0; i < num_pipes; i++) {",
        "\t\t/* dc_state_destruct() might null the stream resources, so fetch tg",
        "\t\t * here first to avoid a race condition. The lifetime of the pointee",
        "\t\t * itself (the timing_generator object) is not a problem here.",
        "\t\t */",
        "\t\tstruct timing_generator *tg = pipe_ctx[i]->stream_res.tg;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\link\\protocols\\link_dp_capability.c",
      "line": 2413,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t\tlink->verified_link_cap = last_verified_link_cap;",
        "\t\t}",
        "",
        "\t\t/* For Dp tunneling link, a pending HPD means that we have a race condition between processing",
        "\t\t * current link and processing the pending HPD. Since the training is failed, we should just brak",
        "\t\t * the loop so that we have chance to process the pending HPD.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn20\\dcn20_optc.c",
      "line": 534,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "doublebuffer_enable = optc2_lock",
      "context": [
        "\t\t.disable_reset_trigger = optc1_disable_reset_trigger,",
        "\t\t.lock = optc1_lock,",
        "\t\t.unlock = optc1_unlock,",
        "\t\t.lock_doublebuffer_enable = optc2_lock_doublebuffer_enable,",
        "\t\t.lock_doublebuffer_disable = optc2_lock_doublebuffer_disable,",
        "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
        "\t\t.set_drr = optc1_set_drr,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn20\\dcn20_optc.c",
      "line": 535,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "doublebuffer_disable = optc2_lock",
      "context": [
        "\t\t.lock = optc1_lock,",
        "\t\t.unlock = optc1_unlock,",
        "\t\t.lock_doublebuffer_enable = optc2_lock_doublebuffer_enable,",
        "\t\t.lock_doublebuffer_disable = optc2_lock_doublebuffer_disable,",
        "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
        "\t\t.set_drr = optc1_set_drr,",
        "\t\t.get_last_used_drr_vtotal = optc2_get_last_used_drr_vtotal,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn30\\dcn30_optc.c",
      "line": 387,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "doublebuffer_enable = optc3_lock",
      "context": [
        "\t\t.disable_reset_trigger = optc1_disable_reset_trigger,",
        "\t\t.lock = optc3_lock,",
        "\t\t.unlock = optc1_unlock,",
        "\t\t.lock_doublebuffer_enable = optc3_lock_doublebuffer_enable,",
        "\t\t.lock_doublebuffer_disable = optc3_lock_doublebuffer_disable,",
        "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
        "\t\t.set_drr = optc1_set_drr,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn30\\dcn30_optc.c",
      "line": 388,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "doublebuffer_disable = optc3_lock",
      "context": [
        "\t\t.lock = optc3_lock,",
        "\t\t.unlock = optc1_unlock,",
        "\t\t.lock_doublebuffer_enable = optc3_lock_doublebuffer_enable,",
        "\t\t.lock_doublebuffer_disable = optc3_lock_doublebuffer_disable,",
        "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
        "\t\t.set_drr = optc1_set_drr,",
        "\t\t.get_last_used_drr_vtotal = optc2_get_last_used_drr_vtotal,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn301\\dcn301_optc.c",
      "line": 139,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "doublebuffer_enable = optc3_lock",
      "context": [
        "\t\t.disable_reset_trigger = optc1_disable_reset_trigger,",
        "\t\t.lock = optc3_lock,",
        "\t\t.unlock = optc1_unlock,",
        "\t\t.lock_doublebuffer_enable = optc3_lock_doublebuffer_enable,",
        "\t\t.lock_doublebuffer_disable = optc3_lock_doublebuffer_disable,",
        "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
        "\t\t.set_drr = optc301_set_drr,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn301\\dcn301_optc.c",
      "line": 140,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "doublebuffer_disable = optc3_lock",
      "context": [
        "\t\t.lock = optc3_lock,",
        "\t\t.unlock = optc1_unlock,",
        "\t\t.lock_doublebuffer_enable = optc3_lock_doublebuffer_enable,",
        "\t\t.lock_doublebuffer_disable = optc3_lock_doublebuffer_disable,",
        "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
        "\t\t.set_drr = optc301_set_drr,",
        "\t\t.get_last_used_drr_vtotal = optc2_get_last_used_drr_vtotal,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn31\\dcn31_optc.c",
      "line": 346,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "doublebuffer_enable = optc3_lock",
      "context": [
        "\t\t.disable_reset_trigger = optc1_disable_reset_trigger,",
        "\t\t.lock = optc3_lock,",
        "\t\t.unlock = optc1_unlock,",
        "\t\t.lock_doublebuffer_enable = optc3_lock_doublebuffer_enable,",
        "\t\t.lock_doublebuffer_disable = optc3_lock_doublebuffer_disable,",
        "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
        "\t\t.set_drr = optc31_set_drr,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn31\\dcn31_optc.c",
      "line": 347,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "doublebuffer_disable = optc3_lock",
      "context": [
        "\t\t.lock = optc3_lock,",
        "\t\t.unlock = optc1_unlock,",
        "\t\t.lock_doublebuffer_enable = optc3_lock_doublebuffer_enable,",
        "\t\t.lock_doublebuffer_disable = optc3_lock_doublebuffer_disable,",
        "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
        "\t\t.set_drr = optc31_set_drr,",
        "\t\t.get_last_used_drr_vtotal = optc2_get_last_used_drr_vtotal,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn314\\dcn314_optc.c",
      "line": 224,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "doublebuffer_enable = optc3_lock",
      "context": [
        "\t\t.disable_reset_trigger = optc1_disable_reset_trigger,",
        "\t\t.lock = optc3_lock,",
        "\t\t.unlock = optc1_unlock,",
        "\t\t.lock_doublebuffer_enable = optc3_lock_doublebuffer_enable,",
        "\t\t.lock_doublebuffer_disable = optc3_lock_doublebuffer_disable,",
        "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
        "\t\t.set_drr = optc31_set_drr,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn314\\dcn314_optc.c",
      "line": 225,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "doublebuffer_disable = optc3_lock",
      "context": [
        "\t\t.lock = optc3_lock,",
        "\t\t.unlock = optc1_unlock,",
        "\t\t.lock_doublebuffer_enable = optc3_lock_doublebuffer_enable,",
        "\t\t.lock_doublebuffer_disable = optc3_lock_doublebuffer_disable,",
        "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
        "\t\t.set_drr = optc31_set_drr,",
        "\t\t.get_last_used_drr_vtotal = optc2_get_last_used_drr_vtotal,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn35\\dcn35_optc.c",
      "line": 460,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "doublebuffer_enable = optc3_lock",
      "context": [
        "\t\t.disable_reset_trigger = optc1_disable_reset_trigger,",
        "\t\t.lock = optc3_lock,",
        "\t\t.unlock = optc1_unlock,",
        "\t\t.lock_doublebuffer_enable = optc3_lock_doublebuffer_enable,",
        "\t\t.lock_doublebuffer_disable = optc3_lock_doublebuffer_disable,",
        "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
        "\t\t.set_drr = optc35_set_drr,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn35\\dcn35_optc.c",
      "line": 461,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "doublebuffer_disable = optc3_lock",
      "context": [
        "\t\t.lock = optc3_lock,",
        "\t\t.unlock = optc1_unlock,",
        "\t\t.lock_doublebuffer_enable = optc3_lock_doublebuffer_enable,",
        "\t\t.lock_doublebuffer_disable = optc3_lock_doublebuffer_disable,",
        "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
        "\t\t.set_drr = optc35_set_drr,",
        "\t\t.get_last_used_drr_vtotal = optc2_get_last_used_drr_vtotal,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn32\\dcn32_optc.c",
      "line": 329,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "doublebuffer_enable = optc3_lock",
      "context": [
        "\t\t.disable_reset_trigger = optc1_disable_reset_trigger,",
        "\t\t.lock = optc3_lock,",
        "\t\t.unlock = optc1_unlock,",
        "\t\t.lock_doublebuffer_enable = optc3_lock_doublebuffer_enable,",
        "\t\t.lock_doublebuffer_disable = optc3_lock_doublebuffer_disable,",
        "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
        "\t\t.set_drr = optc32_set_drr,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn32\\dcn32_optc.c",
      "line": 330,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "doublebuffer_disable = optc3_lock",
      "context": [
        "\t\t.lock = optc3_lock,",
        "\t\t.unlock = optc1_unlock,",
        "\t\t.lock_doublebuffer_enable = optc3_lock_doublebuffer_enable,",
        "\t\t.lock_doublebuffer_disable = optc3_lock_doublebuffer_disable,",
        "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
        "\t\t.set_drr = optc32_set_drr,",
        "\t\t.get_last_used_drr_vtotal = optc2_get_last_used_drr_vtotal,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn401\\dcn401_optc.c",
      "line": 491,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "doublebuffer_enable = optc3_lock",
      "context": [
        "\t\t.disable_reset_trigger = optc1_disable_reset_trigger,",
        "\t\t.lock = optc3_lock,",
        "\t\t.unlock = optc1_unlock,",
        "\t\t.lock_doublebuffer_enable = optc3_lock_doublebuffer_enable,",
        "\t\t.lock_doublebuffer_disable = optc3_lock_doublebuffer_disable,",
        "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
        "\t\t.set_drr = optc401_set_drr,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn401\\dcn401_optc.c",
      "line": 492,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "doublebuffer_disable = optc3_lock",
      "context": [
        "\t\t.lock = optc3_lock,",
        "\t\t.unlock = optc1_unlock,",
        "\t\t.lock_doublebuffer_enable = optc3_lock_doublebuffer_enable,",
        "\t\t.lock_doublebuffer_disable = optc3_lock_doublebuffer_disable,",
        "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
        "\t\t.set_drr = optc401_set_drr,",
        "\t\t.get_last_used_drr_vtotal = optc2_get_last_used_drr_vtotal,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\display\\modules\\color\\color_gamma.c",
      "line": 33,
      "pattern": "hardcoded.*values",
      "rule": "code_quality",
      "severity": "low",
      "match": "hardcoded values",
      "context": [
        "/* When calculating LUT values the first region and at least one subsequent",
        " * region are calculated with full precision. These defines are a demarcation",
        " * of where the second region starts and ends.",
        " * These are hardcoded values to avoid recalculating them in loops.",
        " */",
        "#define PRECISE_LUT_REGION_START 224",
        "#define PRECISE_LUT_REGION_END 239"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\pm\\swsmu\\amdgpu_smu.c",
      "line": 355,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " *",
        " * This API uses no smu->mutex lock protection due to:",
        " * 1. It is either called by other IP block(gfx/sdma/vcn/uvd/vce).",
        " *    This is guarded to be race condition free by the caller.",
        " * 2. Or get called on user setting request of power_dpm_force_performance_level.",
        " *    Under this case, the smu->mutex lock protection is already enforced on",
        " *    the parent API smu_force_performance_level of the call path."
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\pm\\swsmu\\smu11\\arcturus_ppt.c",
      "line": 1862,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t\t\t\t    throttling_events > 1 ? \" and \" : \"\",",
        "\t\t\t\t\t    logging_label[throttler_idx].label);",
        "\t\t\tif (buf_idx >= sizeof(log_buf)) {",
        "\t\t\t\tdev_err(adev->dev, \"buffer overflow!\\n\");",
        "\t\t\t\tlog_buf[sizeof(log_buf) - 1] = '\\0';",
        "\t\t\t\tbreak;",
        "\t\t\t}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\pm\\swsmu\\smu13\\aldebaran_ppt.c",
      "line": 1691,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t\t\t\t    throttling_events > 1 ? \" and \" : \"\",",
        "\t\t\t\t\t    logging_label[throttler_idx].label);",
        "\t\t\tif (buf_idx >= sizeof(log_buf)) {",
        "\t\t\t\tdev_err(adev->dev, \"buffer overflow!\\n\");",
        "\t\t\t\tlog_buf[sizeof(log_buf) - 1] = '\\0';",
        "\t\t\t\tbreak;",
        "\t\t\t}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\amd\\pm\\swsmu\\smu13\\smu_v13_0_6_ppt.c",
      "line": 2501,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t\t\t\"%s%s\", throttling_events > 1 ? \" and \" : \"\",",
        "\t\t\t\tthrottling_logging_label[throttler_idx]);",
        "\t\t\tif (buf_idx >= sizeof(log_buf)) {",
        "\t\t\t\tdev_err(adev->dev, \"buffer overflow!\\n\");",
        "\t\t\t\tlog_buf[sizeof(log_buf) - 1] = '\\0';",
        "\t\t\t\tbreak;",
        "\t\t\t}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\bridge\\analogix\\anx7625.c",
      "line": 43,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "/*",
        " * There is a sync issue while access I2C register between AP(CPU) and",
        " * internal firmware(OCM), to avoid the race condition, AP should access",
        " * the reserved slave address before slave address occurs changes.",
        " */",
        "static int i2c_access_workaround(struct anx7625_data *ctx,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\bridge\\imx\\imx8mp-hdmi-tx.c",
      "line": 44,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double-clock",
      "context": [
        "\tif (abs(round_rate - mode->clock * 1000) > mode->clock * 5)",
        "\t\treturn MODE_CLOCK_RANGE;",
        "",
        "\t/* We don't support double-clocked and Interlaced modes */",
        "\tif ((mode->flags & DRM_MODE_FLAG_DBLCLK) ||",
        "\t    (mode->flags & DRM_MODE_FLAG_INTERLACE))",
        "\t\treturn MODE_BAD;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\bridge\\synopsys\\dw-hdmi.c",
      "line": 2923,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double-clock",
      "context": [
        "\tconst struct dw_hdmi_plat_data *pdata = hdmi->plat_data;",
        "\tenum drm_mode_status mode_status = MODE_OK;",
        "",
        "\t/* We don't support double-clocked modes */",
        "\tif (mode->flags & DRM_MODE_FLAG_DBLCLK)",
        "\t\treturn MODE_BAD;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_cx0_phy.c",
      "line": 2550,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "MISSING_CASE(clock",
      "context": [
        "\tcase 675000: /* 6.75 Gbps eDP*/",
        "\t\treturn 12;",
        "\tdefault:",
        "\t\tMISSING_CASE(clock);",
        "\t\treturn 0;",
        "\t}",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_cx0_phy.c",
      "line": 2570,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "MISSING_CASE(clock",
      "context": [
        "\tcase 1000000: /* 10 Gbps */",
        "\t\treturn 3;",
        "\tdefault:",
        "\t\tMISSING_CASE(clock);",
        "\t\treturn 0;",
        "\t}",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_cx0_phy.c",
      "line": 3122,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "MISSING_CASE(clock",
      "context": [
        "\tcase XELPDP_DDI_CLOCK_SELECT_TBT_625:",
        "\t\treturn 2000000;",
        "\tdefault:",
        "\t\tMISSING_CASE(clock);",
        "\t\treturn 162000;",
        "\t}",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_cx0_phy.c",
      "line": 3152,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "MISSING_CASE(clock",
      "context": [
        "\t\t}",
        "\t\treturn XELPDP_DDI_CLOCK_SELECT_TBT_625;",
        "\tdefault:",
        "\t\tMISSING_CASE(clock);",
        "\t\treturn XELPDP_DDI_CLOCK_SELECT_TBT_162;",
        "\t}",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_cursor.c",
      "line": 913,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use a use-after-free",
      "context": [
        "\t/*",
        "\t * We cannot swap crtc_state as it may be in use by an atomic commit or",
        "\t * page flip that's running simultaneously. If we swap crtc_state and",
        "\t * destroy the old state, we will cause a use-after-free there.",
        "\t *",
        "\t * Only update active_planes, which is needed for our internal",
        "\t * bookkeeping. Either value will do the right thing when updating"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_ddi.c",
      "line": 286,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "MISSING_CASE(clock",
      "context": [
        "\t\tcase 810000:",
        "\t\t\treturn DDI_CLK_SEL_TBT_810;",
        "\t\tdefault:",
        "\t\t\tMISSING_CASE(clock);",
        "\t\t\treturn DDI_CLK_SEL_NONE;",
        "\t\t}",
        "\tcase DPLL_ID_ICL_MGPLL1:"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_ddi.c",
      "line": 319,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "MISSING_CASE(port_clock",
      "context": [
        "\tcase 810000:",
        "\t\treturn DDI_BUF_PHY_LINK_RATE(3);",
        "\tdefault:",
        "\t\tMISSING_CASE(port_clock);",
        "\t\treturn DDI_BUF_PHY_LINK_RATE(0);",
        "\t}",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_display.c",
      "line": 2387,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double wide mode when the dot clock",
      "context": [
        "\t\tclock_limit = display->cdclk.max_cdclk_freq * 9 / 10;",
        "",
        "\t\t/*",
        "\t\t * Enable double wide mode when the dot clock",
        "\t\t * is > 90% of the (display) core speed.",
        "\t\t */",
        "\t\tif (intel_crtc_supports_double_wide(crtc) &&"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_display_power.c",
      "line": 1097,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t/*",
        "\t * Might be running this in parallel to gen9_dc_off_power_well_enable",
        "\t * being called from intel_dp_detect for instance,",
        "\t * which causes assertion triggered by race condition,",
        "\t * as gen9_assert_dbuf_enabled might preempt this when registers",
        "\t * were already updated, while dev_priv was not.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_dpll_mgr.c",
      "line": 1112,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "MISSING_CASE(clock",
      "context": [
        "\t\tpll_id = DPLL_ID_LCPLL_2700;",
        "\t\tbreak;",
        "\tdefault:",
        "\t\tMISSING_CASE(clock / 2);",
        "\t\treturn NULL;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_dpll_mgr.c",
      "line": 2717,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "MISSING_CASE(clock",
      "context": [
        "\t\t}",
        "\t}",
        "",
        "\tMISSING_CASE(clock);",
        "\treturn -EINVAL;",
        "}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_dpll_mgr.c",
      "line": 2944,
      "pattern": "hardcoded.*values",
      "rule": "code_quality",
      "severity": "low",
      "match": "hardcoded values",
      "context": [
        "\t\t\tif (div2 >= 2) {",
        "\t\t\t\t/*",
        "\t\t\t\t * Note: a_divratio not matching TGL BSpec",
        "\t\t\t\t * algorithm but matching hardcoded values and",
        "\t\t\t\t * working on HW for DP alt-mode at least",
        "\t\t\t\t */",
        "\t\t\t\ta_divratio = is_dp ? 10 : 5;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_dsb.c",
      "line": 204,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "",
        "\t/* each instruction is 2 dwords */",
        "\treturn !drm_WARN(display->drm, dsb->free_pos > dsb->size - 2,",
        "\t\t\t \"[CRTC:%d:%s] DSB %d buffer overflow\\n\",",
        "\t\t\t crtc->base.base.id, crtc->base.name, dsb->id);",
        "}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_hotplug.c",
      "line": 696,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * Our hotplug handler can grab modeset locks (by calling down into the",
        "\t * fb helpers). Hence it must not be run on our own dev-priv->wq work",
        "\t * queue for otherwise the flush_work in the pageflip code will",
        "\t * deadlock.",
        "\t */",
        "\tif (queue_dig)",
        "\t\tqueue_work(display->hotplug.dp_wq, &display->hotplug.dig_port_work);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_lpe_audio.c",
      "line": 51,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        " * Threats:",
        " * Due to the restriction in Linux platform device model, user need manually",
        " * uninstall the hdmi-lpe-audio driver before uninstalling i915 module,",
        " * otherwise we might run into use-after-free issues after i915 removes the",
        " * platform device: even though hdmi-lpe-audio driver is released, the modules",
        " * is still in \"installed\" status.",
        " *"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_pmdemand.c",
      "line": 396,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Missing to account genlock",
      "context": [
        "",
        "\t/*",
        "\t * Active_PLLs starts with 1 because of CDCLK PLL.",
        "\t * TODO: Missing to account genlock filter when it gets used.",
        "\t */",
        "\tnew_pmdemand_state->params.plls =",
        "\t\tmin_t(u16, new_pmdemand_state->params.active_phys + 1, 7);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_pps.c",
      "line": 451,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\treturn;",
        "",
        "\t/*",
        "\t * We can't grab pps_mutex here due to deadlock with power_domain",
        "\t * mutex when power_domain functions are called while holding pps_mutex.",
        "\t * That also means that in order to use vlv_pps_pipe the code needs to",
        "\t * hold both a power domain reference and pps_mutex, and the power domain"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_psr.c",
      "line": 1857,
      "pattern": "hardcoded.*values",
      "rule": "code_quality",
      "severity": "low",
      "match": "hardcoded values",
      "context": [
        "",
        "\t/*",
        "\t * Only HSW and BDW have PSR AUX registers that need to be setup.",
        "\t * SKL+ use hardcoded values PSR AUX transactions",
        "\t */",
        "\tif (DISPLAY_VER(display) < 9)",
        "\t\thsw_psr_setup_aux(intel_dp);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_tv.c",
      "line": 187,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        " */",
        "",
        "/*",
        " * Behold, magic numbers!  If we plant them they might grow a big",
        " * s-video cable to the sky... or something.",
        " *",
        " * Pre-converted to appropriate hex value."
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_vblank.c",
      "line": 144,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tu32 scan_prev_time, scan_curr_time, scan_post_time;",
        "",
        "\t/*",
        "\t * To avoid the race condition where we might cross into the",
        "\t * next vblank just between the PIPE_FRMTMSTMP and TIMESTAMP_CTR",
        "\t * reads. We make sure we read PIPE_FRMTMSTMP and TIMESTAMP_CTR",
        "\t * during the same frame."
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\gem\\i915_gem_execbuffer.c",
      "line": 185,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * the object. Simple! ... The relocation entries are stored in user memory",
        " * and so to access them we have to copy them into a local buffer. That copy",
        " * has to avoid taking any pagefaults as they may lead back to a GEM object",
        " * requiring the struct_mutex (i.e. recursive deadlock). So once again we split",
        " * the relocation into multiple passes. First we try to do everything within an",
        " * atomic context (avoid the pagefaults) which requires that we never wait. If",
        " * we detect that we may wait, or if we need to fault, then we have to fallback"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\gem\\i915_gem_execbuffer.c",
      "line": 766,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * progress (perhaps we are fighting the shrinker?). When evicting the",
        "\t * VM this time around, anything that we can't lock we now track using",
        "\t * the busy_bo, using the full lock (after dropping the vm->mutex to",
        "\t * prevent deadlocks), instead of trylock. We then continue to evict the",
        "\t * VM, this time with the stubborn object locked, which we can now",
        "\t * hopefully unbind (if still bound in the VM). Repeat until the VM is",
        "\t * evicted. Finally we should be able bind everything."
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\gem\\i915_gem_object.c",
      "line": 746,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * available.",
        " *",
        " * Return: 0 on success. Negative error code on failure. In particular may",
        " * return -ENXIO on lack of region space, -EDEADLK for deadlock avoidance",
        " * if @ww is set, -EINTR or -ERESTARTSYS if signal pending, and",
        " * -EBUSY if the object is pinned.",
        " */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\gem\\i915_gem_object.c",
      "line": 780,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * available.",
        " *",
        " * Return: 0 on success. Negative error code on failure. In particular may",
        " * return -ENXIO on lack of region space, -EDEADLK for deadlock avoidance",
        " * if @ww is set, -EINTR or -ERESTARTSYS if signal pending, and",
        " * -EBUSY if the object is pinned.",
        " */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\gem\\i915_gem_pages.c",
      "line": 290,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * As these are finite, map_new_virtual() must wait for some",
        "\t\t * other kmap() to finish when it runs out. If we map a large",
        "\t\t * number of objects, there is no method for it to tell us",
        "\t\t * to release the mappings, and we deadlock.",
        "\t\t *",
        "\t\t * However, if we make an explicit vmap of the page, that",
        "\t\t * uses a larger vmalloc arena, and also has the ability"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\gem\\i915_gem_shrinker.c",
      "line": 92,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * free system memory - the pages might still be in-used to due to other reasons",
        " * (like cpu mmaps) or the mm core has reused them before we could grab them.",
        " * Therefore code that needs to explicitly shrink buffer objects caches (e.g. to",
        " * avoid deadlocks in memory reclaim) must fall back to i915_gem_shrink_all().",
        " *",
        " * Also note that any kind of pinning (both per-vma address space pins and",
        " * backing storage pins at the buffer object level) result in the shrinker code"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\gem\\i915_gem_userptr.c",
      "line": 193,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t * migrate_folio, that is alreadying holding the lock",
        "\t\t\t * on the folio. Such a try_to_unmap() will result",
        "\t\t\t * in us calling put_pages() and so recursively try",
        "\t\t\t * to lock the page. We avoid that deadlock with",
        "\t\t\t * a trylock_page() and in exchange we risk missing",
        "\t\t\t * some page dirtying.",
        "\t\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\gem\\i915_gem_wait.c",
      "line": 227,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * non-zero timeout parameter the wait ioctl will wait for the given number of",
        " * nanoseconds on an object becoming unbusy. Since the wait itself does so",
        " * without holding struct_mutex the object may become re-busied before this",
        " * function completes. A similar but shorter * race condition exists in the busy",
        " * ioctl",
        " */",
        "int"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\intel_execlists_submission.c",
      "line": 1890,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t\t * breadcrumb will be complete before we see the",
        "\t\t * context-switch). As we only hold the reference to the",
        "\t\t * request, any pointer chasing underneath the request",
        "\t\t * is subject to a potential use-after-free. Thus we",
        "\t\t * store all of the bookkeeping within port[] as",
        "\t\t * required, and avoid using unguarded pointers beneath",
        "\t\t * request itself. The same applies to the atomic"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\intel_gt_clock_utils.c",
      "line": 50,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "MISSING_CASE(crystal_clock",
      "context": [
        "\tcase GEN11_RPM_CONFIG0_CRYSTAL_CLOCK_FREQ_25_MHZ:",
        "\t\treturn f25_mhz;",
        "\tdefault:",
        "\t\tMISSING_CASE(crystal_clock);",
        "\t\treturn 0;",
        "\t}",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\intel_lrc.c",
      "line": 1634,
      "pattern": "code.*duplication",
      "rule": "code_quality",
      "severity": "low",
      "match": "code duplication",
      "context": [
        " * at that time and set our bit of interest but it makes the WA complicated.",
        " *",
        " * This WA is also required for Gen9 so extracting as a function avoids",
        " * code duplication.",
        " */",
        "static u32 *",
        "gen8_emit_flush_coherentl3_wa(struct intel_engine_cs *engine, u32 *batch)"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\gem\\selftests\\i915_gem_migrate.c",
      "line": 407,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * Use MI_NOOP, making the spinner non-preemptible. If there",
        "\t\t * is a code path where we fail async operation due to the",
        "\t\t * running spinner, we will block and fail to end the",
        "\t\t * spinner resulting in a deadlock. But with a non-",
        "\t\t * preemptible spinner, hangcheck will terminate the spinner",
        "\t\t * for us, and we will later detect that and fail the test.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\gem\\selftests\\i915_gem_migrate.c",
      "line": 444,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * Setting ASYNC_FAIL_ALLOC to 2 will simulate memory allocation failure while",
        " * arming the migration error check and block async migration. This",
        " * will cause us to deadlock and hangcheck will terminate the spinner",
        " * causing the test to fail.",
        " */",
        "#define ASYNC_FAIL_ALLOC 1"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_capture.c",
      "line": 1327,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer in case of overflow",
      "context": [
        "",
        "\t/* Now copy the actual logs. */",
        "\tif (unlikely(new_overflow)) {",
        "\t\t/* copy the whole buffer in case of overflow */",
        "\t\tread_offset = 0;",
        "\t\twrite_offset = buffer_size;",
        "\t} else if (unlikely((read_offset > buffer_size) ||"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_ct.c",
      "line": 21,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\tCT_DEAD_ALIVE = 0,",
        "\tCT_DEAD_SETUP,",
        "\tCT_DEAD_WRITE,",
        "\tCT_DEAD_DEADLOCK,",
        "\tCT_DEAD_H2G_HAS_ROOM,",
        "\tCT_DEAD_READ,",
        "\tCT_DEAD_PROCESS_FAILED,"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_ct.c",
      "line": 569,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "}",
        "",
        "#define GUC_CTB_TIMEOUT_MS\t1500",
        "static inline bool ct_deadlocked(struct intel_guc_ct *ct)",
        "{",
        "\tlong timeout = GUC_CTB_TIMEOUT_MS;",
        "\tbool ret = ktime_ms_delta(ktime_get(), ct->stall_time) > timeout;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_ct.c",
      "line": 590,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t\tCT_ERROR(ct, \"Head: %u\\n (Dwords)\", ct->ctbs.recv.desc->head);",
        "\t\tCT_ERROR(ct, \"Tail: %u\\n (Dwords)\", ct->ctbs.recv.desc->tail);",
        "",
        "\t\tCT_DEAD(ct, DEADLOCK);",
        "\t\tct->ctbs.send.broken = true;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_ct.c",
      "line": 664,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tif (!g2h)",
        "\t\t\ttasklet_hi_schedule(&ct->receive_tasklet);",
        "",
        "\t\tif (unlikely(ct_deadlocked(ct)))",
        "\t\t\treturn -EPIPE;",
        "\t\telse",
        "\t\t\treturn -EBUSY;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_ct.c",
      "line": 749,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\tct->stall_time = ktime_get();",
        "\t\tspin_unlock_irqrestore(&ctb->lock, flags);",
        "",
        "\t\tif (unlikely(ct_deadlocked(ct)))",
        "\t\t\treturn -EPIPE;",
        "",
        "\t\tif (msleep_interruptible(sleep_period_ms))"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_ct.c",
      "line": 1221,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tGEM_BUG_ON(FIELD_GET(GUC_HXG_MSG_0_TYPE, hxg[0]) != GUC_HXG_TYPE_EVENT);",
        "",
        "\t/*",
        "\t * Adjusting the space must be done in IRQ or deadlock can occur as the",
        "\t * CTB processing in the below workqueue can send CTBs which creates a",
        "\t * circular dependency if the space was returned there.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_log.c",
      "line": 336,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t\tlog->stats[type].sampled_overflow += 16;",
        "\t\t}",
        "",
        "\t\tguc_notice_ratelimited(log_to_guc(log), \"log buffer overflow\\n\");",
        "\t}",
        "",
        "\treturn overflow;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_log.c",
      "line": 449,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer in case of overflow",
      "context": [
        "",
        "\t\t/* Now copy the actual logs. */",
        "\t\tif (unlikely(new_overflow)) {",
        "\t\t\t/* copy the whole buffer in case of overflow */",
        "\t\t\tread_offset = 0;",
        "\t\t\twrite_offset = buffer_size;",
        "\t\t} else if (unlikely((read_offset > buffer_size) ||"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_fw.c",
      "line": 174,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * (Higher levels of the driver may decide to reset the GuC and",
        "\t * attempt the ucode load again if this happens.)",
        "\t *",
        "\t * FIXME: There is a known (but exceedingly unlikely) race condition",
        "\t * where the asynchronous frequency management code could reduce",
        "\t * the GT clock while a GuC reload is in progress (during a full",
        "\t * GT reset). A fix is in progress but there are complex locking"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_submission.c",
      "line": 3447,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * with suspend, so we undo everything if the H2G fails in deregister_context so",
        "\t * that GuC reset will find this context during clean up.",
        "\t *",
        "\t * There is a race condition where the reset code could have altered",
        "\t * this context's state and done a wakeref put before we try to",
        "\t * deregister it here. So check if the context is still set to be",
        "\t * destroyed before undoing earlier changes, to avoid two wakeref puts"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_submission.c",
      "line": 3933,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t/*",
        "\t * Call pin_guc_id here rather than in the pinning step as with",
        "\t * dma_resv, contexts can be repeatedly pinned / unpinned trashing the",
        "\t * guc_id and creating horrible race conditions. This is especially bad",
        "\t * when guc_id are being stolen due to over subscription. By the time",
        "\t * this function is reached, it is guaranteed that the guc_id will be",
        "\t * persistent until the generated request is retired. Thus, sealing these"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_submission.c",
      "line": 3937,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * when guc_id are being stolen due to over subscription. By the time",
        "\t * this function is reached, it is guaranteed that the guc_id will be",
        "\t * persistent until the generated request is retired. Thus, sealing these",
        "\t * race conditions. It is still safe to fail here if guc_id are",
        "\t * exhausted and return -EAGAIN to the user indicating that they can try",
        "\t * again in the future.",
        "\t *"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_submission.c",
      "line": 1398,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * hold the reset mutex. The busyness worker also attempts to acquire the",
        "\t * reset mutex. Synchronously flushing a worker thread requires acquiring",
        "\t * the worker mutex. Lockdep sees this as a conflict. It thinks that the",
        "\t * flush can deadlock because it holds the worker mutex while waiting for",
        "\t * the reset mutex, but another thread is holding the reset mutex and might",
        "\t * attempt to use other worker functions.",
        "\t *"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_submission.c",
      "line": 1537,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * gt_park path cancels the worker synchronously and this complicates",
        "\t * the flow if the worker is also running at the same time. The cancel",
        "\t * waits for the worker and when the worker releases the wakeref, that",
        "\t * would call gt_park and would lead to a deadlock.",
        "\t *",
        "\t * The resolution is to take the global pm wakeref if runtime pm is",
        "\t * already active. If not, we don't need to update the busyness stats as"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_submission.c",
      "line": 1565,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * Synchronize with gt reset to make sure the worker does not",
        "\t * corrupt the engine/guc stats. NB: can't actually block waiting",
        "\t * for a reset to complete as the reset requires flushing out",
        "\t * this worker thread if started. So waiting would deadlock.",
        "\t */",
        "\tret = intel_gt_reset_trylock(gt, &srcu);",
        "\tif (ret)"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\msm\\adreno\\a6xx_preempt.c",
      "line": 182,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\ttrace_msm_gpu_preemption_irq(a6xx_gpu->cur_ring->id);",
        "",
        "\t/*",
        "\t * Retrigger preemption to avoid a deadlock that might occur when preemption",
        "\t * is skipped due to it being already in flight when requested.",
        "\t */",
        "\ta6xx_preempt_trigger(gpu);"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\nouveau\\dispnv04\\arb.c",
      "line": 30,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic\" numbers",
      "context": [
        "",
        "/****************************************************************************\\",
        "*                                                                            *",
        "* The video arbitration routines calculate some \"magic\" numbers.  Fixes      *",
        "* the snow seen when accessing the framebuffer without it.                   *",
        "* It just works (I hope).                                                    *",
        "*                                                                            *"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\nouveau\\dispnv50\\crc.c",
      "line": 591,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tif (IS_ERR(crtc_state)) {",
        "\t\tret = PTR_ERR(crtc_state);",
        "\t\tif (ret == -EDEADLK)",
        "\t\t\tgoto deadlock;",
        "\t\telse if (ret)",
        "\t\t\tgoto out_drop_locks;",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\nouveau\\dispnv50\\crc.c",
      "line": 601,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\tret = drm_atomic_commit(state);",
        "\tif (ret == -EDEADLK)",
        "\t\tgoto deadlock;",
        "\telse if (ret)",
        "\t\tgoto out_drop_locks;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\nouveau\\dispnv50\\crc.c",
      "line": 625,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tdrm_modeset_acquire_fini(&ctx);",
        "\treturn ret;",
        "",
        "deadlock:",
        "\tdrm_atomic_state_clear(state);",
        "\tdrm_modeset_backoff(&ctx);",
        "\tgoto retry;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\nouveau\\dispnv50\\disp.c",
      "line": 1470,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/* Don't change the MST state of this connector until we've finished",
        "\t * resuming, since we can't safely grab hpd_irq_lock in our resume",
        "\t * path to protect mstm->is_mst without potentially deadlocking",
        "\t */",
        "\tmutex_lock(&outp->dp.hpd_irq_lock);",
        "\tmstm->suspended = true;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\nouveau\\nvkm\\engine\\gr\\gf100.c",
      "line": 1285,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "STACK_OVERFLOW",
      "context": [
        "\t{ 0x00000001, \"SM_TO_SM_FAULT\" },",
        "\t{ 0x00000002, \"L1_ERROR\" },",
        "\t{ 0x00000004, \"MULTIPLE_WARP_ERRORS\" },",
        "\t{ 0x00000008, \"PHYSICAL_STACK_OVERFLOW\" },",
        "\t{ 0x00000010, \"BPT_INT\" },",
        "\t{ 0x00000020, \"BPT_PAUSE\" },",
        "\t{ 0x00000040, \"SINGLE_STEP_COMPLETE\" },"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\nouveau\\nvkm\\subdev\\bios\\init.c",
      "line": 784,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race(\"IO_FLAG_CONDITION",
      "context": [
        "\tstruct nvkm_bios *bios = init->subdev->device->bios;",
        "\tu8 cond = nvbios_rd08(bios, init->offset + 1);",
        "",
        "\ttrace(\"IO_FLAG_CONDITION\\t0x%02x\\n\", cond);",
        "\tinit->offset += 2;",
        "",
        "\tif (!init_io_flag_condition_met(init, cond))"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\nouveau\\nvkm\\subdev\\bios\\init.c",
      "line": 805,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race(\"GENERIC_CONDITION",
      "context": [
        "\tu8  ver, hdr, cnt, len;",
        "\tu16 data;",
        "",
        "\ttrace(\"GENERIC_CONDITION\\t0x%02x 0x%02x\\n\", cond, size);",
        "\tinit->offset += 3;",
        "",
        "\tswitch (cond) {"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\nouveau\\nvkm\\subdev\\bios\\init.c",
      "line": 1244,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race(\"CONDITION",
      "context": [
        "\tu8 retry = nvbios_rd08(bios, init->offset + 2);",
        "\tu8  wait = min((u16)retry * 50, 100);",
        "",
        "\ttrace(\"CONDITION_TIME\\t0x%02x 0x%02x\\n\", cond, retry);",
        "\tinit->offset += 3;",
        "",
        "\tif (!init_exec(init))"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\nouveau\\nvkm\\subdev\\bios\\init.c",
      "line": 1696,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race(\"RAM_CONDITION",
      "context": [
        "\tu8  mask = nvbios_rd08(bios, init->offset + 1);",
        "\tu8 value = nvbios_rd08(bios, init->offset + 2);",
        "",
        "\ttrace(\"RAM_CONDITION\\t\"",
        "\t      \"(R[0x100000] & 0x%02x) == 0x%02x\\n\", mask, value);",
        "\tinit->offset += 3;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\nouveau\\nvkm\\subdev\\bios\\init.c",
      "line": 1769,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race(\"STRAP_CONDITION",
      "context": [
        "\tu32 mask = nvbios_rd32(bios, init->offset + 1);",
        "\tu32 value = nvbios_rd32(bios, init->offset + 5);",
        "",
        "\ttrace(\"STRAP_CONDITION\\t(R[0x101000] & 0x%08x) == 0x%08x\\n\", mask, value);",
        "\tinit->offset += 9;",
        "",
        "\tif ((init_rd32(init, 0x101000) & mask) != value)"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\nouveau\\nvkm\\subdev\\bios\\init.c",
      "line": 1807,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race(\"CONDITION",
      "context": [
        "\tstruct nvkm_bios *bios = init->subdev->device->bios;",
        "\tu8 cond = nvbios_rd08(bios, init->offset + 1);",
        "",
        "\ttrace(\"CONDITION\\t0x%02x\\n\", cond);",
        "\tinit->offset += 2;",
        "",
        "\tif (!init_condition_met(init, cond))"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\nouveau\\nvkm\\subdev\\bios\\init.c",
      "line": 1824,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race(\"IO_CONDITION",
      "context": [
        "\tstruct nvkm_bios *bios = init->subdev->device->bios;",
        "\tu8 cond = nvbios_rd08(bios, init->offset + 1);",
        "",
        "\ttrace(\"IO_CONDITION\\t0x%02x\\n\", cond);",
        "\tinit->offset += 2;",
        "",
        "\tif (!init_io_condition_met(init, cond))"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\nouveau\\nvkm\\subdev\\therm\\fan.c",
      "line": 81,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t}",
        "",
        "\t/* fan speed updated, drop the fan lock before grabbing the",
        "\t * alarm-scheduling lock and risking a deadlock",
        "\t */",
        "\tspin_unlock_irqrestore(&fan->lock, flags);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\ttm\\tests\\ttm_bo_test.c",
      "line": 134,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "/*",
        " * A test case heavily inspired by ww_test_edeadlk_normal(). It injects",
        " * a deadlock by manipulating the sequence number of the context that holds",
        " * dma_resv lock of bo2 so the other context is \"wounded\" and has to back off",
        " * (indicated by -EDEADLK). The subtest checks if ttm_bo_reserve() properly",
        " * propagates that error."
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\ttm\\tests\\ttm_bo_test.c",
      "line": 139,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * (indicated by -EDEADLK). The subtest checks if ttm_bo_reserve() properly",
        " * propagates that error.",
        " */",
        "static void ttm_bo_reserve_deadlock(struct kunit *test)",
        "{",
        "\tstruct ttm_buffer_object *bo1, *bo2;",
        "\tstruct ww_acquire_ctx ctx1, ctx2;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\ttm\\tests\\ttm_bo_test.c",
      "line": 153,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tww_acquire_init(&ctx1, &reservation_ww_class);",
        "\tww_mutex_base_lock(&bo2->base.resv->lock.base);",
        "",
        "\t/* The deadlock will be caught by WW mutex, don't warn about it */",
        "\tlock_release(&bo2->base.resv->lock.base.dep_map, 1);",
        "",
        "\tbo2->base.resv->lock.ctx = &ctx2;"
      ]
    },
    {
      "file": "linux\\drivers\\gpu\\drm\\ttm\\tests\\ttm_bo_test.c",
      "line": 615,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "#if IS_BUILTIN(CONFIG_DRM_TTM_KUNIT_TEST)",
        "\tKUNIT_CASE(ttm_bo_reserve_interrupted),",
        "#endif",
        "\tKUNIT_CASE(ttm_bo_reserve_deadlock),",
        "\tKUNIT_CASE(ttm_bo_unreserve_basic),",
        "\tKUNIT_CASE(ttm_bo_unreserve_pinned),",
        "\tKUNIT_CASE(ttm_bo_unreserve_bulk),"
      ]
    },
    {
      "file": "linux\\drivers\\hid\\bpf\\hid_bpf_dispatch.c",
      "line": 418,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\tctx_kern = container_of(ctx, struct hid_bpf_ctx_kern, ctx);",
        "",
        "\tif (ctx_kern->from_bpf)",
        "\t\treturn -EDEADLOCK;",
        "",
        "\t/* check arguments */",
        "\tret = __hid_bpf_hw_check_params(ctx, buf, &size, rtype);"
      ]
    },
    {
      "file": "linux\\drivers\\hid\\bpf\\hid_bpf_dispatch.c",
      "line": 476,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "",
        "\tctx_kern = container_of(ctx, struct hid_bpf_ctx_kern, ctx);",
        "\tif (ctx_kern->from_bpf)",
        "\t\treturn -EDEADLOCK;",
        "",
        "\t/* check arguments */",
        "\tret = __hid_bpf_hw_check_params(ctx, buf, &size, HID_OUTPUT_REPORT);"
      ]
    },
    {
      "file": "linux\\drivers\\hid\\bpf\\hid_bpf_dispatch.c",
      "line": 502,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "",
        "\tctx_kern = container_of(ctx, struct hid_bpf_ctx_kern, ctx);",
        "\tif (ctx_kern->from_bpf)",
        "\t\treturn -EDEADLOCK;",
        "",
        "\t/* check arguments */",
        "\tret = __hid_bpf_hw_check_params(ctx, buf, &size, type);"
      ]
    },
    {
      "file": "linux\\drivers\\hid\\usbhid\\hid-pidff.c",
      "line": 465,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing Parameter Block",
      "context": [
        "{",
        "\tint i, max_axis;",
        "",
        "\t/* Devices missing Parameter Block Offset can only have one axis */",
        "\tmax_axis = pidff->quirks & HID_PIDFF_QUIRK_MISSING_PBO ? 1 : 2;",
        "",
        "\tpidff->set_condition[PID_EFFECT_BLOCK_INDEX].value[0] ="
      ]
    },
    {
      "file": "linux\\drivers\\hid\\usbhid\\hid-core.c",
      "line": 565,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t */",
        "\t\t\tusb_block_urb(usbhid->urbout);",
        "",
        "\t\t\t/* Drop lock to avoid deadlock if the callback runs */",
        "\t\t\tspin_unlock(&usbhid->lock);",
        "",
        "\t\t\tusb_unlink_urb(usbhid->urbout);"
      ]
    },
    {
      "file": "linux\\drivers\\hid\\usbhid\\hid-core.c",
      "line": 616,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t */",
        "\t\tusb_block_urb(usbhid->urbctrl);",
        "",
        "\t\t/* Drop lock to avoid deadlock if the callback runs */",
        "\t\tspin_unlock(&usbhid->lock);",
        "",
        "\t\tusb_unlink_urb(usbhid->urbctrl);"
      ]
    },
    {
      "file": "linux\\drivers\\hid\\intel-ish-hid\\ishtp\\client.c",
      "line": 1022,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t}",
        "",
        "\t\t/*",
        "\t\t * If message buffer overflown (exceeds max. client msg",
        "\t\t * size, drop message and return to free buffer.",
        "\t\t * Do we need to disconnect such a client? (We don't send",
        "\t\t * back FC, so communication will be stuck anyway)"
      ]
    },
    {
      "file": "linux\\drivers\\hid\\intel-ish-hid\\ishtp\\client.c",
      "line": 1144,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t}",
        "",
        "\t\t/*",
        "\t\t * If message buffer overflown (exceeds max. client msg",
        "\t\t * size, drop message and return to free buffer.",
        "\t\t * Do we need to disconnect such a client? (We don't send",
        "\t\t * back FC, so communication will be stuck anyway)"
      ]
    },
    {
      "file": "linux\\drivers\\hid\\intel-ish-hid\\ishtp\\hbm.c",
      "line": 858,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t\t(RD_INT_FIFO_SIZE * IPC_PAYLOAD_SIZE) ==",
        "\t\t\tdev->rd_msg_fifo_head) {",
        "\t\tspin_unlock_irqrestore(&dev->rd_msg_spinlock, flags);",
        "\t\tdev_err(dev->devc, \"BH buffer overflow, dropping HBM %u\\n\",",
        "\t\t\t(unsigned int)ishtp_msg->hbm_cmd);",
        "\t\tgoto\teoi;",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\hwtracing\\coresight\\coresight-cpu-debug.c",
      "line": 131,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Double Lock is lock",
      "context": [
        " * registers to avoid lockup issue:",
        " *",
        " * - CPU power domain is powered off;",
        " * - The OS Double Lock is locked;",
        " *",
        " * By checking EDPRSR can get to know if meet these conditions.",
        " */"
      ]
    },
    {
      "file": "linux\\drivers\\hwtracing\\coresight\\coresight-cpu-debug.c",
      "line": 141,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Double Lock is lock",
      "context": [
        "\tif (!(drvdata->edprsr & EDPRSR_PU))",
        "\t\treturn false;",
        "",
        "\t/* The OS Double Lock is locked */",
        "\tif (drvdata->edprsr & EDPRSR_DLK)",
        "\t\treturn false;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\hwtracing\\coresight\\coresight-etm-perf.c",
      "line": 600,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\t/*",
        "\t * The per CPU sink has own interrupt handling, it might have",
        "\t * race condition with updating buffer on AUX trace pause if",
        "\t * it is invoked from NMI.  To avoid the race condition,",
        "\t * disallows updating buffer for the per CPU sink case.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\hwtracing\\coresight\\coresight-etm-perf.c",
      "line": 601,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t/*",
        "\t * The per CPU sink has own interrupt handling, it might have",
        "\t * race condition with updating buffer on AUX trace pause if",
        "\t * it is invoked from NMI.  To avoid the race condition,",
        "\t * disallows updating buffer for the per CPU sink case.",
        "\t */",
        "\tif (coresight_is_percpu_sink(sink))"
      ]
    },
    {
      "file": "linux\\drivers\\hwtracing\\coresight\\coresight-etm4x-core.c",
      "line": 2239,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tinit_arg.csa = &access;",
        "",
        "\t/*",
        "\t * Serialize against CPUHP callbacks to avoid race condition",
        "\t * between the smp call and saving the delayed probe.",
        "\t */",
        "\tcpus_read_lock();"
      ]
    },
    {
      "file": "linux\\drivers\\hwtracing\\coresight\\coresight-syscfg.c",
      "line": 1234,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t/*",
        "\t * grab the mutex - even though we are exiting, some configfs files",
        "\t * may still be live till we dump them, so ensure list data is",
        "\t * protected from a race condition.",
        "\t */",
        "\tmutex_lock(&cscfg_mutex);",
        "\twhile (!list_empty(&cscfg_mgr->load_order_list)) {"
      ]
    },
    {
      "file": "linux\\drivers\\hwtracing\\coresight\\coresight-tmc-etr.c",
      "line": 1557,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use after free",
      "context": [
        "",
        "\t/*",
        "\t * Something went very wrong if the buffer associated with this ID",
        "\t * is not the same in the IDR.  Leak to avoid use after free.",
        "\t */",
        "\tif (buf && WARN_ON(buf != etr_buf))",
        "\t\tgoto free_etr_perf_buffer;"
      ]
    },
    {
      "file": "linux\\drivers\\i2c\\busses\\i2c-altera.c",
      "line": 402,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing clock",
      "context": [
        "",
        "\tidev->i2c_clk = devm_clk_get(&pdev->dev, NULL);",
        "\tif (IS_ERR(idev->i2c_clk)) {",
        "\t\tdev_err(&pdev->dev, \"missing clock\\n\");",
        "\t\treturn PTR_ERR(idev->i2c_clk);",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\i2c\\busses\\i2c-axxia.c",
      "line": 741,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing clock",
      "context": [
        "",
        "\tidev->i2c_clk = devm_clk_get(&pdev->dev, \"i2c\");",
        "\tif (IS_ERR(idev->i2c_clk)) {",
        "\t\tdev_err(&pdev->dev, \"missing clock\\n\");",
        "\t\treturn PTR_ERR(idev->i2c_clk);",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\i2c\\busses\\i2c-bcm-kona.c",
      "line": 709,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing clock",
      "context": [
        "\tint ret = of_property_read_u32(dev->device->of_node, \"clock-frequency\",",
        "\t\t\t\t       &bus_speed);",
        "\tif (ret < 0) {",
        "\t\tdev_err(dev->device, \"missing clock-frequency property\\n\");",
        "\t\treturn -ENODEV;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\i2c\\busses\\i2c-designware-master.c",
      "line": 869,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t/*",
        "\t * We must disable the adapter before returning and signaling the end",
        "\t * of the current transfer. Otherwise the hardware might continue",
        "\t * generating interrupts which in turn causes a race condition with",
        "\t * the following transfer. Needs some more investigation if the",
        "\t * additional interrupts are a hardware bug or this driver doesn't",
        "\t * handle them correctly yet."
      ]
    },
    {
      "file": "linux\\drivers\\i2c\\busses\\i2c-meson.c",
      "line": 80,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * @count:\tNumber of bytes to be sent/received in current transfer",
        " * @pos:\tCurrent position in the send/receive buffer",
        " * @error:\tFlag set when an error is received",
        " * @lock:\tTo avoid race conditions between irq handler and xfer code",
        " * @done:\tCompletion used to wait for transfer termination",
        " * @tokens:\tSequence of tokens to be written to the device",
        " * @num_tokens:\tNumber of tokens"
      ]
    },
    {
      "file": "linux\\drivers\\i2c\\busses\\i2c-microchip-corei2c.c",
      "line": 555,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing clock",
      "context": [
        "\tidev->i2c_clk = devm_clk_get(&pdev->dev, NULL);",
        "\tif (IS_ERR(idev->i2c_clk))",
        "\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(idev->i2c_clk),",
        "\t\t\t\t     \"missing clock\\n\");",
        "",
        "\tidev->dev = &pdev->dev;",
        "\tinit_completion(&idev->msg_complete);"
      ]
    },
    {
      "file": "linux\\drivers\\i2c\\busses\\i2c-npcm7xx.c",
      "line": 2409,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double the timeout for clock",
      "context": [
        "\t\t\t\t       read_block)) {",
        "\t\t/*",
        "\t\t * Adaptive TimeOut: estimated time in usec + 100% margin:",
        "\t\t * 2: double the timeout for clock stretching case",
        "\t\t * 9: bits per transaction (including the ack/nack)",
        "\t\t */",
        "\t\ttimeout_usec = (2 * 9 * USEC_PER_SEC / bus->bus_freq) * (2 + nread + nwrite);"
      ]
    },
    {
      "file": "linux\\drivers\\i2c\\busses\\i2c-ocores.c",
      "line": 557,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Missing required parameter 'opencores,ip-clock",
      "context": [
        "\t\t\t\t\t\t&val)) {",
        "\t\t\tif (!clock_frequency_present) {",
        "\t\t\t\tdev_err(&pdev->dev,",
        "\t\t\t\t\t\"Missing required parameter 'opencores,ip-clock-frequency'\\n\");",
        "\t\t\t\treturn -ENODEV;",
        "\t\t\t}",
        "\t\t\ti2c->ip_clock_khz = clock_frequency / 1000;"
      ]
    },
    {
      "file": "linux\\drivers\\i2c\\busses\\i2c-omap.c",
      "line": 305,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Don't write to this register if the IE state is 0 as it can",
        "\t * cause deadlock.",
        "\t */",
        "\tif (omap->iestate)",
        "\t\tomap_i2c_write_reg(omap, OMAP_I2C_IE_REG, omap->iestate);"
      ]
    },
    {
      "file": "linux\\drivers\\i2c\\busses\\i2c-rcar.c",
      "line": 723,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "/*",
        " * This driver has a lock-free design because there are IP cores (at least",
        " * R-Car Gen2) which have an inherent race condition in their hardware design.",
        " * There, we need to switch to RCAR_BUS_PHASE_DATA as soon as possible after",
        " * the interrupt was generated, otherwise an unwanted repeated message gets",
        " * generated. It turned out that taking a spinlock at the beginning of the ISR"
      ]
    },
    {
      "file": "linux\\drivers\\i2c\\busses\\i2c-riic.c",
      "line": 516,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing controller clock",
      "context": [
        "\triic->clk = devm_clk_get(dev, NULL);",
        "\tif (IS_ERR(riic->clk))",
        "\t\treturn dev_err_probe(dev, PTR_ERR(riic->clk),",
        "\t\t\t\t     \"missing controller clock\");",
        "",
        "\triic->rstc = devm_reset_control_get_optional_exclusive_deasserted(dev, NULL);",
        "\tif (IS_ERR(riic->rstc))"
      ]
    },
    {
      "file": "linux\\drivers\\i2c\\busses\\i2c-tegra.c",
      "line": 80,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "#define I2C_ERR_NO_ACK\t\t\t\tBIT(0)",
        "#define I2C_ERR_ARBITRATION_LOST\t\tBIT(1)",
        "#define I2C_ERR_UNKNOWN_INTERRUPT\t\tBIT(2)",
        "#define I2C_ERR_RX_BUFFER_OVERFLOW\t\tBIT(3)",
        "",
        "#define PACKET_HEADER0_HEADER_SIZE\t\tGENMASK(29, 28)",
        "#define PACKET_HEADER0_PACKET_ID\t\tGENMASK(23, 16)"
      ]
    },
    {
      "file": "linux\\drivers\\i2c\\busses\\i2c-tegra.c",
      "line": 908,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "\t\t\t\t * with no XFER_COMPLETE interrupt but hardware",
        "\t\t\t\t * asks to transfer more.",
        "\t\t\t\t */",
        "\t\t\t\ti2c_dev->msg_err |= I2C_ERR_RX_BUFFER_OVERFLOW;",
        "\t\t\t\tgoto err;",
        "\t\t\t}",
        "\t\t}"
      ]
    },
    {
      "file": "linux\\drivers\\iio\\accel\\fxls8962af-core.c",
      "line": 964,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "Buffer overflow",
      "context": [
        "\t\treturn ret;",
        "",
        "\tif (reg & FXLS8962AF_BUF_STATUS_BUF_OVF) {",
        "\t\tdev_err(dev, \"Buffer overflow\");",
        "\t\treturn -EOVERFLOW;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\iio\\accel\\kionix-kx022a.c",
      "line": 1246,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double tap, free",
      "context": [
        "/*",
        " * Despite the naming, KX132ACR-LBZ is not similar to KX132-1211 but it is",
        " * exact subset of KX022A. KX132ACR-LBZ is meant to be used for industrial",
        " * applications and the tap/double tap, free fall and tilt engines were",
        " * removed. Rest of the registers and functionalities (excluding the ID",
        " * register) are exact match to what is found in KX022.",
        " */"
      ]
    },
    {
      "file": "linux\\drivers\\iio\\adc\\ad4695.c",
      "line": 872,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * NB: technically, this is part the SPI offload trigger enable, but it",
        "\t * doesn't work to call it from the offload trigger enable callback",
        "\t * because it requires accessing the SPI bus. Calling it from the",
        "\t * trigger enable callback could cause a deadlock.",
        "\t */",
        "\tret = regmap_set_bits(st->regmap, AD4695_REG_GP_MODE,",
        "\t\t\t      AD4695_REG_GP_MODE_BUSY_GP_EN);"
      ]
    },
    {
      "file": "linux\\drivers\\iio\\adc\\mt6360-adc.c",
      "line": 61,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "struct mt6360_adc_data {",
        "\tstruct device *dev;",
        "\tstruct regmap *regmap;",
        "\t/* Due to only one set of ADC control, this lock is used to prevent the race condition */",
        "\tstruct mutex adc_lock;",
        "\tktime_t last_off_timestamps[MT6360_CHAN_MAX];",
        "};"
      ]
    },
    {
      "file": "linux\\drivers\\iio\\addac\\stx104.c",
      "line": 91,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "/**",
        " * struct stx104_iio - IIO device private data structure",
        " * @lock: synchronization lock to prevent I/O race conditions",
        " * @aio_data_map: Regmap for analog I/O data",
        " * @aio_ctl_map: Regmap for analog I/O control",
        " */"
      ]
    },
    {
      "file": "linux\\drivers\\iio\\cdc\\ad7150.c",
      "line": 297,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t\tgoto error_ret;",
        "",
        "\t\t/*",
        "\t\t * There is a potential race condition here, but not easy",
        "\t\t * to close given we can't disable the interrupt at the",
        "\t\t * chip side of things. Rely on the status bit.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\iio\\dummy\\iio_simple_dummy.c",
      "line": 34,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic device specific numbers",
      "context": [
        " * struct iio_dummy_accel_calibscale - realworld to register mapping",
        " * @val: first value in read_raw - here integer part.",
        " * @val2: second value in read_raw etc - here micro part.",
        " * @regval: register value - magic device specific numbers.",
        " */",
        "struct iio_dummy_accel_calibscale {",
        "\tint val;"
      ]
    },
    {
      "file": "linux\\drivers\\iio\\frequency\\admv4420.c",
      "line": 212,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "doubler = st->ref_block",
      "context": [
        "\tuint32_t tmp;",
        "\tu8 doubler, divide_by_2;",
        "",
        "\tdoubler = st->ref_block.doubler_en ? 2 : 1;",
        "\tdivide_by_2 = st->ref_block.divide_by_2_en ? 2 : 1;",
        "\ttmp = ADMV4420_REF_FREQ_HZ * doubler;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\iio\\frequency\\admv4420.c",
      "line": 326,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DOUBLER_MASK, st->ref_block",
      "context": [
        "\tret = regmap_write(st->regmap, ADMV4420_REFERENCE,",
        "\t\t\t   st->ref_block.divide_by_2_en |",
        "\t\t\t   FIELD_PREP(ADMV4420_REFERENCE_MODE_MASK, st->ref_block.ref_single_ended) |",
        "\t\t\t   FIELD_PREP(ADMV4420_REFERENCE_DOUBLER_MASK, st->ref_block.doubler_en));",
        "\tif (ret)",
        "\t\treturn ret;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\iio\\light\\si1133.c",
      "line": 82,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "#define SI1133_ERR_INVALID_CMD\t\t0x0",
        "#define SI1133_ERR_INVALID_LOCATION_CMD 0x1",
        "#define SI1133_ERR_SATURATION_ADC_OR_OVERFLOW_ACCUMULATION 0x2",
        "#define SI1133_ERR_OUTPUT_BUFFER_OVERFLOW 0x3",
        "",
        "#define SI1133_COMPLETION_TIMEOUT_MS\t500",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\iio\\light\\si1133.c",
      "line": 354,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "\tresp &= 0xF;",
        "",
        "\tswitch (resp) {",
        "\tcase SI1133_ERR_OUTPUT_BUFFER_OVERFLOW:",
        "\t\tdev_warn(dev, \"Output buffer overflow: 0x%02x\\n\", cmd);",
        "\t\treturn -EOVERFLOW;",
        "\tcase SI1133_ERR_SATURATION_ADC_OR_OVERFLOW_ACCUMULATION:"
      ]
    },
    {
      "file": "linux\\drivers\\iio\\light\\si1133.c",
      "line": 355,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "",
        "\tswitch (resp) {",
        "\tcase SI1133_ERR_OUTPUT_BUFFER_OVERFLOW:",
        "\t\tdev_warn(dev, \"Output buffer overflow: 0x%02x\\n\", cmd);",
        "\t\treturn -EOVERFLOW;",
        "\tcase SI1133_ERR_SATURATION_ADC_OR_OVERFLOW_ACCUMULATION:",
        "\t\tdev_warn(dev, \"Saturation of the ADC or overflow of accumulation: 0x%02x\\n\","
      ]
    },
    {
      "file": "linux\\drivers\\iio\\light\\st_uvis25_core.c",
      "line": 100,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tmsleep(1500);",
        "",
        "\t/*",
        "\t * in order to avoid possible race conditions with interrupt",
        "\t * generation, disable the sensor first and then poll output",
        "\t * register. That sequence guarantees the interrupt will be reset",
        "\t * when irq line is unmasked"
      ]
    },
    {
      "file": "linux\\drivers\\iio\\imu\\bno055\\bno055_ser_core.c",
      "line": 76,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer seems to overflow",
      "context": [
        " *",
        " * **WORKAROUND ALERT**",
        " *",
        " * Serial communication seems very fragile: the BNO055 buffer seems to overflow",
        " * very easy; BNO055 seems able to sink few bytes, then it needs a brief pause.",
        " * On the other hand, it is also picky on timeout: if there is a pause > 30mS in",
        " * between two bytes then the transaction fails (IMU internal RX FSM resets)."
      ]
    },
    {
      "file": "linux\\drivers\\infiniband\\core\\cma.c",
      "line": 401,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double lock",
      "context": [
        "\tint ret;",
        "",
        "\t/*",
        "\t * The FSM uses a funny double locking where state is protected by both",
        "\t * the handler_mutex and the spinlock. State is not allowed to change",
        "\t * to/from a handler_mutex protected value without also holding",
        "\t * handler_mutex."
      ]
    },
    {
      "file": "linux\\drivers\\infiniband\\core\\cm.c",
      "line": 3919,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * The CM worker thread may try to destroy the cm_id before it",
        "\t * can execute this work item.  To prevent potential deadlock,",
        "\t * we need to find the cm_id once we're in the context of the",
        "\t * worker thread, rather than holding a reference on it.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\infiniband\\core\\iwcm.c",
      "line": 894,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tspin_lock_irqsave(&cm_id_priv->lock, flags);",
        "\t/*",
        "\t * Clear the connect wait bit so a callback function calling",
        "\t * iw_cm_disconnect will not wait and deadlock this thread",
        "\t */",
        "\tclear_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags);",
        "\tBUG_ON(cm_id_priv->state != IW_CM_STATE_CONN_SENT);"
      ]
    },
    {
      "file": "linux\\drivers\\infiniband\\hw\\hfi1\\driver.c",
      "line": 1170,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        " *",
        " * The rcd is freed in hfi1_free_ctxtdata after hfi1_postinit_cleanup invokes",
        " * dd->f_cleanup(dd) to disable the interrupt handler and flush workqueues,",
        " * so we're safe from use-after-free of the rcd.",
        " */",
        "void receive_interrupt_work(struct work_struct *work)",
        "{"
      ]
    },
    {
      "file": "linux\\drivers\\infiniband\\hw\\hfi1\\firmware.c",
      "line": 635,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "/*",
        " * Called by all HFIs when loading their firmware - i.e. device probe time.",
        " * The first one will do the actual firmware load.  Use a mutex to resolve",
        " * any possible race condition.",
        " *",
        " * The call to this routine cannot be moved to driver load because the kernel",
        " * call request_firmware() requires a device which is only available after"
      ]
    },
    {
      "file": "linux\\drivers\\infiniband\\hw\\hfi1\\opfn.c",
      "line": 124,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double locking QP s_lock",
      "context": [
        "",
        "/*",
        " * When QP s_lock is held in the caller, the OPFN request must be scheduled",
        " * to a different workqueue to avoid double locking QP s_lock in call to",
        " * ib_post_send in opfn_conn_request",
        " */",
        "static void opfn_schedule_conn_request(struct rvt_qp *qp)"
      ]
    },
    {
      "file": "linux\\drivers\\infiniband\\hw\\hfi1\\qp.c",
      "line": 420,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t/*",
        "\t\t * If we are sending a first-leg packet from the second leg,",
        "\t\t * we need to clear the busy flag from priv->s_flags to",
        "\t\t * avoid a race condition when the qp wakes up before",
        "\t\t * the call to hfi1_verbs_send() returns to the second",
        "\t\t * leg. In that case, the second leg will terminate without",
        "\t\t * being re-scheduled, resulting in failure to send TID RDMA"
      ]
    },
    {
      "file": "linux\\drivers\\infiniband\\hw\\hfi1\\sdma.c",
      "line": 483,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\tcontinue;",
        "\t\t/*",
        "\t\t * We must lock interrupts when acquiring sde->lock,",
        "\t\t * to avoid a deadlock if interrupt triggers and spins on",
        "\t\t * the same lock on same CPU",
        "\t\t */",
        "\t\tspin_lock_irqsave(&curr_sde->tail_lock, flags);"
      ]
    },
    {
      "file": "linux\\drivers\\infiniband\\hw\\hfi1\\tid_rdma.c",
      "line": 603,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * tid_rdma_schedule_tid_wakeup - schedule wakeup for a qp",
        " * @qp: the qp",
        " *",
        " * trigger a schedule or a waiting qp in a deadlock",
        " * safe manner.  The qp reference is held prior",
        " * to this call via first_qp().",
        " *"
      ]
    },
    {
      "file": "linux\\drivers\\infiniband\\hw\\qib\\qib_sd7220.c",
      "line": 619,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "}",
        "",
        "/*",
        " * Lemma to deal with race condition of write..read to epb regs",
        " */",
        "static int epb_trans(struct qib_devdata *dd, u16 reg, u64 i_val, u64 *o_vp)",
        "{"
      ]
    },
    {
      "file": "linux\\drivers\\infiniband\\hw\\qib\\qib_user_sdma.c",
      "line": 1073,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * We need this spin lock here because interrupt handler",
        "\t * might modify this list in qib_user_sdma_send_desc(), also",
        "\t * we can not get interrupted, otherwise it is a deadlock.",
        "\t */",
        "\tspin_lock_irqsave(&pq->sent_lock, flags);",
        "\tlist_for_each_entry_safe(pkt, pkt_prev, &pq->sent, list) {"
      ]
    },
    {
      "file": "linux\\drivers\\infiniband\\hw\\usnic\\usnic_ib_verbs.c",
      "line": 349,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * usdev_lock is acquired after (and not before) ib_get_eth_speed call",
        "\t * because acquiring rtnl_lock in ib_get_eth_speed, while holding",
        "\t * usdev_lock could lead to a deadlock.",
        "\t */",
        "\tmutex_lock(&us_ibdev->usdev_lock);",
        "\t/* props being zeroed by the caller, avoid zeroing it here */"
      ]
    },
    {
      "file": "linux\\drivers\\infiniband\\sw\\rdmavt\\qp.c",
      "line": 465,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tu32 qps_inuse = rvt_free_all_qps(rdi);",
        "",
        "\tif (qps_inuse)",
        "\t\trvt_pr_err(rdi, \"QP memory leak! %u still in use\\n\",",
        "\t\t\t   qps_inuse);",
        "",
        "\tkfree(rdi->qp_dev->qp_table);"
      ]
    },
    {
      "file": "linux\\drivers\\infiniband\\sw\\rxe\\rxe_pool.c",
      "line": 209,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t\t\tmsecs_to_jiffies(50000));",
        "",
        "\t\t\t/* Shouldn't happen. There are still references to",
        "\t\t\t * the object but, rather than deadlock, free the",
        "\t\t\t * object or pass back to rdma-core.",
        "\t\t\t */",
        "\t\t\tif (WARN_ON(!ret))"
      ]
    },
    {
      "file": "linux\\drivers\\infiniband\\ulp\\ipoib\\ipoib_main.c",
      "line": 1006,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\treturn NULL;",
        "\t}",
        "",
        "\t/* To avoid race condition, make sure that the",
        "\t * neigh will be added only once.",
        "\t */",
        "\tif (unlikely(!list_empty(&neigh->list))) {"
      ]
    },
    {
      "file": "linux\\drivers\\infiniband\\ulp\\ipoib\\ipoib_main.c",
      "line": 2721,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * We create a global workqueue here that is used for all flush",
        "\t * operations.  However, if you attempt to flush a workqueue",
        "\t * from a task on that same workqueue, it deadlocks the system.",
        "\t * We want to be able to flush the tasks associated with a",
        "\t * specific net device, so we also create a workqueue for each",
        "\t * netdevice.  We queue up the tasks for that device only on"
      ]
    },
    {
      "file": "linux\\drivers\\infiniband\\ulp\\ipoib\\ipoib_main.c",
      "line": 2726,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * specific net device, so we also create a workqueue for each",
        "\t * netdevice.  We queue up the tasks for that device only on",
        "\t * its private workqueue, and we only queue up flush events",
        "\t * on our global flush workqueue.  This avoids the deadlocks.",
        "\t */",
        "\tipoib_workqueue = alloc_ordered_workqueue(\"ipoib_flush\", 0);",
        "\tif (!ipoib_workqueue) {"
      ]
    },
    {
      "file": "linux\\drivers\\infiniband\\ulp\\ipoib\\ipoib_multicast.c",
      "line": 383,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t\t/*",
        "\t\t * Defer carrier on work to priv->wq to avoid a",
        "\t\t * deadlock on rtnl_lock here.  Requeue our multicast",
        "\t\t * work too, which will end up happening right after",
        "\t\t * our carrier on task work and will allow us to",
        "\t\t * send out all of the non-broadcast joins"
      ]
    },
    {
      "file": "linux\\drivers\\infiniband\\ulp\\ipoib\\ipoib_vlan.c",
      "line": 223,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * sysfs callbacks of a netdevice cannot obtain the rtnl lock as",
        " * unregister_netdev ultimately deletes the sysfs files while holding the rtnl",
        " * lock. This deadlocks the system.",
        " *",
        " * A callback can use rtnl_trylock to avoid the deadlock but it cannot call",
        " * unregister_netdev as that internally takes and releases the rtnl_lock.  So"
      ]
    },
    {
      "file": "linux\\drivers\\infiniband\\ulp\\ipoib\\ipoib_vlan.c",
      "line": 225,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * unregister_netdev ultimately deletes the sysfs files while holding the rtnl",
        " * lock. This deadlocks the system.",
        " *",
        " * A callback can use rtnl_trylock to avoid the deadlock but it cannot call",
        " * unregister_netdev as that internally takes and releases the rtnl_lock.  So",
        " * instead we find the netdev to unregister and then do the actual unregister",
        " * from the global work queue where we can obtain the rtnl_lock safely."
      ]
    },
    {
      "file": "linux\\drivers\\infiniband\\ulp\\rtrs\\rtrs-srv-sysfs.c",
      "line": 55,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\tsizeof(str));",
        "",
        "\trtrs_info(s, \"disconnect for path %s requested\\n\", str);",
        "\t/* first remove sysfs itself to avoid deadlock */",
        "\tsysfs_remove_file_self(&srv_path->kobj, &attr->attr);",
        "\tclose_path(srv_path);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\input\\joystick\\xpad.c",
      "line": 602,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "",
        "/*",
        " * starting with xbox one, the game input protocol is used",
        " * magic numbers are taken from",
        " * - https://github.com/xpadneo/gip-dissector/blob/main/src/gip-dissector.lua",
        " * - https://github.com/medusalix/xone/blob/master/bus/protocol.c",
        " */"
      ]
    },
    {
      "file": "linux\\drivers\\input\\keyboard\\amikbd.c",
      "line": 158,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "static const char *amikbd_messages[8] = {",
        "\t[0] = KERN_ALERT \"amikbd: Ctrl-Amiga-Amiga reset warning!!\\n\",",
        "\t[1] = KERN_WARNING \"amikbd: keyboard lost sync\\n\",",
        "\t[2] = KERN_WARNING \"amikbd: keyboard buffer overflow\\n\",",
        "\t[3] = KERN_WARNING \"amikbd: keyboard controller failure\\n\",",
        "\t[4] = KERN_ERR \"amikbd: keyboard selftest failure\\n\",",
        "\t[5] = KERN_INFO \"amikbd: initiate power-up key stream\\n\","
      ]
    },
    {
      "file": "linux\\drivers\\input\\keyboard\\applespi.c",
      "line": 1539,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t/*",
        "\t\t * We don't actually know if this was a pure read, or a response",
        "\t\t * to a write. But this is a rare error condition that should",
        "\t\t * never occur, so clearing both flags to avoid deadlock.",
        "\t\t */",
        "\t\tapplespi_msg_complete(applespi, true, true);",
        "\t} else {"
      ]
    },
    {
      "file": "linux\\drivers\\input\\misc\\xen-kbdfront.c",
      "line": 515,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\tcase XenbusStateConnected:",
        "\t\t/*",
        "\t\t * Work around xenbus race condition: If backend goes",
        "\t\t * through InitWait to Connected fast enough, we can",
        "\t\t * get Connected twice here.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\input\\mouse\\elantech.c",
      "line": 1420,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "",
        "\t/*",
        "\t * Report this in case there are Elantech models that use a different",
        "\t * set of magic numbers",
        "\t */",
        "\tif (param[0] != 0x3c || param[1] != 0x03 ||",
        "\t    (param[2] != 0xc8 && param[2] != 0x00)) {"
      ]
    },
    {
      "file": "linux\\drivers\\input\\mouse\\psmouse-smbus.c",
      "line": 145,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "/*",
        " * This schedules removal of SMBus companion device. We have to do",
        " * it in a separate tread to avoid deadlocking on psmouse_mutex in",
        " * case the device has a trackstick (which is also driven by psmouse).",
        " *",
        " * Note that this may be racing with i2c adapter removal, but we"
      ]
    },
    {
      "file": "linux\\drivers\\input\\mouse\\synaptics_i2c.c",
      "line": 237,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "}",
        "",
        "/*",
        " * Driver's initial design makes no race condition possible on i2c bus,",
        " * so there is no need in any locking.",
        " * Keep it in mind, while playing with the code.",
        " */"
      ]
    },
    {
      "file": "linux\\drivers\\input\\rmi4\\rmi_f54.c",
      "line": 193,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t}",
        "",
        "\t/*",
        "\t * Small delay after disabling interrupts to avoid race condition",
        "\t * in firmare. This value is a bit higher than absolutely necessary.",
        "\t * Should be removed once issue is resolved in firmware.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\input\\serio\\arc_ps2.c",
      "line": 245,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "",
        "\tdev_dbg(&pdev->dev, \"interrupt count = %i\\n\", arc_ps2->total_int);",
        "\tdev_dbg(&pdev->dev, \"frame error count = %i\\n\", arc_ps2->frame_error);",
        "\tdev_dbg(&pdev->dev, \"buffer overflow count = %i\\n\",",
        "\t\tarc_ps2->buf_overflow);",
        "}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\input\\serio\\userio.c",
      "line": 65,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "Buffer overflow",
      "context": [
        "",
        "\t\tif (userio->head == userio->tail)",
        "\t\t\tdev_warn(userio_misc.this_device,",
        "\t\t\t\t \"Buffer overflowed, userio client isn't keeping up\");",
        "\t}",
        "",
        "\twake_up_interruptible(&userio->waitq);"
      ]
    },
    {
      "file": "linux\\drivers\\iommu\\amd\\init.c",
      "line": 747,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "",
        "/*",
        " * This function restarts event logging in case the IOMMU experienced",
        " * an event log buffer overflow.",
        " */",
        "void amd_iommu_restart_event_logging(struct amd_iommu *iommu)",
        "{"
      ]
    },
    {
      "file": "linux\\drivers\\iommu\\intel\\iommu.c",
      "line": 2204,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\tif (ecap_prs(iommu->ecap)) {",
        "\t\t\t/*",
        "\t\t\t * Call dmar_alloc_hwirq() with dmar_global_lock held,",
        "\t\t\t * could cause possible lock race condition.",
        "\t\t\t */",
        "\t\t\tup_write(&dmar_global_lock);",
        "\t\t\tret = intel_iommu_enable_prq(iommu);"
      ]
    },
    {
      "file": "linux\\drivers\\iommu\\intel\\iommu.c",
      "line": 4508,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "/* On Tylersburg chipsets, some BIOSes have been known to enable the",
        "   ISOCH DMAR unit for the Azalia sound device, but not give it any",
        "   TLB entries, which causes it to deadlock. Check for that.  We do",
        "   this in a function called from init_dmars(), instead of in a PCI",
        "   quirk, because we don't want to print the obnoxious \"BIOS broken\"",
        "   message if VT-d is actually disabled."
      ]
    },
    {
      "file": "linux\\drivers\\iommu\\intel\\dmar.c",
      "line": 1456,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * We will leave the interrupts disabled, to prevent interrupt",
        "\t\t * context to queue another cmd while a cmd is already submitted",
        "\t\t * and waiting for completion on this cpu. This is to avoid",
        "\t\t * a deadlock where the interrupt context can wait indefinitely",
        "\t\t * for free slots in the queue.",
        "\t\t */",
        "\t\trc = qi_check_fault(iommu, index, wait_index);"
      ]
    },
    {
      "file": "linux\\drivers\\iommu\\iommufd\\device.c",
      "line": 64,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        " * parallel xarray indexed by iommu_group id to hold this instead of putting it",
        " * in the core structure. To keep things simple the iommufd_group memory is",
        " * unique within the iommufd_ctx. This makes it easy to check there are no",
        " * memory leaks.",
        " */",
        "static struct iommufd_group *iommufd_get_group(struct iommufd_ctx *ictx,",
        "\t\t\t\t\t       struct device *dev)"
      ]
    },
    {
      "file": "linux\\drivers\\iommu\\iommufd\\io_pagetable.c",
      "line": 747,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t\t\t/* Something is not responding to unmap requests. */",
        "\t\t\ttries++;",
        "\t\t\tif (WARN_ON(tries > 100))",
        "\t\t\t\treturn -EDEADLOCK;",
        "\t\t\tgoto again;",
        "\t\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\iommu\\iommufd\\selftest.c",
      "line": 1529,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t * the range is unpinned. This simple implementation puts a global lock",
        "\t * around the pin, which may not suit drivers that want this to be a",
        "\t * performance path. drivers that get this wrong will trigger WARN_ON",
        "\t * races and cause EDEADLOCK failures to userspace.",
        "\t */",
        "\tmutex_lock(&staccess->lock);",
        "\trc = iommufd_access_pin_pages(staccess->access, iova, length, pages,"
      ]
    },
    {
      "file": "linux\\drivers\\iommu\\arm\\arm-smmu\\arm-smmu-qcom-debug.c",
      "line": 74,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t\t      DEFAULT_RATELIMIT_BURST);",
        "",
        "\tif (__ratelimit(&rs)) {",
        "\t\tdev_err(smmu->dev, \"TLB sync timed out -- SMMU may be deadlocked\\n\");",
        "",
        "\t\tcfg = qsmmu->data->cfg;",
        "\t\tif (!cfg)"
      ]
    },
    {
      "file": "linux\\drivers\\iommu\\arm\\arm-smmu\\arm-smmu-nvidia.c",
      "line": 129,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t}",
        "",
        "\tdev_err_ratelimited(smmu->dev,",
        "\t\t\t    \"TLB sync timed out -- SMMU may be deadlocked\\n\");",
        "}",
        "",
        "static int nvidia_smmu_reset(struct arm_smmu_device *smmu)"
      ]
    },
    {
      "file": "linux\\drivers\\iommu\\arm\\arm-smmu\\arm-smmu.c",
      "line": 233,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tudelay(delay);",
        "\t}",
        "\tdev_err_ratelimited(smmu->dev,",
        "\t\t\t    \"TLB sync timed out -- SMMU may be deadlocked\\n\");",
        "}",
        "",
        "static void arm_smmu_tlb_sync_global(struct arm_smmu_device *smmu)"
      ]
    },
    {
      "file": "linux\\drivers\\isdn\\hardware\\mISDN\\hfcmulti.c",
      "line": 1368,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing PCM clock",
      "context": [
        "\t\t}",
        "\t\tif (test_bit(HFC_CHIP_PCM_SLAVE, &hc->chip)) {",
        "\t\t\tprintk(KERN_INFO \"controller is PCM bus SLAVE \"",
        "\t\t\t       \"(ignoring missing PCM clock)\\n\");",
        "\t\t} else {",
        "\t\t\t/* only one pcm master */",
        "\t\t\tif (test_bit(HFC_CHIP_PLXSD, &hc->chip)"
      ]
    },
    {
      "file": "linux\\drivers\\isdn\\hardware\\mISDN\\hfcmulti.c",
      "line": 1312,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double clock",
      "context": [
        "\tif (test_bit(HFC_CHIP_CLOCK2, &hc->chip)) {",
        "\t\tif (debug & DEBUG_HFCMULTI_INIT)",
        "\t\t\tprintk(KERN_DEBUG",
        "\t\t\t       \"%s: setting double clock\\n\", __func__);",
        "\t\tHFC_outb(hc, R_BRG_PCM_CFG, V_PCM_CLK);",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\leds\\trigger\\ledtrig-netdev.c",
      "line": 274,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Take RTNL lock before trigger_data lock to prevent potential",
        "\t * deadlock with netdev notifier registration.",
        "\t */",
        "\trtnl_lock();",
        "\tmutex_lock(&trigger_data->lock);"
      ]
    },
    {
      "file": "linux\\drivers\\md\\bcache\\alloc.c",
      "line": 363,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tallocator_wait(ca, !atomic_read(&ca->set->prio_blocked));",
        "\t\tif (CACHE_SYNC(&ca->sb)) {",
        "\t\t\t/*",
        "\t\t\t * This could deadlock if an allocation with a btree",
        "\t\t\t * node locked ever blocked - having the btree node",
        "\t\t\t * locked would block garbage collection, but here we're",
        "\t\t\t * waiting on garbage collection before we invalidate"
      ]
    },
    {
      "file": "linux\\drivers\\md\\bcache\\btree.c",
      "line": 1090,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * If the btree node is selected and flushing in btree_flush_write(),",
        "\t * delay and retry until the BTREE_NODE_journal_flush bit cleared,",
        "\t * then it is safe to free the btree node here. Otherwise this btree",
        "\t * node will be in race condition.",
        "\t */",
        "\tif (btree_node_journal_flush(b)) {",
        "\t\tmutex_unlock(&b->write_lock);"
      ]
    },
    {
      "file": "linux\\drivers\\md\\bcache\\btree.c",
      "line": 907,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "/*",
        " * We can only have one thread cannibalizing other cached btree nodes at a time,",
        " * or we'll deadlock. We use an open coded mutex to ensure that, which a",
        " * cannibalize_bucket() will take. This means every time we unlock the root of",
        " * the btree, we need to release this lock if we have it held.",
        " */"
      ]
    },
    {
      "file": "linux\\drivers\\md\\bcache\\journal.c",
      "line": 884,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t/*",
        "\t\t\t * XXX: If we were inserting so many keys that they",
        "\t\t\t * won't fit in an _empty_ journal write, we'll",
        "\t\t\t * deadlock. For now, handle this in",
        "\t\t\t * bch_keylist_realloc() - but something to think about.",
        "\t\t\t */",
        "\t\t\tBUG_ON(!w->data->keys);"
      ]
    },
    {
      "file": "linux\\drivers\\md\\bcache\\super.c",
      "line": 1251,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Deadlock",
      "context": [
        "\t}",
        "",
        "\t/*",
        "\t * Deadlocks since we're called via sysfs...",
        "\t * sysfs_remove_file(&dc->kobj, &sysfs_attach);",
        "\t */",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\md\\bcache\\super.c",
      "line": 2777,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t/*",
        "\t\t * The reason bch_register_lock is not held to call",
        "\t\t * bch_cache_set_stop() and bcache_device_stop() is to",
        "\t\t * avoid potential deadlock during reboot, because cache",
        "\t\t * set or bcache device stopping process will acquire",
        "\t\t * bch_register_lock too.",
        "\t\t *"
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-vdo\\action-manager.c",
      "line": 261,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\tmanager->current_action = manager->current_action->next;",
        "",
        "\t/*",
        "\t * We need to check this now to avoid use-after-free issues if running the conclusion or",
        "\t * notifying the parent results in the manager being freed.",
        "\t */",
        "\thas_next_action ="
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-vdo\\data-vio.c",
      "line": 1198,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "stack overflow",
      "context": [
        "\t\tcancel_data_vio_compression(next_lock_holder);",
        "",
        "\t/*",
        "\t * Avoid stack overflow on lock transfer.",
        "\t * FIXME: this is only an issue in the 1 thread config.",
        "\t */",
        "\tnext_lock_holder->vio.completion.requeue = true;"
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-vdo\\dm-vdo-target.c",
      "line": 190,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\tvdo_free(config->parent_device_name);",
        "\tvdo_free(config->original_string);",
        "",
        "\t/* Reduce the chance a use-after-free (as in BZ 1669960) happens to work. */",
        "\tmemset(config, 0, sizeof(*config));",
        "\tvdo_free(config);",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-vdo\\dm-vdo-target.c",
      "line": 915,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\treturn DM_MAPIO_SUBMITTED;",
        "\t}",
        "",
        "\t/* This could deadlock, */",
        "\tcurrent_work_queue = vdo_get_current_work_queue();",
        "\tBUG_ON((current_work_queue != NULL) &&",
        "\t       (vdo == vdo_get_work_queue_owner(current_work_queue)->vdo));"
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-vdo\\funnel-workqueue.c",
      "line": 187,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t *",
        "\t\t * Force synchronization between setting the idle flag and checking the funnel",
        "\t\t * queue; the producer side will do them in the reverse order. (There's still a",
        "\t\t * race condition we've chosen to allow, because we've got a timeout below that",
        "\t\t * unwedges us if we hit it, but this may narrow the window a little.)",
        "\t\t */",
        "\t\tatomic_set(&queue->idle, 1);"
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-vdo\\io-submitter.c",
      "line": 462,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * @io_submitter: The I/O submitter data to destroy.",
        " *",
        " * This must be called after vdo_cleanup_io_submitter(). It is used to release resources late in",
        " * the shutdown process to avoid or reduce the chance of race conditions.",
        " */",
        "void vdo_free_io_submitter(struct io_submitter *io_submitter)",
        "{"
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-vdo\\physical-zone.c",
      "line": 217,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "{",
        "\tidle_pbn_lock *idle;",
        "",
        "\t/* A bit expensive, but will promptly catch some use-after-free errors. */",
        "\tmemset(lock, 0, sizeof(*lock));",
        "",
        "\tidle = container_of(lock, idle_pbn_lock, lock);"
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-vdo\\repair.c",
      "line": 648,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "stack overflow",
      "context": [
        "\t\treturn;",
        "",
        "\t/*",
        "\t * Completion chaining from page cache hits can lead to stack overflow during the rebuild,",
        "\t * so clear out the cache before this rebuild phase.",
        "\t */",
        "\tif (abort_on_error(vdo_invalidate_page_cache(cache), repair))"
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-vdo\\slab-depot.c",
      "line": 3514,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tif (operation == VDO_ADMIN_STATE_LOADING_FOR_REBUILD) {",
        "\t\t/*",
        "\t\t * Must requeue because the kcopyd client cannot be freed in the same stack frame",
        "\t\t * as the kcopyd callback, lest it deadlock.",
        "\t\t */",
        "\t\tvdo_prepare_completion_for_requeue(&allocator->completion,",
        "\t\t\t\t\t\t   finish_loading_allocator,"
      ]
    },
    {
      "file": "linux\\drivers\\md\\persistent-data\\dm-space-map-common.c",
      "line": 404,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double check this block",
      "context": [
        "\t\tif (r)",
        "\t\t\tbreak;",
        "",
        "\t\t/* double check this block wasn't used in the old transaction */",
        "\t\tif (*b >= old_ll->nr_blocks)",
        "\t\t\tcount = 0;",
        "\t\telse {"
      ]
    },
    {
      "file": "linux\\drivers\\md\\dm-vdo\\indexer\\index-session.c",
      "line": 335,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing required block",
      "context": [
        "\t\treturn -EINVAL;",
        "\t}",
        "\tif (parameters->bdev == NULL) {",
        "\t\tvdo_log_error(\"missing required block device\");",
        "\t\treturn -EINVAL;",
        "\t}",
        "\tif (session == NULL) {"
      ]
    },
    {
      "file": "linux\\drivers\\media\\dvb-core\\dmxdev.c",
      "line": 46,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "",
        "\tfree = dvb_ringbuffer_free(buf);",
        "\tif (len > free) {",
        "\t\tdprintk(\"buffer overflow\\n\");",
        "\t\treturn -EOVERFLOW;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\media\\dvb-core\\dvbdev.c",
      "line": 483,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "",
        "\t/*",
        "\t * When a device of the same type is probe()d more than once,",
        "\t * the first allocated fops are used. This prevents memory leaks",
        "\t * that can occur when the same device is probe()d repeatedly.",
        "\t */",
        "\tlist_for_each_entry(node, &dvbdevfops_list, list_head) {"
      ]
    },
    {
      "file": "linux\\drivers\\media\\dvb-core\\dvb_ca_en50221.c",
      "line": 844,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\t/*",
        "\t * It may need some time for the CAM to settle down, or there might",
        "\t * be a race condition between the CAM, writing HC and our last",
        "\t * check for DA. This happens, if the CAM asserts DA, just after",
        "\t * checking DA before we are setting HC. In this case it might be",
        "\t * a bug in the CAM to keep the FR bit, the lower layer/HW"
      ]
    },
    {
      "file": "linux\\drivers\\media\\dvb-core\\dvb_vb2.c",
      "line": 274,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "Buffer overflow",
      "context": [
        "\twhile (todo) {",
        "\t\tif (!ctx->buf) {",
        "\t\t\tif (list_empty(&ctx->dvb_q)) {",
        "\t\t\t\tdprintk(3, \"[%s] Buffer overflow!!!\\n\",",
        "\t\t\t\t\tctx->name);",
        "\t\t\t\tbreak;",
        "\t\t\t}"
      ]
    },
    {
      "file": "linux\\drivers\\media\\dvb-frontends\\si2165.c",
      "line": 212,
      "pattern": "hardcoded.*values",
      "rule": "code_quality",
      "severity": "low",
      "match": "hardcoded values",
      "context": [
        "\tu8 buf[4];",
        "",
        "\t/*",
        "\t * hardcoded values can be deleted if calculation is verified",
        "\t * or it yields the same values as the windows driver",
        "\t */",
        "\tswitch (ref_freq_hz) {"
      ]
    },
    {
      "file": "linux\\drivers\\media\\dvb-frontends\\tda10021.c",
      "line": 261,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "\t * gcc optimizes the code below the same way as it would code:",
        "\t *           \"if (qam > 5) return -EINVAL;\"",
        "\t * Yet, the code is clearer, as it shows what QAM standards are",
        "\t * supported by the driver, and avoids the usage of magic numbers on",
        "\t * it.",
        "\t */",
        "\tswitch (qam) {"
      ]
    },
    {
      "file": "linux\\drivers\\media\\dvb-frontends\\tda10023.c",
      "line": 323,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "\t * gcc optimizes the code below the same way as it would code:",
        "\t *\t\t \"if (qam > 5) return -EINVAL;\"",
        "\t * Yet, the code is clearer, as it shows what QAM standards are",
        "\t * supported by the driver, and avoids the usage of magic numbers on",
        "\t * it.",
        "\t */",
        "\tswitch (qam) {"
      ]
    },
    {
      "file": "linux\\drivers\\media\\i2c\\adv7511-v4l2.c",
      "line": 930,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tu8 irq_status;",
        "\tu8 cec_irq;",
        "",
        "\t/* disable interrupts to prevent a race condition */",
        "\tadv7511_set_isr(sd, false);",
        "\tirq_status = adv7511_rd(sd, 0x96);",
        "\tcec_irq = adv7511_rd(sd, 0x97);"
      ]
    },
    {
      "file": "linux\\drivers\\media\\i2c\\imx290.c",
      "line": 942,
      "pattern": "hardcoded.*values",
      "rule": "code_quality",
      "severity": "low",
      "match": "hardcoded values",
      "context": [
        "",
        "\t/*",
        "\t * Set the link frequency, pixel rate, horizontal blanking and vertical",
        "\t * blanking to hardcoded values, they will be updated by",
        "\t * imx290_ctrl_update().",
        "\t */",
        "\timx290->link_freq ="
      ]
    },
    {
      "file": "linux\\drivers\\media\\i2c\\ov7670.c",
      "line": 658,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic matrix numbers",
      "context": [
        "/*",
        " * Store information about the video data format.  The color matrix",
        " * is deeply tied into the format, so keep the relevant values here.",
        " * The magic matrix numbers come from OmniVision.",
        " */",
        "static struct ov7670_format_struct {",
        "\tu32 mbus_code;"
      ]
    },
    {
      "file": "linux\\drivers\\media\\i2c\\vd56g3.c",
      "line": 699,
      "pattern": "hardcoded.*values",
      "rule": "code_quality",
      "severity": "low",
      "match": "hardcoded values",
      "context": [
        "",
        "\t/*",
        "\t * Set the exposure, horizontal and vertical blanking ctrls",
        "\t * to hardcoded values, they will be updated in vd56g3_update_controls.",
        "\t * Exposure being in an auto-cluster, set a significant value here.",
        "\t */",
        "\tsensor->expo_ctrl = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_EXPOSURE,"
      ]
    },
    {
      "file": "linux\\drivers\\media\\mc\\mc-request.c",
      "line": 270,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * the request can never be released. The fdget() above ensures that",
        "\t * even if userspace closes the request filehandle, the release()",
        "\t * fop won't be called, so the media_request_get() always succeeds",
        "\t * and there is no race condition where the request was released",
        "\t * before media_request_get() is called.",
        "\t */",
        "\tmedia_request_get(req);"
      ]
    },
    {
      "file": "linux\\drivers\\media\\mc\\mc-entity.c",
      "line": 493,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "stack overflow",
      "context": [
        "\tstruct media_pipeline_walk_entry *entries;",
        "\tunsigned int new_size;",
        "",
        "\t/* Safety check, to avoid stack overflows in case of bugs. */",
        "\tif (walk->stack.size >= 256)",
        "\t\treturn -E2BIG;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\media\\radio\\radio-si476x.c",
      "line": 1055,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\tgoto power_down;",
        "",
        "\t\tsi476x_core_unlock(radio->core);",
        "\t\t/*Must be done after si476x_core_unlock to prevent a deadlock*/",
        "\t\tv4l2_ctrl_handler_setup(&radio->ctrl_handler);",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\media\\rc\\igorplugusb.c",
      "line": 57,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer from the beginning. The overflow",
      "context": [
        "",
        "\t/*",
        "\t * If more than 36 pulses and spaces follow each other, the igorplugusb",
        "\t * overwrites its buffer from the beginning. The overflow value is the",
        "\t * last offset which was not overwritten. Everything from this offset",
        "\t * onwards occurred before everything until this offset.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\media\\rc\\imon.c",
      "line": 591,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * Sends a packet to the device -- this function must be called with",
        " * ictx->lock held, or its unlock/lock sequence while waiting for tx",
        " * to complete can/will lead to a deadlock.",
        " */",
        "static int send_packet(struct imon_context *ictx)",
        "{"
      ]
    },
    {
      "file": "linux\\drivers\\media\\rc\\rc-main.c",
      "line": 681,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tunsigned long flags;",
        "",
        "\t/*",
        "\t * ir->keyup_jiffies is used to prevent a race condition if a",
        "\t * hardware interrupt occurs at this point and the keyup timer",
        "\t * event is moved further into the future as a result.",
        "\t *"
      ]
    },
    {
      "file": "linux\\drivers\\media\\tuners\\tda8290.c",
      "line": 279,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t}",
        "\t}",
        "",
        "\t/* l/ l' deadlock? */",
        "\tif(priv->tda8290_easy_mode & 0x60) {",
        "\t\ttuner_i2c_xfer_send_recv(&priv->i2c_props,",
        "\t\t\t\t\t &addr_adc_sat, 1,"
      ]
    },
    {
      "file": "linux\\drivers\\media\\tuners\\tda8290.c",
      "line": 288,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t\t\t &addr_pll_stat, 1,",
        "\t\t\t\t\t &pll_stat, 1);",
        "\t\tif ((adc_sat > 20) || !(pll_stat & 0x80)) {",
        "\t\t\ttuner_dbg(\"trying to resolve SECAM L deadlock\\n\");",
        "\t\t\ttuner_i2c_xfer_send(&priv->i2c_props, agc_rst_on, 2);",
        "\t\t\tmsleep(40);",
        "\t\t\ttuner_i2c_xfer_send(&priv->i2c_props, agc_rst_off, 2);"
      ]
    },
    {
      "file": "linux\\drivers\\media\\cec\\usb\\rainshadow\\rainshadow-cec.c",
      "line": 175,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\tstruct rain *rain = serio_get_drvdata(serio);",
        "",
        "\tif (rain->buf_len == DATA_SIZE) {",
        "\t\tdev_warn_once(rain->dev, \"buffer overflow\\n\");",
        "\t\treturn IRQ_HANDLED;",
        "\t}",
        "\tspin_lock(&rain->buf_lock);"
      ]
    },
    {
      "file": "linux\\drivers\\media\\pci\\cobalt\\cobalt-v4l2.c",
      "line": 561,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing \" : \"found-clock",
      "context": [
        "\t\t(ioread32(&clkloss->ctrl) & M00479_CTRL_BITMAP_ENABLE_MSK) ?",
        "\t\t\t\"enabled \" : \"disabled \",",
        "\t\t(ioread32(&clkloss->status) & M00479_STATUS_BITMAP_CLOCK_MISSING_MSK) ?",
        "\t\t\t\"clock-missing \" : \"found-clock \");",
        "\tcobalt_info(\"rx%d: Packer: %x\\n\", rx, ioread32(&packer->control));",
        "}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\media\\pci\\cx18\\cx18-av-audio.c",
      "line": 28,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "\t *\t4.5 MHz/286 * 455/2 * 8 = 28.63636363... MHz",
        "\t *",
        "\t * The accidents of history and rationale that explain from where this",
        "\t * combination of magic numbers originate can be found in:",
        "\t *",
        "\t * [1] Abrahams, I. C., \"Choice of Chrominance Subcarrier Frequency in",
        "\t * the NTSC Standards\", Proceedings of the I-R-E, January 1954, pp 79-80"
      ]
    },
    {
      "file": "linux\\drivers\\media\\pci\\cx18\\cx18-firmware.c",
      "line": 226,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "\t *\t4.5 MHz/286 * 455/2 * 8 = 28.63636363... MHz",
        "\t *",
        "\t * The accidents of history and rationale that explain from where this",
        "\t * combination of magic numbers originate can be found in:",
        "\t *",
        "\t * [1] Abrahams, I. C., \"Choice of Chrominance Subcarrier Frequency in",
        "\t * the NTSC Standards\", Proceedings of the I-R-E, January 1954, pp 79-80"
      ]
    },
    {
      "file": "linux\\drivers\\media\\pci\\cx23885\\cx23885-core.c",
      "line": 1611,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " *",
        " * It also sets the final jump of the previous buffer to the start of the new",
        " * buffer, thus chaining the new buffer into the DMA chain. This is a single",
        " * atomic u32 write, so there is no race condition.",
        " *",
        " * The end-result of all this that you only get an interrupt when a buffer",
        " * is ready, so the control flow is very easy."
      ]
    },
    {
      "file": "linux\\drivers\\media\\pci\\cx23885\\cx23885-vbi.c",
      "line": 177,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " *",
        " * It also sets the final jump of the previous buffer to the start of the new",
        " * buffer, thus chaining the new buffer into the DMA chain. This is a single",
        " * atomic u32 write, so there is no race condition.",
        " *",
        " * The end-result of all this that you only get an interrupt when a buffer",
        " * is ready, so the control flow is very easy."
      ]
    },
    {
      "file": "linux\\drivers\\media\\pci\\cx23885\\cx23885-video.c",
      "line": 451,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " *",
        " * It also sets the final jump of the previous buffer to the start of the new",
        " * buffer, thus chaining the new buffer into the DMA chain. This is a single",
        " * atomic u32 write, so there is no race condition.",
        " *",
        " * The end-result of all this that you only get an interrupt when a buffer",
        " * is ready, so the control flow is very easy."
      ]
    },
    {
      "file": "linux\\drivers\\media\\pci\\intel\\ipu-bridge.c",
      "line": 523,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "/*",
        " * The actual instantiation must be done from a workqueue to avoid",
        " * a deadlock on taking list_lock from v4l2-async twice.",
        " */",
        "struct ipu_bridge_instantiate_vcm_work_data {",
        "\tstruct work_struct work;"
      ]
    },
    {
      "file": "linux\\drivers\\media\\pci\\ivtv\\ivtv-firmware.c",
      "line": 52,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\tconst u32 *src = (const u32 *)fw->data;",
        "",
        "\t\tif (fw->size != size) {",
        "\t\t\t/* Due to race conditions in firmware loading (esp. with udev <0.95)",
        "\t\t\t   the wrong file was sometimes loaded. So we check filesizes to",
        "\t\t\t   see if at least the right-sized file was loaded. If not, then we",
        "\t\t\t   retry. */"
      ]
    },
    {
      "file": "linux\\drivers\\media\\pci\\mantis\\mantis_evm.c",
      "line": 66,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "Buffer Overflow",
      "context": [
        "\t\tdprintk(MANTIS_DEBUG, 1, \"Event Mgr: Adapter(%d) Slot(0): Alignment Error\", mantis->num);",
        "",
        "\tif (gpif_stat & MANTIS_SBUF_OVFLW)",
        "\t\tdprintk(MANTIS_DEBUG, 1, \"Event Mgr: Adapter(%d) Slot(0): Smart Buffer Overflow\", mantis->num);",
        "",
        "\tif (gpif_stat & MANTIS_GPIF_BRRDY)",
        "\t\tdprintk(MANTIS_DEBUG, 1, \"Event Mgr: Adapter(%d) Slot(0): Smart Buffer Read Ready\", mantis->num);"
      ]
    },
    {
      "file": "linux\\drivers\\media\\pci\\netup_unidvb\\netup_unidvb_core.c",
      "line": 602,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t\tstruct netup_unidvb_buffer, list);",
        "\t\tif (buf->size >= NETUP_DMA_PACKETS_COUNT * 188) {",
        "\t\t\tdev_dbg(&ndev->pci_dev->dev,",
        "\t\t\t\t\"%s(): buffer overflow, size %d\\n\",",
        "\t\t\t\t__func__, buf->size);",
        "\t\t\tgoto work_done;",
        "\t\t}"
      ]
    },
    {
      "file": "linux\\drivers\\media\\pci\\ngene\\ngene-cards.c",
      "line": 852,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "\t\t\t*pLength = EETag[2];",
        "#if 0",
        "\t\t\tif (Length < EETag[2])",
        "\t\t\t\tstatus = STATUS_BUFFER_OVERFLOW;",
        "#endif",
        "\t\t}",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\media\\pci\\ngene\\ngene-core.c",
      "line": 816,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "Buffer, dev->PAOverflow",
      "context": [
        "",
        "\tif (dev->OverflowBuffer)",
        "\t\tdma_free_coherent(&dev->pci_dev->dev, OVERFLOW_BUFFER_SIZE,",
        "\t\t\t\t  dev->OverflowBuffer, dev->PAOverflowBuffer);",
        "",
        "\tif (dev->FWInterfaceBuffer)",
        "\t\tdma_free_coherent(&dev->pci_dev->dev, 4096,"
      ]
    },
    {
      "file": "linux\\drivers\\media\\pci\\pt1\\pt1.c",
      "line": 460,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t\tcontinue;",
        "",
        "\t\tif (upacket >> 24 & 1)",
        "\t\t\tprintk_ratelimited(KERN_INFO \"earth-pt1: device buffer overflowing. table[%d] buf[%d]\\n\",",
        "\t\t\t\tpt1->table_index, pt1->buf_index);",
        "\t\tsc = upacket >> 26 & 0x7;",
        "\t\tif (adap->st_count != -1 && sc != ((adap->st_count + 1) & 0x7))"
      ]
    },
    {
      "file": "linux\\drivers\\media\\pci\\saa7134\\saa7134-alsa.c",
      "line": 83,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "/*",
        " * saa7134 DMA audio stop",
        " *",
        " *   Called when the capture device is released or the buffer overflows",
        " *",
        " *   - Copied verbatim from saa7134-oss's dsp_dma_stop.",
        " *"
      ]
    },
    {
      "file": "linux\\drivers\\media\\pci\\saa7134\\saa7134-tvaudio.c",
      "line": 1023,
      "pattern": "missing.*error.*handling",
      "rule": "error_handling",
      "severity": "medium",
      "match": "missing error handling",
      "context": [
        "\t\tif (IS_ERR(dev->thread.thread)) {",
        "\t\t\tpr_warn(\"%s: kernel_thread() failed\\n\",",
        "\t\t\t       dev->name);",
        "\t\t\t/* XXX: missing error handling here */",
        "\t\t}",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\media\\pci\\saa7164\\saa7164-fw.c",
      "line": 386,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t\"%s() The firmware hung, probably bad firmware\\n\",",
        "\t\t\t__func__);",
        "",
        "\t\t/* Tell the second stage loader we have a deadlock */",
        "\t\tsaa7164_writel(SAA_DEVICE_DEADLOCK_DETECTED_OFFSET,",
        "\t\t\tSAA_DEVICE_DEADLOCK_DETECTED);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\media\\pci\\saa7164\\saa7164-fw.c",
      "line": 387,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t\t\t__func__);",
        "",
        "\t\t/* Tell the second stage loader we have a deadlock */",
        "\t\tsaa7164_writel(SAA_DEVICE_DEADLOCK_DETECTED_OFFSET,",
        "\t\t\tSAA_DEVICE_DEADLOCK_DETECTED);",
        "",
        "\t\tsaa7164_getfirmwarestatus(dev);"
      ]
    },
    {
      "file": "linux\\drivers\\media\\pci\\saa7164\\saa7164-fw.c",
      "line": 388,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "",
        "\t\t/* Tell the second stage loader we have a deadlock */",
        "\t\tsaa7164_writel(SAA_DEVICE_DEADLOCK_DETECTED_OFFSET,",
        "\t\t\tSAA_DEVICE_DEADLOCK_DETECTED);",
        "",
        "\t\tsaa7164_getfirmwarestatus(dev);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\media\\pci\\tw68\\tw68-risc.c",
      "line": 171,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer hasn't overflow",
      "context": [
        "\t/* save pointer to jmp instruction address */",
        "\tbuf->jmp = rp;",
        "\tbuf->cpu[1] = cpu_to_le32(buf->dma + 8);",
        "\t/* assure risc buffer hasn't overflowed */",
        "\tBUG_ON((buf->jmp - buf->cpu + 2) * sizeof(buf->cpu[0]) > buf->size);",
        "\treturn 0;",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\media\\pci\\tw68\\tw68-video.c",
      "line": 399,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " *",
        " * It also sets the final jump of the previous buffer to the start of the new",
        " * buffer, thus chaining the new buffer into the DMA chain. This is a single",
        " * atomic u32 write, so there is no race condition.",
        " *",
        " * The end-result of all this that you only get an interrupt when a buffer",
        " * is ready, so the control flow is very easy."
      ]
    },
    {
      "file": "linux\\drivers\\media\\platform\\allegro-dvt\\allegro-core.c",
      "line": 489,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\tcase AL_ERR_NO_MEMORY:",
        "\t\treturn \"out of memory\";",
        "\tcase AL_ERR_STREAM_OVERFLOW:",
        "\t\treturn \"stream buffer overflow\";",
        "\tcase AL_ERR_TOO_MANY_SLICES:",
        "\t\treturn \"too many slices\";",
        "\tcase AL_ERR_BUF_NOT_READY:"
      ]
    },
    {
      "file": "linux\\drivers\\media\\platform\\broadcom\\bcm2835-unicam.c",
      "line": 826,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t}",
        "",
        "\t/*",
        "\t * Cannot swap buffer at frame end, there may be a race condition",
        "\t * where the HW does not actually swap it if the new frame has",
        "\t * already started.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\media\\platform\\cadence\\cdns-csi2tx.c",
      "line": 97,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tunsigned int\t\t\tcount;",
        "",
        "\t/*",
        "\t * Used to prevent race conditions between multiple,",
        "\t * concurrent calls to start and stop.",
        "\t */",
        "\tstruct mutex\t\t\tlock;"
      ]
    },
    {
      "file": "linux\\drivers\\media\\platform\\cadence\\cdns-csi2rx.c",
      "line": 79,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tunsigned int\t\t\tcount;",
        "",
        "\t/*",
        "\t * Used to prevent race conditions between multiple,",
        "\t * concurrent calls to start and stop.",
        "\t */",
        "\tstruct mutex\t\t\tlock;"
      ]
    },
    {
      "file": "linux\\drivers\\media\\platform\\marvell\\cafe-driver.c",
      "line": 533,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Set up I2C/SMBUS communications.  We have to drop the mutex here",
        "\t * because the sensor could attach in this call chain, leading to",
        "\t * unsightly deadlocks.",
        "\t */",
        "\tret = cafe_smbus_setup(cam);",
        "\tif (ret)"
      ]
    },
    {
      "file": "linux\\drivers\\media\\platform\\chips-media\\coda\\coda-bit.c",
      "line": 2608,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tstruct vb2_v4l2_buffer *dst_buf;",
        "",
        "\t/*",
        "\t * For now this only handles the case where we would deadlock with",
        "\t * userspace, i.e. userspace issued DEC_CMD_STOP and waits for EOS,",
        "\t * but after a failed decode run we would hold the context and wait for",
        "\t * userspace to queue more buffers."
      ]
    },
    {
      "file": "linux\\drivers\\media\\platform\\chips-media\\coda\\coda-bit.c",
      "line": 287,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t\t\t\t\t\t   header_size);",
        "\t\t\t\tif (ret < 0) {",
        "\t\t\t\t\tv4l2_err(&ctx->dev->v4l2_dev,",
        "\t\t\t\t\t\t \"bitstream buffer overflow\\n\");",
        "\t\t\t\t\treturn false;",
        "\t\t\t\t}",
        "\t\t\t\tif (ctx->dev->devtype->product == CODA_960)"
      ]
    },
    {
      "file": "linux\\drivers\\media\\platform\\chips-media\\coda\\coda-bit.c",
      "line": 305,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "",
        "\tret = coda_bitstream_queue(ctx, vaddr, payload);",
        "\tif (ret < 0) {",
        "\t\tv4l2_err(&ctx->dev->v4l2_dev, \"bitstream buffer overflow\\n\");",
        "\t\treturn false;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\media\\platform\\mediatek\\vcodec\\encoder\\mtk_vcodec_enc.c",
      "line": 1131,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * v4l2_m2m_streamoff() holds dev_mutex and waits mtk_venc_worker()",
        " * to call v4l2_m2m_job_finish().",
        " * If mtk_venc_worker() tries to acquire dev_mutex, it will deadlock.",
        " * So this function must not try to acquire dev->dev_mutex.",
        " * This means v4l2 ioctls and mtk_venc_worker() can run at the same time.",
        " * mtk_venc_worker() should be carefully implemented to avoid bugs."
      ]
    },
    {
      "file": "linux\\drivers\\media\\platform\\nxp\\imx8-isi\\imx8-isi-video.c",
      "line": 543,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t *",
        "\t * As none of the shadow registers are accessible, races can occur",
        "\t * between address programming and buffer switching. It is possible to",
        "\t * detect the race condition by checking if a frame end interrupt",
        "\t * occurred after programming the addresses, but impossible to",
        "\t * determine if the race has been won or lost.",
        "\t *"
      ]
    },
    {
      "file": "linux\\drivers\\media\\platform\\nxp\\imx8-isi\\imx8-isi-video.c",
      "line": 623,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * using B1 just before we programmed B3. Unlike in the previous race",
        "\t * condition, B3 has been programmed and will be written to the next",
        "\t * time the ISI switches to BUF2. We can however handle this exactly as",
        "\t * the first race condition, as we'll program B3 (still at the head of",
        "\t * the pending list) when handling IRQ3.",
        "\t */",
        "\tstatus = mxc_isi_channel_irq_status(pipe, false);"
      ]
    },
    {
      "file": "linux\\drivers\\media\\platform\\qcom\\iris\\iris_hfi_gen2_response.c",
      "line": 200,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "\t\tinfo = \"data corrupt\";",
        "\t\tinst_hfi_gen2->hfi_frame_info.data_corrupt = 1;",
        "\t\tbreak;",
        "\tcase HFI_INFO_BUFFER_OVERFLOW:",
        "\t\tinfo = \"buffer overflow\";",
        "\t\tinst_hfi_gen2->hfi_frame_info.overflow = 1;",
        "\t\tbreak;"
      ]
    },
    {
      "file": "linux\\drivers\\media\\platform\\qcom\\iris\\iris_hfi_gen2_response.c",
      "line": 201,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\tinst_hfi_gen2->hfi_frame_info.data_corrupt = 1;",
        "\t\tbreak;",
        "\tcase HFI_INFO_BUFFER_OVERFLOW:",
        "\t\tinfo = \"buffer overflow\";",
        "\t\tinst_hfi_gen2->hfi_frame_info.overflow = 1;",
        "\t\tbreak;",
        "\tcase HFI_INFO_HFI_FLAG_DRAIN_LAST:"
      ]
    },
    {
      "file": "linux\\drivers\\media\\platform\\ti\\omap3isp\\isp.c",
      "line": 1200,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\t/*",
        "\t * atomic_set() doesn't include memory barrier on ARM platform for SMP",
        "\t * scenario. We'll call it here to avoid race conditions.",
        "\t */",
        "\tatomic_set(stopping, 1);",
        "\tsmp_mb();"
      ]
    },
    {
      "file": "linux\\drivers\\media\\platform\\ti\\omap3isp\\isp.c",
      "line": 534,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer logic overflow",
      "context": [
        "\tu32 sbl_pcr;",
        "",
        "\t/*",
        "\t * Handle shared buffer logic overflows for video buffers.",
        "\t * ISPSBL_PCR_CCDCPRV_2_RSZ_OVF can be safely ignored.",
        "\t */",
        "\tsbl_pcr = isp_reg_readl(isp, OMAP3_ISP_IOMEM_SBL, ISPSBL_PCR);"
      ]
    },
    {
      "file": "linux\\drivers\\media\\platform\\ti\\omap3isp\\ispresizer.c",
      "line": 1330,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\t/* Update the source format, resizing ratios and crop rectangle. If",
        "\t * streaming is on the IRQ handler will reprogram the resizer after the",
        "\t * current frame. We thus we need to protect against race conditions.",
        "\t */",
        "\tspin_lock_irqsave(&res->lock, flags);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\media\\platform\\ti\\omap3isp\\ispstat.c",
      "line": 36,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer to start to be written in the same point where the overflow",
      "context": [
        "",
        "/*",
        " * HACK: H3A modules go to an invalid state after have a SBL overflow. It makes",
        " * the next buffer to start to be written in the same point where the overflow",
        " * occurred instead of the configured address. The only known way to make it to",
        " * go back to a valid state is having a valid buffer processing. Of course it",
        " * requires at least a doubled buffer size to avoid an access to invalid memory"
      ]
    },
    {
      "file": "linux\\drivers\\media\\platform\\ti\\omap3isp\\ispstat.c",
      "line": 108,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "",
        "\tisp_stat_buf_sync_magic_for_cpu(stat, buf, buf_size, DMA_FROM_DEVICE);",
        "",
        "\t/* Checking initial magic numbers. They shouldn't be here anymore. */",
        "\tfor (w = buf->virt_addr, end = w + MAGIC_SIZE; w < end; w++)",
        "\t\tif (likely(*w != MAGIC_NUM))",
        "\t\t\tret = 0;"
      ]
    },
    {
      "file": "linux\\drivers\\media\\platform\\ti\\omap3isp\\ispstat.c",
      "line": 120,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "\t\treturn ret;",
        "\t}",
        "",
        "\t/* Checking magic numbers at the end. They must be still here. */",
        "\tfor (w = buf->virt_addr + buf_size, end = w + MAGIC_SIZE;",
        "\t     w < end; w++) {",
        "\t\tif (unlikely(*w != MAGIC_NUM)) {"
      ]
    },
    {
      "file": "linux\\drivers\\media\\platform\\ti\\omap3isp\\ispvideo.c",
      "line": 110,
      "pattern": "null.*pointer.*dereference",
      "rule": "memory_management",
      "severity": "high",
      "match": "NULL pointer dereference",
      "context": [
        "\t  MEDIA_BUS_FMT_YUYV8_2X8, 0,",
        "\t  V4L2_PIX_FMT_YUYV, 8, 2, },",
        "\t/* Empty entry to catch the unsupported pixel code (0) used by the CCDC",
        "\t * module and avoid NULL pointer dereferences.",
        "\t */",
        "\t{ 0, }",
        "};"
      ]
    },
    {
      "file": "linux\\drivers\\media\\rc\\img-ir\\img-ir-hw.c",
      "line": 556,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Release the lock to stop the end timer, since the end timer handler",
        "\t * acquires the lock and we don't want to deadlock waiting for it.",
        "\t */",
        "\tspin_unlock_irq(&priv->lock);",
        "\ttimer_delete_sync(&hw->end_timer);"
      ]
    },
    {
      "file": "linux\\drivers\\media\\test-drivers\\vivid\\vivid-kthread-cap.c",
      "line": 441,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * lock is already taken and there is no need to take the mutex.",
        "\t\t *",
        "\t\t * The problem with taking the mutex is that you can get",
        "\t\t * deadlocked if instance A locks instance B and vice versa.",
        "\t\t * It is not really worth trying to be very smart about this,",
        "\t\t * so just try to take the lock, and if you can't, then just",
        "\t\t * set out_dev to NULL and you will end up with a single frame"
      ]
    },
    {
      "file": "linux\\drivers\\media\\usb\\dvb-usb-v2\\af9015.c",
      "line": 66,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "Buffer overflow",
      "context": [
        "\t\tgoto error;",
        "\t}",
        "",
        "\t/* Buffer overflow check */",
        "\tif ((write && (req->data_len > BUF_LEN - REQ_HDR_LEN)) ||",
        "\t    (!write && (req->data_len > BUF_LEN - ACK_HDR_LEN))) {",
        "\t\tdev_err(&intf->dev, \"too much data, cmd %u, len %u\\n\","
      ]
    },
    {
      "file": "linux\\drivers\\media\\usb\\dvb-usb-v2\\af9035.c",
      "line": 45,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "",
        "\tmutex_lock(&d->usb_mutex);",
        "",
        "\t/* buffer overflow check */",
        "\tif (req->wlen > (BUF_LEN - REQ_HDR_LEN - CHECKSUM_LEN) ||",
        "\t\t\treq->rlen > (BUF_LEN - ACK_HDR_LEN - CHECKSUM_LEN)) {",
        "\t\tdev_err(&intf->dev, \"too much data wlen=%d rlen=%d\\n\","
      ]
    },
    {
      "file": "linux\\drivers\\media\\usb\\gspca\\conex.c",
      "line": 64,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\tstruct usb_device *dev = gspca_dev->dev;",
        "",
        "\tif (len > USB_BUF_SZ) {",
        "\t\tgspca_err(gspca_dev, \"reg_r: buffer overflow\\n\");",
        "\t\treturn;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\media\\usb\\gspca\\conex.c",
      "line": 103,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\tstruct usb_device *dev = gspca_dev->dev;",
        "",
        "\tif (len > USB_BUF_SZ) {",
        "\t\tgspca_err(gspca_dev, \"reg_w: buffer overflow\\n\");",
        "\t\treturn;",
        "\t}",
        "\tgspca_dbg(gspca_dev, D_USBO, \"reg write [%02x] = %02x..\\n\","
      ]
    },
    {
      "file": "linux\\drivers\\media\\usb\\gspca\\etoms.c",
      "line": 154,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\tstruct usb_device *dev = gspca_dev->dev;",
        "",
        "\tif (len > USB_BUF_SZ) {",
        "\t\tgspca_err(gspca_dev, \"reg_r: buffer overflow\\n\");",
        "\t\treturn;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\media\\usb\\gspca\\etoms.c",
      "line": 191,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\tstruct usb_device *dev = gspca_dev->dev;",
        "",
        "\tif (len > USB_BUF_SZ) {",
        "\t\tpr_err(\"reg_w: buffer overflow\\n\");",
        "\t\treturn;",
        "\t}",
        "\tgspca_dbg(gspca_dev, D_USBO, \"reg write [%02x] = %02x..\\n\","
      ]
    },
    {
      "file": "linux\\drivers\\media\\usb\\gspca\\ov519.c",
      "line": 3206,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double clock",
      "context": [
        "\treg_w(sd, 0x23, fr_tb[sd->gspca_dev.curr_mode][fr][1]);",
        "\tclock = fr_tb[sd->gspca_dev.curr_mode][fr][2];",
        "\tif (sd->sensor == SEN_OV7660)",
        "\t\tclock |= 0x80;\t\t/* enable double clock */",
        "\tov518_i2c_w(sd, OV7670_R11_CLKRC, clock);",
        "}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\media\\usb\\gspca\\sonixj.c",
      "line": 1149,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\tif (gspca_dev->usb_err < 0)",
        "\t\treturn;",
        "\tif (len > USB_BUF_SZ) {",
        "\t\tgspca_err(gspca_dev, \"reg_r: buffer overflow\\n\");",
        "\t\treturn;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\media\\usb\\gspca\\sonixj.c",
      "line": 1209,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t  value, buffer[0], buffer[1]);",
        "",
        "\tif (len > USB_BUF_SZ) {",
        "\t\tgspca_err(gspca_dev, \"reg_w: buffer overflow\\n\");",
        "\t\treturn;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\media\\usb\\gspca\\sn9c20x.c",
      "line": 2101,
      "pattern": "hardcoded.*values",
      "rule": "code_quality",
      "severity": "low",
      "match": "hardcoded values",
      "context": [
        "\ts16 new_exp;",
        "",
        "\t/*",
        "\t * some hardcoded values are present",
        "\t * like those for maximal/minimal exposure",
        "\t * and exposure steps",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\media\\usb\\gspca\\sunplus.c",
      "line": 242,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\tint ret;",
        "",
        "\tif (len > USB_BUF_SZ) {",
        "\t\tgspca_err(gspca_dev, \"reg_r: buffer overflow\\n\");",
        "\t\treturn;",
        "\t}",
        "\tif (len == 0) {"
      ]
    },
    {
      "file": "linux\\drivers\\media\\usb\\gspca\\xirlink_cit.c",
      "line": 1318,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "\t}",
        "\tcase CIT_MODEL3:",
        "\t{\t/*",
        "\t\t * \"Use a table of magic numbers.",
        "\t\t *  This setting doesn't really change much.",
        "\t\t *  But that's how Windows does it.\"",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\media\\usb\\stk1160\\stk1160-video.c",
      "line": 161,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "",
        "\tif ((unsigned long)dst + lencopy >",
        "\t\t(unsigned long)buf->mem + buf->length) {",
        "\t\tprintk_ratelimited(KERN_WARNING \"stk1160: buffer overflow detected\\n\");",
        "\t\treturn;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\media\\usb\\stk1160\\stk1160-video.c",
      "line": 205,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "",
        "\t\tif ((unsigned long)dst + lencopy >",
        "\t\t\t(unsigned long)buf->mem + buf->length) {",
        "\t\t\tprintk_ratelimited(KERN_WARNING \"stk1160: buffer overflow detected\\n\");",
        "\t\t\treturn;",
        "\t\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\media\\usb\\gspca\\m5602\\m5602_ov9650.c",
      "line": 42,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double clock",
      "context": [
        "\t{BRIDGE, M5602_XB_I2C_CLK_DIV, 0x0a},",
        "\t/* Reset chip */",
        "\t{SENSOR, OV9650_COM7, OV9650_REGISTER_RESET},",
        "\t/* Enable double clock */",
        "\t{SENSOR, OV9650_CLKRC, 0x80},",
        "\t/* Do something out of spec with the power */",
        "\t{SENSOR, OV9650_OFON, 0x40}"
      ]
    },
    {
      "file": "linux\\drivers\\media\\usb\\gspca\\m5602\\m5602_ov9650.c",
      "line": 72,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double clock",
      "context": [
        "\t   properly when resuming from ram, could be a timing issue */",
        "\t{SENSOR, OV9650_COM7, OV9650_REGISTER_RESET},",
        "",
        "\t/* Enable double clock */",
        "\t{SENSOR, OV9650_CLKRC, 0x80},",
        "\t/* Do something out of spec with the power */",
        "\t{SENSOR, OV9650_OFON, 0x40},"
      ]
    },
    {
      "file": "linux\\drivers\\message\\fusion\\mptbase.c",
      "line": 379,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t/*",
        "\t\t * Call mptscsih_flush_pending_cmds callback so that we",
        "\t\t * flush all pending commands back to OS.",
        "\t\t * This call is required to aovid deadlock at block layer.",
        "\t\t * Dead IOC will fail to do diag reset,and this call is safe",
        "\t\t * since dead ioc will never return any command back from HW.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\misc\\bcm-vk\\bcm_vk_msg.c",
      "line": 1284,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t/*",
        "\t * if there are outstanding DMA transactions, need to delay long enough",
        "\t * to ensure that the card side would have stopped touching the host buffer",
        "\t * and its SGL list.  A race condition could happen if the host app is killed",
        "\t * abruptly, eg kill -9, while some DMA transfer orders are still inflight.",
        "\t * Nothing could be done except for a delay as host side is running in a",
        "\t * completely async fashion."
      ]
    },
    {
      "file": "linux\\drivers\\misc\\genwqe\\card_base.c",
      "line": 253,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magical numbers",
      "context": [
        " * bitstreams to function will with this version of our device driver.",
        " *",
        " * Thise circumventions are applied to the physical function only.",
        " * The magical numbers below are identifying development/manufacturing",
        " * versions of the bitstream used on the card.",
        " *",
        " * Turn off error reporting for old/manufacturing images."
      ]
    },
    {
      "file": "linux\\drivers\\misc\\lkdtm\\core.c",
      "line": 112,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "stack overflow",
      "context": [
        "/* Module parameters */",
        "static int recur_count = -1;",
        "module_param(recur_count, int, 0644);",
        "MODULE_PARM_DESC(recur_count, \" Recursion level for the stack overflow test\");",
        "",
        "static char* cpoint_name;",
        "module_param(cpoint_name, charp, 0444);"
      ]
    },
    {
      "file": "linux\\drivers\\misc\\lkdtm\\heap.c",
      "line": 12,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double_free",
      "context": [
        "#include <linux/vmalloc.h>",
        "#include <linux/sched.h>",
        "",
        "static struct kmem_cache *double_free_cache;",
        "static struct kmem_cache *a_cache;",
        "static struct kmem_cache *b_cache;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\misc\\lkdtm\\heap.c",
      "line": 320,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double_free",
      "context": [
        "{",
        "\tint *val;",
        "",
        "\tval = kmem_cache_alloc(double_free_cache, GFP_KERNEL);",
        "\tif (!val) {",
        "\t\tpr_info(\"Unable to allocate double_free_cache memory.\\n\");",
        "\t\treturn;"
      ]
    },
    {
      "file": "linux\\drivers\\misc\\lkdtm\\heap.c",
      "line": 322,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double_free",
      "context": [
        "",
        "\tval = kmem_cache_alloc(double_free_cache, GFP_KERNEL);",
        "\tif (!val) {",
        "\t\tpr_info(\"Unable to allocate double_free_cache memory.\\n\");",
        "\t\treturn;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\misc\\lkdtm\\heap.c",
      "line": 328,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double slab free",
      "context": [
        "",
        "\t/* Just make sure we got real memory. */",
        "\t*val = 0x12345678;",
        "\tpr_info(\"Attempting double slab free ...\\n\");",
        "\tkmem_cache_free(double_free_cache, val);",
        "\tkmem_cache_free(double_free_cache, val);",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\misc\\lkdtm\\heap.c",
      "line": 329,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double_free",
      "context": [
        "\t/* Just make sure we got real memory. */",
        "\t*val = 0x12345678;",
        "\tpr_info(\"Attempting double slab free ...\\n\");",
        "\tkmem_cache_free(double_free_cache, val);",
        "\tkmem_cache_free(double_free_cache, val);",
        "}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\misc\\lkdtm\\heap.c",
      "line": 330,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double_free",
      "context": [
        "\t*val = 0x12345678;",
        "\tpr_info(\"Attempting double slab free ...\\n\");",
        "\tkmem_cache_free(double_free_cache, val);",
        "\tkmem_cache_free(double_free_cache, val);",
        "}",
        "",
        "static void lkdtm_SLAB_FREE_CROSS(void)"
      ]
    },
    {
      "file": "linux\\drivers\\misc\\lkdtm\\heap.c",
      "line": 360,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double_free_cache = kmem_cache_create(\"lkdtm-heap-double_free",
      "context": [
        "",
        "void __init lkdtm_heap_init(void)",
        "{",
        "\tdouble_free_cache = kmem_cache_create(\"lkdtm-heap-double_free\",",
        "\t\t\t\t\t      64, 0, SLAB_NO_MERGE, NULL);",
        "\ta_cache = kmem_cache_create(\"lkdtm-heap-a\", 64, 0, SLAB_NO_MERGE, NULL);",
        "\tb_cache = kmem_cache_create(\"lkdtm-heap-b\", 64, 0, SLAB_NO_MERGE, NULL);"
      ]
    },
    {
      "file": "linux\\drivers\\misc\\lkdtm\\heap.c",
      "line": 368,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double_free",
      "context": [
        "",
        "void __exit lkdtm_heap_exit(void)",
        "{",
        "\tkmem_cache_destroy(double_free_cache);",
        "\tkmem_cache_destroy(a_cache);",
        "\tkmem_cache_destroy(b_cache);",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\misc\\sgi-xp\\xpc_main.c",
      "line": 806,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t/*",
        "\t\t\t * NOTE: if (ignore_disconnecting &&",
        "\t\t\t * !(ch->flags & XPC_C_DISCONNECTINGCALLOUT)) is true,",
        "\t\t\t * then we'll deadlock if all other kthreads assigned",
        "\t\t\t * to this channel are blocked in the channel's",
        "\t\t\t * registerer, because the only thing that will unblock",
        "\t\t\t * them is the xpDisconnecting callout that this"
      ]
    },
    {
      "file": "linux\\drivers\\misc\\uacce\\uacce.c",
      "line": 576,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use NULL deref rather than use-after-free",
      "context": [
        "\txa_erase(&uacce_xa, uacce->dev_id);",
        "\t/*",
        "\t * uacce exists as long as there are open fds, but ops will be freed",
        "\t * now. Ensure that bugs cause NULL deref rather than use-after-free.",
        "\t */",
        "\tuacce->ops = NULL;",
        "\tuacce->parent = NULL;"
      ]
    },
    {
      "file": "linux\\drivers\\mmc\\core\\core.c",
      "line": 2347,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\thost->pm_flags = 0;",
        "",
        "\tif (host->bus_ops) {",
        "\t\t/* Calling bus_ops->remove() with a claimed host can deadlock */",
        "\t\thost->bus_ops->remove(host);",
        "\t\tmmc_claim_host(host);",
        "\t\tmmc_detach_bus(host);"
      ]
    },
    {
      "file": "linux\\drivers\\mmc\\core\\sdio_uart.c",
      "line": 530,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Missing hardware shouldn't block",
      "context": [
        "\tstruct sdio_uart_port *port =",
        "\t\t\tcontainer_of(tport, struct sdio_uart_port, port);",
        "\tunsigned int ret = sdio_uart_claim_func(port);",
        "\tif (ret)\t/* Missing hardware shouldn't block for carrier */",
        "\t\treturn 1;",
        "\tret = sdio_uart_get_mctrl(port);",
        "\tsdio_uart_release_func(port);"
      ]
    },
    {
      "file": "linux\\drivers\\mmc\\host\\meson-gx-mmc.c",
      "line": 449,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Missing clock",
      "context": [
        "\t\tclk = devm_clk_get(host->dev, name);",
        "\t\tif (IS_ERR(clk))",
        "\t\t\treturn dev_err_probe(host->dev, PTR_ERR(clk),",
        "\t\t\t\t\t     \"Missing clock %s\\n\", name);",
        "",
        "\t\tmux_parent_names[i] = __clk_get_name(clk);",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\mmc\\host\\omap_hsmmc.c",
      "line": 2068,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\tif (!(OMAP_HSMMC_READ(host->base, PSTATE) & DLEV_DAT(1))) {",
        "\t\t\t/*",
        "\t\t\t * dat1 line low, pending sdio irq",
        "\t\t\t * race condition: possible irq handler running on",
        "\t\t\t * multi-core, abort",
        "\t\t\t */",
        "\t\t\tdev_dbg(dev, \"pending sdio irq, abort suspend\\n\");"
      ]
    },
    {
      "file": "linux\\drivers\\mmc\\host\\sdhci-uhs2.c",
      "line": 209,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t}",
        "",
        "\tif (count >= 0xF) {",
        "\t\tDBG(\"%s: Too large timeout 0x%x requested for DEADLOCK!\\n\",",
        "\t\t    mmc_hostname(host->mmc), count);",
        "\t\tcount = 0xE;",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\mmc\\host\\sdhci-uhs2.c",
      "line": 223,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\tu8 cmd_res, dead_lock;",
        "",
        "\tsdhci_calc_timeout_uhs2(host, &cmd_res, &dead_lock);",
        "\tcmd_res |= FIELD_PREP(SDHCI_UHS2_TIMER_CTRL_DEADLOCK_MASK, dead_lock);",
        "\tsdhci_writeb(host, cmd_res, SDHCI_UHS2_TIMER_CTRL);",
        "}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\mmc\\host\\sdhci-uhs2.c",
      "line": 266,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\tsdhci_calc_timeout_uhs2(host, &cmd_res, &dead_lock);",
        "",
        "\t/* change to use calculate value */",
        "\tcmd_res |= FIELD_PREP(SDHCI_UHS2_TIMER_CTRL_DEADLOCK_MASK, dead_lock);",
        "",
        "\tsdhci_uhs2_clear_set_irqs(host,",
        "\t\t\t\t  SDHCI_UHS2_INT_CMD_TIMEOUT |"
      ]
    },
    {
      "file": "linux\\drivers\\mmc\\host\\sdhci-uhs2.c",
      "line": 270,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "",
        "\tsdhci_uhs2_clear_set_irqs(host,",
        "\t\t\t\t  SDHCI_UHS2_INT_CMD_TIMEOUT |",
        "\t\t\t\t  SDHCI_UHS2_INT_DEADLOCK_TIMEOUT,",
        "\t\t\t\t  0);",
        "\tsdhci_writeb(host, cmd_res, SDHCI_UHS2_TIMER_CTRL);",
        "\tsdhci_uhs2_clear_set_irqs(host, 0,"
      ]
    },
    {
      "file": "linux\\drivers\\mmc\\host\\sdhci-uhs2.c",
      "line": 275,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\tsdhci_writeb(host, cmd_res, SDHCI_UHS2_TIMER_CTRL);",
        "\tsdhci_uhs2_clear_set_irqs(host, 0,",
        "\t\t\t\t  SDHCI_UHS2_INT_CMD_TIMEOUT |",
        "\t\t\t\t  SDHCI_UHS2_INT_DEADLOCK_TIMEOUT);",
        "",
        "\t/* UHS2 timing. Note, UHS2 timing is disabled when powering off */",
        "\tctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);"
      ]
    },
    {
      "file": "linux\\drivers\\mmc\\host\\sdhci-uhs2.c",
      "line": 1024,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t\t\treturn;",
        "\t\t}",
        "",
        "\t\tif (uhs2mask & SDHCI_UHS2_INT_DEADLOCK_TIMEOUT) {",
        "\t\t\tpr_err(\"%s: Got deadlock timeout interrupt 0x%08x\\n\",",
        "\t\t\t       mmc_hostname(host->mmc),",
        "\t\t\t       (unsigned int)uhs2mask);"
      ]
    },
    {
      "file": "linux\\drivers\\mmc\\host\\sdhci-uhs2.c",
      "line": 1025,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t}",
        "",
        "\t\tif (uhs2mask & SDHCI_UHS2_INT_DEADLOCK_TIMEOUT) {",
        "\t\t\tpr_err(\"%s: Got deadlock timeout interrupt 0x%08x\\n\",",
        "\t\t\t       mmc_hostname(host->mmc),",
        "\t\t\t       (unsigned int)uhs2mask);",
        "\t\t\thost->data->error = -ETIMEDOUT;"
      ]
    },
    {
      "file": "linux\\drivers\\mmc\\host\\sunxi-mmc.c",
      "line": 780,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double the card clock",
      "context": [
        "",
        "\t/*",
        "\t * Under the old timing mode, 8 bit DDR requires the module",
        "\t * clock to be double the card clock. Under the new timing",
        "\t * mode, all DDR modes require a doubled module clock.",
        "\t *",
        "\t * We currently only support the standard MMC DDR52 mode."
      ]
    },
    {
      "file": "linux\\drivers\\mmc\\host\\sunxi-mmc.c",
      "line": 781,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "doubled module clock",
      "context": [
        "\t/*",
        "\t * Under the old timing mode, 8 bit DDR requires the module",
        "\t * clock to be double the card clock. Under the new timing",
        "\t * mode, all DDR modes require a doubled module clock.",
        "\t *",
        "\t * We currently only support the standard MMC DDR52 mode.",
        "\t * This block should be updated once support for other DDR"
      ]
    },
    {
      "file": "linux\\drivers\\mmc\\host\\wbsd.c",
      "line": 749,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tstruct mmc_command *cmd;",
        "",
        "\t/*",
        "\t * Disable bh works to avoid a deadlock.",
        "\t */",
        "\tspin_lock_bh(&host->lock);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\mtd\\chips\\cfi_cmdset_0020.c",
      "line": 19,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        " *\t  (command set 0x0020)",
        " *\t- added a writev function",
        " * 07/13/2005\tJoern Engel <joern@wh.fh-wedel.de>",
        " * \t- Plugged memory leak in cfi_staa_writev().",
        " */",
        "",
        "#include <linux/module.h>"
      ]
    },
    {
      "file": "linux\\drivers\\mtd\\spi-nor\\core.c",
      "line": 3606,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t/*",
        "\t * None of the existing parts have > 512B pages, but let's play safe",
        "\t * and add this logic so that if anyone ever adds support for such",
        "\t * a NOR we don't end up with buffer overflows.",
        "\t */",
        "\tif (nor->params->page_size > PAGE_SIZE) {",
        "\t\tnor->bouncebuf_size = nor->params->page_size;"
      ]
    },
    {
      "file": "linux\\drivers\\mtd\\ubi\\eba.c",
      "line": 1350,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * are moving it, so lock it.",
        "\t *",
        "\t * Note, we are using non-waiting locking here, because we cannot sleep",
        "\t * on the LEB, since it may cause deadlocks. Indeed, imagine a task is",
        "\t * unmapping the LEB which is mapped to the PEB we are going to move",
        "\t * (@from). This task locks the LEB and goes sleep in the",
        "\t * 'ubi_wl_put_peb()' function on the @ubi->move_mutex. In turn, we are"
      ]
    },
    {
      "file": "linux\\drivers\\mtd\\ubi\\io.c",
      "line": 458,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        " * with an LEB, which leads to subsequent failures (e.g., UBIFS fails).",
        " *",
        " * This function is called before erasing NOR PEBs and it zeroes out EC and VID",
        " * magic numbers in order to invalidate them and prevent the failures. Returns",
        " * zero in case of success and a negative error code in case of failure.",
        " */",
        "static int nor_erase_prepare(struct ubi_device *ubi, int pnum)"
      ]
    },
    {
      "file": "linux\\drivers\\mtd\\nand\\raw\\nandsim.c",
      "line": 1549,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * We allocate memory with GFP_NOFS because a flash FS may",
        "\t\t * utilize this. If it is holding an FS lock, then gets here,",
        "\t\t * then kernel memory alloc runs writeback which goes to the FS",
        "\t\t * again and deadlocks. This was seen in practice.",
        "\t\t */",
        "\t\tmypage->byte = kmem_cache_alloc(ns->nand_pages_slab, GFP_NOFS);",
        "\t\tif (mypage->byte == NULL) {"
      ]
    },
    {
      "file": "linux\\drivers\\net\\arcnet\\arcnet.c",
      "line": 415,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race window between the exit condition",
      "context": [
        "\trtnl_lock();",
        "",
        "\t/* Do another check, in case of an ifdown that was triggered in",
        "\t * the small race window between the exit condition above and",
        "\t * acquiring RTNL.",
        "\t */",
        "\tif (!netif_running(dev) || !lp->reset_in_progress)"
      ]
    },
    {
      "file": "linux\\drivers\\net\\bonding\\bond_main.c",
      "line": 357,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * The design of synchronization/protection for this operation in the 8021q",
        " * module is good for one or more VLAN devices over a single physical device",
        " * and cannot be extended for a teaming solution like bonding, so there is a",
        " * potential race condition here where a net device from the vlan group might",
        " * be referenced (either by a base driver or the 8021q code) while it is being",
        " * removed from the system. However, it turns out we're not making matters",
        " * worse, and if it works for regular VLAN usage it will work here too."
      ]
    },
    {
      "file": "linux\\drivers\\net\\bonding\\bond_main.c",
      "line": 6570,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "}",
        "",
        "/* According to commit 69b0216ac255 (\"bonding: fix bonding_masters",
        " * race condition in bond unloading\") we need to remove sysfs files",
        " * before we remove our devices (done later in bond_net_exit_rtnl())",
        " */",
        "static void __net_exit bond_net_pre_exit(struct net *net)"
      ]
    },
    {
      "file": "linux\\drivers\\net\\bonding\\bond_main.c",
      "line": 5601,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tstruct bonding *bond = netdev_priv(dev);",
        "\tnetdev_tx_t ret = NETDEV_TX_OK;",
        "",
        "\t/* If we risk deadlock from transmitting this in the",
        "\t * netpoll path, tell netpoll to queue the frame for later tx",
        "\t */",
        "\tif (unlikely(is_netpoll_tx_blocked(dev)))"
      ]
    },
    {
      "file": "linux\\drivers\\net\\can\\can327.c",
      "line": 714,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t\t * Did we even connect at the right baud rate?",
        "\t\t\t */",
        "\t\t\tnetdev_err(elm->dev,",
        "\t\t\t\t   \"RX buffer overflow. Faulty ELM327 or UART?\\n\");",
        "\t\t\tcan327_uart_side_failure(elm);",
        "\t\t} else if (len == elm->rxfill) {",
        "\t\t\tif (can327_is_ready_char(elm->rxbuf[elm->rxfill - 1])) {"
      ]
    },
    {
      "file": "linux\\drivers\\net\\can\\can327.c",
      "line": 907,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\twhile (count--) {",
        "\t\tif (elm->rxfill >= CAN327_SIZE_RXBUF) {",
        "\t\t\tnetdev_err(elm->dev,",
        "\t\t\t\t   \"Receive buffer overflowed. Bad chip or wiring? count = %zu\",",
        "\t\t\t\t   count);",
        "\t\t\tgoto uart_failure;",
        "\t\t}"
      ]
    },
    {
      "file": "linux\\drivers\\net\\can\\at91_can.c",
      "line": 560,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\tu32 timestamp;",
        "\tint err;",
        "",
        "\tnetdev_dbg(dev, \"RX buffer overflow\\n\");",
        "\tstats->rx_over_errors++;",
        "\tstats->rx_errors++;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\fealnx.c",
      "line": 23,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "",
        "\tVersion 2.51, Nov 17, 2001 (jgarzik):",
        "\t- Add ethtool support",
        "\t- Replace some MII-related magic numbers with constants",
        "",
        "*/",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\oa_tc6.c",
      "line": 33,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "#define STATUS0_RESETC\t\t\t\tBIT(6)\t/* Reset Complete */",
        "#define STATUS0_HEADER_ERROR\t\t\tBIT(5)",
        "#define STATUS0_LOSS_OF_FRAME_ERROR\t\tBIT(4)",
        "#define STATUS0_RX_BUFFER_OVERFLOW_ERROR\tBIT(3)",
        "#define STATUS0_TX_PROTOCOL_ERROR\t\tBIT(0)",
        "",
        "/* Buffer Status Register */"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\oa_tc6.c",
      "line": 45,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "#define OA_TC6_REG_INT_MASK0\t\t\t0x000C",
        "#define INT_MASK0_HEADER_ERR_MASK\t\tBIT(5)",
        "#define INT_MASK0_LOSS_OF_FRAME_ERR_MASK\tBIT(4)",
        "#define INT_MASK0_RX_BUFFER_OVERFLOW_ERR_MASK\tBIT(3)",
        "#define INT_MASK0_TX_PROTOCOL_ERR_MASK\t\tBIT(0)",
        "",
        "/* PHY Clause 22 registers base address and mask */"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\oa_tc6.c",
      "line": 632,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "\t\treturn ret;",
        "",
        "\tregval &= ~(INT_MASK0_TX_PROTOCOL_ERR_MASK |",
        "\t\t    INT_MASK0_RX_BUFFER_OVERFLOW_ERR_MASK |",
        "\t\t    INT_MASK0_LOSS_OF_FRAME_ERR_MASK |",
        "\t\t    INT_MASK0_HEADER_ERR_MASK);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\oa_tc6.c",
      "line": 692,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "\t\treturn ret;",
        "\t}",
        "",
        "\tif (FIELD_GET(STATUS0_RX_BUFFER_OVERFLOW_ERROR, value)) {",
        "\t\ttc6->rx_buf_overflow = true;",
        "\t\toa_tc6_cleanup_ongoing_rx_skb(tc6);",
        "\t\tnet_err_ratelimited(\"%s: Receive buffer overflow error\\n\","
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\oa_tc6.c",
      "line": 695,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\tif (FIELD_GET(STATUS0_RX_BUFFER_OVERFLOW_ERROR, value)) {",
        "\t\ttc6->rx_buf_overflow = true;",
        "\t\toa_tc6_cleanup_ongoing_rx_skb(tc6);",
        "\t\tnet_err_ratelimited(\"%s: Receive buffer overflow error\\n\",",
        "\t\t\t\t    tc6->netdev->name);",
        "\t\treturn -EAGAIN;",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\oa_tc6.c",
      "line": 834,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\tbool end_valid = FIELD_GET(OA_TC6_DATA_FOOTER_END_VALID, footer);",
        "\tu16 size;",
        "",
        "\t/* Restart the new rx frame after receiving rx buffer overflow error */",
        "\tif (start_valid && tc6->rx_buf_overflow)",
        "\t\ttc6->rx_buf_overflow = false;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\oa_tc6.c",
      "line": 868,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t * start.",
        "\t */",
        "\tif (start_valid && end_valid && start_byte_offset > end_byte_offset) {",
        "\t\t/* After rx buffer overflow error received, there might be a",
        "\t\t * possibility of getting an end valid of a previously",
        "\t\t * incomplete rx frame along with the new rx frame start valid.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\net\\hamradio\\6pack.c",
      "line": 44,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "#define SIXP_SEOF\t\t0x40\t/* start and end of a 6pack frame */",
        "#define SIXP_TX_URUN\t\t0x48\t/* transmit overrun */",
        "#define SIXP_RX_ORUN\t\t0x50\t/* receive overrun */",
        "#define SIXP_RX_BUF_OVL\t\t0x58\t/* receive buffer overflow */",
        "",
        "#define SIXP_CHKSUM\t\t0xFF\t/* valid checksum of a 6pack frame */",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\hamradio\\6pack.c",
      "line": 924,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\tcase SIXP_RX_ORUN: printk(KERN_DEBUG \"6pack: RX overrun\\n\");",
        "\t\tbreak;",
        "\tcase SIXP_RX_BUF_OVL:",
        "\t\tprintk(KERN_DEBUG \"6pack: RX buffer overflow\\n\");",
        "\t}",
        "}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\hyperv\\netvsc.c",
      "line": 104,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tstruct rndis_device *rdev;",
        "\tint i, ret;",
        "",
        "\t/* Avoid deadlock with device removal already under RTNL */",
        "\tif (!rtnl_trylock()) {",
        "\t\tschedule_work(w);",
        "\t\treturn;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\hyperv\\netvsc.c",
      "line": 428,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer will not overflow",
      "context": [
        "\tnet_device->recv_section_size = resp->sections[0].sub_alloc_size;",
        "\tnet_device->recv_section_cnt = resp->sections[0].num_sub_allocs;",
        "",
        "\t/* Ensure buffer will not overflow */",
        "\tif (net_device->recv_section_size < NETVSC_MTU_MIN || (u64)net_device->recv_section_size *",
        "\t    (u64)net_device->recv_section_cnt > (u64)buf_size) {",
        "\t\tnetdev_err(ndev, \"invalid recv_section_size %u\\n\","
      ]
    },
    {
      "file": "linux\\drivers\\net\\ieee802154\\at86rf230.c",
      "line": 412,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t * STATE_BUSY_RX_AACK and a SHR was detected.",
        "\t\t */",
        "\t\tif  (trx_state == STATE_BUSY_RX_AACK) {",
        "\t\t\t/* Undocumented race condition. If we send a state",
        "\t\t\t * change to STATE_RX_AACK_ON the transceiver could",
        "\t\t\t * change his state automatically to STATE_BUSY_RX_AACK",
        "\t\t\t * if a SHR was detected. This is not an error, but we"
      ]
    },
    {
      "file": "linux\\drivers\\net\\hyperv\\rndis_filter.c",
      "line": 335,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t\t\trndis_set_link_state(dev, request);",
        "\t\t} else {",
        "\t\t\tnetdev_err(ndev,",
        "\t\t\t\t\"rndis response buffer overflow \"",
        "\t\t\t\t\"detected (size %u max %zu)\\n\",",
        "\t\t\t\tresp->msg_len,",
        "\t\t\t\tsizeof(struct rndis_message));"
      ]
    },
    {
      "file": "linux\\drivers\\net\\hyperv\\rndis_filter.c",
      "line": 344,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "\t\t\t    RNDIS_MSG_RESET_C) {",
        "\t\t\t\t/* does not have a request id field */",
        "\t\t\t\trequest->response_msg.msg.reset_complete.",
        "\t\t\t\t\tstatus = RNDIS_STATUS_BUFFER_OVERFLOW;",
        "\t\t\t} else {",
        "\t\t\t\trequest->response_msg.msg.",
        "\t\t\t\tinit_complete.status ="
      ]
    },
    {
      "file": "linux\\drivers\\net\\hyperv\\rndis_filter.c",
      "line": 348,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "\t\t\t} else {",
        "\t\t\t\trequest->response_msg.msg.",
        "\t\t\t\tinit_complete.status =",
        "\t\t\t\t\tRNDIS_STATUS_BUFFER_OVERFLOW;",
        "\t\t\t}",
        "\t\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\mdio\\mdio-mux-meson-g12a.c",
      "line": 241,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Missing clock",
      "context": [
        "\t\tclk = devm_clk_get(dev, in_name);",
        "\t\tif (IS_ERR(clk))",
        "\t\t\treturn dev_err_probe(dev, PTR_ERR(clk),",
        "\t\t\t\t\t     \"Missing clock %s\\n\", in_name);",
        "",
        "\t\tparent_names[i] = __clk_get_name(clk);",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\net\\phy\\dp83tg720.c",
      "line": 536,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * reliably detect or report a stable link state. To recover from such",
        " * scenarios, the PHY must be periodically reset when the link is down. However,",
        " * if the link partner also runs Linux with the same driver, synchronized reset",
        " * intervals can lead to a deadlock where the link never establishes due to",
        " * simultaneous resets on both sides.",
        " *",
        " * To avoid this, the function implements randomized polling intervals when the"
      ]
    },
    {
      "file": "linux\\drivers\\net\\phy\\phy_device.c",
      "line": 1804,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "",
        "\t/*",
        "\t * The phydev might go away on the put_device() below, so avoid",
        "\t * a use-after-free bug by reading the underlying bus first.",
        "\t */",
        "\tbus = phydev->mdio.bus;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\phy\\phy_device.c",
      "line": 351,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/* We must stop the state machine manually, otherwise it stops out of",
        "\t * control, possibly with the phydev->lock held. Upon resume, netdev",
        "\t * may call phy routines that try to grab the same lock, and that may",
        "\t * lead to a deadlock.",
        "\t */",
        "\tif (phy_uses_state_machine(phydev))",
        "\t\tphy_stop_machine(phydev);"
      ]
    },
    {
      "file": "linux\\drivers\\net\\plip\\plip.c",
      "line": 956,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\tbreak;",
        "",
        "\tcase PLIP_CN_RECEIVE:",
        "\t\t/* May occur because there is race condition",
        "\t\t   around test and set of dev->interrupt.",
        "\t\t   Ignore this interrupt. */",
        "\t\tbreak;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ppp\\pppoe.c",
      "line": 38,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        " * 190701 :\tWhen doing copies of skb's in __pppoe_xmit, always delete",
        " *\t\tthe original skb that was passed in on success, never on",
        " *\t\tfailure.  Delete the copy of the skb on failure to avoid",
        " *\t\ta memory leak.",
        " * 081001 :\tMisc. cleanup (licence string, non-blocking, prevent",
        " *\t\treference of device on close).",
        " * 121301 :\tNew ppp channels interface; cannot unregister a channel"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ppp\\pppoe.c",
      "line": 924,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * xmit operations conclude prior to an unregistration call.  Thus",
        "\t * sk->sk_state cannot change, so we don't need to do lock_sock().",
        "\t * But, we also can't do a lock_sock since that introduces a potential",
        "\t * deadlock as we'd reverse the lock ordering used when calling",
        "\t * ppp_unregister_channel().",
        "\t */",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\ppp\\ppp_generic.c",
      "line": 1333,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/* rtnl_lock is already held here, but ppp_create_interface() locks",
        "\t * ppp_mutex before holding rtnl_lock. Using mutex_trylock() avoids",
        "\t * possible deadlock due to lock order inversion, at the cost of",
        "\t * pushing the problem back to userspace.",
        "\t */",
        "\tif (!mutex_trylock(&ppp_mutex)) {"
      ]
    },
    {
      "file": "linux\\drivers\\net\\slip\\slhc.c",
      "line": 40,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        " *\t\t\tseparate routines",
        " *\t\t\tstatus display",
        " *\t- Jul 1994\tDmitry Gorodchanin",
        " *\t\t\tFixes for memory leaks.",
        " *      - Oct 1994      Dmitry Gorodchanin",
        " *                      Modularization.",
        " *\t- Jan 1995\tBjorn Ekwall"
      ]
    },
    {
      "file": "linux\\drivers\\net\\slip\\slip.c",
      "line": 18,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "Memory leak",
      "context": [
        " *\t\tAlan Cox\t: \tFound cause of overrun. ifconfig sl0",
        " *\t\t\t\t\tmtu upwards. Driver now spots this",
        " *\t\t\t\t\tand grows/shrinks its buffers(hack!).",
        " *\t\t\t\t\tMemory leak if you run out of memory",
        " *\t\t\t\t\tsetting up a slip driver fixed.",
        " *\t\tMatt Dillon\t:\tPrintable slip (borrowed from NET2E)",
        " *\tPauline Middelink\t:\tSlip driver fixes."
      ]
    },
    {
      "file": "linux\\drivers\\net\\slip\\slip.c",
      "line": 30,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        " *\t\tAlan Cox\t:\tNow uses hardware type as per FvK.",
        " *\t\tAlan Cox\t:\tDefault to 192.168.0.0 (RFC 1597)",
        " *\t\tA.N.Kuznetsov\t:\tdev_tint() recursion fix.",
        " *\tDmitry Gorodchanin\t:\tSLIP memory leaks",
        " *      Dmitry Gorodchanin      :       Code cleanup. Reduce tty driver",
        " *                                      buffering from 4096 to 256 bytes.",
        " *                                      Improving SLIP response time."
      ]
    },
    {
      "file": "linux\\drivers\\net\\slip\\slip.c",
      "line": 1246,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\tbreak;",
        "",
        "\tcase SIOCSLEASE:",
        "\t\t/* Resolve race condition, when ioctl'ing hanged up",
        "\t\t   and opened by another process device.",
        "\t\t */",
        "\t\tif (sl->tty != current->signal->tty &&"
      ]
    },
    {
      "file": "linux\\drivers\\net\\usb\\gl620a.c",
      "line": 145,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "\t__le32\t*packet_count;",
        "\t__le32\t*packet_len;",
        "",
        "\t// FIXME:  magic numbers, bleech",
        "\tpadlen = ((skb->len + (4 + 4*1)) % 64) ? 0 : 1;",
        "",
        "\tif ((!skb_cloned(skb))"
      ]
    },
    {
      "file": "linux\\drivers\\net\\usb\\lan78xx.c",
      "line": 2940,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "",
        "\t\t/* Get reference count of the URB to avoid it to be",
        "\t\t * freed during usb_unlink_urb, which may trigger",
        "\t\t * use-after-free problem inside usb_unlink_urb since",
        "\t\t * usb_unlink_urb is always racing with .complete",
        "\t\t * handler(include defer_bh).",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\net\\usb\\lan78xx.c",
      "line": 3554,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/* deferred work (task, timer, softirq) must also stop.",
        "\t * can't flush_scheduled_work() until we drop rtnl (later),",
        "\t * else workers could deadlock; so make workers a NOP.",
        "\t */",
        "\tclear_bit(EVENT_TX_HALT, &dev->flags);",
        "\tclear_bit(EVENT_RX_HALT, &dev->flags);"
      ]
    },
    {
      "file": "linux\\drivers\\net\\usb\\usbnet.c",
      "line": 754,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t\t/*",
        "\t\t * Get reference count of the URB to avoid it to be",
        "\t\t * freed during usb_unlink_urb, which may trigger",
        "\t\t * use-after-free problem inside usb_unlink_urb since",
        "\t\t * usb_unlink_urb is always racing with .complete",
        "\t\t * handler(include defer_bh).",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\net\\usb\\usbnet.c",
      "line": 2220,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double free",
      "context": [
        "fail_free_buf:",
        "\tkfree(buf);",
        "\t/*",
        "\t * avoid a double free",
        "\t * needed because the flag can be set only",
        "\t * after filling the URB",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\net\\usb\\usbnet.c",
      "line": 2090,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "/*",
        " * The function can't be called inside suspend/resume callback,",
        " * otherwise deadlock will be caused.",
        " */",
        "int usbnet_read_cmd(struct usbnet *dev, u8 cmd, u8 reqtype,",
        "\t\t    u16 value, u16 index, void *data, u16 size)"
      ]
    },
    {
      "file": "linux\\drivers\\net\\usb\\usbnet.c",
      "line": 2108,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "/*",
        " * The function can't be called inside suspend/resume callback,",
        " * otherwise deadlock will be caused.",
        " */",
        "int usbnet_write_cmd(struct usbnet *dev, u8 cmd, u8 reqtype,",
        "\t\t     u16 value, u16 index, const void *data, u16 size)"
      ]
    },
    {
      "file": "linux\\drivers\\net\\vmxnet3\\vmxnet3_drv.c",
      "line": 3618,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * we must clear VMXNET3_STATE_BIT_RESETTING, otherwise",
        "\t * vmxnet3_close() will deadlock.",
        "\t */",
        "\tBUG_ON(test_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state));",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\vmxnet3\\vmxnet3_drv.c",
      "line": 3622,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t */",
        "\tBUG_ON(test_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state));",
        "",
        "\t/* we need to enable NAPI, otherwise dev_close will deadlock */",
        "\tfor (i = 0; i < adapter->num_rx_queues; i++)",
        "\t\tnapi_enable(&adapter->rx_queue[i].napi);",
        "\t/*"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wwan\\wwan_hwsim.c",
      "line": 373,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "{",
        "\tstruct wwan_hwsim_port *port = file->private_data;",
        "",
        "\t/* We can not delete port here since it will cause a deadlock due to",
        "\t * waiting this callback to finish in the debugfs_remove() call. So,",
        "\t * use workqueue.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wwan\\wwan_hwsim.c",
      "line": 418,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "{",
        "\tstruct wwan_hwsim_dev *dev = file->private_data;",
        "",
        "\t/* We can not delete device here since it will cause a deadlock due to",
        "\t * waiting this callback to finish in the debugfs_remove() call. So,",
        "\t * use workqueue.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\net\\can\\ctucanfd\\ctucanfd_base.c",
      "line": 965,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tif (!framecnt && res != 0) {",
        "\t\tif (napi_complete_done(napi, work_done)) {",
        "\t\t\t/* Clear and enable RBNEI. It is level-triggered, so",
        "\t\t\t * there is no race condition.",
        "\t\t\t */",
        "\t\t\tctucan_write32(priv, CTUCANFD_INT_STAT, REG_INT_STAT_RBNEI);",
        "\t\t\tctucan_write32(priv, CTUCANFD_INT_MASK_CLR, REG_INT_STAT_RBNEI);"
      ]
    },
    {
      "file": "linux\\drivers\\net\\can\\ctucanfd\\ctucanfd_base.c",
      "line": 1070,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\tspin_unlock_irqrestore(&priv->tx_lock, flags);",
        "",
        "\t\t/* If no buffers were processed this time, we cannot clear - that would introduce",
        "\t\t * a race condition.",
        "\t\t */",
        "\t\tif (some_buffers_processed) {",
        "\t\t\t/* Clear the interrupt again. We do not want to receive again interrupt for"
      ]
    },
    {
      "file": "linux\\drivers\\net\\can\\esd\\esdacc.c",
      "line": 334,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race period where it counts 128 \"idle condition",
      "context": [
        "\t\t}",
        "\t\tacc_resetmode_leave(priv->core);",
        "\t\t/* To leave the bus-off state the esdACC controller begins",
        "\t\t * here a grace period where it counts 128 \"idle conditions\" (each",
        "\t\t * of 11 consecutive recessive bits) on the bus as required",
        "\t\t * by the CAN spec.",
        "\t\t *"
      ]
    },
    {
      "file": "linux\\drivers\\net\\can\\rockchip\\rockchip_canfd-core.c",
      "line": 661,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tif (!reg_int)",
        "\t\treturn IRQ_NONE;",
        "",
        "\t/* First ACK then handle, to avoid lost-IRQ race condition on",
        "\t * fast re-occurring interrupts.",
        "\t */",
        "\trkcanfd_write(priv, RKCANFD_REG_INT, reg_int);"
      ]
    },
    {
      "file": "linux\\drivers\\net\\can\\spi\\mcp251x.c",
      "line": 1086,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t\tif (!(intf & CANINTF_RX1IF)) {",
        "\t\t\t\tu8 intf1, eflag1;",
        "",
        "\t\t\t\t/* intf needs to be read again to avoid a race condition */",
        "\t\t\t\tmcp251x_read_2regs(spi, CANINTF, &intf1, &eflag1);",
        "",
        "\t\t\t\t/* combine flags from both operations for error handling */"
      ]
    },
    {
      "file": "linux\\drivers\\net\\can\\usb\\mcba_usb.c",
      "line": 770,
      "pattern": "hardcoded.*values",
      "rule": "code_quality",
      "severity": "low",
      "match": "hardcoded bittiming values",
      "context": [
        "\t.get_ts_info = ethtool_op_get_ts_info,",
        "};",
        "",
        "/* Microchip CANBUS has hardcoded bittiming values by default.",
        " * This function sends request via USB to change the speed and align bittiming",
        " * values for presentation purposes only",
        " */"
      ]
    },
    {
      "file": "linux\\drivers\\net\\can\\usb\\gs_usb.c",
      "line": 317,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tu32 feature;",
        "\tunsigned int hf_size_tx;",
        "",
        "\t/* This lock prevents a race condition between xmit and receive. */",
        "\tspinlock_t tx_ctx_lock;",
        "\tstruct gs_tx_context tx_context[GS_MAX_TX_URBS];",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\can\\spi\\mcp251xfd\\mcp251xfd-core.c",
      "line": 1218,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * Sometimes there is an ECC error in the TX-RAM, which leads",
        "\t * to a TX MAB underflow.",
        "\t *",
        "\t * However, probably due to a race condition, there is no",
        "\t * associated MODIF pending.",
        "\t *",
        "\t * Further, there are situations, where the SERRIF is caused"
      ]
    },
    {
      "file": "linux\\drivers\\net\\can\\spi\\mcp251xfd\\mcp251xfd-core.c",
      "line": 1511,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t * - First ACK then handle, to avoid lost-IRQ race",
        "\t\t *   condition on fast re-occurring interrupts.",
        "\t\t * - Write \"0\" to clear active IRQs, \"1\" to all other,",
        "\t\t *   to avoid r/m/w race condition on the",
        "\t\t *   MCP251XFD_REG_INT register.",
        "\t\t */",
        "\t\tintf_pending_clearable = intf_pending &"
      ]
    },
    {
      "file": "linux\\drivers\\net\\can\\usb\\etas_es58x\\es58x_core.c",
      "line": 646,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * through the drivers/net/can/dev.c:can_restart() function. The",
        " * device is technically capable to recover by itself under certain",
        " * circumstances, however, allowing self recovery would create",
        " * complex race conditions with drivers/net/can/dev.c:can_restart()",
        " * and thus was not implemented. To activate automatic restart, please",
        " * set the restart-ms parameter (e.g. ip link set can0 type can",
        " * restart-ms 100)."
      ]
    },
    {
      "file": "linux\\drivers\\net\\dsa\\sja1105\\sja1105_tas.c",
      "line": 754,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t/* Plan to start the earliest schedule first. The others",
        "\t\t * will be started in hardware, by way of their respective",
        "\t\t * entry points delta.",
        "\t\t * Try our best to avoid fringe cases (race condition between",
        "\t\t * ptpschtm and ptpstrtsch) by pushing the oper_base_time at",
        "\t\t * least one second in the future from now. This is not ideal,",
        "\t\t * but this only needs to buy us time until the"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\3com\\3c509.c",
      "line": 38,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\tv1.10 4/21/97 Fixed module code so that multiple cards may be detected,",
        "\t\t\t\tother cleanups.  -djb",
        "\t\tAndrea Arcangeli:\tUpgraded to Donald Becker's version 1.12.",
        "\t\tRick Payne:\tFixed SMP race condition",
        "\t\tv1.13 9/8/97 Made 'max_interrupt_work' an insmod-settable variable -djb",
        "\t\tv1.14 10/15/97 Avoided waiting..discard message for fast machines -djb",
        "\t\tv1.15 1/31/98 Faster recovery for Tx errors. -djb"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\3com\\3c515.c",
      "line": 1471,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "/*  Update statistics.",
        "\tUnlike with the EL3 we need not worry about interrupts changing",
        "\tthe window setting from underneath us, but we must still guard",
        "\tagainst a race condition with a StatsUpdate interrupt updating the",
        "\ttable.  This is done by checking that the ASM (!) code generated uses",
        "\tatomic updates with '+='.",
        "\t*/"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\3com\\3c59x.c",
      "line": 2841,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "/*  Update statistics.",
        "\tUnlike with the EL3 we need not worry about interrupts changing",
        "\tthe window setting from underneath us, but we must still guard",
        "\tagainst a race condition with a StatsUpdate interrupt updating the",
        "\ttable.  This is done by checking that the ASM (!) code generated uses",
        "\tatomic updates with '+='.",
        "\t*/"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\3com\\3c59x.c",
      "line": 2131,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * We can't allow a recursion from our interrupt handler back into the",
        "\t * tx routine, as they take the same spin lock, and that causes",
        "\t * deadlock.  Just return NETDEV_TX_BUSY and let the stack try again in",
        "\t * a bit",
        "\t */",
        "\tif (vp->handling_irq)"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\8390\\lib8390.c",
      "line": 170,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *\t\tDisable the IRQ (but not mask locally- someone seems to have",
        " *\t\t\tbroken this with the lock validator stuff)",
        " *\t\t\t[This must be _nosync as the page lock may otherwise",
        " *\t\t\t\tdeadlock us]",
        " *\t\tDrop the page lock and turn IRQs back on",
        " *",
        " *\t\tAt this point an existing IRQ may still be running but we can't"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\8390\\lib8390.c",
      "line": 186,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " *",
        " *\tWe have to use disable_irq because otherwise you will get delayed",
        " *\tinterrupts on the APIC bus deadlocking the transmit path.",
        " *",
        " *\tQuite hairy but the chip simply wasn't designed for SMP and you can't",
        " *\teven ACK an interrupt without risking corrupting other parallel"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\alteon\\acenic.c",
      "line": 44,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "Memory leak",
      "context": [
        " *   Val Henson <vhenson@esscom.com>:    Reset Jumbo skb producer and",
        " *                                       rx producer index when",
        " *                                       flushing the Jumbo ring.",
        " *   Hans Grobler <grobh@sun.ac.za>:     Memory leak fixes in the",
        " *                                       driver init path.",
        " *   Grant Grundler <grundler@cup.hp.com>: PCI write posting fixes.",
        " */"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\alteon\\acenic.c",
      "line": 30,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " *                              driver under Linux/Sparc64",
        " *   Matt Domsch <Matt_Domsch@dell.com>: Detect Alteon 1000baseT cards",
        " *                                       ETHTOOL_GDRVINFO support",
        " *   Chip Salzenberg <chip@valinux.com>: Fix race condition between tx",
        " *                                       handler and close() cleanup.",
        " *   Ken Aaker <kdaaker@rchland.vnet.ibm.com>: Correct check for whether",
        " *                                       memory mapped IO is enabled to"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\alteon\\acenic.c",
      "line": 2066,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t/* So... tx_ret_csm is advanced _after_ check for device wakeup.",
        "\t *",
        "\t * We could try to make it before. In this case we would get",
        "\t * the following race condition: hard_start_xmit on other cpu",
        "\t * enters after we advanced tx_ret_csm and fills space,",
        "\t * which we have just freed, so that we make illegal device wakeup.",
        "\t * There is no good way to workaround this (at entry"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\alteon\\acenic.c",
      "line": 2077,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * if we really have some space in ring (though the core doing",
        "\t * hard_start_xmit can see full ring for some period and has to",
        "\t * synchronize.) Superb.",
        "\t * BUT! We get another subtle race condition. hard_start_xmit",
        "\t * may think that ring is full between wakeup and advancing",
        "\t * tx_ret_csm and will stop device instantly! It is not so bad.",
        "\t * We are guaranteed that there is something in ring, so that"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\alteon\\acenic.c",
      "line": 2509,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "overflow:",
        "\t/*",
        "\t * This race condition is unavoidable with lock-free drivers.",
        "\t * We wake up the queue _before_ tx_prd is advanced, so that we can",
        "\t * enter hard_start_xmit too early, while tx ring still looks closed.",
        "\t * This happens ~1-4 times per 100000 packets, so that we can allow"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\amd\\nmclan_cs.c",
      "line": 85,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * Revision 0.14  1995/05/23  03:19:30  rpao",
        " * Added, in nmclan_config(), \"tuple.Attributes = 0;\".",
        " * Modified MACE ID check to ignore chip revision level.",
        " * Avoid tx_free_frames race condition between _start_xmit and _interrupt.",
        " *",
        " * Revision 0.13  1995/05/18  05:56:34  rpao",
        " * Statistics changes."
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\broadcom\\cnic.c",
      "line": 502,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\trcu_assign_pointer(cnic_ulp_tbl[ulp_type], ulp_ops);",
        "\tmutex_unlock(&cnic_lock);",
        "",
        "\t/* Prevent race conditions with netdev_event */",
        "\trtnl_lock();",
        "\tlist_for_each_entry(dev, &cnic_dev_list, list) {",
        "\t\tstruct cnic_local *cp = dev->cnic_priv;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\broadcom\\tg3.c",
      "line": 7293,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t\ttw32_mailbox(tnapi->int_mbox, tnapi->last_tag << 24);",
        "",
        "\t\t\t/* This test here is synchronized by napi_schedule()",
        "\t\t\t * and napi_complete() to close the race condition.",
        "\t\t\t */",
        "\t\t\tif (unlikely(tnapi == &tp->napi[1] && tp->rx_refill)) {",
        "\t\t\t\ttw32(HOSTCC_MODE, tp->coalesce_mode |"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\broadcom\\tg3.c",
      "line": 7991,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/* We are running in BH disabled context with netif_tx_lock",
        "\t * and TX reclaim runs via tp->napi.poll inside of a software",
        "\t * interrupt.  Furthermore, IRQ processing runs lockless so we have",
        "\t * no IRQ context deadlocks to worry about either.  Rejoice!",
        "\t */",
        "\tif (unlikely(budget <= (skb_shinfo(skb)->nr_frags + 1))) {",
        "\t\tif (!netif_tx_queue_stopped(txq)) {"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\cadence\\macb_main.c",
      "line": 2120,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\ttx_skb->skb = skb;",
        "",
        "\t/* Update TX ring: update buffer descriptors in reverse order",
        "\t * to avoid race condition",
        "\t */",
        "",
        "\t/* Set 'TX_USED' bit in buffer descriptor at tx_head position"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\calxeda\\xgmac.c",
      "line": 1130,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\telse",
        "\t\tdesc_flags |= TXDESC_LAST_SEG | irq_flag;",
        "",
        "\t/* Set owner on first desc last to avoid race condition */",
        "\twmb();",
        "\tdesc_set_tx_owner(first, desc_flags | TXDESC_FIRST_SEG);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\faraday\\ftgmac100.c",
      "line": 1589,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/* Note about the reset task: We are called with the rtnl lock",
        "\t * held, so we are synchronized against the core of the reset",
        "\t * task. We must not try to synchronously cancel it otherwise",
        "\t * we can deadlock. But since it will test for netif_running()",
        "\t * which has already been cleared by the net core, we don't",
        "\t * anything special to do.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\freescale\\ucc_geth.c",
      "line": 1902,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Tell the kernel the link is down.",
        "\t * Must be done before disabling the controller",
        "\t * or deadlock may happen.",
        "\t */",
        "\tphylink_stop(ugeth->phylink);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\freescale\\ucc_geth.c",
      "line": 3399,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing %s-clock",
      "context": [
        "\t\t\t/* If both *-clock-name and *-clock are missing,",
        "\t\t\t * we want to tell people to use *-clock-name.",
        "\t\t\t */",
        "\t\t\tpr_err(\"missing %s-clock-name property\\n\", buf);",
        "\t\t\treturn -EINVAL;",
        "\t\t}",
        "\t\t*out = val;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\natsemi\\ns83820.c",
      "line": 22,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *\t20010713\t0.4 - zero copy, no hangs.",
        " *\t\t\t0.5 - 64 bit dma support (davem will hate me for this)",
        " *\t\t\t    - disable jumbo frames to avoid tx hangs",
        " *\t\t\t    - work around tx deadlocks on my 1.02 card via",
        " *\t\t\t      fiddling with TXCFG",
        " *\t20010810\t0.6 - use pci dma api for ringbuffers, work on ia64",
        " *\t20010816\t0.7 - misc cleanups"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\sfc\\mcdi.c",
      "line": 1189,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * efx_mcdi_ev_cpl()]",
        "\t *",
        "\t * If there is an outstanding asynchronous request, we can't",
        "\t * complete it now (efx_mcdi_complete() would deadlock).  The",
        "\t * reset process will take care of this.",
        "\t *",
        "\t * There's a race here with efx_mcdi_send_request(), because"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\sfc\\tc.c",
      "line": 1946,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double-free",
      "context": [
        "\t\t\tgoto release;",
        "\t\t}",
        "\t\tlist_add_tail(&act->list, &rule->acts.list);",
        "\t\tact = NULL; /* Prevent double-free in error path */",
        "\t}",
        "",
        "\trule->match = match;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\sfc\\tc.c",
      "line": 2496,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double-free",
      "context": [
        "\t\t\tgoto release;",
        "\t\t}",
        "\t\tlist_add_tail(&act->list, &rule->acts.list);",
        "\t\tact = NULL; /* Prevent double-free in error path */",
        "\t}",
        "",
        "\tnetif_dbg(efx, drv, efx->net_dev,"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\sfc\\tc_conntrack.c",
      "line": 479,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "used-after-free",
      "context": [
        "{",
        "\t/* Remove related CT counter.  This is delayed after the conn object we",
        "\t * are working with has been successfully removed.  This protects the",
        "\t * counter from being used-after-free inside efx_tc_ct_stats.",
        "\t */",
        "\tefx_tc_flower_release_counter(efx, conn->cnt);",
        "\tkfree(conn);"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\sgi\\ioc3-eth.c",
      "line": 501,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\tif (eisr & EISR_RXOFLO)",
        "\t\tnet_err_ratelimited(\"%s: RX overflow.\\n\", dev->name);",
        "\tif (eisr & EISR_RXBUFOFLO)",
        "\t\tnet_err_ratelimited(\"%s: RX buffer overflow.\\n\", dev->name);",
        "\tif (eisr & EISR_RXMEMERR)",
        "\t\tnet_err_ratelimited(\"%s: RX PCI error.\\n\", dev->name);",
        "\tif (eisr & EISR_RXPARERR)"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\smsc\\smc91x.c",
      "line": 218,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "/*",
        " * Wait while MMU is busy.  This is usually in the order of a few nanosecs",
        " * if at all, but let's avoid deadlocking the system if the hardware",
        " * decides to go south.",
        " */",
        "#define SMC_WAIT_MMU_BUSY(lp) do {\t\t\t\t\t\\"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\socionext\\netsec.c",
      "line": 1913,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing required property 'socionext,phy-clock",
      "context": [
        "\t\t\t\t       &priv->freq);",
        "\tif (ret)",
        "\t\treturn dev_err_probe(&pdev->dev, ret,",
        "\t\t\t\t     \"missing required property 'socionext,phy-clock-frequency'\\n\");",
        "\treturn 0;",
        "}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\socionext\\netsec.c",
      "line": 2083,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing PHY reference clock",
      "context": [
        "\tpriv->phy_addr = phy_addr;",
        "",
        "\tif (!priv->freq) {",
        "\t\tdev_err(&pdev->dev, \"missing PHY reference clock frequency\\n\");",
        "\t\tret = -ENODEV;",
        "\t\tgoto free_ndev;",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\sun\\cassini.c",
      "line": 166,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "#if 1",
        "/*",
        " * Eliminate these and use separate atomic counters for each, to",
        " * avoid a race condition.",
        " */",
        "#else",
        "#define CAS_RESET_MTU                   1"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\sun\\cassini.c",
      "line": 240,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tspin_lock_nested(&cp->tx_lock[i], i);",
        "}",
        "",
        "/* WTZ: QA was finding deadlock problems with the previous",
        " * versions after long test runs with multiple cards per machine.",
        " * See if replacing cas_lock_all with safer versions helps. The",
        " * symptoms QA is reporting match those we'd expect if interrupts"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\sun\\cassini.c",
      "line": 244,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * versions after long test runs with multiple cards per machine.",
        " * See if replacing cas_lock_all with safer versions helps. The",
        " * symptoms QA is reporting match those we'd expect if interrupts",
        " * aren't being properly restored, and we fixed a previous deadlock",
        " * with similar symptoms by using save/restore versions in other",
        " * places.",
        " */"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\sun\\sungem.c",
      "line": 2186,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\ttimer_delete_sync(&gp->link_timer);",
        "",
        "\t/* We cannot cancel the reset task while holding the",
        "\t * rtnl lock, we'd get an A->B / B->A deadlock stituation",
        "\t * if we did. This is not an issue however as the reset",
        "\t * task is synchronized vs. us (rtnl_lock) and will do",
        "\t * nothing if the device is down or suspended. We do"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\sun\\sunhme.c",
      "line": 1489,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tregtmp |= BIGMAC_TXCFG_FULLDPLX;",
        "",
        "\t/* Don't turn on the \"don't give up\" bit for now.  It could cause hme",
        "\t * to deadlock with the PHY if a Jabber occurs.",
        "\t */",
        "\thme_write32(hp, bregs + BMAC_TXCFG, regtmp /*| BIGMAC_TXCFG_DGIVEUP*/);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\sun\\sunvnet_common.c",
      "line": 706,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\treturn 0;",
        "\t}",
        "",
        "\t/* sync for race conditions with vnet_start_xmit() and tell xmit it",
        "\t * is time to send a trigger.",
        "\t */",
        "\ttrace_vnet_rx_stopped_ack(port->vio._local_sid,"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\xircom\\xirc2ps_cs.c",
      "line": 130,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "Buffer Overflow",
      "context": [
        "#define XIRCREG_EDP 4\t/* Ethernet Data Port Register */",
        "#define XIRCREG_ISR 6\t/* Ethernet Interrupt Status Register */",
        "enum xirc_isr {",
        "    TxBufOvr = 0x01,\t/* TX Buffer Overflow */",
        "    PktTxed  = 0x02,\t/* Packet Transmitted */",
        "    MACIntr  = 0x04,\t/* MAC Interrupt occurred */",
        "    TxResGrant = 0x08,\t/* Tx Reservation Granted */"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\amazon\\ena\\ena_netdev.c",
      "line": 3543,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/* For the rare case where the device runs out of Rx descriptors and the",
        " * napi handler failed to refill new Rx descriptors (due to a lack of memory",
        " * for example).",
        " * This case will lead to a deadlock:",
        " * The device won't send interrupts since all the new Rx packets will be dropped",
        " * The napi handler won't allocate new Rx descriptors so the device will be",
        " * able to send new packets."
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\amd\\pds_core\\core.c",
      "line": 625,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tif (fw_status != PDS_RC_BAD_PCI)",
        "\t\treturn;",
        "",
        "\t/* prevent deadlock between pdsc_reset_prepare and pdsc_health_thread */",
        "\tqueue_work(pdsc->wq, &pdsc->pci_reset_work);",
        "}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\atheros\\atl1c\\atl1c_main.c",
      "line": 969,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double free",
      "context": [
        "\tadapter->ring_header.desc = NULL;",
        "",
        "\t/* Note: just free tdp_ring.buffer_info,",
        "\t * it contain rfd_ring.buffer_info, do not double free",
        "\t */",
        "\tif (adapter->tpd_ring[0].buffer_info) {",
        "\t\tkfree(adapter->tpd_ring[0].buffer_info);"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\broadcom\\bnx2x\\bnx2x_stats.c",
      "line": 54,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\tif (size)",
        "\t\t\tres = size;",
        "",
        "\t\t/* prevent newer BC from causing buffer overflow */",
        "\t\tif (res > sizeof(struct host_port_stats))",
        "\t\t\tres = sizeof(struct host_port_stats);",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\broadcom\\bnxt\\bnxt.c",
      "line": 3122,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffers in rx/agg rings to prevent overflow",
      "context": [
        "\trx_pkts = __bnxt_poll_work(bp, cpr, budget);",
        "",
        "\t/* ACK completion ring before freeing tx ring and producing new",
        "\t * buffers in rx/agg rings to prevent overflowing the completion",
        "\t * ring.",
        "\t */",
        "\tbnxt_db_cq(bp, &cpr->cp_db, cpr->cp_raw_cons);"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\brocade\\bna\\bnad.c",
      "line": 2988,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\t\tsmp_mb();",
        "\t\t/*",
        "\t\t * Check again to deal with race condition between",
        "\t\t * netif_stop_queue here, and netif_wake_queue in",
        "\t\t * interrupt handler which is not inside netif tx lock.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\brocade\\bna\\bnad.c",
      "line": 2448,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "",
        "\tstats->rx_length_errors = mac_stats->rx_frame_length_error;",
        "",
        "\t/* receive ring buffer overflow  ?? */",
        "",
        "\tstats->rx_crc_errors = mac_stats->rx_fcs_error;",
        "\tstats->rx_frame_errors = mac_stats->rx_alignment_error;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\cavium\\liquidio\\octeon_device.c",
      "line": 906,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\ttxpciq.s.use_qpg = 0;",
        "\ttxpciq.s.qpg = 0;",
        "\tif (octeon_init_instr_queue(oct, txpciq, num_descs)) {",
        "\t\t/* prevent memory leak */",
        "\t\tvfree(oct->instr_queue[0]);",
        "\t\toct->instr_queue[0] = NULL;",
        "\t\treturn 1;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\chelsio\\cxgb\\tp.c",
      "line": 14,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tadapter_t *adapter;",
        "};",
        "",
        "/* Pause deadlock avoidance parameters */",
        "#define DROP_MSEC 16",
        "#define DROP_PKTS_CNT  1",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\chelsio\\cxgb\\tp.c",
      "line": 42,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t       V_5TUPLE_LOOKUP(p->use_5tuple_mode) |",
        "\t       V_SYN_COOKIE_PARAMETER(29), ap->regs + A_TP_GLOBAL_CONFIG);",
        "\t/*",
        "\t * Enable pause frame deadlock prevention.",
        "\t */",
        "\tif (is_T2(ap) && ap->params.nports > 1) {",
        "\t\tu32 drop_ticks = DROP_MSEC * (tp_clk / 1000);"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\chelsio\\cxgb3\\cxgb3_main.c",
      "line": 142,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * We have work elements that we need to cancel when an interface is taken",
        " * down.  Normally the work elements would be executed by keventd but that",
        " * can deadlock because of linkwatch.  If our close method takes the rtnl",
        " * lock and linkwatch is ahead of our work elements in keventd, linkwatch",
        " * will block keventd as it needs the rtnl lock, and we'll deadlock waiting",
        " * for our work to complete.  Get our own work queue to solve this."
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\chelsio\\cxgb3\\cxgb3_main.c",
      "line": 144,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * down.  Normally the work elements would be executed by keventd but that",
        " * can deadlock because of linkwatch.  If our close method takes the rtnl",
        " * lock and linkwatch is ahead of our work elements in keventd, linkwatch",
        " * will block keventd as it needs the rtnl lock, and we'll deadlock waiting",
        " * for our work to complete.  Get our own work queue to solve this.",
        " */",
        "struct workqueue_struct *cxgb3_wq;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\chelsio\\cxgb4\\sge.c",
      "line": 164,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double unmappings.  All of the above requires that the Free",
      "context": [
        " * these to specify the buffer size as an index into the SGE Free List Buffer",
        " * Size register array.  We also use bit 4, when the buffer has been unmapped",
        " * for DMA, but this is of course never sent to the hardware and is only used",
        " * to prevent double unmappings.  All of the above requires that the Free List",
        " * Buffers which we allocate have the bottom 5 bits free (0) -- i.e. are",
        " * 32-byte or or a power of 2 greater in alignment.  Since the SGE's minimal",
        " * Free List Buffer alignment is 32 bytes, this works out for us ..."
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\chelsio\\cxgb4vf\\cxgb4vf_main.c",
      "line": 2525,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Some environments do not properly handle PCIE FLRs -- e.g. in Linux",
        "\t * 2.6.31 and later we can't call pci_reset_function() in order to",
        "\t * issue an FLR because of a self- deadlock on the device semaphore.",
        "\t * Meanwhile, the OS infrastructure doesn't issue FLRs in all the",
        "\t * cases where they're needed -- for instance, some versions of KVM",
        "\t * fail to reset \"Assigned Devices\" when the VM reboots.  Therefore we"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\chelsio\\cxgb4\\t4_hw.c",
      "line": 5959,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tif (tp->snap_len > ((10 * 1024 / 4) - (2 * 8)))",
        "\t\t\treturn -EINVAL;",
        "\t} else {",
        "\t\t/* If multiple tracers are disabled, to avoid deadlocks",
        "\t\t * maximum packet capture size of 9600 bytes is recommended.",
        "\t\t * Also in this mode, only trace0 can be enabled and running.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\cisco\\enic\\enic_rq.c",
      "line": 381,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "Buffer overflow",
      "context": [
        "\t\tbuf->dma_addr = 0;",
        "\t\tbuf = buf->next;",
        "\t} else {",
        "\t\t/* Buffer overflow",
        "\t\t */",
        "\t\trqstats->pkt_truncated++;",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\cisco\\enic\\vnic_rq.c",
      "line": 149,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tstruct vnic_dev *vdev = rq->vdev;",
        "\tint i;",
        "",
        "\t/* Due to a race condition with clearing RQ \"mini-cache\" in hw, we need",
        "\t * to disable the RQ twice to guarantee that stale descriptors are not",
        "\t * used when this RQ is re-enabled.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\dec\\tulip\\winbond-840.c",
      "line": 40,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "\t\tsupport for big endian descriptors",
        "\t\t\tCopyright (C) 2001 Manfred Spraul",
        "\t* ethtool support (jgarzik)",
        "\t* Replace some MII-related magic numbers with constants (jgarzik)",
        "",
        "\tTODO:",
        "\t* enable pci_power_off"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\emulex\\benet\\be_ethtool.c",
      "line": 91,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer tank (PMEM) overflow",
      "context": [
        "\t{DRVSTAT_INFO(rx_priority_pause_frames)},",
        "\t{DRVSTAT_INFO(tx_priority_pauseframes)},",
        "\t/* Received packets dropped when an internal fifo going into",
        "\t * main packet buffer tank (PMEM) overflows.",
        "\t */",
        "\t{DRVSTAT_INFO(pmem_fifo_overflow_drop)},",
        "\t{DRVSTAT_INFO(jabber_events)},"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\freescale\\fs_enet\\fs_enet-main.c",
      "line": 597,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * shortly after, it no longer makes sense to try to recover from the",
        "\t * timeout. netif_running() will return false when called from the",
        "\t * .ndo_close() callback. Calling the following recovery code while",
        "\t * called from .ndo_close() could deadlock on rtnl.",
        "\t */",
        "\tif (!netif_running(dev))",
        "\t\treturn;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\google\\gve\\gve_main.c",
      "line": 2496,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double free",
      "context": [
        "\tgve_rx_stop_ring(priv, idx);",
        "",
        "\t/* All failures in this func result in a reset, by clearing the struct",
        "\t * at idx, we prevent a double free when that reset runs. The reset,",
        "\t * which needs the rtnl lock, will not run till this func returns and",
        "\t * its caller gives up the lock.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\google\\gve\\gve_rx_dqo.c",
      "line": 582,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer_overflow",
      "context": [
        "\t\t      u32 desc_idx, int queue_idx)",
        "{",
        "\tconst u16 buffer_id = le16_to_cpu(compl_desc->buf_id);",
        "\tconst bool hbo = compl_desc->header_buffer_overflow;",
        "\tconst bool eop = compl_desc->end_of_packet != 0;",
        "\tconst bool hsplit = compl_desc->split_header;",
        "\tstruct gve_rx_buf_state_dqo *buf_state;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\hisilicon\\hns3\\hns3vf\\hclgevf_mbx.c",
      "line": 20,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "static void hclgevf_reset_mbx_resp_status(struct hclgevf_dev *hdev)",
        "{",
        "\t/* this function should be called with mbx_resp.mbx_mutex held",
        "\t * to protect the received_response from race condition",
        "\t */",
        "\thdev->mbx_resp.received_resp  = false;",
        "\thdev->mbx_resp.origin_mbx_msg = 0;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\ibm\\emac\\mal.c",
      "line": 603,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tcfg |= MAL_CFG_PLBB | MAL_CFG_OPBBL | MAL_CFG_LEA;",
        "",
        "\t/* Current Axon is not happy with priority being non-0, it can",
        "\t * deadlock, fix it up here",
        "\t */",
        "\tif (of_device_is_compatible(ofdev->dev.of_node, \"ibm,mcmal-axon\"))",
        "\t\tcfg &= ~(MAL2_CFG_RPP_10 | MAL2_CFG_WPP_10);"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\intel\\e1000\\e1000_main.c",
      "line": 504,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tmsleep(10);",
        "",
        "\t/* Set the carrier off after transmits have been disabled in the",
        "\t * hardware, to avoid race conditions with e1000_watchdog() (which",
        "\t * may be running concurrently to us, checking for the carrier",
        "\t * bit to decide whether it should enable transmits again). Such",
        "\t * a race condition would result into transmission being disabled"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\intel\\e1000\\e1000_main.c",
      "line": 507,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * hardware, to avoid race conditions with e1000_watchdog() (which",
        "\t * may be running concurrently to us, checking for the carrier",
        "\t * bit to decide whether it should enable transmits again). Such",
        "\t * a race condition would result into transmission being disabled",
        "\t * in the hardware until the next IFF_DOWN+IFF_UP cycle.",
        "\t */",
        "\tnetif_carrier_off(netdev);"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\intel\\i40e\\i40e_adminq.c",
      "line": 995,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " *",
        " *  Acquires the lock and calls the main send command execution",
        " *  routine. Returns the last Admin Queue status in aq_status",
        " *  to avoid race conditions in access to hw->aq.asq_last_status.",
        " **/",
        "int",
        "i40e_asq_send_command_atomic_v2(struct i40e_hw *hw,"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\intel\\i40e\\i40e_common.c",
      "line": 2297,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " *",
        " * Add MAC/VLAN addresses to the HW filtering.",
        " * The _v2 version returns the last Admin Queue status in aq_status",
        " * to avoid race conditions in access to hw->aq.asq_last_status.",
        " * It also calls _v2 versions of asq_send_command functions to",
        " * get the aq_status on the stack.",
        " **/"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\intel\\i40e\\i40e_common.c",
      "line": 2373,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " *",
        " * Remove MAC/VLAN addresses from the HW filtering.",
        " * The _v2 version returns the last Admin Queue status in aq_status",
        " * to avoid race conditions in access to hw->aq.asq_last_status.",
        " * It also calls _v2 versions of asq_send_command functions to",
        " * get the aq_status on the stack.",
        " **/"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\intel\\i40e\\i40e_ethtool.c",
      "line": 4930,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use a use-after-free",
      "context": [
        "",
        "\t/* Add the input filter to the fdir_input_list, possibly replacing",
        "\t * a previous filter. Do not free the input structure after adding it",
        "\t * to the list as this would cause a use-after-free bug.",
        "\t */",
        "\ti40e_update_ethtool_fdir_entry(vsi, input, fsp->location, NULL);",
        "\tret = i40e_add_del_fdir(vsi, input, true);"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\intel\\i40e\\i40e_nvm.c",
      "line": 1539,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\thw->nvmupd_state = I40E_NVMUPD_STATE_INIT;",
        "\t}",
        "",
        "\t/* Acquire lock to prevent race condition where adminq_task",
        "\t * can execute after i40e_nvmupd_nvm_read/write but before state",
        "\t * variables (nvm_wait_opcode, nvm_release_on_done) are updated.",
        "\t *"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\intel\\iavf\\iavf_virtchnl.c",
      "line": 405,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer before it overflow",
      "context": [
        "\tvqci->num_queue_pairs = pairs;",
        "\tvqpi = vqci->qpair;",
        "\t/* Size check is not needed here - HW max is 16 queue pairs, and we",
        "\t * can fit info for 31 of them into the AQ buffer before it overflows.",
        "\t */",
        "\tfor (i = 0; i < pairs; i++) {",
        "\t\tvqpi->txq.vsi_id = vqci->vsi_id;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\intel\\iavf\\iavf_main.c",
      "line": 4579,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tset_bit(__IAVF_VSI_DOWN, adapter->vsi.state);",
        "\t/* We cannot send IAVF_FLAG_AQ_GET_OFFLOAD_VLAN_V2_CAPS before",
        "\t * IAVF_FLAG_AQ_DISABLE_QUEUES because in such case there is rtnl",
        "\t * deadlock with adminq_task() until iavf_close timeouts. We must send",
        "\t * IAVF_FLAG_AQ_GET_CONFIG before IAVF_FLAG_AQ_DISABLE_QUEUES to make",
        "\t * disable queues possible for vf. Give only necessary flags to",
        "\t * iavf_down and save other to set them right before iavf_close()"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\intel\\ice\\ice_dcb_lib.c",
      "line": 412,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tice_send_event_to_aux(pf, event);",
        "\tkfree(event);",
        "",
        "\t/* avoid race conditions by holding the lock while disabling and",
        "\t * re-enabling the VSI",
        "\t */",
        "\tif (!locked)"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\intel\\ice\\ice_ethtool.c",
      "line": 1908,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t * correlations for statistics.",
        "\t\t *",
        "\t\t * Even if it appears to be safe, changes to the size or",
        "\t\t * order of strings will suffer from race conditions and are",
        "\t\t * not safe.",
        "\t\t */",
        "\t\treturn ICE_ALL_STATS_LEN(netdev);"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\intel\\ice\\ice_idc.c",
      "line": 16,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * @cdev: pointer to iidc_rdma_core_dev_info struct",
        " *",
        " * This function has to be called with a device_lock on the",
        " * cdev->adev.dev to avoid race conditions.",
        " *",
        " * Return: pointer to the matched auxiliary driver struct",
        " */"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\intel\\ice\\ice_switch.c",
      "line": 20,
      "pattern": "hardcoded.*values",
      "rule": "code_quality",
      "severity": "low",
      "match": "Hardcoded values",
      "context": [
        " * Ether type (2 bytes for header without VLAN tag) OR",
        " * VLAN tag (4 bytes for header with VLAN tag) }",
        " *",
        " * Word on Hardcoded values",
        " * byte 0 = 0x2: to identify it as locally administered DA MAC",
        " * byte 6 = 0x2: to identify it as locally administered SA MAC",
        " * byte 12 = 0x81 & byte 13 = 0x00:"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\intel\\idpf\\idpf_ethtool.c",
      "line": 615,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer under/overflow",
      "context": [
        "\t * size has changed, which can typically happen as a result of changing",
        "\t * number of queues. If the number/order of stats change in the middle",
        "\t * of this call chain it will lead to userspace crashing/accessing bad",
        "\t * data through buffer under/overflow.",
        "\t */",
        "\tmax_txq = vport_config->max_q.max_txq;",
        "\tmax_rxq = vport_config->max_q.max_rxq;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\intel\\idpf\\idpf_txrx.c",
      "line": 3250,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "}",
        "",
        "/**",
        " * idpf_rx_hsplit_wa - handle header buffer overflows and split errors",
        " * @hdr: Rx buffer for the headers",
        " * @buf: Rx buffer for the payload",
        " * @data_len: number of bytes received to the payload buffer"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\intel\\idpf\\idpf_txrx.c",
      "line": 3255,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        " * @buf: Rx buffer for the payload",
        " * @data_len: number of bytes received to the payload buffer",
        " *",
        " * When a header buffer overflow occurs or the HW was unable do parse the",
        " * packet type to perform header split, the whole frame gets placed to the",
        " * payload buffer. We can't build a valid skb around a payload buffer when",
        " * the header split is active since it doesn't reserve any head- or tailroom."
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\intel\\idpf\\idpf_txrx.c",
      "line": 3418,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "#define __HBO_BIT\tVIRTCHNL2_RX_FLEX_DESC_ADV_STATUS0_HBO_M",
        "#define __HDR_LEN_MASK\tVIRTCHNL2_RX_FLEX_DESC_ADV_LEN_HDR_M",
        "\t\tif (likely(!(rx_desc->status_err0_qw1 & __HBO_BIT)))",
        "\t\t\t/* If a header buffer overflow, occurs, i.e. header is",
        "\t\t\t * too large to fit in the header split buffer, HW will",
        "\t\t\t * put the entire packet, including headers, in the",
        "\t\t\t * data/payload buffer."
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\intel\\igb\\e1000_mbx.c",
      "line": 378,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\ts32 ret_val;",
        "\tu16 i;",
        "",
        "\t/* lock the mailbox to prevent pf/vf race condition */",
        "\tret_val = igb_obtain_mbx_lock_pf(hw, vf_number);",
        "\tif (ret_val)",
        "\t\tgoto out_no_write;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\intel\\igb\\e1000_mbx.c",
      "line": 420,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\ts32 ret_val;",
        "\tu16 i;",
        "",
        "\t/* lock the mailbox to prevent pf/vf race condition */",
        "\tret_val = igb_obtain_mbx_lock_pf(hw, vf_number);",
        "\tif (ret_val)",
        "\t\tgoto out_no_read;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\intel\\igbvf\\mbx.c",
      "line": 247,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\tlockdep_assert_held(&hw->mbx_lock);",
        "",
        "\t/* lock the mailbox to prevent pf/vf race condition */",
        "\terr = e1000_obtain_mbx_lock_vf(hw);",
        "\tif (err)",
        "\t\tgoto out_no_write;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\intel\\igbvf\\mbx.c",
      "line": 285,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\tlockdep_assert_held(&hw->mbx_lock);",
        "",
        "\t/* lock the mailbox to prevent pf/vf race condition */",
        "\terr = e1000_obtain_mbx_lock_vf(hw);",
        "\tif (err)",
        "\t\tgoto out_no_read;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\intel\\ixgbe\\ixgbe_mbx.c",
      "line": 339,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tint ret_val;",
        "\tu16 i;",
        "",
        "\t/* lock the mailbox to prevent pf/vf race condition */",
        "\tret_val = ixgbe_obtain_mbx_lock_pf(hw, vf_number);",
        "\tif (ret_val)",
        "\t\treturn ret_val;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\intel\\ixgbe\\ixgbe_mbx.c",
      "line": 378,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tint ret_val;",
        "\tu16 i;",
        "",
        "\t/* lock the mailbox to prevent pf/vf race condition */",
        "\tret_val = ixgbe_obtain_mbx_lock_pf(hw, vf_number);",
        "\tif (ret_val)",
        "\t\treturn ret_val;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\intel\\ixgbe\\ixgbe_main.c",
      "line": 6341,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\tif (ixgbe_removed(hw->hw_addr))",
        "\t\treturn;",
        "\t/* lock SFP init bit to prevent race conditions with the watchdog */",
        "\twhile (test_and_set_bit(__IXGBE_IN_SFP_INIT, &adapter->state))",
        "\t\tusleep_range(1000, 2000);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\intel\\ixgbevf\\mbx.c",
      "line": 268,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\ts32 ret_val;",
        "\tu16 i;",
        "",
        "\t/* lock the mailbox to prevent PF/VF race condition */",
        "\tret_val = ixgbevf_obtain_mbx_lock_vf(hw);",
        "\tif (ret_val)",
        "\t\tgoto out_no_write;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\intel\\ixgbevf\\mbx.c",
      "line": 311,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\ts32 ret_val;",
        "\tu16 i;",
        "",
        "\t/* lock the mailbox to prevent PF/VF race condition */",
        "\tret_val = ixgbevf_obtain_mbx_lock_vf(hw);",
        "\tif (ret_val)",
        "\t\tgoto out_no_write;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\intel\\ixgbevf\\mbx.c",
      "line": 385,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\ts32 ret_val = 0;",
        "\tu16 i;",
        "",
        "\t/* lock the mailbox to prevent PF/VF race condition */",
        "\tret_val = ixgbevf_obtain_mbx_lock_vf(hw);",
        "\tif (ret_val)",
        "\t\tgoto out_no_read;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\marvell\\mvpp2\\mvpp2_prs.c",
      "line": 801,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double_vlan_ai_free",
      "context": [
        "}",
        "",
        "/* Get first free double vlan ai number */",
        "static int mvpp2_prs_double_vlan_ai_free_get(struct mvpp2 *priv)",
        "{",
        "\tint i;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\marvell\\mvpp2\\mvpp2_prs.c",
      "line": 866,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double_vlan_ai_free",
      "context": [
        "\t\t\treturn tid;",
        "",
        "\t\t/* Set ai value for new double vlan entry */",
        "\t\tai = mvpp2_prs_double_vlan_ai_free_get(priv);",
        "\t\tif (ai < 0)",
        "\t\t\treturn ai;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\marvell\\mvpp2\\mvpp2_main.c",
      "line": 7686,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing clock",
      "context": [
        "\t} else {",
        "\t\terr = device_property_read_u32(&pdev->dev, \"clock-frequency\", &priv->tclk);",
        "\t\tif (err) {",
        "\t\t\tdev_err(&pdev->dev, \"missing clock-frequency value\\n\");",
        "\t\t\treturn err;",
        "\t\t}",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\marvell\\octeontx2\\nic\\qos.c",
      "line": 126,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t(*num_regs)++;",
        "",
        "\t/* Don't configure CIR when both CIR+PIR not supported",
        "\t * On 96xx, CIR + PIR + RED_ALGO=STALL causes deadlock",
        "\t */",
        "\tif (!test_bit(QOS_CIR_PIR_SUPPORT, &pfvf->hw.cap_flag))",
        "\t\treturn;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\mellanox\\mlx4\\en_main.c",
      "line": 330,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tmlx4_en_set_num_rx_rings(mdev);",
        "",
        "\t/* Create our own workqueue for reset/multicast tasks",
        "\t * Note: we cannot use the shared workqueue because of deadlocks caused",
        "\t *       by the rtnl lock */",
        "\tmdev->workqueue = create_singlethread_workqueue(\"mlx4_en\");",
        "\tif (!mdev->workqueue) {"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\mellanox\\mlxsw\\spectrum_ptp.c",
      "line": 806,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * networking stack. This is usually done from a trap handler, which is",
        "\t * invoked in a softirq context. Here we are going to do it in process",
        "\t * context. If that were to be interrupted by a softirq, it could cause",
        "\t * a deadlock when an attempt is made to take an already-taken lock",
        "\t * somewhere along the sending path. Disable softirqs to prevent this.",
        "\t */",
        "\tlocal_bh_disable();"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\mellanox\\mlxsw\\spectrum_span.c",
      "line": 1674,
      "pattern": "null.*pointer.*dereference",
      "rule": "memory_management",
      "severity": "high",
      "match": "NULL pointer dereference",
      "context": [
        "{",
        "\tsize_t arr_size = ARRAY_SIZE(mlxsw_sp1_span_entry_ops_arr);",
        "",
        "\t/* Must be first to avoid NULL pointer dereference by subsequent",
        "\t * can_handle() callbacks.",
        "\t */",
        "\tif (WARN_ON(mlxsw_sp1_span_entry_ops_arr[0] !="
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\mellanox\\mlxsw\\spectrum_span.c",
      "line": 1703,
      "pattern": "null.*pointer.*dereference",
      "rule": "memory_management",
      "severity": "high",
      "match": "NULL pointer dereference",
      "context": [
        "{",
        "\tsize_t arr_size = ARRAY_SIZE(mlxsw_sp2_span_entry_ops_arr);",
        "",
        "\t/* Must be first to avoid NULL pointer dereference by subsequent",
        "\t * can_handle() callbacks.",
        "\t */",
        "\tif (WARN_ON(mlxsw_sp2_span_entry_ops_arr[0] !="
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\mellanox\\mlxsw\\spectrum_router.c",
      "line": 8539,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tstruct mlxsw_sp_router_hwstats_notify_work *hws_work;",
        "",
        "\t/* To collect notification payload, the core ends up sending another",
        "\t * notifier block message, which would deadlock on the attempt to",
        "\t * acquire the router lock again. Just postpone the notification until",
        "\t * later.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\mellanox\\mlx5\\core\\en_stats.c",
      "line": 1572,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer_overflow\", PCIE_PERF_OFF64(tx_overflow",
      "context": [
        "#define PCIE_PERF_OFF64(c) \\",
        "\tMLX5_BYTE_OFF(mpcnt_reg, counter_set.pcie_perf_cntrs_grp_data_layout.c##_high)",
        "static const struct counter_desc pcie_perf_stats_desc64[] = {",
        "\t{ \"outbound_pci_buffer_overflow\", PCIE_PERF_OFF64(tx_overflow_buffer_pkt) },",
        "};",
        "",
        "static const struct counter_desc pcie_perf_stall_stats_desc[] = {"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\mellanox\\mlx5\\core\\en_txrx.c",
      "line": 105,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\txsk_clear_tx_need_wakeup(xsksq->xsk_pool);",
        "",
        "\t/* If WQ is empty, RX won't trigger NAPI, so set need_wakeup. Do it",
        "\t * before refilling to avoid race condition with userspace.",
        "\t */",
        "\tif (need_wakeup && !mlx5e_rqwq_get_cur_sz(xskrq))",
        "\t\txsk_set_rx_need_wakeup(xskrq->xsk_pool);"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\mellanox\\mlx5\\core\\en\\reporter_tx.c",
      "line": 201,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use a dead lock or a read-after-free",
      "context": [
        "}",
        "",
        "/* state lock cannot be grabbed within this function.",
        " * It can cause a dead lock or a read-after-free.",
        " */",
        "static int mlx5e_tx_reporter_recover_from_ctx(struct mlx5e_err_ctx *err_ctx)",
        "{"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\mellanox\\mlx5\\core\\lib\\crypto.c",
      "line": 69,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "used after sync, and 1 means it is in use, or free",
      "context": [
        "",
        "\t/* The bits are set when they are used, and reset after crypto_sync",
        "\t * is executed. So, the value 0 means the key is newly created, or not",
        "\t * used after sync, and 1 means it is in use, or freed but not synced",
        "\t */",
        "\tunsigned long *need_sync;",
        "};"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\myricom\\myri10ge\\myri10ge.c",
      "line": 3965,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "#endif",
        "\tmyri10ge_dummy_rdma(mgp, 0);",
        "",
        "\t/* avoid a memory leak */",
        "\tpci_restore_state(pdev);",
        "",
        "\tiounmap(mgp->sram);"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\netronome\\nfp\\nfp_net_main.c",
      "line": 821,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double free",
      "context": [
        "\t}",
        "",
        "\tnfp_net_pf_app_stop(pf);",
        "\t/* stop app first, to avoid double free of ctrl vNIC's ddir */",
        "\tnfp_net_debugfs_dir_clean(&pf->ddir);",
        "",
        "\tnfp_devlink_params_unregister(pf);"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\netronome\\nfp\\flower\\conntrack.c",
      "line": 2220,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tswitch (type) {",
        "\tcase TC_SETUP_CLSFLOWER:",
        "\t\twhile (!mutex_trylock(&zt->priv->nfp_fl_lock)) {",
        "\t\t\tif (!zt->nft) /* avoid deadlock */",
        "\t\t\t\treturn err;",
        "\t\t\tmsleep(20);",
        "\t\t}"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\netronome\\nfp\\flower\\conntrack.c",
      "line": 2274,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t\tif (!zt->pre_ct_count && zt->nft) {",
        "\t\t\tnft = zt->nft;",
        "\t\t\tzt->nft = NULL; /* avoid deadlock */",
        "\t\t\tnf_flow_table_offload_del_cb(nft,",
        "\t\t\t\t\t\t     nfp_fl_ct_handle_nft_flow,",
        "\t\t\t\t\t\t     zt);"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\netronome\\nfp\\nfpcore\\nfp_target.c",
      "line": 332,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic NFP-6xxx IMB 'mode' numbers",
      "context": [
        "#undef P32",
        "#undef P64",
        "",
        "/* All magic NFP-6xxx IMB 'mode' numbers here are from:",
        " * Databook (1 August 2013)",
        " * - System Overview and Connectivity",
        " * -- Internal Connectivity"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\qlogic\\netxen\\netxen_nic_init.c",
      "line": 1795,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * the card has already interrupted the host then the host can miss the",
        "\t * interrupt.",
        "\t *",
        "\t * There is still a possible race condition and the host could miss an",
        "\t * interrupt. The card has to take care of this.",
        "\t */",
        "\thw_consumer = le32_to_cpu(*(tx_ring->hw_consumer));"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\qlogic\\qed\\qed_sriov.c",
      "line": 1187,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "Buffer overflow",
      "context": [
        "\t\ttotal_length += tlv->length;",
        "",
        "\t\tif (total_length >= sizeof(struct tlv_buffer_size)) {",
        "\t\t\tDP_NOTICE(p_hwfn, \"TLV ==> Buffer overflow\\n\");",
        "\t\t\treturn;",
        "\t\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\qlogic\\qede\\qede_main.c",
      "line": 1121,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tif (test_and_clear_bit(QEDE_SP_RECOVERY, &edev->sp_flags)) {",
        "\t\tcancel_delayed_work_sync(&edev->periodic_task);",
        "#ifdef CONFIG_QED_SRIOV",
        "\t\t/* SRIOV must be disabled outside the lock to avoid a deadlock.",
        "\t\t * The recovery of the active VFs is currently not supported.",
        "\t\t */",
        "\t\tif (pci_num_vf(edev->pdev))"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\qlogic\\qede\\qede_main.c",
      "line": 1150,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\tif (test_and_clear_bit(QEDE_SP_AER, &edev->sp_flags)) {",
        "#ifdef CONFIG_QED_SRIOV",
        "\t\t/* SRIOV must be disabled outside the lock to avoid a deadlock.",
        "\t\t * The recovery of the active VFs is currently not supported.",
        "\t\t */",
        "\t\tif (pci_num_vf(edev->pdev))"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\qlogic\\qlcnic\\qlcnic_io.c",
      "line": 948,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * the card has already interrupted the host then the host can miss the",
        "\t * interrupt.",
        "\t *",
        "\t * There is still a possible race condition and the host could miss an",
        "\t * interrupt. The card has to take care of this.",
        "\t */",
        "\thw_consumer = le32_to_cpu(*(tx_ring->hw_consumer));"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\qualcomm\\emac\\emac-mac.c",
      "line": 973,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tphy_stop(adpt->phydev);",
        "",
        "\t/* Interrupts must be disabled before the PHY is disconnected, to",
        "\t * avoid a race condition where adjust_link is null when we get",
        "\t * an interrupt.",
        "\t */",
        "\twritel(DIS_INT, adpt->base + EMAC_INT_STATUS);"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\sfc\\siena\\mcdi.c",
      "line": 1212,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * efx_mcdi_ev_cpl()]",
        "\t *",
        "\t * If there is an outstanding asynchronous request, we can't",
        "\t * complete it now (efx_mcdi_complete() would deadlock).  The",
        "\t * reset process will take care of this.",
        "\t *",
        "\t * There's a race here with efx_mcdi_send_request(), because"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\stmicro\\stmmac\\dwmac-rk.c",
      "line": 187,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Missing clk_mac_speed clock",
      "context": [
        "\tint ret;",
        "",
        "\tif (!clk_mac_speed) {",
        "\t\tdev_err(dev, \"%s: Missing clk_mac_speed clock\\n\", __func__);",
        "\t\treturn;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\stmicro\\stmmac\\dwmac4_descs.c",
      "line": 353,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tif (is_fs && tx_own)",
        "\t\t/* When the own bit, for the first frame, has to be set, all",
        "\t\t * descriptors for the same frame has to be set before, to",
        "\t\t * avoid race condition.",
        "\t\t */",
        "\t\tdma_wmb();",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\stmicro\\stmmac\\dwmac4_descs.c",
      "line": 396,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tif (is_fs && tx_own)",
        "\t\t/* When the own bit, for the first frame, has to be set, all",
        "\t\t * descriptors for the same frame has to be set before, to",
        "\t\t * avoid race condition.",
        "\t\t */",
        "\t\tdma_wmb();",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\stmicro\\stmmac\\dwxgmac2_descs.c",
      "line": 192,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tif (is_fs && tx_own)",
        "\t\t/* When the own bit, for the first frame, has to be set, all",
        "\t\t * descriptors for the same frame has to be set before, to",
        "\t\t * avoid race condition.",
        "\t\t */",
        "\t\tdma_wmb();",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\stmicro\\stmmac\\dwxgmac2_descs.c",
      "line": 232,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tif (is_fs && tx_own)",
        "\t\t/* When the own bit, for the first frame, has to be set, all",
        "\t\t * descriptors for the same frame has to be set before, to",
        "\t\t * avoid race condition.",
        "\t\t */",
        "\t\tdma_wmb();",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\stmicro\\stmmac\\enh_desc.c",
      "line": 342,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tif (is_fs && tx_own)",
        "\t\t/* When the own bit, for the first frame, has to be set, all",
        "\t\t * descriptors for the same frame has to be set before, to",
        "\t\t * avoid race condition.",
        "\t\t */",
        "\t\tdma_wmb();",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\wangxun\\libwx\\wx_mbx.c",
      "line": 101,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\treturn -EINVAL;",
        "\t}",
        "",
        "\t/* lock the mailbox to prevent pf/vf race condition */",
        "\tret = wx_obtain_mbx_lock_pf(wx, vf);",
        "\tif (ret)",
        "\t\treturn ret;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\ethernet\\wangxun\\libwx\\wx_mbx.c",
      "line": 141,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tif (size > mbx->size)",
        "\t\tsize = mbx->size;",
        "",
        "\t/* lock the mailbox to prevent pf/vf race condition */",
        "\tret = wx_obtain_mbx_lock_pf(wx, vf);",
        "\tif (ret)",
        "\t\treturn ret;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\fddi\\skfp\\skfddi.c",
      "line": 2013,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer is full / FIFO overflow",
      "context": [
        " *\tsmc - A pointer to the SMT context struct.",
        " *",
        " *\tstat -\t= 0: A ring operational change occurred.",
        " *\t\t= 1: The FORMAC FIFO buffer is full / FIFO overflow.",
        " * Out",
        " *\tNothing.",
        " *"
      ]
    },
    {
      "file": "linux\\drivers\\net\\phy\\realtek\\realtek_main.c",
      "line": 493,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "\t\treturn ret;",
        "",
        "\t/* Quirk was copied from vendor driver. Unfortunately it includes no",
        "\t * description of the magic numbers.",
        "\t */",
        "\tif (phydev->speed == SPEED_100 && phydev->autoneg == AUTONEG_DISABLE) {",
        "\t\tphy_write(phydev, 0x17, 0x2138);"
      ]
    },
    {
      "file": "linux\\drivers\\net\\phy\\realtek\\realtek_main.c",
      "line": 1067,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "\t\tphydev->rate_matching = RATE_MATCH_NONE;",
        "\t}",
        "",
        "\t/* the following sequence with magic numbers sets up the SerDes",
        "\t * option mode",
        "\t */",
        "\tret = phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x75f3, 0);"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\ath\\ar5523\\ar5523.c",
      "line": 24,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "/*",
        " * This driver is based on the uath driver written by Damien Bergamini for",
        " * OpenBSD, who did black-box analysis of the Windows binary driver to find",
        " * out how the hardware works.  It contains a lot magic numbers because of",
        " * that and only has minimal functionality.",
        " */",
        "#include <linux/compiler.h>"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\ath\\ath10k\\core.c",
      "line": 3565,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double free",
      "context": [
        "\tath10k_thermal_unregister(ar);",
        "\t/* Stop spectral before unregistering from mac80211 to remove the",
        "\t * relayfs debugfs file cleanly. Otherwise the parent debugfs tree",
        "\t * would be already be free'd recursively, leading to a double free.",
        "\t */",
        "\tath10k_spectral_destroy(ar);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\ath\\ath10k\\core.c",
      "line": 2560,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/* TODO: We can have one instance of cancelling coverage_class_work by",
        "\t * moving it to ath10k_halt(), so that both stop() and restart() would",
        "\t * call that but it takes conf_mutex() and if we call cancel_work_sync()",
        "\t * with conf_mutex it will deadlock.",
        "\t */",
        "\tcancel_work_sync(&ar->set_coverage_class_work);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\ath\\ath10k\\core.c",
      "line": 3537,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tath10k_core_free_firmware_files(ar);",
        "err:",
        "\t/* TODO: It's probably a good idea to release device from the driver",
        "\t * but calling device_release_driver() here will cause a deadlock.",
        "\t */",
        "\treturn;",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\ath\\ath10k\\debug.c",
      "line": 1752,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t      ar->normal_mode_fw.fw_file.fw_features))",
        "\t\tath10k_debug_cal_data_fetch(ar);",
        "",
        "\t/* Must not use _sync to avoid deadlock, we do that in",
        "\t * ath10k_debug_destroy(). The check for htt_stats_mask is to avoid",
        "\t * warning from timer_delete().",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\ath\\ath10k\\htt_tx.c",
      "line": 1356,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "",
        "\t/* As msdu is freed by mac80211 (in ieee80211_tx_status()) and by",
        "\t * ath10k (in ath10k_htt_htc_tx_complete()) we have to increase",
        "\t * reference by one to avoid a use-after-free case and a double",
        "\t * free.",
        "\t */",
        "\tskb_get(msdu);"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\ath\\ath10k\\htt_rx.c",
      "line": 3524,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\tlen += sizeof(resp->tx_fetch_confirm.resp_ids[0]) * num_resp_ids;",
        "",
        "\tif (unlikely(skb->len < len)) {",
        "\t\tath10k_warn(ar, \"received corrupted tx_fetch_confirm event: resp_ids buffer overflow\\n\");",
        "\t\treturn;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\ath\\ath10k\\mac.c",
      "line": 7506,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\tath10k_mac_txq_init(sta->txq[i]);",
        "\t}",
        "",
        "\t/* cancel must be done outside the mutex to avoid deadlock */",
        "\tif ((old_state == IEEE80211_STA_NONE &&",
        "\t     new_state == IEEE80211_STA_NOTEXIST)) {",
        "\t\tcancel_work_sync(&arsta->update_wk);"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\ath\\ath11k\\mac.c",
      "line": 9668,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tstruct ath11k_peer *peer;",
        "\tint ret = 0;",
        "",
        "\t/* cancel must be done outside the mutex to avoid deadlock */",
        "\tif ((old_state == IEEE80211_STA_NONE &&",
        "\t     new_state == IEEE80211_STA_NOTEXIST)) {",
        "\t\tcancel_work_sync(&arsta->update_wk);"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\ath\\ath11k\\reg.c",
      "line": 914,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\t\t * is true. If pdev_idx is valid but not 0, discard the",
        "\t\t * event. Otherwise, it goes to fallback. In either case",
        "\t\t * ath11k_reg_reset_info() needs to be called to avoid",
        "\t\t * memory leak issue.",
        "\t\t */",
        "\t\tath11k_reg_reset_info(reg_info);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\ath\\ath5k\\dma.c",
      "line": 747,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\told_mask = ah->ah_imr;",
        "",
        "\t/*",
        "\t * Disable card interrupts to prevent any race conditions",
        "\t * (they will be re-enabled afterwards if AR5K_INT GLOBAL",
        "\t * is set again on the new mask).",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\ath\\ath6kl\\htc_pipe.c",
      "line": 954,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tint status = 0;",
        "",
        "\t/*",
        "\t * ar->htc_target can be NULL due to a race condition that can occur",
        "\t * during driver initialization(we do 'ath6kl_hif_power_on' before",
        "\t * initializing 'ar->htc_target' via 'ath6kl_htc_create').",
        "\t * 'ath6kl_hif_power_on' assigns 'ath6kl_recv_complete' as"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\ath\\ath6kl\\main.c",
      "line": 932,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\t/*",
        "\t * If there are no associated STAs, ignore the DTIM expiry event.",
        "\t * There can be potential race conditions where the last associated",
        "\t * STA may disconnect & before the host could clear the 'Indicate",
        "\t * DTIM' request to the firmware, the firmware would have just",
        "\t * indicated a DTIM expiry event. The race is between 'clear DTIM"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\ath\\ath9k\\xmit.c",
      "line": 2649,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\tbf = list_first_entry(&txq->axq_q, struct ath_buf, list);",
        "",
        "\t\t/*",
        "\t\t * There is a race condition that a BH gets scheduled",
        "\t\t * after sw writes TxE and before hw re-load the last",
        "\t\t * descriptor to get the newly chained one.",
        "\t\t * Software must keep the last DONE descriptor as a"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\ath\\carl9170\\tx.c",
      "line": 220,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double-free",
      "context": [
        "\t *  1. The firmware might use it generate BlockACK frames",
        "\t *     in responds of an incoming BlockAckReqs.",
        "\t *",
        "\t *  2. Prevent double-free bugs.",
        "\t */",
        "\tsuper->s.cookie = (u8) cookie + 1;",
        "\treturn 0;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\ath\\wil6210\\interrupt.c",
      "line": 312,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "",
        "\t/* RX_DONE and RX_HTRSH interrupts are the same if interrupt",
        "\t * moderation is not used. Interrupt moderation may cause RX",
        "\t * buffer overflow while RX_DONE is delayed. The required",
        "\t * action is always the same - should empty the accumulated",
        "\t * packets from the RX ring.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\ath\\wil6210\\main.c",
      "line": 454,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t}",
        "",
        "\t/* call event handler manually after processing wmi_call,",
        "\t * to avoid deadlock - disconnect event handler acquires",
        "\t * wil->mutex while it is already held here",
        "\t */",
        "\t_wil6210_disconnect_complete(vif, bssid, reason_code);"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\ath\\wil6210\\txrx.c",
      "line": 1985,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t}",
        "",
        "\t/* Make sure to advance the head only after descriptor update is done.",
        "\t * This will prevent a race condition where the completion thread",
        "\t * will see the DU bit set from previous run and will handle the",
        "\t * skb before it was completed.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\ath\\wil6210\\txrx.c",
      "line": 2138,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t}",
        "",
        "\t/* Make sure to advance the head only after descriptor update is done.",
        "\t * This will prevent a race condition where the completion thread",
        "\t * will see the DU bit set from previous run and will handle the",
        "\t * skb before it was completed.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\broadcom\\b43\\dma.c",
      "line": 1442,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tskip = 0;",
        "\tif (unlikely(slot != firstused)) {",
        "\t\t/* This possibly is a firmware bug and will result in",
        "\t\t * malfunction, memory leaks and/or stall of DMA functionality.",
        "\t\t */",
        "\t\tif (slot == next_slot(ring, next_slot(ring, firstused))) {",
        "\t\t\t/* If a single header/data pair was missed, skip over"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\broadcom\\b43\\dma.c",
      "line": 1292,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "{",
        "#ifdef CONFIG_B43_DEBUG",
        "\tif (unlikely(b43_debug(ring->dev, B43_DBG_DMAOVERFLOW))) {",
        "\t\t/* Check if we should inject another ringbuffer overflow",
        "\t\t * to test handling of this situation in the stack. */",
        "\t\tunsigned long next_overflow;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\broadcom\\b43\\main.c",
      "line": 1431,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tif (dev->phy.type != B43_PHYTYPE_G)",
        "\t\treturn;",
        "",
        "\t/* Possible race condition: It might be possible that the user",
        "\t * changed to a different channel in the meantime since we",
        "\t * started the calculation. We ignore that fact, since it's",
        "\t * not really that much of a problem. The background noise is"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\broadcom\\b43\\main.c",
      "line": 4338,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tif (!dev || b43_status(dev) < B43_STAT_STARTED)",
        "\t\treturn dev;",
        "",
        "\t/* Cancel work. Unlock to avoid deadlocks. */",
        "\tmutex_unlock(&wl->mutex);",
        "\tcancel_delayed_work_sync(&dev->periodic_work);",
        "\tcancel_work_sync(&wl->tx_work);"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\broadcom\\b43\\main.c",
      "line": 4362,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tb43_read32(dev, B43_MMIO_GEN_IRQ_MASK);\t/* Flush */",
        "\t\tspin_unlock_irq(&wl->hardirq_lock);",
        "\t}",
        "\t/* Synchronize and free the interrupt handlers. Unlock to avoid deadlocks. */",
        "\torig_dev = dev;",
        "\tmutex_unlock(&wl->mutex);",
        "\tif (b43_bus_host_is_sdio(dev->dev))"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\broadcom\\b43legacy\\dma.c",
      "line": 1123,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\t\tfirstused = ring->nr_slots + firstused;",
        "\tif (unlikely(slot != firstused)) {",
        "\t\t/* This possibly is a firmware bug and will result in",
        "\t\t * malfunction, memory leaks and/or stall of DMA functionality.",
        "\t\t */",
        "\t\tb43legacydbg(dev->wl, \"Out of order TX status report on DMA \"",
        "\t\t\t     \"ring %d. Expected %d, but got %d\\n\","
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\broadcom\\b43legacy\\dma.c",
      "line": 1031,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "#ifdef CONFIG_B43LEGACY_DEBUG",
        "\tif (unlikely(b43legacy_debug(ring->dev,",
        "\t\t\t\t     B43legacy_DBG_DMAOVERFLOW))) {",
        "\t\t/* Check if we should inject another ringbuffer overflow",
        "\t\t * to test handling of this situation in the stack. */",
        "\t\tunsigned long next_overflow;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\broadcom\\b43legacy\\main.c",
      "line": 2404,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tstruct b43legacy_wl *wl = (struct b43legacy_wl *)rng->priv;",
        "\tunsigned long flags;",
        "",
        "\t/* Don't take wl->mutex here, as it could deadlock with",
        "\t * hwrng internal locking. It's not needed to take",
        "\t * wl->mutex here, anyway. */",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\broadcom\\b43legacy\\main.c",
      "line": 2935,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tb43legacy_set_status(dev, B43legacy_STAT_INITIALIZED);",
        "",
        "\tmutex_unlock(&wl->mutex);",
        "\t/* Must unlock as it would otherwise deadlock. No races here.",
        "\t * Cancel the possibly running self-rearming periodic work. */",
        "\tcancel_delayed_work_sync(&dev->periodic_work);",
        "\tcancel_work_sync(&wl->tx_work);"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\broadcom\\brcm80211\\brcmfmac\\flowring.c",
      "line": 272,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t    (skb_queue_len(&ring->skblist) > BRCMF_FLOWRING_HIGH)) {",
        "\t\tbrcmf_flowring_block(flow, flowid, true);",
        "\t\tbrcmf_dbg(MSGBUF, \"Flowcontrol: BLOCK for ring %d\\n\", flowid);",
        "\t\t/* To prevent (work around) possible race condition, check",
        "\t\t * queue len again. It is also possible to use locking to",
        "\t\t * protect, but that is undesirable for every enqueue and",
        "\t\t * dequeue. This simple check will solve a possible race"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\broadcom\\brcm80211\\brcmfmac\\fwsignal.c",
      "line": 1428,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double free",
      "context": [
        "\t\t/* suppress q is full drop this packet */",
        "\t\tbrcmf_fws_hanger_poppkt(&fws->hanger, hslot, &skb, true);",
        "\t} else {",
        "\t\t/* Mark suppressed to avoid a double free during wlfc cleanup */",
        "\t\tbrcmf_fws_hanger_mark_suppressed(&fws->hanger, hslot);",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\intel\\ipw2x00\\ipw2200.c",
      "line": 3629,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer to protect from overflow",
      "context": [
        " * Theory of operation",
        " *",
        " * A queue is a circular buffers with 'Read' and 'Write' pointers.",
        " * 2 empty entries always kept in the buffer to protect from overflow.",
        " *",
        " * For Tx queue, there are low mark and high mark limits. If, after queuing",
        " * the packet for Tx, free space become < low mark, Tx queue stopped. When"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\intel\\ipw2x00\\ipw2200.c",
      "line": 2558,
      "pattern": "long.*functions",
      "rule": "code_quality",
      "severity": "low",
      "match": "long with some helper functions",
      "context": [
        " * through a couple of memory mapped registers.",
        " *",
        " * The following is a simplified implementation for pulling data out of the",
        " * eeprom, along with some helper functions to find information in",
        " * the per device private data's copy of the eeprom.",
        " *",
        " * NOTE: To better understand how these functions work (i.e what is a chip"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\intel\\ipw2x00\\ipw2100.c",
      "line": 6517,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * @returns 0 if ok, < 0 errno node con error.",
        " *",
        " * Note: we cannot init the /proc stuff until the PCI driver is there,",
        " * or we risk an unlikely race condition on someone accessing",
        " * uninitialized data in the PCI dev struct through /proc.",
        " */",
        "static int __init ipw2100_init(void)"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\intel\\iwlegacy\\4965-mac.c",
      "line": 5357,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\til_clear_ucode_stations(il);",
        "",
        "\t/* FIXME: race conditions ? */",
        "\tspin_lock_irq(&il->sta_lock);",
        "\t/*",
        "\t * Remove all key information that is not stored as part"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\intel\\iwlwifi\\mld\\mac80211.c",
      "line": 1367,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "{",
        "\tstruct iwl_mld *mld = IWL_MAC80211_GET_MLD(hw);",
        "",
        "\t/* Due to a race condition, it's possible that mac80211 asks",
        "\t * us to stop a hw_scan when it's already stopped. This can",
        "\t * happen, for instance, if we stopped the scan ourselves,",
        "\t * called ieee80211_scan_completed() and the userspace called"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\intel\\iwlwifi\\mld\\mac80211.c",
      "line": 1398,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "{",
        "\tstruct iwl_mld *mld = IWL_MAC80211_GET_MLD(hw);",
        "",
        "\t/* Due to a race condition, it's possible that mac80211 asks",
        "\t * us to stop a sched_scan when it's already stopped. This",
        "\t * can happen, for instance, if we stopped the scan ourselves,",
        "\t * called ieee80211_sched_scan_stopped() and the userspace called"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\intel\\iwlwifi\\mvm\\mac80211.c",
      "line": 3337,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\tguard(mvm)(mvm);",
        "",
        "\t/* Due to a race condition, it's possible that mac80211 asks",
        "\t * us to stop a hw_scan when it's already stopped.  This can",
        "\t * happen, for instance, if we stopped the scan ourselves,",
        "\t * called ieee80211_scan_completed() and the userspace called"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\intel\\iwlwifi\\mvm\\mac80211.c",
      "line": 4349,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\tmutex_lock(&mvm->mutex);",
        "",
        "\t/* Due to a race condition, it's possible that mac80211 asks",
        "\t * us to stop a sched_scan when it's already stopped.  This",
        "\t * can happen, for instance, if we stopped the scan ourselves,",
        "\t * called ieee80211_sched_scan_stopped() and the userspace called"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\intel\\iwlwifi\\mvm\\sta.c",
      "line": 1618,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "/*",
        " * In DQA mode, after a HW restart the queues should be allocated as before, in",
        " * order to avoid race conditions when there are shared queues. This function",
        " * does the re-mapping and queue allocation.",
        " *",
        " * Note that re-enabling aggregations isn't done in this function."
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\intel\\iwlwifi\\mvm\\tx.c",
      "line": 1210,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t * Note that the no lock is taken here in order to not serialize",
        "\t\t * the TX flow. This isn't dangerous because scheduling",
        "\t\t * mvm->add_stream_wk can't ruin the state, and if we DON'T",
        "\t\t * schedule it due to some race condition then next TX we get",
        "\t\t * here we will.",
        "\t\t */",
        "\t\tif (unlikely(mvm->queue_info[txq_id].status =="
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\marvell\\libertas\\if_sdio.c",
      "line": 1043,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * The actual reset operation must be run outside of lbs_thread. This",
        "\t * is because mmc_remove_host() will cause the device to be instantly",
        "\t * destroyed, and the libertas driver then needs to end lbs_thread,",
        "\t * leading to a deadlock.",
        "\t *",
        "\t * We run it in a workqueue totally independent from the if_sdio_card",
        "\t * instance for that reason."
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\marvell\\mwifiex\\main.c",
      "line": 1474,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t/*",
        "\t\t\t * Close the netdev now, because if we do it later, the",
        "\t\t\t * netdev notifiers will need to acquire the wiphy lock",
        "\t\t\t * again --> deadlock.",
        "\t\t\t */",
        "\t\t\tdev_close(priv->wdev.netdev);",
        "\t\t\twiphy_lock(adapter->wiphy);"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\marvell\\mwifiex\\main.c",
      "line": 1218,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t}",
        "",
        "\tif (dump_len + 1 + adapter->devdump_len > MWIFIEX_FW_DUMP_SIZE) {",
        "\t\t/* Realloc in case buffer overflow */",
        "\t\tfw_dump_ptr = vzalloc(dump_len + 1 + adapter->devdump_len);",
        "\t\tmwifiex_dbg(adapter, MSG, \"Realloc device dump data.\\n\");",
        "\t\tif (!fw_dump_ptr) {"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\marvell\\mwifiex\\pcie.c",
      "line": 2071,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\tbool cmd7_before = false, first_cmd = false;",
        "",
        "\twhile (1) {",
        "\t\t/* Check for integer and buffer overflow */",
        "\t\tif (offset + sizeof(fwdata->header) < sizeof(fwdata->header) ||",
        "\t\t    offset + sizeof(fwdata->header) >= firmware_len) {",
        "\t\t\tmwifiex_dbg(adapter, ERROR,"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\ralink\\rt2x00\\rt2400pci.c",
      "line": 1135,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\trt2x00_desc_write(txd, 4, word);",
        "",
        "\t/*",
        "\t * Writing TXD word 0 must the last to prevent a race condition with",
        "\t * the device, whereby the device may take hold of the TXD before we",
        "\t * finished updating it.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\ralink\\rt2x00\\rt2500pci.c",
      "line": 1284,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\trt2x00_desc_write(txd, 10, word);",
        "",
        "\t/*",
        "\t * Writing TXD word 0 must the last to prevent a race condition with",
        "\t * the device, whereby the device may take hold of the TXD before we",
        "\t * finished updating it.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\ralink\\rt2x00\\rt2x00mac.c",
      "line": 102,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * Mac80211 might be calling this function while we are trying",
        "\t * to remove the device or perhaps suspending it.",
        "\t * Note that we can only stop the TX queues inside the TX path",
        "\t * due to possible race conditions in mac80211.",
        "\t */",
        "\tif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))",
        "\t\tgoto exit_free_skb;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\ralink\\rt2x00\\rt61pci.c",
      "line": 1832,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t}",
        "",
        "\t/*",
        "\t * Writing TXD word 0 must the last to prevent a race condition with",
        "\t * the device, whereby the device may take hold of the TXD before we",
        "\t * finished updating it.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\realtek\\rtlwifi\\btcoexist\\halbtcoutsrc.c",
      "line": 181,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tif (!halbtc_is_hw_mailbox_exist(btcoexist))",
        "\t\treturn false;",
        "",
        "\tif (wait_ms)\t/* before h2c to avoid race condition */",
        "\t\treinit_completion(&btcoexist->bt_mp_comp);",
        "",
        "\trtlpriv = btcoexist->adapter;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\realtek\\rtlwifi\\rtl8192ee\\fw.c",
      "line": 190,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD, \"come in\\n\");",
        "",
        "\t/* 1. Prevent race condition in setting H2C cmd.",
        "\t * (copy from MgntActSet_RF_State().)",
        "\t */",
        "\twhile (true) {"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\st\\cw1200\\txrx.c",
      "line": 1204,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Double-check status with lock",
      "context": [
        "",
        "\tif (early_data) {",
        "\t\tspin_lock_bh(&priv->ps_state_lock);",
        "\t\t/* Double-check status with lock held */",
        "\t\tif (entry->status == CW1200_LINK_SOFT)",
        "\t\t\tskb_queue_tail(&entry->rx_queue, skb);",
        "\t\telse"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\st\\cw1200\\wsm.c",
      "line": 1321,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\tu16 wsm_cmd;",
        "",
        "\t\t/* Do not trust FW too much. Protection against repeated",
        "\t\t * response and race condition removal (see above).",
        "\t\t */",
        "\t\tspin_lock(&priv->wsm_cmd.lock);",
        "\t\twsm_arg = priv->wsm_cmd.arg;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\ti\\wlcore\\main.c",
      "line": 604,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\t/*",
        "\t * In case edge triggered interrupt must be used, we cannot iterate",
        "\t * more than once without introducing race conditions with the hardirq.",
        "\t */",
        "\tif (wl->irq_flags & (IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING))",
        "\t\tloopcount = 1;"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\ti\\wlcore\\main.c",
      "line": 119,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tret = wl1271_set_rx_streaming(wl, wlvif, true);",
        "\telse {",
        "\t\tret = wl1271_set_rx_streaming(wl, wlvif, false);",
        "\t\t/* don't cancel_work_sync since we might deadlock */",
        "\t\ttimer_delete_sync(&wlvif->rx_streaming_timer);",
        "\t}",
        "out:"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\ti\\wlcore\\main.c",
      "line": 796,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tcounter->cur_vif_running = true;",
        "}",
        "",
        "/* caller must not hold wl->mutex, as it might deadlock */",
        "static void wl12xx_get_vif_count(struct ieee80211_hw *hw,",
        "\t\t\t       struct ieee80211_vif *cur_vif,",
        "\t\t\t       struct vif_counter_data *data)"
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\ti\\wlcore\\main.c",
      "line": 2001,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Use the nosync variant to disable interrupts, so the mutex could be",
        "\t * held while doing so without deadlocking.",
        "\t */",
        "\twlcore_disable_interrupts_nosync(wl);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\net\\wireless\\ti\\wlcore\\main.c",
      "line": 5782,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\twl1271_tx_flush(wl);",
        "",
        "\t/*",
        "\t * we can't just flush_work here, because it might deadlock",
        "\t * (as we might get called from the same workqueue)",
        "\t */",
        "\tcancel_delayed_work_sync(&wl->roc_complete_work);"
      ]
    },
    {
      "file": "linux\\drivers\\nfc\\nxp-nci\\core.c",
      "line": 100,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Missing or unstable clock",
      "context": [
        "\t\t\t\t       struct sk_buff *skb)",
        "{",
        "\tnfc_err(&ndev->nfc_dev->dev,",
        "\t\t\"PLL didn't lock. Missing or unstable clock?\\n\");",
        "",
        "\treturn 0;",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\nfc\\pn533\\uart.c",
      "line": 35,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t/*",
        "\t * send_wakeup variable is used to control if we need to send a wakeup",
        "\t * request to the pn532 chip prior to our actual command. There is a",
        "\t * little propability of a race condition. We decided to not mutex the",
        "\t * variable as the worst that could happen is, that we send a wakeup",
        "\t * to the chip that is already awake. This does not hurt. It is a",
        "\t * no-op to the chip."
      ]
    },
    {
      "file": "linux\\drivers\\ntb\\test\\ntb_perf.c",
      "line": 269,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race-condition",
      "context": [
        "\t/*",
        "\t * Perform predefined number of attempts before give up.",
        "\t * We are sending the data to the port specific scratchpad, so",
        "\t * to prevent a multi-port access race-condition. Additionally",
        "\t * there is no need in local locking since only thread-safe",
        "\t * service work is using this method.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\ntb\\test\\ntb_perf.c",
      "line": 359,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race-condition",
      "context": [
        "",
        "\t/*",
        "\t * Perform predefined number of attempts before give up. Message",
        "\t * registers are free of race-condition problem when accessed",
        "\t * from different ports, so we don't need splitting registers",
        "\t * by global device index. We also won't have local locking,",
        "\t * since the method is used from service work only."
      ]
    },
    {
      "file": "linux\\drivers\\nvme\\host\\apple.c",
      "line": 870,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * The driver will not be starting up queues again if shutting down so",
        "\t * must flush all entered requests to their failed completion to avoid",
        "\t * deadlocking blk-mq hot-cpu notifier.",
        "\t */",
        "\tif (shutdown) {",
        "\t\tnvme_unquiesce_io_queues(&anv->ctrl);"
      ]
    },
    {
      "file": "linux\\drivers\\nvme\\host\\core.c",
      "line": 1211,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t\t/*",
        "\t\t * NVME_CMD_EFFECTS_CSE_MASK causes a freeze all I/O queues,",
        "\t\t * which would deadlock when done on an I/O command.  Note that",
        "\t\t * We already warn about an unusual effect above.",
        "\t\t */",
        "\t\teffects &= ~NVME_CMD_EFFECTS_CSE_MASK;"
      ]
    },
    {
      "file": "linux\\drivers\\nvme\\host\\core.c",
      "line": 4143,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tmutex_lock(&ctrl->namespaces_lock);",
        "\t/*",
        "\t * Ensure that no namespaces are added to the ctrl list after the queues",
        "\t * are frozen, thereby avoiding a deadlock between scan and reset.",
        "\t */",
        "\tif (test_bit(NVME_CTRL_FROZEN, &ctrl->flags)) {",
        "\t\tmutex_unlock(&ctrl->namespaces_lock);"
      ]
    },
    {
      "file": "linux\\drivers\\nvme\\host\\ioctl.c",
      "line": 726,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Handle ioctls that apply to the controller instead of the namespace",
        "\t * separately and drop the ns SRCU reference early.  This avoids a",
        "\t * deadlock when deleting namespaces using the passthrough interface.",
        "\t */",
        "\tif (is_ctrl_ioctl(cmd))",
        "\t\treturn nvme_ns_head_ctrl_ioctl(ns, cmd, argp, head, srcu_idx,"
      ]
    },
    {
      "file": "linux\\drivers\\nvme\\host\\multipath.c",
      "line": 762,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * We need to suppress the partition scan from occuring within the",
        "\t * controller's scan_work context. If a path error occurs here, the IO",
        "\t * will wait until a path becomes available or all paths are torn down,",
        "\t * but that action also occurs within scan_work, so it would deadlock.",
        "\t * Defer the partition scan to a different context that does not block",
        "\t * scan_work.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\nvme\\host\\multipath.c",
      "line": 872,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * nvme_mpath_set_live() will trigger I/O to the multipath path device",
        "\t * and in turn to this path device.  However we cannot accept this I/O",
        "\t * if the controller is not live.  This may deadlock if called from",
        "\t * nvme_mpath_init_identify() and the ctrl will never complete",
        "\t * initialization, preventing I/O from completing.  For this case we",
        "\t * will reprocess the ANA log page in nvme_mpath_update() once the"
      ]
    },
    {
      "file": "linux\\drivers\\nvme\\host\\pci.c",
      "line": 1496,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * unblocks PCIe error handling if the nvme driver is waiting in",
        "\t * error_resume for a device that has been removed. We can't unbind the",
        "\t * driver while the driver's error callback is waiting to complete, so",
        "\t * we're relying on a timeout to break that deadlock if a removal",
        "\t * occurs while reset work is running.",
        "\t */",
        "\tif (pci_dev_is_disconnected(pdev))"
      ]
    },
    {
      "file": "linux\\drivers\\nvme\\host\\pci.c",
      "line": 2897,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * The driver will not be starting up queues again if shutting down so",
        "\t * must flush all entered requests to their failed completion to avoid",
        "\t * deadlocking blk-mq hot-cpu notifier.",
        "\t */",
        "\tif (shutdown) {",
        "\t\tnvme_unquiesce_io_queues(&dev->ctrl);"
      ]
    },
    {
      "file": "linux\\drivers\\nvme\\target\\fcloop.c",
      "line": 217,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double free",
      "context": [
        "\tstruct fcloop_lport *lport;",
        "};",
        "",
        "/* The port is already being removed, avoid double free */",
        "#define PORT_DELETED\t0",
        "",
        "struct fcloop_rport {"
      ]
    },
    {
      "file": "linux\\drivers\\nvme\\target\\rdma.c",
      "line": 1006,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\tspin_lock_irqsave(&queue->state_lock, flags);",
        "\t/*",
        "\t * recheck queue state is not live to prevent a race condition",
        "\t * with RDMA_CM_EVENT_ESTABLISHED handler.",
        "\t */",
        "\tif (queue->state == NVMET_RDMA_Q_LIVE)"
      ]
    },
    {
      "file": "linux\\drivers\\nvme\\target\\rdma.c",
      "line": 1452,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Schedules the actual release because calling rdma_destroy_id from",
        "\t * inside a CM callback would trigger a deadlock. (great API design..)",
        "\t */",
        "\tINIT_WORK(&queue->release_work, nvmet_rdma_release_queue_work);",
        "\tqueue->dev = ndev;"
      ]
    },
    {
      "file": "linux\\drivers\\pci\\controller\\vmd.c",
      "line": 382,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "}",
        "",
        "/*",
        " * CPU may deadlock if config space is not serialized on some versions of this",
        " * hardware, so all config space access is done under a spinlock.",
        " */",
        "static int vmd_pci_read(struct pci_bus *bus, unsigned int devfn, int reg,"
      ]
    },
    {
      "file": "linux\\drivers\\pci\\hotplug\\pciehp_pci.c",
      "line": 69,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Release reset_lock during driver binding",
        "\t * to avoid AB-BA deadlock with device_lock.",
        "\t */",
        "\tup_read(&ctrl->reset_lock);",
        "\tpci_bus_add_devices(parent);"
      ]
    },
    {
      "file": "linux\\drivers\\pci\\hotplug\\pciehp_pci.c",
      "line": 121,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t\t/*",
        "\t\t * Release reset_lock during driver unbinding",
        "\t\t * to avoid AB-BA deadlock with device_lock.",
        "\t\t */",
        "\t\tup_read(&ctrl->reset_lock);",
        "\t\tpci_stop_and_remove_bus_device(dev);"
      ]
    },
    {
      "file": "linux\\drivers\\pci\\pcie\\aer.c",
      "line": 1343,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t\t\t &aer_recover_ring_lock))",
        "\t\tschedule_work(&aer_recover_work);",
        "\telse",
        "\t\tpr_err(\"buffer overflow in recovery for %04x:%02x:%02x.%x\\n\",",
        "\t\t       domain, bus, PCI_SLOT(devfn), PCI_FUNC(devfn));",
        "}",
        "EXPORT_SYMBOL_GPL(aer_recover_queue);"
      ]
    },
    {
      "file": "linux\\drivers\\pci\\controller\\dwc\\pcie-rcar-gen4.c",
      "line": 609,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magical numbers",
      "context": [
        "",
        "static int rcar_gen4_pcie_download_phy_firmware(struct rcar_gen4_pcie *rcar)",
        "{",
        "\t/* The check_addr values are magical numbers in the datasheet */",
        "\tstatic const u32 check_addr[] = {",
        "\t\t0x00101018,",
        "\t\t0x00101118,"
      ]
    },
    {
      "file": "linux\\drivers\\pci\\controller\\dwc\\pcie-rcar-gen4.c",
      "line": 694,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magical offset numbers",
      "context": [
        "\t/*",
        "\t * The R-Car Gen4 datasheet doesn't describe the PHY registers' name.",
        "\t * But, the initialization procedure describes these offsets. So,",
        "\t * this driver has magical offset numbers.",
        "\t */",
        "\trcar_gen4_pcie_phy_reg_update_bits(rcar, 0x700, BIT(28), 0);",
        "\trcar_gen4_pcie_phy_reg_update_bits(rcar, 0x700, BIT(20), 0);"
      ]
    },
    {
      "file": "linux\\drivers\\phy\\allwinner\\phy-sun50i-usb3.c",
      "line": 80,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "\twritel(val, phy->regs + SUNXI_ISCR);",
        "",
        "\t/*",
        "\t * All the magic numbers written to the PHY_TUNE_{LOW_HIGH}",
        "\t * registers are directly taken from the BSP USB3 driver from",
        "\t * Allwiner.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\phy\\rockchip\\phy-rockchip-samsung-hdptx.c",
      "line": 2024,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Missing clock",
      "context": [
        "\tif (ret < 0)",
        "\t\treturn dev_err_probe(dev, ret, \"Failed to get clocks\\n\");",
        "\tif (ret == 0)",
        "\t\treturn dev_err_probe(dev, -EINVAL, \"Missing clocks\\n\");",
        "",
        "\thdptx->nr_clks = ret;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\pinctrl\\samsung\\pinctrl-samsung.c",
      "line": 553,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "/*",
        " * The samsung_gpio_set_vlaue() should be called with \"bank->slock\" held",
        " * to avoid race condition.",
        " */",
        "static void samsung_gpio_set_value(struct gpio_chip *gc,",
        "\t\t\t\t\t  unsigned offset, int value)"
      ]
    },
    {
      "file": "linux\\drivers\\pinctrl\\samsung\\pinctrl-samsung.c",
      "line": 625,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "/*",
        " * The samsung_gpio_set_direction() should be called with \"bank->slock\" held",
        " * to avoid race condition.",
        " * The calls to gpio_direction_output() and gpio_direction_input()",
        " * leads to this function call.",
        " */"
      ]
    },
    {
      "file": "linux\\drivers\\platform\\chrome\\chromeos_pstore.c",
      "line": 120,
      "pattern": "hardcoded.*values",
      "rule": "code_quality",
      "severity": "low",
      "match": "hardcoded values",
      "context": [
        "{",
        "\tbool acpi_dev_found;",
        "",
        "\t/* First check ACPI for non-hardcoded values from firmware. */",
        "\tacpi_dev_found = chromeos_check_acpi();",
        "",
        "\tif (acpi_dev_found || dmi_check_system(chromeos_pstore_dmi_table))"
      ]
    },
    {
      "file": "linux\\drivers\\platform\\x86\\lenovo-yogabook.c",
      "line": 130,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * We are called from the ACPI core and the driver [un]binding which is",
        "\t * done also needs ACPI functions, use a workqueue to avoid deadlocking.",
        "\t */",
        "\tschedule_work(&data->work);",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\platform\\x86\\msi-wmi-platform.c",
      "line": 274,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer for detecting buffer overflow",
      "context": [
        "{",
        "\tstruct msi_wmi_platform_debugfs_data *data = inode->i_private;",
        "",
        "\t/* The seq_file uses the last byte of the buffer for detecting buffer overflows */",
        "\treturn single_open_size(fp, msi_wmi_platform_show, data, data->length + 1);",
        "}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\platform\\x86\\p2sb.c",
      "line": 252,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "/*",
        " * pci_rescan_remove_lock() can not be locked in sysfs PCI bus rescan path",
        " * because of deadlock. To avoid the deadlock, access P2SB devices with the lock",
        " * at an early step in kernel initialization and cache required resources.",
        " *",
        " * We want to run as early as possible. If the P2SB was assigned a bad BAR,"
      ]
    },
    {
      "file": "linux\\drivers\\platform\\x86\\p2sb.c",
      "line": 252,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "/*",
        " * pci_rescan_remove_lock() can not be locked in sysfs PCI bus rescan path",
        " * because of deadlock. To avoid the deadlock, access P2SB devices with the lock",
        " * at an early step in kernel initialization and cache required resources.",
        " *",
        " * We want to run as early as possible. If the P2SB was assigned a bad BAR,"
      ]
    },
    {
      "file": "linux\\drivers\\platform\\x86\\sony-laptop.c",
      "line": 1710,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "\tif (i < 0)",
        "\t\treturn i;",
        "",
        "\t/* The buffer is filled with magic numbers describing the devices",
        "\t * available, 0xff terminates the enumeration.",
        "\t * Known codes:",
        "\t *\t0x00 WLAN"
      ]
    },
    {
      "file": "linux\\drivers\\platform\\surface\\aggregator\\ssh_packet_layer.c",
      "line": 167,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * >> General Notes <<",
        " *",
        " * - To avoid deadlocks, if both queue and pending locks are required, the",
        " *   pending lock must be acquired before the queue lock.",
        " *",
        " * - The packet priority must be accessed only while holding the queue lock."
      ]
    },
    {
      "file": "linux\\drivers\\platform\\x86\\dell\\dell-lis3lv02d.c",
      "line": 133,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * bus_for_each_dev() and not i2c_for_each_dev() to avoid",
        "\t * a deadlock when find_i801() calls i2c_get_adapter().",
        "\t */",
        "\tbus_for_each_dev(&i2c_bus_type, NULL, &adap, find_i801);",
        "\tif (!adap)"
      ]
    },
    {
      "file": "linux\\drivers\\platform\\x86\\tuxedo\\nb04\\wmi_util.c",
      "line": 3,
      "pattern": "code.*duplication",
      "rule": "code_quality",
      "severity": "low",
      "match": "code gives functions to avoid code duplication",
      "context": [
        "// SPDX-License-Identifier: GPL-2.0-or-later",
        "/*",
        " * This code gives functions to avoid code duplication while interacting with",
        " * the TUXEDO NB04 wmi interfaces.",
        " *",
        " * Copyright (C) 2024-2025 Werner Sembach <wse@tuxedocomputers.com>"
      ]
    },
    {
      "file": "linux\\drivers\\pmdomain\\imx\\imx8m-blk-ctrl.c",
      "line": 294,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * nesting being visible at the genpd level, so we need a",
        "\t\t * separate lock class to make lockdep aware of the fact that",
        "\t\t * this are separate domain locks that can be nested without a",
        "\t\t * self-deadlock.",
        "\t\t */",
        "\t\tlockdep_set_class(&domain->genpd.mlock,",
        "\t\t\t\t  &blk_ctrl_genpd_lock_class);"
      ]
    },
    {
      "file": "linux\\drivers\\pmdomain\\imx\\imx93-blk-ctrl.c",
      "line": 282,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * nesting being visible at the genpd level, so we need a",
        "\t\t * separate lock class to make lockdep aware of the fact that",
        "\t\t * this are separate domain locks that can be nested without a",
        "\t\t * self-deadlock.",
        "\t\t */",
        "\t\tlockdep_set_class(&domain->genpd.mlock,",
        "\t\t\t\t  &blk_ctrl_genpd_lock_class);"
      ]
    },
    {
      "file": "linux\\drivers\\pmdomain\\imx\\imx8mp-blk-ctrl.c",
      "line": 722,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * nesting being visible at the genpd level, so we need a",
        "\t\t * separate lock class to make lockdep aware of the fact that",
        "\t\t * this are separate domain locks that can be nested without a",
        "\t\t * self-deadlock.",
        "\t\t */",
        "\t\tlockdep_set_class(&domain->genpd.mlock,",
        "\t\t\t\t  &blk_ctrl_genpd_lock_class);"
      ]
    },
    {
      "file": "linux\\drivers\\power\\supply\\axp20x_usb_power.c",
      "line": 462,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t}",
        "",
        "\t/*",
        "\t * BC1.2 detection can cause a race condition if we try to set a current",
        "\t * limit while it's in progress. When it finishes it will overwrite the",
        "\t * current limit we just set.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\power\\supply\\power_supply_sysfs.c",
      "line": 574,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "",
        "\t/*",
        "\t * Kernel generates KOBJ_REMOVE uevent in device removal path, after",
        "\t * resources have been freed. Exit early to avoid use-after-free.",
        "\t */",
        "\tif (psy->removing)",
        "\t\treturn 0;"
      ]
    },
    {
      "file": "linux\\drivers\\s390\\block\\dasd_eckd.c",
      "line": 2750,
      "pattern": "incorrect.*flags",
      "rule": "api_usage",
      "severity": "medium",
      "match": "incorrect flags",
      "context": [
        "\t\tbreak;",
        "\tdefault:",
        "\t\tdev_warn(&startdev->cdev->dev,",
        "\t\t\t \"An I/O control call used incorrect flags 0x%x\\n\",",
        "\t\t\t fdata->intensity);",
        "\t\treturn ERR_PTR(-EINVAL);",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\s390\\char\\tape_34xx.c",
      "line": 134,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * interrupt handler.",
        " * Note: the work handler is called by the system work queue. The tape",
        " * commands started by the handler need to be asynchrounous, otherwise",
        " * a deadlock can occur e.g. in case of a deferred cc=1 (see __tape_do_irq).",
        " */",
        "static void",
        "tape_34xx_work_handler(struct work_struct *work)"
      ]
    },
    {
      "file": "linux\\drivers\\s390\\char\\tape_34xx.c",
      "line": 738,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffered log (Overflow",
      "context": [
        "\t\treturn tape_34xx_erp_bug(device, request, irb, sense[3]);",
        "\tcase 0x50:",
        "\t\t/*",
        "\t\t * Read buffered log (Overflow). CU is running in extended",
        "\t\t * buffered log mode, and a counter overflows. This should",
        "\t\t * never happen, since we're never running in extended",
        "\t\t * buffered log mode."
      ]
    },
    {
      "file": "linux\\drivers\\s390\\char\\tape_34xx.c",
      "line": 739,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffered log mode, and a counter overflow",
      "context": [
        "\tcase 0x50:",
        "\t\t/*",
        "\t\t * Read buffered log (Overflow). CU is running in extended",
        "\t\t * buffered log mode, and a counter overflows. This should",
        "\t\t * never happen, since we're never running in extended",
        "\t\t * buffered log mode.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\s390\\char\\tape_3590.c",
      "line": 616,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * interrupt context (like unsolicited interrupts).",
        " * Note: the work handler is called by the system work queue. The tape",
        " * commands started by the handler need to be asynchrounous, otherwise",
        " * a deadlock can occur e.g. in case of a deferred cc=1 (see __tape_do_irq).",
        " */",
        "struct work_handler_data {",
        "\tstruct tape_device *device;"
      ]
    },
    {
      "file": "linux\\drivers\\s390\\char\\tape_core.c",
      "line": 770,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\trequest = list_entry(l, struct tape_request, list);",
        "",
        "\t\t/*",
        "\t\t * Avoid race condition if bottom-half was triggered more than",
        "\t\t * once.",
        "\t\t */",
        "\t\tif (request->status == TAPE_REQUEST_IN_IO)"
      ]
    },
    {
      "file": "linux\\drivers\\s390\\net\\ctcm_mpc.c",
      "line": 593,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t\t/* on the io_queue will now be sen t\t*/",
        "\t\t\ttasklet_schedule(&rch->ch_tasklet);",
        "\t\t}",
        "\t\t/* possible race condition\t\t\t*/",
        "\t\tif (mpcg_state == MPCG_STATE_READY) {",
        "\t\t\tgrp->flow_off_called = 1;",
        "\t\t\tbreak;"
      ]
    },
    {
      "file": "linux\\drivers\\s390\\scsi\\zfcp_dbf.c",
      "line": 238,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race event for bit error condition",
      "context": [
        "}",
        "",
        "/**",
        " * zfcp_dbf_hba_bit_err - trace event for bit error conditions",
        " * @tag: tag indicating which kind of bit error unsolicited status was received",
        " * @req: request which caused the bit_error condition",
        " */"
      ]
    },
    {
      "file": "linux\\drivers\\s390\\scsi\\zfcp_scsi.c",
      "line": 179,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tint retry = 3;",
        "\tchar *dbf_tag;",
        "",
        "\t/* avoid race condition between late normal completion and abort */",
        "\twrite_lock_irqsave(&adapter->abort_lock, flags);",
        "",
        "\told_req = zfcp_reqlist_find(adapter->req_list, old_reqid);"
      ]
    },
    {
      "file": "linux\\drivers\\s390\\scsi\\zfcp_fsf.c",
      "line": 910,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t *",
        "\t * The request might complete and be freed concurrently at any point",
        "\t * now. This is not protected by the QDIO-lock (req_q_lock). So any",
        "\t * uncontrolled access after this might result in an use-after-free bug.",
        "\t * Only if the request doesn't have ZFCP_STATUS_FSFREQ_CLEANUP set, and",
        "\t * when it is completed via req->completion, is it safe to use req",
        "\t * again."
      ]
    },
    {
      "file": "linux\\drivers\\sbus\\char\\oradax.c",
      "line": 93,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "",
        "/* completion err */",
        "#define\tCCA_ERR_SUCCESS\t\t0x0\t/* no error */",
        "#define\tCCA_ERR_OVERFLOW\t0x1\t/* buffer overflow */",
        "#define\tCCA_ERR_DECODE\t\t0x2\t/* CCB decode error */",
        "#define\tCCA_ERR_PAGE_OVERFLOW\t0x3\t/* page overflow */",
        "#define\tCCA_ERR_KILLED\t\t0x7\t/* command was killed */"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\arm\\acornscsi.c",
      "line": 21,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " *\t\t\tUpdated proc/scsi reporting.",
        " *  05-Oct-1997\tRMK\tImplemented writing to SCSI devices.",
        " *  06-Oct-1997\tRMK\tCorrected small (non-serious) bug with the connect/",
        " *\t\t\treconnect race condition causing a warning message.",
        " *  12-Oct-1997\tRMK\tAdded catch for re-entering interrupt routine.",
        " *  15-Oct-1997\tRMK\tImproved handling of commands.",
        " *  27-Jun-1998\tRMK\tChanged asm/delay.h to linux/delay.h."
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\arcmsr\\arcmsr_hba.c",
      "line": 3062,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);",
        "\t\tkfree(ver_addr);",
        "\t\tpcmdmessagefld->cmdmessage.Length = allxfer_len;",
        "\t\tif (acb->fw_flag == FW_DEADLOCK)",
        "\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =",
        "\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;",
        "\t\telse"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\arcmsr\\arcmsr_hba.c",
      "line": 3124,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t\t}",
        "\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);",
        "\t\tkfree(ver_addr);",
        "\t\tif (acb->fw_flag == FW_DEADLOCK)",
        "\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =",
        "\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;",
        "\t\telse"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\arcmsr\\arcmsr_hba.c",
      "line": 3142,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t\tacb->rqbuf_putIndex = 0;",
        "\t\tmemset(pQbuffer, 0, ARCMSR_MAX_QBUFFER);",
        "\t\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);",
        "\t\tif (acb->fw_flag == FW_DEADLOCK)",
        "\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =",
        "\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;",
        "\t\telse"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\arcmsr\\arcmsr_hba.c",
      "line": 3159,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t\tacb->wqbuf_putIndex = 0;",
        "\t\tmemset(pQbuffer, 0, ARCMSR_MAX_QBUFFER);",
        "\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);",
        "\t\tif (acb->fw_flag == FW_DEADLOCK)",
        "\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =",
        "\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;",
        "\t\telse"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\arcmsr\\arcmsr_hba.c",
      "line": 3185,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t\tpQbuffer = acb->wqbuffer;",
        "\t\tmemset(pQbuffer, 0, sizeof(struct QBUFFER));",
        "\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);",
        "\t\tif (acb->fw_flag == FW_DEADLOCK)",
        "\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =",
        "\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;",
        "\t\telse"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\arcmsr\\arcmsr_hba.c",
      "line": 3194,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t\tbreak;",
        "\t}",
        "\tcase ARCMSR_MESSAGE_RETURN_CODE_3F: {",
        "\t\tif (acb->fw_flag == FW_DEADLOCK)",
        "\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =",
        "\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;",
        "\t\telse"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\arcmsr\\arcmsr_hba.c",
      "line": 3204,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t}",
        "\tcase ARCMSR_MESSAGE_SAY_HELLO: {",
        "\t\tint8_t *hello_string = \"Hello! I am ARCMSR\";",
        "\t\tif (acb->fw_flag == FW_DEADLOCK)",
        "\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =",
        "\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;",
        "\t\telse"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\arcmsr\\arcmsr_hba.c",
      "line": 3215,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t\tbreak;",
        "\t}",
        "\tcase ARCMSR_MESSAGE_SAY_GOODBYE: {",
        "\t\tif (acb->fw_flag == FW_DEADLOCK)",
        "\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =",
        "\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;",
        "\t\telse"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\arcmsr\\arcmsr_hba.c",
      "line": 3225,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t\tbreak;",
        "\t}",
        "\tcase ARCMSR_MESSAGE_FLUSH_ADAPTER_CACHE: {",
        "\t\tif (acb->fw_flag == FW_DEADLOCK)",
        "\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =",
        "\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;",
        "\t\telse"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\arcmsr\\arcmsr_hba.c",
      "line": 4698,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t\tssleep(ARCMSR_SLEEPTIME);",
        "\t\tif (arcmsr_reset_in_progress(acb)) {",
        "\t\t\tif (retry_count > ARCMSR_RETRYCOUNT) {",
        "\t\t\t\tacb->fw_flag = FW_DEADLOCK;",
        "\t\t\t\tpr_notice(\"arcmsr%d: waiting for hw bus reset\"",
        "\t\t\t\t\t\" return, RETRY TERMINATED!!\\n\",",
        "\t\t\t\t\tacb->host->host_no);"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\be2iscsi\\be_main.c",
      "line": 952,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "Double Free in IO SGL io_sgl_free",
      "context": [
        "\t\t * failed in xmit_task or alloc_pdu.",
        "\t\t */",
        "\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_IO,",
        "\t\t\t    \"BM_%d : Double Free in IO SGL io_sgl_free_index=%d, value there=%p\\n\",",
        "\t\t\t    phba->io_sgl_free_index,",
        "\t\t\t    phba->io_sgl_hndl_base[phba->io_sgl_free_index]);",
        "\t\tspin_unlock_irqrestore(&phba->io_sgl_lock, flags);"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\be2iscsi\\be_main.c",
      "line": 1100,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "Double Free",
      "context": [
        "\t\t * failed in xmit_task or alloc_pdu.",
        "\t\t */",
        "\t\tbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,",
        "\t\t\t    \"BM_%d : Double Free in eh SGL ,\"",
        "\t\t\t    \"eh_sgl_free_index=%d\\n\",",
        "\t\t\t    phba->eh_sgl_free_index);",
        "\t\tspin_unlock_irqrestore(&phba->mgmt_sgl_lock, flags);"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\bnx2fc\\bnx2fc_io.c",
      "line": 1194,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t/*",
        "\t * Only eh_abort processing will remove the IO from",
        "\t * active_cmd_q before processing the request. this is",
        "\t * done to avoid race conditions between IOs aborted",
        "\t * as part of task management completion and eh_abort",
        "\t * processing",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\bnx2fc\\bnx2fc_io.c",
      "line": 1271,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\tgoto done;",
        "\t} else {",
        "\t\t/*",
        "\t\t * We come here even when there was a race condition",
        "\t\t * between timeout and abts completion, and abts",
        "\t\t * completion happens just in time.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\esas2r\\esas2r_disc.c",
      "line": 169,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * now, interrupt processing may have queued up a discovery event.  go",
        "\t * see if we have one to start.  we couldn't start it in the ISR since",
        "\t * polled discovery would cause a deadlock.",
        "\t */",
        "",
        "\tesas2r_disc_start_waiting(a);"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\esas2r\\esas2r_disc.c",
      "line": 302,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Don't start discovery before or during polled discovery.  if we did,",
        "\t * we would have a deadlock if we are in the ISR already.",
        "\t */",
        "\tif (!test_bit(AF_CHPRST_PENDING, &a->flags) &&",
        "\t    !test_bit(AF_DISC_POLLED, &a->flags))"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\hisi_sas\\hisi_sas_v1_hw.c",
      "line": 330,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "\tDMA_RX_DIF_CRC_ERR, /* 0x101 */",
        "\tDMA_RX_DIF_APP_ERR, /* 0x102 */",
        "\tDMA_RX_DIF_RPP_ERR, /* 0x103 */",
        "\tDMA_RX_RESP_BUFFER_OVERFLOW_ERR, /* 0x104 */",
        "\tDMA_RX_AXI_BUS_ERR, /* 0x105 */",
        "\tDMA_RX_DATA_SGL_OVERFLOW_ERR, /* 0x106 */",
        "\tDMA_RX_DIF_SGL_OVERFLOW_ERR, /* 0x107 */"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\hisi_sas\\hisi_sas_v3_hw.c",
      "line": 5258,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tphys_init_v3_hw(hisi_hba);",
        "",
        "\t/*",
        "\t * If a directly-attached disk is removed during suspend, a deadlock",
        "\t * may occur, as the PHYE_RESUME_TIMEOUT processing will require the",
        "\t * hisi_hba->device to be active, which can only happen when resume",
        "\t * completes. So don't wait for the HA event workqueue to drain upon"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\lpfc\\lpfc_attr.c",
      "line": 6437,
      "pattern": "deprecated.*function",
      "rule": "api_usage",
      "severity": "medium",
      "match": "Deprecated function",
      "context": [
        " * @count: bytes to transfer.",
        " *",
        " * Description:",
        " * Deprecated function. All mailbox access from user space is performed via the",
        " * bsg interface.",
        " *",
        " * Returns:"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\lpfc\\lpfc_attr.c",
      "line": 6461,
      "pattern": "deprecated.*function",
      "rule": "api_usage",
      "severity": "medium",
      "match": "Deprecated function",
      "context": [
        " * @count: bytes to transfer.",
        " *",
        " * Description:",
        " * Deprecated function. All mailbox access from user space is performed via the",
        " * bsg interface.",
        " *",
        " * Returns:"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\lpfc\\lpfc_init.c",
      "line": 1739,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t}",
        "",
        "\t/*",
        "\t * This is to ptrotect against a race condition in which",
        "\t * first write to the host attention register clear the",
        "\t * host status register.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\lpfc\\lpfc_sli.c",
      "line": 9276,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\tif (pmbox != NULL)",
        "\t\tmb = &pmbox->u.mb;",
        "\t/* Check the pmbox pointer first.  There is a race condition",
        "\t * between the mbox timeout handler getting executed in the",
        "\t * worklist and the mailbox actually completing. When this",
        "\t * race condition occurs, the mbox_active will be NULL."
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\lpfc\\lpfc_sli.c",
      "line": 9279,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t/* Check the pmbox pointer first.  There is a race condition",
        "\t * between the mbox timeout handler getting executed in the",
        "\t * worklist and the mailbox actually completing. When this",
        "\t * race condition occurs, the mbox_active will be NULL.",
        "\t */",
        "\tspin_lock_irq(&phba->hbalock);",
        "\tif (pmbox == NULL) {"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\lpfc\\lpfc_sli.c",
      "line": 15768,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * the io path completion will only arm eq's when it",
        "\t * receives a completion.  But since eq's are in disa-",
        "\t * rmed state it doesn't receive a completion.  This",
        "\t * creates a deadlock scenaro.",
        "\t */",
        "\tphba->sli4_hba.sli4_write_eq_db(phba, eq, 0, LPFC_QUEUE_REARM);",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\lpfc\\lpfc_sli.c",
      "line": 8172,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t\t\t  entry->cmf_info, entry->timer_utilization,",
        "\t\t\t\t  entry->timer_interval);",
        "",
        "\t\t\t/* Check for buffer overflow */",
        "\t\t\tif ((strlen(buf) + strlen(tmp)) >= buf_len)",
        "\t\t\t\tbreak;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\mpi3mr\\mpi3mr_os.c",
      "line": 391,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * get called as part of processing the",
        "\t\t * same fwevt work (or) when worker thread is",
        "\t\t * waiting for device add/remove APIs to complete.",
        "\t\t * Otherwise we will see deadlock.",
        "\t\t */",
        "\t\tif (current_work() == &fwevt->work || fwevt->pending_at_sml) {",
        "\t\t\tfwevt->discard = 1;"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\mpt3sas\\mpt3sas_base.c",
      "line": 1587,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * @ioc: per adapter object",
        " *",
        " * Pause polling on the mq poll (io uring) queues when driver is flushing",
        " * out the IOs. Otherwise we may see the race condition of completing the same",
        " * IO from two paths.",
        " *",
        " * Returns nothing."
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\mpt3sas\\mpt3sas_base.c",
      "line": 732,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t/*",
        "\t\t * Call _scsih_flush_pending_cmds callback so that we flush all",
        "\t\t * pending commands back to OS. This call is required to avoid",
        "\t\t * deadlock at block layer. Dead IOC will fail to do diag reset,",
        "\t\t * and this call is safe since dead ioc will never return any",
        "\t\t * command back from HW.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\mpt3sas\\mpt3sas_scsih.c",
      "line": 3702,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t/*",
        "\t\t * Don't call cancel_work_sync() for current_event",
        "\t\t * other than MPT3SAS_REMOVE_UNRESPONDING_DEVICES;",
        "\t\t * otherwise we may observe deadlock if current",
        "\t\t * hard reset issued as part of processing the current_event.",
        "\t\t *",
        "\t\t * Orginal logic of cleaning the current_event is added"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\mvsas\\mv_sas.c",
      "line": 1542,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tspin_lock(&task->task_state_lock);",
        "\ttask->task_state_flags &= ~SAS_TASK_STATE_PENDING;",
        "\ttask->task_state_flags |= SAS_TASK_STATE_DONE;",
        "\t/* race condition*/",
        "\taborted = task->task_state_flags & SAS_TASK_STATE_ABORTED;",
        "\tspin_unlock(&task->task_state_lock);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\pm8001\\pm8001_hwi.c",
      "line": 2947,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\tpm8001_ha->memoryMap.region[NVMD].virt_ptr,",
        "\t\tfw_control_context->len);",
        "\tkfree(ccb->fw_control_context);",
        "\t/* To avoid race condition, complete should be",
        "\t * called after the message is copied to",
        "\t * fw_control_context->usrAddr",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\pm8001\\pm8001_sas.c",
      "line": 1121,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double free",
      "context": [
        "\t\t\t * that it's not processing requests, and we want to",
        "\t\t\t * avoid getting a completion for this and either",
        "\t\t\t * leaking the task in libsas or losing the race and",
        "\t\t\t * getting a double free.",
        "\t\t\t */",
        "\t\t\tpm8001_dbg(pm8001_ha, MSG,",
        "\t\t\t\t   \"Waiting for local phy ctl\\n\");"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\qedf\\qedf_main.c",
      "line": 2032,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "/*",
        " * During removal we need to wait for all the vports associated with a port",
        " * to be destroyed so we avoid a race condition where libfc is still trying",
        " * to reap vports while the driver remove function has already reaped the",
        " * driver contexts associated with the physical port.",
        " */"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\qla2xxx\\qla_gs.c",
      "line": 3462,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\t\t */",
        "\t\trc = qla2x00_post_next_scan_work(vha, sp, QLA_EVT_SCAN_FINISH);",
        "\t\tif (rc) {",
        "\t\t\t/* Cleanup here to prevent memory leak */",
        "\t\t\tqla24xx_sp_unmap(vha, sp);",
        "",
        "\t\t\tspin_lock_irqsave(&vha->work_lock, flags);"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\qla2xxx\\qla_tmpl.c",
      "line": 711,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\tif (offset + length > size) {",
        "\t\tlength = size - offset;",
        "\t\tql_dbg(ql_dbg_misc, vha, 0xd030,",
        "\t\t    \"%s: buffer overflow, truncate [%lx]\\n\", __func__, length);",
        "\t\tent->t275.length = cpu_to_le32(length);",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\qla4xxx\\ql4_os.c",
      "line": 4029,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing - block",
      "context": [
        "}",
        "",
        "/***",
        " * qla4xxx_mark_device_missing - blocks the session",
        " * @cls_session: Pointer to the session to be blocked",
        " * @ddb_entry: Pointer to device database entry",
        " *"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\smartpqi\\smartpqi_init.c",
      "line": 3210,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "\tcase PQI_DATA_IN_OUT_TIMEOUT:",
        "\t\thost_byte = DID_TIME_OUT;",
        "\t\tbreak;",
        "\tcase PQI_DATA_IN_OUT_BUFFER_OVERFLOW:",
        "\tcase PQI_DATA_IN_OUT_PROTOCOL_ERROR:",
        "\tcase PQI_DATA_IN_OUT_BUFFER_ERROR:",
        "\tcase PQI_DATA_IN_OUT_BUFFER_OVERFLOW_DESCRIPTOR_AREA:"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\smartpqi\\smartpqi_init.c",
      "line": 3213,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "\tcase PQI_DATA_IN_OUT_BUFFER_OVERFLOW:",
        "\tcase PQI_DATA_IN_OUT_PROTOCOL_ERROR:",
        "\tcase PQI_DATA_IN_OUT_BUFFER_ERROR:",
        "\tcase PQI_DATA_IN_OUT_BUFFER_OVERFLOW_DESCRIPTOR_AREA:",
        "\tcase PQI_DATA_IN_OUT_BUFFER_OVERFLOW_BRIDGE:",
        "\tcase PQI_DATA_IN_OUT_ERROR:",
        "\tcase PQI_DATA_IN_OUT_HARDWARE_ERROR:"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\smartpqi\\smartpqi_init.c",
      "line": 3214,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "\tcase PQI_DATA_IN_OUT_PROTOCOL_ERROR:",
        "\tcase PQI_DATA_IN_OUT_BUFFER_ERROR:",
        "\tcase PQI_DATA_IN_OUT_BUFFER_OVERFLOW_DESCRIPTOR_AREA:",
        "\tcase PQI_DATA_IN_OUT_BUFFER_OVERFLOW_BRIDGE:",
        "\tcase PQI_DATA_IN_OUT_ERROR:",
        "\tcase PQI_DATA_IN_OUT_HARDWARE_ERROR:",
        "\tcase PQI_DATA_IN_OUT_PCIE_FABRIC_ERROR:"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\smartpqi\\smartpqi_init.c",
      "line": 6688,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "\tcase PQI_DATA_IN_OUT_UNDERFLOW:",
        "\t\tciss_cmd_status = CISS_CMD_STATUS_DATA_UNDERRUN;",
        "\t\tbreak;",
        "\tcase PQI_DATA_IN_OUT_BUFFER_OVERFLOW:",
        "\t\tciss_cmd_status = CISS_CMD_STATUS_DATA_OVERRUN;",
        "\t\tbreak;",
        "\tcase PQI_DATA_IN_OUT_PROTOCOL_ERROR:"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\smartpqi\\smartpqi_init.c",
      "line": 6693,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "\t\tbreak;",
        "\tcase PQI_DATA_IN_OUT_PROTOCOL_ERROR:",
        "\tcase PQI_DATA_IN_OUT_BUFFER_ERROR:",
        "\tcase PQI_DATA_IN_OUT_BUFFER_OVERFLOW_DESCRIPTOR_AREA:",
        "\tcase PQI_DATA_IN_OUT_BUFFER_OVERFLOW_BRIDGE:",
        "\tcase PQI_DATA_IN_OUT_ERROR:",
        "\t\tciss_cmd_status = CISS_CMD_STATUS_PROTOCOL_ERROR;"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\smartpqi\\smartpqi_init.c",
      "line": 6694,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "\tcase PQI_DATA_IN_OUT_PROTOCOL_ERROR:",
        "\tcase PQI_DATA_IN_OUT_BUFFER_ERROR:",
        "\tcase PQI_DATA_IN_OUT_BUFFER_OVERFLOW_DESCRIPTOR_AREA:",
        "\tcase PQI_DATA_IN_OUT_BUFFER_OVERFLOW_BRIDGE:",
        "\tcase PQI_DATA_IN_OUT_ERROR:",
        "\t\tciss_cmd_status = CISS_CMD_STATUS_PROTOCOL_ERROR;",
        "\t\tbreak;"
      ]
    },
    {
      "file": "linux\\drivers\\scsi\\sym53c8xx_2\\sym_hipd.c",
      "line": 2856,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tistatc = INB(np, nc_istat);",
        "\t\tistat |= istatc;",
        "",
        "\t\t/* Prevent deadlock waiting on a condition that may",
        "\t\t * never clear. */",
        "\t\tif (unlikely(sist == 0xffff && dstat == 0xff)) {",
        "\t\t\tif (pci_channel_offline(pdev))"
      ]
    },
    {
      "file": "linux\\drivers\\soc\\hisilicon\\kunpeng_hccs.c",
      "line": 546,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\thead = &rsp->rsp_head;",
        "\tif (head->data_len > buf_len) {",
        "\t\tdev_err(hdev->dev,",
        "\t\t\t\"buffer overflow (buf_len = %zu, data_len = %u)!\\n\",",
        "\t\t\tbuf_len, head->data_len);",
        "\t\treturn -ENOMEM;",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\soc\\ixp4xx\\ixp4xx-npe.c",
      "line": 183,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t__raw_writel(cmd, &npe->regs->exec_status_cmd);",
        "\t/* Iintroduce extra read cycles after issuing read command to NPE",
        "\t   so that we read the register after the NPE has updated it.",
        "\t   This is to overcome race condition between XScale and NPE */",
        "\t__raw_readl(&npe->regs->exec_data);",
        "\t__raw_readl(&npe->regs->exec_data);",
        "\treturn __raw_readl(&npe->regs->exec_data);"
      ]
    },
    {
      "file": "linux\\drivers\\soc\\ti\\pruss.c",
      "line": 391,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing its 'clock",
      "context": [
        "",
        "\tif (!clks_np)",
        "\t\treturn dev_err_probe(dev, -ENODEV,",
        "\t\t\t\t     \"%pOF is missing its 'clocks' node\\n\",",
        "\t\t\t\t     cfg_node);",
        "",
        "\tif (data && data->has_core_mux_clock) {"
      ]
    },
    {
      "file": "linux\\drivers\\soc\\fsl\\qbman\\qman.c",
      "line": 2049,
      "pattern": "code.*duplication",
      "rule": "code_quality",
      "severity": "low",
      "match": "code duplication",
      "context": [
        "\t * \"Friendly\" is to process OK immediately, and not set CHANGING. We do",
        "\t * friendly, otherwise the caller doesn't necessarily have a fully",
        "\t * \"retired\" FQ on return even if the retirement was immediate. However",
        "\t * this does mean some code duplication between here and",
        "\t * fq_state_change().",
        "\t */",
        "\tif (res == QM_MCR_RESULT_OK) {"
      ]
    },
    {
      "file": "linux\\drivers\\soc\\fsl\\qe\\tsa.c",
      "line": 781,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double-speed-clock",
      "context": [
        "\t\t    of_property_read_bool(tdm_np, \"fsl,fsync-active-low\"))",
        "\t\t\ttdm->simode_tdm |= TSA_QE_SIMODE_TDM_SL;",
        "",
        "\t\tif (of_property_read_bool(tdm_np, \"fsl,double-speed-clock\"))",
        "\t\t\ttdm->simode_tdm |= TSA_SIMODE_TDM_DSC;",
        "",
        "\t\tclk = of_clk_get_by_name(tdm_np, tsa_is_qe(tsa) ? \"rsync\" : \"l1rsync\");"
      ]
    },
    {
      "file": "linux\\drivers\\staging\\nvec\\nvec.c",
      "line": 696,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t\tnvec->rx->data[nvec->rx->pos++] = received;",
        "\t\telse",
        "\t\t\tdev_err(nvec->dev,",
        "\t\t\t\t\"RX buffer overflow on %p: Trying to write byte %u of %u\\n\",",
        "\t\t\t\tnvec->rx, nvec->rx ? nvec->rx->pos : 0,",
        "\t\t\t\tNVEC_MSG_SIZE);",
        "\t\tbreak;"
      ]
    },
    {
      "file": "linux\\drivers\\staging\\media\\atomisp\\pci\\atomisp_csi2_bridge.c",
      "line": 615,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory is leak",
      "context": [
        "\t/*",
        "\t * This function is intended to run only once and then leave",
        "\t * the created nodes attached even after a rmmod, therefore:",
        "\t * 1. The bridge memory is leaked deliberately on success",
        "\t * 2. If a secondary fwnode is already set exit early.",
        "\t */",
        "\tfwnode = dev_fwnode(dev);"
      ]
    },
    {
      "file": "linux\\drivers\\staging\\media\\atomisp\\pci\\sh_css_sp.c",
      "line": 1637,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race-condition",
      "context": [
        "\t * Note 2: Not all SP binaries supports host2sp_commands.",
        "\t * In case a binary does support it, the host2sp_command",
        "\t * will have status cmd_ready after return of the function",
        "\t * sh_css_hrt_sp_start_isp. There is no race-condition here",
        "\t * because only after the process_frame command has been",
        "\t * received, the SP starts configuring the input network.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\staging\\media\\atomisp\\pci\\runtime\\event\\src\\event.c",
      "line": 78,
      "pattern": "code.*duplication",
      "rule": "code_quality",
      "severity": "low",
      "match": "code duplication",
      "context": [
        "\t * In case of a PORT_EOF event we overwrite with",
        "\t * the specific values",
        "\t * This is somewhat ugly but probably somewhat efficient",
        "\t * (and it avoids some code duplication)",
        "\t */",
        "\tpayload[0] = event & 0xff;  /*event_code */",
        "\tpayload[1] = (event >> 8) & 0xff;"
      ]
    },
    {
      "file": "linux\\drivers\\staging\\media\\atomisp\\pci\\runtime\\frame\\src\\frame.c",
      "line": 467,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\t   Images won't be impacted by this round up,",
        "\t   only needed by jpeg/embedded data.",
        "\t   As long as buffer allocation and release are using data_bytes,",
        "\t   there won't be memory leak. */",
        "\tframe->data_bytes = stride * CEIL_MUL2(height, 2);",
        "\tframe_init_plane(plane, subpixels_per_line, stride, height, 0);",
        "\treturn;"
      ]
    },
    {
      "file": "linux\\drivers\\staging\\most\\dim2\\dim2.c",
      "line": 771,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing dt property clock",
      "context": [
        "\tret = of_property_read_string(pdev->dev.of_node,",
        "\t\t\t\t      \"microchip,clock-speed\", &clock_speed);",
        "\tif (ret) {",
        "\t\tdev_err(&pdev->dev, \"missing dt property clock-speed\\n\");",
        "\t\tgoto err_free_dev;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\staging\\rtl8723bs\\core\\rtw_cmd.c",
      "line": 1653,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "}",
        "",
        "/* dont call R/W in this function, beucase SDIO interrupt have claim host */",
        "/* or deadlock will happen and cause special-systemserver-died in android */",
        "u8 rtw_c2h_wk_cmd(struct adapter *padapter, u8 *c2h_evt)",
        "{",
        "\tstruct cmd_obj *ph2c;"
      ]
    },
    {
      "file": "linux\\drivers\\staging\\rtl8723bs\\hal\\rtl8723b_cmd.c",
      "line": 71,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tif (padapter->bSurpriseRemoved)",
        "\t\tgoto exit;",
        "",
        "\t/* pay attention to if  race condition happened in  H2C cmd setting. */",
        "\tdo {",
        "\t\th2c_box_num = pHalData->LastHMEBoxNum;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\thermal\\intel\\x86_pkg_temp_thermal.c",
      "line": 437,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tif (zonedev->work_scheduled && was_target) {",
        "\t\t/*",
        "\t\t * To cancel the work we need to drop the lock, otherwise",
        "\t\t * we might deadlock if the work needs to be flushed.",
        "\t\t */",
        "\t\traw_spin_unlock_irq(&pkg_temp_lock);",
        "\t\tcancel_delayed_work_sync(&zonedev->work);"
      ]
    },
    {
      "file": "linux\\drivers\\tty\\hvc\\hvcs.c",
      "line": 78,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "races around single statements following condition",
      "context": [
        "",
        "/*",
        " * 1.3.0 -> 1.3.1 In hvcs_open memset(..,0x00,..) instead of memset(..,0x3F,00).",
        " * Removed braces around single statements following conditionals.  Removed '=",
        " * 0' after static int declarations since these default to zero.  Removed",
        " * list_for_each_safe() and replaced with list_for_each_entry() in",
        " * hvcs_get_by_index().  The 'safe' version is un-needed now that the driver is"
      ]
    },
    {
      "file": "linux\\drivers\\tty\\hvc\\hvcs.c",
      "line": 896,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "/*",
        " * This function is executed by the driver \"rescan\" sysfs entry.  It shouldn't",
        " * be executed elsewhere, in order to prevent deadlock issues.",
        " */",
        "static int hvcs_rescan_devices_list(void)",
        "{"
      ]
    },
    {
      "file": "linux\\drivers\\tty\\hvc\\hvcs.c",
      "line": 1035,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * Please remember to dec when you are done with the instance.",
        " *",
        " * NOTICE: Do NOT hold either the hvcs_struct.lock or hvcs_structs_lock when",
        " * calling this function or you will get deadlock.",
        " */",
        "static struct hvcs_struct *hvcs_get_by_index(int index)",
        "{"
      ]
    },
    {
      "file": "linux\\drivers\\tty\\hvc\\hvcs.c",
      "line": 1344,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\thvcsd->chars_in_buffer = 0;",
        "\t\t/*",
        "\t\t * Test after the chars_in_buffer reset otherwise this could",
        "\t\t * deadlock our writes if hvc_put_chars fails.",
        "\t\t */",
        "\t\tif (result < 0)",
        "\t\t\tbreak;"
      ]
    },
    {
      "file": "linux\\drivers\\tty\\serial\\atmel_serial.c",
      "line": 745,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "Buffer overflow",
      "context": [
        "\tstruct atmel_uart_char *c;",
        "",
        "\tif (!CIRC_SPACE(ring->head, ring->tail, ATMEL_SERIAL_RINGSIZE))",
        "\t\t/* Buffer overflow, ignore char */",
        "\t\treturn;",
        "",
        "\tc = &((struct atmel_uart_char *)ring->buf)[ring->head];"
      ]
    },
    {
      "file": "linux\\drivers\\tty\\serial\\fsl_lpuart.c",
      "line": 2077,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * baud rate and restart Rx DMA path.",
        "\t *",
        "\t * Since timer function acqures port->lock, need to stop before",
        "\t * acquring same lock because otherwise timer_delete_sync() can deadlock.",
        "\t */",
        "\tif (old && sport->lpuart_dma_rx_use)",
        "\t\tlpuart_dma_rx_free(port);"
      ]
    },
    {
      "file": "linux\\drivers\\tty\\serial\\fsl_lpuart.c",
      "line": 2322,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * baud rate and restart Rx DMA path.",
        "\t *",
        "\t * Since timer function acqures port->lock, need to stop before",
        "\t * acquring same lock because otherwise timer_delete_sync() can deadlock.",
        "\t */",
        "\tif (old && sport->lpuart_dma_rx_use)",
        "\t\tlpuart_dma_rx_free(port);"
      ]
    },
    {
      "file": "linux\\drivers\\tty\\serial\\max3100.c",
      "line": 109,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tstruct work_struct work;",
        "\t/* set to 1 to make the workhandler exit as soon as possible */",
        "\tint  force_end_work;",
        "\t/* need to know we are suspending to avoid deadlock on workqueue */",
        "\tint suspending;",
        "",
        "\tstruct timer_list\ttimer;"
      ]
    },
    {
      "file": "linux\\drivers\\tty\\serial\\milbeaut_usio.c",
      "line": 506,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Missing clock",
      "context": [
        "\tint ret;",
        "",
        "\tif (IS_ERR(clk)) {",
        "\t\tdev_err(&pdev->dev, \"Missing clock\\n\");",
        "\t\treturn PTR_ERR(clk);",
        "\t}",
        "\tret = clk_prepare_enable(clk);"
      ]
    },
    {
      "file": "linux\\drivers\\tty\\serial\\mpc52xx_uart.c",
      "line": 8,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * FIXME According to the usermanual the status bits in the status register",
        " * are only updated when the peripherals access the FIFO and not when the",
        " * CPU access them. So since we use this bits to know when we stop writing",
        " * and reading, they may not be updated in-time and a race condition may",
        " * exists. But I haven't be able to prove this and I don't care. But if",
        " * any problem arises, it might worth checking. The TX/RX FIFO Stats",
        " * registers should be used in addition."
      ]
    },
    {
      "file": "linux\\drivers\\tty\\serial\\pic32_uart.c",
      "line": 190,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tsport->enable_tx_irq = true;",
        "\t} else if (!en && sport->enable_tx_irq) {",
        "\t\t/* use disable_irq_nosync() and not disable_irq() to avoid self",
        "\t\t * imposed deadlock by not waiting for irq handler to end,",
        "\t\t * since this callback is called from interrupt context.",
        "\t\t */",
        "\t\tdisable_irq_nosync(sport->irq_tx);"
      ]
    },
    {
      "file": "linux\\drivers\\tty\\serial\\serial_core.c",
      "line": 1076,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t/*",
        "\t * If we're about to load something into the transmit",
        "\t * register, we'll pretend the transmitter isn't empty to",
        "\t * avoid a race condition (depending on when the transmit",
        "\t * interrupt happens).",
        "\t */",
        "\tif (uport->x_char ||"
      ]
    },
    {
      "file": "linux\\drivers\\tty\\serial\\stm32-usart.c",
      "line": 985,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer is about to overflow",
      "context": [
        "\t\tstm32_usart_tx_dma_terminate(stm32_port);",
        "}",
        "",
        "/* Throttle the remote when input buffer is about to overflow. */",
        "static void stm32_usart_throttle(struct uart_port *port)",
        "{",
        "\tstruct stm32_port *stm32_port = to_stm32_port(port);"
      ]
    },
    {
      "file": "linux\\drivers\\tty\\serial\\ucc_uart.c",
      "line": 1295,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing rx-clock",
      "context": [
        "",
        "\tsprop = of_get_property(np, \"rx-clock-name\", NULL);",
        "\tif (!sprop) {",
        "\t\tdev_err(&ofdev->dev, \"missing rx-clock-name in device tree\\n\");",
        "\t\tret = -ENODEV;",
        "\t\tgoto out_free;",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\tty\\serial\\ucc_uart.c",
      "line": 1314,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing tx-clock",
      "context": [
        "#else",
        "\tsprop = of_get_property(np, \"tx-clock-name\", NULL);",
        "\tif (!sprop) {",
        "\t\tdev_err(&ofdev->dev, \"missing tx-clock-name in device tree\\n\");",
        "\t\tret = -ENODEV;",
        "\t\tgoto out_free;",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\tty\\vt\\consolemap.c",
      "line": 23,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "stack overflow",
      "context": [
        " *",
        " * As all the affected functions are all called directly from vt_ioctl(), we",
        " * can allocate some small buffers directly on stack without worrying about",
        " * stack overflow.",
        " */",
        "",
        "#include <linux/bitfield.h>"
      ]
    },
    {
      "file": "linux\\drivers\\tty\\vt\\vt_ioctl.c",
      "line": 8,
      "pattern": "code.*duplication",
      "rule": "code_quality",
      "severity": "low",
      "match": "code moved for less code duplication",
      "context": [
        " *  Dynamic diacritical handling - aeb@cwi.nl - Dec 1993",
        " *  Dynamic keymap and string allocation - aeb@cwi.nl - May 1994",
        " *  Restrict VT switching via ioctl() - grif@cs.ucr.edu - Dec 1995",
        " *  Some code moved for less code duplication - Andi Kleen - Mar 1997",
        " *  Check put/get_user, cleanups - acme@conectiva.com.br - Jun 2001",
        " */",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\tty\\serial\\8250\\8250_dw.c",
      "line": 179,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\twriteb(value, addr);",
        "\t}",
        "\t/*",
        "\t * FIXME: this deadlocks if port->lock is already held",
        "\t * dev_err(p->dev, \"Couldn't set LCR to %d\\n\", value);",
        "\t */",
        "}"
      ]
    },
    {
      "file": "linux\\drivers\\tty\\serial\\8250\\8250_dw.c",
      "line": 353,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * We have no choice but to defer the uartclk update due to two",
        "\t * deadlocks. First one is caused by a recursive mutex lock which",
        "\t * happens when clk_set_rate() is called from dw8250_set_termios().",
        "\t * Second deadlock is more tricky and is caused by an inverted order of",
        "\t * the clk and tty-port mutexes lock. It happens if clock rate change"
      ]
    },
    {
      "file": "linux\\drivers\\tty\\serial\\8250\\8250_dw.c",
      "line": 355,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * We have no choice but to defer the uartclk update due to two",
        "\t * deadlocks. First one is caused by a recursive mutex lock which",
        "\t * happens when clk_set_rate() is called from dw8250_set_termios().",
        "\t * Second deadlock is more tricky and is caused by an inverted order of",
        "\t * the clk and tty-port mutexes lock. It happens if clock rate change",
        "\t * is requested asynchronously while set_termios() is executed between",
        "\t * tty-port mutex lock and clk_set_rate() function invocation and"
      ]
    },
    {
      "file": "linux\\drivers\\tty\\serial\\8250\\8250_port.c",
      "line": 1593,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * em485->active_timer != &em485->stop_tx_timer, it might happen that",
        "\t * the timer is still armed and triggers only after the current bunch of",
        "\t * chars is send and em485->active_timer == &em485->stop_tx_timer again.",
        "\t * So cancel the timer. There is still a theoretical race condition if",
        "\t * the timer is already running and only comes around to check for",
        "\t * em485->active_timer when &em485->stop_tx_timer is armed again.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\tty\\serial\\8250\\8250_port.c",
      "line": 2710,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "}",
        "",
        "/*",
        " * Note in order to avoid the tty port mutex deadlock don't use the next method",
        " * within the uart port callbacks. Primarily it's supposed to be utilized to",
        " * handle a sudden reference clock rate change.",
        " */"
      ]
    },
    {
      "file": "linux\\drivers\\ufs\\core\\ufshcd.c",
      "line": 7910,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * If runtime PM sent SSU and got a timeout, scsi_error_handler is",
        "\t * stuck in this function waiting for flush_work(&hba->eh_work). And",
        "\t * ufshcd_err_handler(eh_work) is stuck waiting for runtime PM. Do",
        "\t * ufshcd_link_recovery instead of eh_work to prevent deadlock.",
        "\t */",
        "\tif (hba->pm_op_in_progress) {",
        "\t\tif (ufshcd_link_recovery(hba))"
      ]
    },
    {
      "file": "linux\\drivers\\ufs\\core\\ufshcd.c",
      "line": 9060,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * If we get here we know that no TMFs are outstanding and also that",
        "\t * the only pending command is a START STOP UNIT command. Handle the",
        "\t * timeout of that command directly to prevent a deadlock between",
        "\t * ufshcd_set_dev_pwr_mode() and ufshcd_err_handler().",
        "\t */",
        "\tufshcd_link_recovery(hba);"
      ]
    },
    {
      "file": "linux\\drivers\\ufs\\host\\ufs-mediatek.c",
      "line": 82,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "\t\"AFCx_REQUEST_TIMER_EXPIRED\",",
        "\t\"FCx_PROTECTION_TIMER_EXPIRED\",",
        "\t\"CRC_ERROR\",",
        "\t\"RX_BUFFER_OVERFLOW\",",
        "\t\"MAX_FRAME_LENGTH_EXCEEDED\",",
        "\t\"WRONG_SEQUENCE_NUMBER\",",
        "\t\"AFC_FRAME_SYNTAX_ERROR\","
      ]
    },
    {
      "file": "linux\\drivers\\ufs\\host\\ufshcd-pltfrm.c",
      "line": 282,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Missing clock",
      "context": [
        "",
        "\tcnt = of_property_count_strings(np, \"clock-names\");",
        "\tif (cnt <= 0) {",
        "\t\tdev_err(dev, \"%s: Missing clock-names\\n\",  __func__);",
        "\t\treturn -ENODEV;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\usb\\atm\\usbatm.c",
      "line": 34,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        " *\t\tto alloc and free it",
        " *\t\t- remove_wait_queue() added to usbatm_atm_processqueue_thread()",
        " *",
        " *  1.5:\t- fixed memory leak when atmsar_decode_aal5 returned NULL.",
        " *\t\t(reported by stephen.robinson@zen.co.uk)",
        " *",
        " *  1.4:\t- changed the spin_lock() under interrupt to spin_lock_irqsave()"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\atm\\usbatm.c",
      "line": 43,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        " *  1.3.1:\t- added the version number",
        " *",
        " *  1.3:\t- Added multiple send urb support",
        " *\t\t- fixed memory leak and vcc->tx_inuse starvation bug",
        " *\t\t  when not enough memory left in vcc.",
        " *",
        " *  1.2:\t- Fixed race condition in usbatm_usb_send_data()"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\atm\\usbatm.c",
      "line": 46,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " *\t\t- fixed memory leak and vcc->tx_inuse starvation bug",
        " *\t\t  when not enough memory left in vcc.",
        " *",
        " *  1.2:\t- Fixed race condition in usbatm_usb_send_data()",
        " *  1.1:\t- Turned off packet debugging",
        " *",
        " */"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\class\\cdc-acm.c",
      "line": 687,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing ctrlout lock",
      "context": [
        "\telse",
        "\t\tval = 0;",
        "",
        "\t/* FIXME: add missing ctrlout locking throughout driver */",
        "\tacm->ctrlout = val;",
        "",
        "\tres = acm_set_control(acm, val);"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\class\\cdc-wdm.c",
      "line": 222,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer would overflow",
      "context": [
        "\t}",
        "",
        "\tif (length + desc->length > desc->wMaxCommand) {",
        "\t\t/* The buffer would overflow */",
        "\t\tset_bit(WDM_OVERFLOW, &desc->flags);",
        "\t} else {",
        "\t\t/* we may already be in overflow */"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\core\\devio.c",
      "line": 1559,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/* Don't touch the device if any interfaces are claimed.",
        "\t * It could interfere with other drivers' operations, and if",
        "\t * an interface is claimed by usbfs it could easily deadlock.",
        "\t */",
        "\tif (actconfig) {",
        "\t\tint i;"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\core\\hcd.c",
      "line": 2079,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "Double-free",
      "context": [
        "\tif (dev->speed < USB_SPEED_SUPER)",
        "\t\treturn -EINVAL;",
        "",
        "\t/* Double-free is not allowed */",
        "\tfor (i = 0; i < num_eps; i++)",
        "\t\tif (!eps[i] || !eps[i]->streams)",
        "\t\t\treturn -EINVAL;"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\core\\hub.c",
      "line": 6342,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Don't allocate memory with GFP_KERNEL in current",
        "\t * context to avoid possible deadlock if usb mass",
        "\t * storage interface or usbnet interface(iSCSI case)",
        "\t * is included in current configuration. The easist",
        "\t * approach is to do it for every device reset,"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\core\\message.c",
      "line": 1401,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t */",
        "\tif (dev->actconfig) {",
        "\t\t/*",
        "\t\t * FIXME: In order to avoid self-deadlock involving the",
        "\t\t * bandwidth_mutex, we have to mark all the interfaces",
        "\t\t * before unregistering any of them.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\core\\port.c",
      "line": 71,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tgoto out_hub_get;",
        "",
        "\t/*",
        "\t * Prevent deadlock if another process is concurrently",
        "\t * trying to unregister hdev.",
        "\t */",
        "\tkn = sysfs_break_active_protection(&dev->kobj, &attr->attr);"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\core\\port.c",
      "line": 126,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tgoto out_hub_get;",
        "",
        "\t/*",
        "\t * Prevent deadlock if another process is concurrently",
        "\t * trying to unregister hdev.",
        "\t */",
        "\tkn = sysfs_break_active_protection(&dev->kobj, &attr->attr);"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\core\\sysfs.c",
      "line": 1230,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tusb_authorize_interface(intf);",
        "\t} else {",
        "\t\t/*",
        "\t\t * Prevent deadlock if another process is concurrently",
        "\t\t * trying to unregister intf.",
        "\t\t */",
        "\t\tkn = sysfs_break_active_protection(&dev->kobj, &attr->attr);"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\core\\usb.c",
      "line": 885,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * Attempts to acquire the device lock, but fails if the device is",
        " * NOTATTACHED or SUSPENDED, or if iface is specified and the interface",
        " * is neither BINDING nor BOUND.  Rather than sleeping to wait for the",
        " * lock, the routine polls repeatedly.  This is to prevent deadlock with",
        " * disconnect; in some drivers (such as usb-storage) the disconnect()",
        " * or suspend() method will block waiting for a device reset to complete.",
        " *"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\core\\usb.c",
      "line": 907,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\twhile (!usb_trylock_device(udev)) {",
        "",
        "\t\t/* If we can't acquire the lock after waiting one second,",
        "\t\t * we're probably deadlocked */",
        "\t\tif (time_after(jiffies, jiffies_expire))",
        "\t\t\treturn -EBUSY;",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\usb\\dwc2\\core.c",
      "line": 269,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\t/*",
        "\t * Wait For Restore_done Interrupt. This mechanism of polling the",
        "\t * interrupt is introduced to avoid any possible race conditions",
        "\t */",
        "\tif (dwc2_hsotg_wait_bit_set(hsotg, GINTSTS, GINTSTS_RESTOREDONE,",
        "\t\t\t\t    20000)) {"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\dwc2\\hcd_ddma.c",
      "line": 396,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "/*",
        " * Determine starting frame for Isochronous transfer.",
        " * Few frames skipped to prevent race condition with HC.",
        " */",
        "static u16 dwc2_calc_starting_frame(struct dwc2_hsotg *hsotg,",
        "\t\t\t\t    struct dwc2_qh *qh, u16 *skip_frames)"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\fotg210\\fotg210-hcd.c",
      "line": 48,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "#undef FOTG210_URB_TRACE",
        "#define FOTG210_STATS",
        "",
        "/* magic numbers that can affect system performance */",
        "#define FOTG210_TUNE_CERR\t3 /* 0-3 qtd retries; 0 == don't stop */",
        "#define FOTG210_TUNE_RL_HS\t4 /* nak throttle; see 4.9 */",
        "#define FOTG210_TUNE_RL_TT\t0"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\gadget\\composite.c",
      "line": 95,
      "pattern": "null.*pointer.*dereference",
      "rule": "memory_management",
      "severity": "high",
      "match": "NULL pointer dereference",
      "context": [
        "",
        "\t/*",
        "\t * if we can't find any descriptors at all, then this gadget deserves to",
        "\t * Oops with a NULL pointer dereference",
        "\t */",
        "",
        "\treturn descriptors;"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\host\\ehci-hcd.c",
      "line": 65,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "",
        "#undef EHCI_URB_TRACE",
        "",
        "/* magic numbers that can affect system performance */",
        "#define\tEHCI_TUNE_CERR\t\t3\t/* 0-3 qtd retries; 0 == don't stop */",
        "#define\tEHCI_TUNE_RL_HS\t\t4\t/* nak throttle; see 4.9 */",
        "#define\tEHCI_TUNE_RL_TT\t\t0"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\host\\oxu210hp-hcd.c",
      "line": 82,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "Magic numbers",
      "context": [
        " * Proper EHCI structs & defines",
        " */",
        "",
        "/* Magic numbers that can affect system performance */",
        "#define EHCI_TUNE_CERR\t\t3\t/* 0-3 qtd retries; 0 == don't stop */",
        "#define EHCI_TUNE_RL_HS\t\t4\t/* nak throttle; see 4.9 */",
        "#define EHCI_TUNE_RL_TT\t\t0"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\image\\mdc800.c",
      "line": 32,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * version 0.7.5",
        " * Fixed potential SMP races with Spinlocks.",
        " * Thanks to Oliver Neukum <oliver@neukum.name> who ",
        " * noticed the race conditions.",
        " * (30/10/2000)",
        " *",
        " * Fixed: Setting urb->dev before submitting urb."
      ]
    },
    {
      "file": "linux\\drivers\\usb\\image\\microtek.c",
      "line": 87,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *\t20000516 Removed unnecessary up on instance lock in mts_remove_nolock (john)",
        " *\t20000516 Implemented (badly) scsi_abort (john)",
        " *\t20000516 Version 0.0.12j",
        " *      20000517 Hopefully removed mts_remove_nolock quasideadlock (john)",
        " *      20000517 Added mts_debug_dump to print ll USB info (john)",
        " *\t20000518 Tweaks and documentation updates (john)",
        " *\t20000518 Version 0.0.13j"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\image\\microtek.c",
      "line": 102,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *\t20000603 Version 0.2.1",
        " *\t20000620 minor cosmetic changes",
        " *\t20000620 Version 0.2.2",
        " *\t20000822 Hopefully fixed deadlock in mts_remove_nolock()",
        " *\t20000822 Fixed minor race in mts_transfer_cleanup()",
        " *\t20000822 Fixed deadlock on submission error in queuecommand",
        " *\t20000822 Version 0.2.3"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\image\\microtek.c",
      "line": 104,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *\t20000620 Version 0.2.2",
        " *\t20000822 Hopefully fixed deadlock in mts_remove_nolock()",
        " *\t20000822 Fixed minor race in mts_transfer_cleanup()",
        " *\t20000822 Fixed deadlock on submission error in queuecommand",
        " *\t20000822 Version 0.2.3",
        " *\t20000913 Reduced module size if debugging is off",
        " *\t20000913 Version 0.2.4"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\isp1760\\isp1760-hcd.c",
      "line": 809,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "\treturn (qtd->urb != urb);",
        "}",
        "",
        "/* magic numbers that can affect system performance */",
        "#define\tEHCI_TUNE_CERR\t\t3\t/* 0-3 qtd retries; 0 == don't stop */",
        "#define\tEHCI_TUNE_RL_HS\t\t4\t/* nak throttle; see 4.9 */",
        "#define\tEHCI_TUNE_RL_TT\t\t0"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\misc\\adutux.c",
      "line": 189,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t\tdev_dbg(&dev->udev->dev, \"%s reading  %d\\n\", __func__,",
        "\t\t\t\turb->actual_length);",
        "\t\t} else {",
        "\t\t\tdev_dbg(&dev->udev->dev, \"%s : read_buffer overflow\\n\",",
        "\t\t\t\t__func__);",
        "\t\t}",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\misc\\ldusb.c",
      "line": 173,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer_overflow",
      "context": [
        "\tsize_t\t\t\tinterrupt_in_endpoint_size;",
        "\tint\t\t\tinterrupt_in_running;",
        "\tint\t\t\tinterrupt_in_done;",
        "\tint\t\t\tbuffer_overflow;",
        "\tspinlock_t\t\trbsl;",
        "",
        "\tchar\t\t\t*interrupt_out_buffer;"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\misc\\ldusb.c",
      "line": 254,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t\t\t__func__, urb->actual_length);",
        "\t\t} else {",
        "\t\t\tdev_warn(&dev->intf->dev,",
        "\t\t\t\t \"Ring buffer overflow, %d bytes dropped\\n\",",
        "\t\t\t\t urb->actual_length);",
        "\t\t\tdev->buffer_overflow = 1;",
        "\t\t}"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\misc\\ldusb.c",
      "line": 256,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer_overflow",
      "context": [
        "\t\t\tdev_warn(&dev->intf->dev,",
        "\t\t\t\t \"Ring buffer overflow, %d bytes dropped\\n\",",
        "\t\t\t\t urb->actual_length);",
        "\t\t\tdev->buffer_overflow = 1;",
        "\t\t}",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\usb\\misc\\ldusb.c",
      "line": 262,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer_overflow",
      "context": [
        "",
        "resubmit:",
        "\t/* resubmit if we're still running */",
        "\tif (dev->interrupt_in_running && !dev->buffer_overflow) {",
        "\t\tretval = usb_submit_urb(dev->interrupt_in_urb, GFP_ATOMIC);",
        "\t\tif (retval) {",
        "\t\t\tdev_err(&dev->intf->dev,"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\misc\\ldusb.c",
      "line": 267,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer_overflow",
      "context": [
        "\t\tif (retval) {",
        "\t\t\tdev_err(&dev->intf->dev,",
        "\t\t\t\t\"usb_submit_urb failed (%d)\\n\", retval);",
        "\t\t\tdev->buffer_overflow = 1;",
        "\t\t}",
        "\t}",
        "\tspin_unlock_irqrestore(&dev->rbsl, flags);"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\misc\\ldusb.c",
      "line": 336,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer_overflow",
      "context": [
        "\t/* initialize in direction */",
        "\tdev->ring_head = 0;",
        "\tdev->ring_tail = 0;",
        "\tdev->buffer_overflow = 0;",
        "\tusb_fill_int_urb(dev->interrupt_in_urb,",
        "\t\t\t interface_to_usbdev(interface),",
        "\t\t\t usb_rcvintpipe(interface_to_usbdev(interface),"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\misc\\ldusb.c",
      "line": 489,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t}",
        "\tbytes_to_read = min(count, *actual_buffer);",
        "\tif (bytes_to_read < *actual_buffer)",
        "\t\tdev_warn(&dev->intf->dev, \"Read buffer overflow, %zu bytes dropped\\n\",",
        "\t\t\t *actual_buffer-bytes_to_read);",
        "",
        "\t/* copy one interrupt_in_buffer from ring_buffer into userspace */"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\misc\\ldusb.c",
      "line": 502,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer_overflow",
      "context": [
        "\tspin_lock_irq(&dev->rbsl);",
        "\tdev->ring_tail = (dev->ring_tail + 1) % ring_buffer_size;",
        "",
        "\tif (dev->buffer_overflow) {",
        "\t\tdev->buffer_overflow = 0;",
        "\t\tspin_unlock_irq(&dev->rbsl);",
        "\t\trv = usb_submit_urb(dev->interrupt_in_urb, GFP_KERNEL);"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\misc\\ldusb.c",
      "line": 503,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer_overflow",
      "context": [
        "\tdev->ring_tail = (dev->ring_tail + 1) % ring_buffer_size;",
        "",
        "\tif (dev->buffer_overflow) {",
        "\t\tdev->buffer_overflow = 0;",
        "\t\tspin_unlock_irq(&dev->rbsl);",
        "\t\trv = usb_submit_urb(dev->interrupt_in_urb, GFP_KERNEL);",
        "\t\tif (rv < 0)"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\misc\\ldusb.c",
      "line": 507,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer_overflow",
      "context": [
        "\t\tspin_unlock_irq(&dev->rbsl);",
        "\t\trv = usb_submit_urb(dev->interrupt_in_urb, GFP_KERNEL);",
        "\t\tif (rv < 0)",
        "\t\t\tdev->buffer_overflow = 1;",
        "\t} else {",
        "\t\tspin_unlock_irq(&dev->rbsl);",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\misc\\ldusb.c",
      "line": 564,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t/* write the data into interrupt_out_buffer from userspace */",
        "\tbytes_to_write = min(count, write_buffer_size*dev->interrupt_out_endpoint_size);",
        "\tif (bytes_to_write < count)",
        "\t\tdev_warn(&dev->intf->dev, \"Write buffer overflow, %zu bytes dropped\\n\",",
        "\t\t\tcount - bytes_to_write);",
        "\tdev_dbg(&dev->intf->dev, \"%s: count = %zu, bytes_to_write = %zu\\n\",",
        "\t\t__func__, count, bytes_to_write);"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\misc\\legousbtower.c",
      "line": 692,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t\tdev_dbg(&dev->udev->dev, \"%s: received %d bytes\\n\",",
        "\t\t\t\t__func__, urb->actual_length);",
        "\t\t} else {",
        "\t\t\tpr_warn(\"read_buffer overflow, %d bytes dropped\\n\",",
        "\t\t\t\turb->actual_length);",
        "\t\t}",
        "\t\tspin_unlock_irqrestore(&dev->read_buffer_lock, flags);"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\misc\\onboard_usb_dev.c",
      "line": 502,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * onboard_dev_remove() (e.g. through an 'unbind' by userspace),",
        "\t * make sure to re-attach it if needed.",
        "\t *",
        "\t * This needs to be done deferred to avoid self-deadlocks on systems",
        "\t * with nested onboard hubs.",
        "\t */",
        "\tschedule_work(&attach_usb_driver_work);"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\misc\\usb251xb.c",
      "line": 656,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * placed at the same i2c-bus segment. In this case an error should be",
        "\t * returned since we can't safely use the GPIO controller to clear the",
        "\t * reset state (it may affect the hub configuration) and we can't lock",
        "\t * the i2c-bus segment (it will cause a deadlock).",
        "\t */",
        "\terr = usb251x_check_gpio_chip(hub);",
        "\tif (err)"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\musb\\musb_host.c",
      "line": 27,
      "pattern": "code.*duplication",
      "rule": "code_quality",
      "severity": "low",
      "match": "code duplication",
      "context": [
        "",
        "/* MUSB HOST status 22-mar-2006",
        " *",
        " * - There's still lots of partial code duplication for fault paths, so",
        " *   they aren't handled as consistently as they need to be.",
        " *",
        " * - PIO mostly behaved when last tested."
      ]
    },
    {
      "file": "linux\\drivers\\usb\\phy\\phy-tegra-usb.c",
      "line": 998,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * disable interrupt for both PHY and CI or for CI only.  The",
        "\t * interrupt needs to be disabled while hardware is reprogrammed",
        "\t * because interrupt touches the programmed registers, and thus,",
        "\t * there could be a race condition.",
        "\t */",
        "\tif (phy->irq > 0)",
        "\t\tdisable_irq(phy->irq);"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\serial\\digi_acceleport.c",
      "line": 566,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " *  Digi transmit idle waits, up to timeout ticks, for the transmitter",
        " *  to go idle.  It returns 0 if successful or a negative error.",
        " *",
        " *  There are race conditions here if more than one process is calling",
        " *  digi_transmit_idle on the same port at the same time.  However, this",
        " *  is only called from close, and only one process can be in close on a",
        " *  port at a time, so its ok."
      ]
    },
    {
      "file": "linux\\drivers\\usb\\serial\\oti6858.c",
      "line": 20,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        " *  - analyzing traffic between device and the M$ Windows 2000 driver,",
        " *  - trying different bit combinations and checking pin states",
        " *    with a voltmeter,",
        " *  - receiving malformed frames and producing buffer overflows",
        " *    to learn how errors are reported,",
        " * So, THIS CODE CAN DESTROY OTi-6858 AND ANY OTHER DEVICES, THAT ARE",
        " * CONNECTED TO IT!"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\storage\\uas.c",
      "line": 90,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * In the course of error handling and power management uas_wait_for_pending_cmnds()",
        " * needs to flush pending work items. In these contexts we cannot allocate memory",
        " * by doing block IO as we would deadlock. For the same reason we cannot wait",
        " * for anything allocating memory not heeding these constraints.",
        " *",
        " * So we have to control all work items that can be on the workqueue we flush."
      ]
    },
    {
      "file": "linux\\drivers\\usb\\storage\\uas.c",
      "line": 1154,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t     \"%s: alloc streams error %d after reset\",",
        "\t\t\t     __func__, err);",
        "",
        "\t/* we must unblock the host in every case lest we deadlock */",
        "\tspin_lock_irqsave(shost->host_lock, flags);",
        "\tscsi_report_bus_reset(shost, 0);",
        "\tspin_unlock_irqrestore(shost->host_lock, flags);"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\usbip\\vhci_hcd.c",
      "line": 1012,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "/*",
        " * The important thing is that only one context begins cleanup.",
        " * This is why error handling and cleanup become simple.",
        " * We do not want to consider race condition as possible.",
        " */",
        "static void vhci_shutdown_connection(struct usbip_device *ud)",
        "{"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\gadget\\function\\f_eem.c",
      "line": 260,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * in drivers/usb/gadget/configfs.c:configfs_composite_bind()",
        "\t * configurations are bound in sequence with list_for_each_entry,",
        "\t * in each configuration its functions are bound in sequence",
        "\t * with list_for_each_entry, so we assume no race condition",
        "\t * with regard to eem_opts->bound access",
        "\t */",
        "\tif (!eem_opts->bound) {"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\gadget\\function\\f_fs.c",
      "line": 2236,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t/*",
        "\t * potential race possible between ffs_func_eps_disable",
        "\t * & ffs_epfile_release therefore maintaining a local",
        "\t * copy of epfile will save us from use-after-free.",
        "\t */",
        "\tif (epfiles) {",
        "\t\tffs_epfiles_destroy(epfiles, ffs->eps_count);"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\gadget\\function\\f_fs.c",
      "line": 1132,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t\t\tgoto error_lock;",
        "\t\t\t}",
        "\t\t\t/*",
        "\t\t\t * To avoid race condition with ffs_epfile_io_complete,",
        "\t\t\t * dequeue the request first then check",
        "\t\t\t * status. usb_ep_dequeue API should guarantee no race",
        "\t\t\t * condition with req->complete callback."
      ]
    },
    {
      "file": "linux\\drivers\\usb\\gadget\\function\\f_fs.c",
      "line": 3521,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * in drivers/usb/gadget/configfs.c:configfs_composite_bind()",
        "\t * configurations are bound in sequence with list_for_each_entry,",
        "\t * in each configuration its functions are bound in sequence",
        "\t * with list_for_each_entry, so we assume no race condition",
        "\t * with regard to ffs_opts->bound access",
        "\t */",
        "\tif (!ffs_opts->refcnt) {"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\gadget\\function\\f_fs.c",
      "line": 1397,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * The fence will be unref'd in ffs_dmabuf_cleanup.",
        "\t * It can't be done here, as the unref functions might try to lock",
        "\t * the resv object, which would deadlock.",
        "\t */",
        "\tINIT_WORK(&dma_fence->work, ffs_dmabuf_cleanup);",
        "\tqueue_work(priv->ffs->io_completion_wq, &dma_fence->work);"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\gadget\\function\\f_fs.c",
      "line": 3500,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Legacy gadget triggers binding in functionfs_ready_callback,",
        "\t * which already uses locking; taking the same lock here would",
        "\t * cause a deadlock.",
        "\t *",
        "\t * Configfs-enabled gadgets however do need ffs_dev_lock.",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\gadget\\function\\f_phonet.c",
      "line": 497,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * in drivers/usb/gadget/configfs.c:configfs_composite_bind()",
        "\t * configurations are bound in sequence with list_for_each_entry,",
        "\t * in each configuration its functions are bound in sequence",
        "\t * with list_for_each_entry, so we assume no race condition",
        "\t * with regard to phonet_opts->bound access",
        "\t */",
        "\tif (!phonet_opts->bound) {"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\gadget\\function\\f_phonet.c",
      "line": 364,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\tbreak;",
        "",
        "\t/* Do resubmit in these cases: */",
        "\tcase -EOVERFLOW: /* request buffer overflow */",
        "\t\tdev->stats.rx_over_errors++;",
        "\t\tfallthrough;",
        "\tdefault:"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\gadget\\function\\f_printer.c",
      "line": 415,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\treq->length = USB_BUFSIZE;",
        "\t\treq->complete = rx_complete;",
        "",
        "\t\t/* here, we unlock, and only unlock, to avoid deadlock. */",
        "\t\tspin_unlock(&dev->lock);",
        "\t\terror = usb_ep_queue(dev->out_ep, req, GFP_ATOMIC);",
        "\t\tspin_lock(&dev->lock);"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\gadget\\function\\f_printer.c",
      "line": 680,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t\tlist_add(&req->list, &dev->tx_reqs_active);",
        "",
        "\t\t/* here, we unlock, and only unlock, to avoid deadlock. */",
        "\t\tspin_unlock(&dev->lock);",
        "\t\tvalue = usb_ep_queue(dev->in_ep, req, GFP_ATOMIC);",
        "\t\tspin_lock(&dev->lock);"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\gadget\\function\\f_rndis.c",
      "line": 688,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * in drivers/usb/gadget/configfs.c:configfs_composite_bind()",
        "\t * configurations are bound in sequence with list_for_each_entry,",
        "\t * in each configuration its functions are bound in sequence",
        "\t * with list_for_each_entry, so we assume no race condition",
        "\t * with regard to rndis_opts->bound access",
        "\t */",
        "\tif (!rndis_opts->bound) {"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\gadget\\function\\f_subset.c",
      "line": 308,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * in drivers/usb/gadget/configfs.c:configfs_composite_bind()",
        "\t * configurations are bound in sequence with list_for_each_entry,",
        "\t * in each configuration its functions are bound in sequence",
        "\t * with list_for_each_entry, so we assume no race condition",
        "\t * with regard to gether_opts->bound access",
        "\t */",
        "\tif (!gether_opts->bound) {"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\gadget\\function\\u_serial.c",
      "line": 87,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "#define WRITE_BUF_SIZE\t\t8192\t\t/* TX only */",
        "#define GS_CONSOLE_BUF_SIZE\t8192",
        "",
        "/* Prevents race conditions while accessing gser->ioport */",
        "static DEFINE_SPINLOCK(serial_port_lock);",
        "",
        "/* console info */"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\gadget\\legacy\\raw_gadget.c",
      "line": 271,
      "pattern": "deprecated.*function",
      "rule": "api_usage",
      "severity": "medium",
      "match": "deprecated simple_strtoul() function",
      "context": [
        "{",
        "\t/* If the endpoint has fixed function (named as e.g. \"ep12out-bulk\"),",
        "\t * parse the endpoint address from its name. We deliberately use",
        "\t * deprecated simple_strtoul() function here, as the number isn't",
        "\t * followed by '\\0' nor '\\n'.",
        "\t */",
        "\tif (isdigit(name[2]))"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\gadget\\udc\\at91_udc.c",
      "line": 335,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\tif (count > ep->ep.maxpacket)",
        "\t\tcount = ep->ep.maxpacket;",
        "\tif (count > bufferspace) {",
        "\t\tDBG(\"%s buffer overflow\\n\", ep->ep.name);",
        "\t\treq->req.status = -EOVERFLOW;",
        "\t\tcount = bufferspace;",
        "\t}"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\gadget\\udc\\core.c",
      "line": 274,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * have queued some data to transfer at that time.",
        " *",
        " * Note that @req's ->complete() callback must never be called from",
        " * within usb_ep_queue() as that can create deadlock situations.",
        " *",
        " * This routine may be called in interrupt context.",
        " *"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\gadget\\udc\\gr_udc.c",
      "line": 1643,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\t\treturn;",
        "\treq = container_of(_req, struct gr_request, req);",
        "",
        "\t/* Leads to memory leak */",
        "\tWARN(!list_empty(&req->queue),",
        "\t     \"request not dequeued properly before freeing\\n\");",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\usb\\gadget\\udc\\renesas_usbf.c",
      "line": 1674,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\tdo {",
        "\t\t/* Were going to read the FIFO for this current request.",
        "\t\t * NAK any other incoming data to avoid a race condition if no",
        "\t\t * more request are available.",
        "\t\t */",
        "\t\tif (!ep->is_in && ep->id != 0) {"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\gadget\\udc\\snps_udc_core.c",
      "line": 78,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "/* set_rde -- Is used to control enabling of RX DMA. Problem is",
        " * that UDC has only one bit (RDE) to enable/disable RX DMA for",
        " * all OUT endpoints. So we have to handle race conditions like",
        " * when OUT data reaches the fifo but no request was queued yet.",
        " * This cannot be solved by letting the RX DMA disabled until a",
        " * request gets queued because there may be other OUT packets"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\typec\\tcpm\\fusb302.c",
      "line": 155,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer, \"overflow",
      "context": [
        "",
        "\tif (fusb302_log_full(chip)) {",
        "\t\tchip->logbuffer_head = max(chip->logbuffer_head - 1, 0);",
        "\t\tstrscpy(tmpbuffer, \"overflow\", sizeof(tmpbuffer));",
        "\t}",
        "",
        "\tif (chip->logbuffer_head < 0 ||"
      ]
    },
    {
      "file": "linux\\drivers\\usb\\typec\\tcpm\\tcpm.c",
      "line": 728,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer, \"overflow",
      "context": [
        "",
        "\tif (tcpm_log_full(port)) {",
        "\t\tport->logbuffer_head = max(port->logbuffer_head - 1, 0);",
        "\t\tstrcpy(tmpbuffer, \"overflow\");",
        "\t}",
        "",
        "\tif (port->logbuffer_head < 0 ||"
      ]
    },
    {
      "file": "linux\\drivers\\vdpa\\pds\\vdpa_dev.c",
      "line": 745,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t}",
        "",
        "\t/* We use the _vdpa_register_device() call rather than the",
        "\t * vdpa_register_device() to avoid a deadlock because our",
        "\t * dev_add() is called with the vdpa_dev_lock already set",
        "\t * by vdpa_nl_cmd_dev_add_set_doit()",
        "\t */"
      ]
    },
    {
      "file": "linux\\drivers\\vfio\\pci\\vfio_pci_core.c",
      "line": 269,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\t\t\t * state can be changed to D0 without the involvement",
        "\t\t\t * of the driver. For these cases, free the earlier",
        "\t\t\t * allocated memory first before overwriting 'pm_save'",
        "\t\t\t * to prevent the memory leak.",
        "\t\t\t */",
        "\t\t\tkfree(vdev->pm_save);",
        "\t\t\tvdev->pm_save = pci_store_saved_state(pdev);"
      ]
    },
    {
      "file": "linux\\drivers\\vfio\\pci\\vfio_pci_core.c",
      "line": 659,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tpci_write_config_word(pdev, PCI_COMMAND, PCI_COMMAND_INTX_DISABLE);",
        "",
        "\t/*",
        "\t * Try to get the locks ourselves to prevent a deadlock. The",
        "\t * success of this is dependent on being able to lock the device,",
        "\t * which is not always possible.",
        "\t * We can not use the \"try\" reset interface here, which will"
      ]
    },
    {
      "file": "linux\\drivers\\vfio\\pci\\vfio_pci_core.c",
      "line": 2450,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t/*",
        "\t\t * Take the memory write lock for each device and zap BAR",
        "\t\t * mappings to prevent the user accessing the device while in",
        "\t\t * reset.  Locking multiple devices is prone to deadlock,",
        "\t\t * runaway and unwind if we hit contention.",
        "\t\t */",
        "\t\tif (!down_write_trylock(&vdev->memory_lock)) {"
      ]
    },
    {
      "file": "linux\\drivers\\vfio\\pci\\vfio_pci_intrs.c",
      "line": 161,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "/*",
        " * If this is triggered by an eventfd, we can't call eventfd_signal",
        " * or else we'll deadlock on the eventfd wait queue.  Return >0 when",
        " * a signal is necessary, which can then be handled via a work queue",
        " * or directly depending on the caller.",
        " */"
      ]
    },
    {
      "file": "linux\\drivers\\vfio\\pci\\mlx5\\main.c",
      "line": 1284,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * As the higher VFIO layers are holding locks across reset and using",
        "\t * those same locks with the mm_lock we need to prevent ABBA deadlock",
        "\t * with the state_mutex and mm_lock.",
        "\t * In case the state_mutex was taken already we defer the cleanup work",
        "\t * to the unlock flow of the other running context."
      ]
    },
    {
      "file": "linux\\drivers\\vfio\\pci\\virtio\\migrate.c",
      "line": 279,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * As the higher VFIO layers are holding locks across reset and using",
        "\t * those same locks with the mm_lock we need to prevent ABBA deadlock",
        "\t * with the state_mutex and mm_lock.",
        "\t * In case the state_mutex was taken already we defer the cleanup work",
        "\t * to the unlock flow of the other running context."
      ]
    },
    {
      "file": "linux\\drivers\\video\\fbdev\\cirrusfb.c",
      "line": 520,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double the pixel clock",
      "context": [
        "\t}",
        "",
        "\t/* If we have a 1MB 5434, we need to put ourselves in a mode where",
        "\t * the VCLK is double the pixel clock. */",
        "\tcinfo->doubleVCLK = 0;",
        "\tif (cinfo->btype == BT_SD64 && info->fix.smem_len <= MB_ &&",
        "\t    var->bits_per_pixel == 16) {"
      ]
    },
    {
      "file": "linux\\drivers\\video\\fbdev\\ps3fb.c",
      "line": 1092,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory to prevent kernel info leak",
      "context": [
        "\tdinfo->irq.mask = (1 << GPU_INTR_STATUS_VSYNC_1) |",
        "\t\t\t  (1 << GPU_INTR_STATUS_FLIP_1);",
        "",
        "\t/* Clear memory to prevent kernel info leakage into userspace */",
        "\tmemset(ps3fb_videomemory.address, 0, ps3fb_videomemory.size);",
        "",
        "\txdr_lpar = ps3_mm_phys_to_lpar(__pa(ps3fb_videomemory.address));"
      ]
    },
    {
      "file": "linux\\drivers\\video\\fbdev\\pxafb.c",
      "line": 1020,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Double Pixel Clock",
      "context": [
        "{",
        "\tunsigned long long pcd;",
        "",
        "\t/* FIXME: Need to take into account Double Pixel Clock mode",
        "\t * (DPC) bit? or perhaps set it based on the various clock",
        "\t * speeds */",
        "\tpcd = (unsigned long long)(clk_get_rate(fbi->clk) / 10000);"
      ]
    },
    {
      "file": "linux\\drivers\\video\\fbdev\\pxafb.c",
      "line": 1961,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double pixel clock",
      "context": [
        "\t\t}",
        "\t} else if (!strncmp(this_opt, \"dpc:\", 4)) {",
        "\t\tif (simple_strtoul(this_opt+4, NULL, 0) == 0) {",
        "\t\t\tsprintf(s, \"double pixel clock: false\\n\");",
        "\t\t\tinf->lccr3 &= ~LCCR3_DPC;",
        "\t\t} else {",
        "\t\t\tsprintf(s, \"double pixel clock: true\\n\");"
      ]
    },
    {
      "file": "linux\\drivers\\video\\fbdev\\pxafb.c",
      "line": 1964,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double pixel clock",
      "context": [
        "\t\t\tsprintf(s, \"double pixel clock: false\\n\");",
        "\t\t\tinf->lccr3 &= ~LCCR3_DPC;",
        "\t\t} else {",
        "\t\t\tsprintf(s, \"double pixel clock: true\\n\");",
        "\t\t\tinf->lccr3 |= LCCR3_DPC;",
        "\t\t}",
        "\t} else if (!strncmp(this_opt, \"outputen:\", 9)) {"
      ]
    },
    {
      "file": "linux\\drivers\\video\\fbdev\\s3c-fb.c",
      "line": 1051,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing_pixclock() - calculates pixel clock",
      "context": [
        "};",
        "",
        "/**",
        " * s3c_fb_missing_pixclock() - calculates pixel clock",
        " * @mode: The video mode to change.",
        " *",
        " * Calculate the pixel clock when none has been given through platform data."
      ]
    },
    {
      "file": "linux\\drivers\\video\\fbdev\\s3c-fb.c",
      "line": 1056,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing_pixclock",
      "context": [
        " *",
        " * Calculate the pixel clock when none has been given through platform data.",
        " */",
        "static void s3c_fb_missing_pixclock(struct fb_videomode *mode)",
        "{",
        "\tu64 pixclk = 1000000000000ULL;",
        "\tu32 div;"
      ]
    },
    {
      "file": "linux\\drivers\\video\\fbdev\\s3c-fb.c",
      "line": 1294,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing_pixclock",
      "context": [
        "\tu32 data;",
        "",
        "\tif (!vmode->pixclock)",
        "\t\ts3c_fb_missing_pixclock(vmode);",
        "",
        "\tclkdiv = s3c_fb_calc_pixclk(sfb, vmode->pixclock);",
        ""
      ]
    },
    {
      "file": "linux\\drivers\\video\\fbdev\\s1d13xxxfb.c",
      "line": 638,
      "pattern": "hardcoded.*values",
      "rule": "code_quality",
      "severity": "low",
      "match": "hardcoded values",
      "context": [
        " *\tsoftware values needs to match the hardware ones. This is what",
        " *\tthis function ensures.",
        " *",
        " *\tNote: some of the hardcoded values here might need some love to",
        " *\twork on various chips, and might need to no longer be hardcoded.",
        " */",
        "static void s1d13xxxfb_fetch_hw_state(struct fb_info *info)"
      ]
    },
    {
      "file": "linux\\drivers\\video\\fbdev\\smscufx.c",
      "line": 901,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "/* NOTE: fb_defio.c is holding info->fbdefio.mutex",
        " *   Touching ANY framebuffer memory that triggers a page fault",
        " *   in fb_defio will cause a deadlock, when it also tries to",
        " *   grab the same mutex. */",
        "static void ufx_dpy_deferred_io(struct fb_info *info, struct list_head *pagereflist)",
        "{"
      ]
    },
    {
      "file": "linux\\drivers\\video\\fbdev\\smscufx.c",
      "line": 1793,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tdev->urbs.available++;",
        "\tspin_unlock_irqrestore(&dev->urbs.lock, flags);",
        "",
        "\t/* When using fb_defio, we deadlock if up() is called",
        "\t * while another is waiting. So queue to another process */",
        "\tif (fb_defio)",
        "\t\tschedule_delayed_work(&unode->release_urb_work, 0);"
      ]
    },
    {
      "file": "linux\\drivers\\video\\fbdev\\udlfb.c",
      "line": 723,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * NOTE: fb_defio.c is holding info->fbdefio.mutex",
        " *   Touching ANY framebuffer memory that triggers a page fault",
        " *   in fb_defio will cause a deadlock, when it also tries to",
        " *   grab the same mutex.",
        " */",
        "static void dlfb_dpy_deferred_io(struct fb_info *info, struct list_head *pagereflist)"
      ]
    },
    {
      "file": "linux\\drivers\\video\\fbdev\\vga16fb.c",
      "line": 105,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "   the scenes in the VGA's 32-bit latch register, and reading and writing",
        "   video memory just invokes latch behavior.",
        "",
        "   To avoid race conditions (is this necessary?), reading and writing",
        "   the memory byte should be done with a single instruction.  One",
        "   suitable instruction is the x86 bitwise OR.  The following",
        "   read-modify-write routine should optimize to one such bitwise"
      ]
    },
    {
      "file": "linux\\drivers\\video\\fbdev\\xen-fbfront.c",
      "line": 634,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\tcase XenbusStateConnected:",
        "\t\t/*",
        "\t\t * Work around xenbus race condition: If backend goes",
        "\t\t * through InitWait to Connected fast enough, we can",
        "\t\t * get Connected twice here.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\drivers\\video\\fbdev\\core\\fbcon.c",
      "line": 95,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *   means concurrent access to the same fbdev from both fbcon and userspace",
        " *   will blow up. To fix this all fbcon calls from fbmem.c need to be moved out",
        " *   of fb_lock/unlock protected sections, since otherwise we'll recurse and",
        " *   deadlock eventually. Aside: Due to these deadlock issues the fbdev code in",
        " *   fbmem.c cannot use locking asserts, and there's lots of callers which get",
        " *   the rules wrong, e.g. fbsysfs.c entirely missed fb_lock/unlock calls too.",
        " */"
      ]
    },
    {
      "file": "linux\\drivers\\video\\fbdev\\core\\fbcon.c",
      "line": 95,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *   means concurrent access to the same fbdev from both fbcon and userspace",
        " *   will blow up. To fix this all fbcon calls from fbmem.c need to be moved out",
        " *   of fb_lock/unlock protected sections, since otherwise we'll recurse and",
        " *   deadlock eventually. Aside: Due to these deadlock issues the fbdev code in",
        " *   fbmem.c cannot use locking asserts, and there's lots of callers which get",
        " *   the rules wrong, e.g. fbsysfs.c entirely missed fb_lock/unlock calls too.",
        " */"
      ]
    },
    {
      "file": "linux\\drivers\\video\\fbdev\\nvidia\\nv_accel.c",
      "line": 58,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "#include \"nv_dma.h\"",
        "#include \"nv_local.h\"",
        "",
        "/* There is a HW race condition with videoram command buffers.",
        "   You can't jump to the location of your put offset.  We write put",
        "   at the jump offset + SKIPS dwords with noop padding in between",
        "   to solve this problem */"
      ]
    },
    {
      "file": "linux\\drivers\\video\\fbdev\\nvidia\\nv_hw.c",
      "line": 90,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic\" numbers",
      "context": [
        "",
        "/****************************************************************************\\",
        "*                                                                            *",
        "* The video arbitration routines calculate some \"magic\" numbers.  Fixes      *",
        "* the snow seen when accessing the framebuffer without it.                   *",
        "* It just works (I hope).                                                    *",
        "*                                                                            *"
      ]
    },
    {
      "file": "linux\\drivers\\video\\fbdev\\riva\\riva_hw.c",
      "line": 136,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic\" numbers",
      "context": [
        "",
        "/****************************************************************************\\",
        "*                                                                            *",
        "* The video arbitration routines calculate some \"magic\" numbers.  Fixes      *",
        "* the snow seen when accessing the framebuffer without it.                   *",
        "* It just works (I hope).                                                    *",
        "*                                                                            *"
      ]
    },
    {
      "file": "linux\\drivers\\video\\fbdev\\sis\\sis_main.c",
      "line": 5375,
      "pattern": "hardcoded.*values",
      "rule": "code_quality",
      "severity": "low",
      "match": "hardcoded to 0. Enable other values",
      "context": [
        "\t * 0 == DDR1, 1 == DDR2, 2..7 == reserved?",
        "\t *",
        "\t * The code seems to written so that regb should equal ramtype,",
        "\t * however, so far it has been hardcoded to 0. Enable other values only",
        "\t * on XGI Z9, as it passes the POST, and add a warning for others.",
        "\t */",
        "\tramtype = sisfb_post_xgi_ramtype(ivideo);"
      ]
    },
    {
      "file": "linux\\drivers\\virt\\nitro_enclaves\\ne_misc_dev.c",
      "line": 1497,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Acquire the enclave list mutex before the enclave mutex",
        "\t * in order to avoid deadlocks with @ref ne_event_work_handler.",
        "\t */",
        "\tmutex_lock(&ne_pci_dev->enclaves_list_mutex);",
        "\tmutex_lock(&ne_enclave->enclave_info_mutex);"
      ]
    },
    {
      "file": "linux\\drivers\\virt\\vboxguest\\vboxguest_utils.c",
      "line": 776,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t[-VERR_SEEK_ON_DEVICE]                           = -ESPIPE,",
        "\t[-VERR_WRITE_PROTECT]                            = -EROFS,",
        "\t[-VERR_BROKEN_PIPE]                              = -EPIPE,",
        "\t[-VERR_DEADLOCK]                                 = -EDEADLK,",
        "\t[-VERR_FILENAME_TOO_LONG]                        = -ENAMETOOLONG,",
        "\t[-VERR_FILE_LOCK_FAILED]                         = -ENOLCK,",
        "\t[-VERR_NOT_IMPLEMENTED]                          = -ENOSYS,"
      ]
    },
    {
      "file": "linux\\drivers\\xen\\xenbus\\xenbus_dev_frontend.c",
      "line": 345,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * We might be called in xenbus_thread().",
        "\t * Use workqueue to avoid deadlock.",
        "\t */",
        "\tu = container_of(kref, struct xenbus_file_priv, kref);",
        "\tschedule_work(&u->wq);"
      ]
    },
    {
      "file": "linux\\fs\\afs\\yfsclient.c",
      "line": 143,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\tsize_t len = (void *)bp - call->request;",
        "",
        "\tif (len > call->request_size)",
        "\t\tpr_err(\"kAFS: %s: Request buffer overflow (%zu>%u)\\n\",",
        "\t\t       call->type->name, len, call->request_size);",
        "\telse if (len < call->request_size)",
        "\t\tpr_warn(\"kAFS: %s: Request buffer underflow (%zu<%u)\\n\","
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_cache.c",
      "line": 702,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "/*",
        " * We can only have one thread cannibalizing other cached btree nodes at a time,",
        " * or we'll deadlock. We use an open coded mutex to ensure that, which a",
        " * cannibalize_bucket() will take. This means every time we unlock the root of",
        " * the btree, we need to release this lock if we have it held.",
        " */"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_gc.c",
      "line": 1205,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * We have to use trylock here. Otherwise, we would",
        "\t * introduce a deadlock in the RO path - we take the",
        "\t * state lock at the start of going RO.",
        "\t */",
        "\tif (!down_read_trylock(&c->state_lock)) {"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_io.c",
      "line": 1692,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "}",
        "",
        "/*",
        " * XXX This allocates multiple times from the same mempools, and can deadlock",
        " * under sufficient memory pressure (but is only a debug path)",
        " */",
        "static int btree_node_read_all_replicas(struct bch_fs *c, struct btree *b, bool sync)"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_locking.c",
      "line": 155,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\treturn false;",
        "}",
        "",
        "static void trace_would_deadlock(struct lock_graph *g, struct btree_trans *trans)",
        "{",
        "\tstruct bch_fs *c = trans->c;",
        ""
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_locking.c",
      "line": 159,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "{",
        "\tstruct bch_fs *c = trans->c;",
        "",
        "\tcount_event(c, trans_restart_would_deadlock);",
        "",
        "\tif (trace_trans_restart_would_deadlock_enabled()) {",
        "\t\tstruct printbuf buf = PRINTBUF;"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_locking.c",
      "line": 161,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\tcount_event(c, trans_restart_would_deadlock);",
        "",
        "\tif (trace_trans_restart_would_deadlock_enabled()) {",
        "\t\tstruct printbuf buf = PRINTBUF;",
        "",
        "\t\tbuf.atomic++;"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_locking.c",
      "line": 167,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tbuf.atomic++;",
        "\t\tprint_cycle(&buf, g);",
        "",
        "\t\ttrace_trans_restart_would_deadlock(trans, buf.buf);",
        "\t\tprintbuf_exit(&buf);",
        "\t}",
        "}"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_locking.c",
      "line": 175,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "static int abort_lock(struct lock_graph *g, struct trans_waiting_for_lock *i)",
        "{",
        "\tif (i == g->g) {",
        "\t\ttrace_would_deadlock(g, i->trans);",
        "\t\treturn btree_trans_restart_foreign_task(i->trans,",
        "\t\t\t\t\tBCH_ERR_transaction_restart_would_deadlock,",
        "\t\t\t\t\t_THIS_IP_);"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_locking.c",
      "line": 177,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tif (i == g->g) {",
        "\t\ttrace_would_deadlock(g, i->trans);",
        "\t\treturn btree_trans_restart_foreign_task(i->trans,",
        "\t\t\t\t\tBCH_ERR_transaction_restart_would_deadlock,",
        "\t\t\t\t\t_THIS_IP_);",
        "\t} else {",
        "\t\ti->trans->lock_must_abort = true;"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_locking.c",
      "line": 280,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tif (cycle)",
        "\t\t\treturn 0;",
        "",
        "\t\ttrace_and_count(trans->c, trans_restart_would_deadlock_recursion_limit, trans, _RET_IP_);",
        "\t\treturn btree_trans_restart(orig_trans, BCH_ERR_transaction_restart_deadlock_recursion_limit);",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_locking.c",
      "line": 281,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\treturn 0;",
        "",
        "\t\ttrace_and_count(trans->c, trans_restart_would_deadlock_recursion_limit, trans, _RET_IP_);",
        "\t\treturn btree_trans_restart(orig_trans, BCH_ERR_transaction_restart_deadlock_recursion_limit);",
        "\t}",
        "",
        "\t__lock_graph_down(g, trans);"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_locking.c",
      "line": 293,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\treturn t1 + t2 > 1;",
        "}",
        "",
        "int bch2_check_for_deadlock(struct btree_trans *trans, struct printbuf *cycle)",
        "{",
        "\tstruct lock_graph g;",
        "\tstruct trans_waiting_for_lock *top;"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_locking.c",
      "line": 307,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tif (cycle)",
        "\t\t\treturn -1;",
        "",
        "\t\ttrace_would_deadlock(&g, trans);",
        "\t\treturn btree_trans_restart(trans, BCH_ERR_transaction_restart_would_deadlock);",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_locking.c",
      "line": 308,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\treturn -1;",
        "",
        "\t\ttrace_would_deadlock(&g, trans);",
        "\t\treturn btree_trans_restart(trans, BCH_ERR_transaction_restart_would_deadlock);",
        "\t}",
        "",
        "\tlock_graph_down(&g, trans);"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_locking.c",
      "line": 387,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t\t\t\ttop->lock_start_time = trans->locking_wait.start_time;",
        "",
        "\t\t\t\t/* Don't check for self deadlock: */",
        "\t\t\t\tif (trans == top->trans ||",
        "\t\t\t\t    !lock_type_conflicts(lock_held, trans->locking_wait.lock_want))",
        "\t\t\t\t\tcontinue;"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_locking.c",
      "line": 415,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\treturn ret;",
        "}",
        "",
        "int bch2_six_check_for_deadlock(struct six_lock *lock, void *p)",
        "{",
        "\tstruct btree_trans *trans = p;",
        ""
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_locking.c",
      "line": 419,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "{",
        "\tstruct btree_trans *trans = p;",
        "",
        "\treturn bch2_check_for_deadlock(trans, NULL);",
        "}",
        "",
        "int __bch2_btree_node_lock_write(struct btree_trans *trans, struct btree_path *path,"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_key_cache.c",
      "line": 490,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "err:",
        "\tbch2_fs_fatal_err_on(ret &&",
        "\t\t\t     !bch2_err_matches(ret, BCH_ERR_transaction_restart) &&",
        "\t\t\t     !bch2_err_matches(ret, BCH_ERR_journal_reclaim_would_deadlock) &&",
        "\t\t\t     !bch2_journal_error(j), c,",
        "\t\t\t     \"flushing key cache: %s\", bch2_err_str(ret));",
        "\tif (ret)"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_trans_commit.c",
      "line": 115,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tbch2_btree_node_unlock_write(trans, trans->paths + i->path, insert_l(trans, i)->b);",
        "\t}",
        "",
        "\ttrace_and_count(trans->c, trans_restart_would_deadlock_write, trans);",
        "\treturn btree_trans_restart(trans, BCH_ERR_transaction_restart_would_deadlock_write);",
        "}",
        ""
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_trans_commit.c",
      "line": 116,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t}",
        "",
        "\ttrace_and_count(trans->c, trans_restart_would_deadlock_write, trans);",
        "\treturn btree_trans_restart(trans, BCH_ERR_transaction_restart_would_deadlock_write);",
        "}",
        "",
        "static inline int bch2_trans_lock_write(struct btree_trans *trans)"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_trans_commit.c",
      "line": 901,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t */",
        "\t\tif ((flags & BCH_TRANS_COMMIT_journal_reclaim) &&",
        "\t\t    watermark < BCH_WATERMARK_reclaim) {",
        "\t\t\tret = bch_err_throw(c, journal_reclaim_would_deadlock);",
        "\t\t\tgoto out;",
        "\t\t}",
        ""
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_update_interior.c",
      "line": 1177,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tif (watermark < BCH_WATERMARK_reclaim &&",
        "\t    test_bit(JOURNAL_space_low, &c->journal.flags)) {",
        "\t\tif (flags & BCH_TRANS_COMMIT_journal_reclaim)",
        "\t\t\treturn ERR_PTR(-BCH_ERR_journal_reclaim_would_deadlock);",
        "",
        "\t\tret = drop_locks_do(trans,",
        "\t\t\t({ wait_event(c->journal.wait, !test_bit(JOURNAL_space_low, &c->journal.flags)); 0; }));"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_update_interior.c",
      "line": 1253,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * We don't want to allocate if we're in an error state, that can cause",
        "\t * deadlock on emergency shutdown due to open buckets getting stuck in",
        "\t * the btree_reserve_cache after allocator shutdown has cleared it out.",
        "\t * This check needs to come after adding us to the btree_interior_update",
        "\t * list but before calling bch2_btree_reserve_get, to synchronize with"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_update_interior.c",
      "line": 1282,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tif (bch2_err_matches(ret, ENOSPC) &&",
        "\t\t    (flags & BCH_TRANS_COMMIT_journal_reclaim) &&",
        "\t\t    watermark < BCH_WATERMARK_reclaim) {",
        "\t\t\tret = bch_err_throw(c, journal_reclaim_would_deadlock);",
        "\t\t\tgoto err;",
        "\t\t}",
        ""
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_update_interior.c",
      "line": 1313,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tbch2_btree_update_free(as, trans);",
        "\tif (!bch2_err_matches(ret, ENOSPC) &&",
        "\t    !bch2_err_matches(ret, EROFS) &&",
        "\t    ret != -BCH_ERR_journal_reclaim_would_deadlock &&",
        "\t    ret != -BCH_ERR_journal_shutdown)",
        "\t\tbch_err_fn_ratelimited(c, ret);",
        "\treturn ERR_PTR(ret);"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_update_interior.c",
      "line": 2027,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tBUG_ON(!btree_node_locked(&trans->paths[path], level));",
        "",
        "\t/*",
        "\t * Work around a deadlock caused by the btree write buffer not doing",
        "\t * merges and leaving tons of merges for us to do - we really don't need",
        "\t * to be doing merges at all from the interior update path, and if the",
        "\t * interior update path is generating too many new interior updates we"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_update_interior.c",
      "line": 2031,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * merges and leaving tons of merges for us to do - we really don't need",
        "\t * to be doing merges at all from the interior update path, and if the",
        "\t * interior update path is generating too many new interior updates we",
        "\t * deadlock:",
        "\t */",
        "\tif ((flags & BCH_WATERMARK_MASK) == BCH_WATERMARK_interior_updates)",
        "\t\treturn 0;"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_update_interior.c",
      "line": 2194,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tbch2_path_put(trans, new_path, true);",
        "\tbch2_path_put(trans, sib_path, true);",
        "\tbch2_trans_verify_locks(trans);",
        "\tif (ret == -BCH_ERR_journal_reclaim_would_deadlock)",
        "\t\tret = 0;",
        "\tif (!ret)",
        "\t\tret = bch2_trans_relock(trans);"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_write_buffer.c",
      "line": 321,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t *",
        "\t * However, since we're not flushing in the order they appear in the",
        "\t * journal we won't be able to drop our journal pin until everything is",
        "\t * flushed - which means this could deadlock the journal if we weren't",
        "\t * passing BCH_TRANS_COMMIT_journal_reclaim. This causes the update to fail",
        "\t * if it would block taking a journal reservation.",
        "\t *"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_write_buffer.c",
      "line": 396,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tbool accounting_accumulated = false;",
        "\t\tdo {",
        "\t\t\tif (race_fault()) {",
        "\t\t\t\tret = bch_err_throw(c, journal_reclaim_would_deadlock);",
        "\t\t\t\tbreak;",
        "\t\t\t}",
        ""
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_write_buffer.c",
      "line": 408,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t\tif (!ret) {",
        "\t\t\tk->journal_seq = 0;",
        "\t\t} else if (ret == -BCH_ERR_journal_reclaim_would_deadlock) {",
        "\t\t\tslowpath++;",
        "\t\t\tret = 0;",
        "\t\t} else"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\btree_write_buffer.c",
      "line": 472,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t * can't flush accounting keys at all - condense them and leave",
        "\t\t * them for next time.",
        "\t\t *",
        "\t\t * Q: Can the write buffer overflow?",
        "\t\t * A Shouldn't be any actual risk. It's just new accounting",
        "\t\t * updates that the write buffer can't flush, and those are only",
        "\t\t * going to be generated by interior btree node updates as"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\debug.c",
      "line": 818,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t.read\t\t= btree_transaction_stats_read,",
        "};",
        "",
        "/* walk btree transactions until we find a deadlock and print it */",
        "static void btree_deadlock_to_text(struct printbuf *out, struct bch_fs *c)",
        "{",
        "\tstruct btree_trans *trans;"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\debug.c",
      "line": 819,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "};",
        "",
        "/* walk btree transactions until we find a deadlock and print it */",
        "static void btree_deadlock_to_text(struct printbuf *out, struct bch_fs *c)",
        "{",
        "\tstruct btree_trans *trans;",
        "\tulong iter = 0;"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\debug.c",
      "line": 838,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t\tu32 seq = seqmutex_unlock(&c->btree_trans_lock);",
        "",
        "\t\tbool found = bch2_check_for_deadlock(trans, out) != 0;",
        "",
        "\t\tclosure_put(&trans->ref);",
        ""
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\debug.c",
      "line": 879,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\treturn ret ?: i->ret;",
        "}",
        "",
        "static ssize_t bch2_btree_deadlock_read(struct file *file, char __user *buf,",
        "\t\t\t\t\tsize_t size, loff_t *ppos)",
        "{",
        "\treturn bch2_simple_print(file, buf, size, ppos, btree_deadlock_to_text);"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\debug.c",
      "line": 882,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "static ssize_t bch2_btree_deadlock_read(struct file *file, char __user *buf,",
        "\t\t\t\t\tsize_t size, loff_t *ppos)",
        "{",
        "\treturn bch2_simple_print(file, buf, size, ppos, btree_deadlock_to_text);",
        "}",
        "",
        "static const struct file_operations btree_deadlock_ops = {"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\debug.c",
      "line": 885,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\treturn bch2_simple_print(file, buf, size, ppos, btree_deadlock_to_text);",
        "}",
        "",
        "static const struct file_operations btree_deadlock_ops = {",
        "\t.owner\t\t= THIS_MODULE,",
        "\t.open\t\t= bch2_dump_open,",
        "\t.release\t= bch2_dump_release,"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\debug.c",
      "line": 889,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t.owner\t\t= THIS_MODULE,",
        "\t.open\t\t= bch2_dump_open,",
        "\t.release\t= bch2_dump_release,",
        "\t.read\t\t= bch2_btree_deadlock_read,",
        "};",
        "",
        "static ssize_t bch2_write_points_read(struct file *file, char __user *buf,"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\debug.c",
      "line": 957,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tdebugfs_create_file(\"btree_transaction_stats\", 0400, c->fs_debug_dir,",
        "\t\t\t    c, &btree_transaction_stats_op);",
        "",
        "\tdebugfs_create_file(\"btree_deadlock\", 0400, c->fs_debug_dir,",
        "\t\t\t    c->btree_debug, &btree_deadlock_ops);",
        "",
        "\tdebugfs_create_file(\"write_points\", 0400, c->fs_debug_dir,"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\debug.c",
      "line": 958,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t    c, &btree_transaction_stats_op);",
        "",
        "\tdebugfs_create_file(\"btree_deadlock\", 0400, c->fs_debug_dir,",
        "\t\t\t    c->btree_debug, &btree_deadlock_ops);",
        "",
        "\tdebugfs_create_file(\"write_points\", 0400, c->fs_debug_dir,",
        "\t\t\t    c->btree_debug, &write_points_ops);"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\fs-io-buffered.c",
      "line": 1003,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "again:",
        "\t\t/*",
        "\t\t * Bring in the user page that we will copy from _first_.",
        "\t\t * Otherwise there's a nasty deadlock on copying from the",
        "\t\t * same page as we're writing to, without it being marked",
        "\t\t * up-to-date.",
        "\t\t *"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\fs-io-direct.c",
      "line": 128,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * This is one of the sketchier things I've encountered: we have to skip",
        "\t * the dirtying of requests that are internal from the kernel (i.e. from",
        "\t * loopback), because we'll deadlock on page_lock.",
        "\t */",
        "\tdio->should_dirty = iter_is_iovec(iter);",
        ""
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\fs.c",
      "line": 621,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t *",
        "\t * also, calling bch2_inode_hash_insert() without passing in the",
        "\t * transaction object is sketchy - if we could ever end up in",
        "\t * __wait_on_freeing_inode(), we'd risk deadlock.",
        "\t *",
        "\t * But that shouldn't be possible, since we still have the inode locked",
        "\t * that we just created, and we _really_ can't take a transaction"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\move.c",
      "line": 424,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use after free",
      "context": [
        "\tmutex_unlock(&ctxt->lock);",
        "",
        "\t/*",
        "\t * dropped by move_read_endio() - guards against use after free of",
        "\t * ctxt when doing wakeup",
        "\t */",
        "\tclosure_get(&ctxt->cl);"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\recovery.c",
      "line": 382,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * First, attempt to replay keys in sorted order. This is more",
        "\t * efficient - better locality of btree access -  but some might fail if",
        "\t * that would cause a journal deadlock.",
        "\t */",
        "\tdarray_for_each(*keys, k) {",
        "\t\tcond_resched();"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\six.c",
      "line": 482,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t * If should_sleep_fn() returns an error, we are",
        "\t\t\t * required to return that error even if we already",
        "\t\t\t * acquired the lock - should_sleep_fn() might have",
        "\t\t\t * modified external state (e.g. when the deadlock cycle",
        "\t\t\t * detector in bcachefs issued a transaction restart)",
        "\t\t\t */",
        "\t\t\traw_spin_lock(&lock->wait_lock);"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\six.c",
      "line": 521,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * @ip:\t\tip parameter for lockdep/lockstat, i.e. _THIS_IP_",
        " *",
        " * This is the most general six_lock() variant, with parameters to support full",
        " * cycle detection for deadlock avoidance.",
        " *",
        " * The code calling this function must implement tracking of held locks, and the",
        " * @wait object should be embedded into the struct that tracks held locks -"
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\six.c",
      "line": 808,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * When an upper layer is implementing lock reentrency, we may have both read",
        " * and intent locks on the same lock.",
        " *",
        " * When we need to take a write lock, the read locks will cause self-deadlock,",
        " * because six locks themselves do not track which read locks are held by the",
        " * current thread and which are held by a different thread - it does no",
        " * per-thread tracking of held locks."
      ]
    },
    {
      "file": "linux\\fs\\bcachefs\\super-io.c",
      "line": 1059,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "\t\tenumerated_ref_get(&ca->io_ref[READ], BCH_DEV_READ_REF_write_super);",
        "\t}",
        "",
        "\t/* Make sure we're using the new magic numbers: */",
        "\tc->disk_sb.sb->magic = BCHFS_MAGIC;",
        "\tc->disk_sb.sb->layout.magic = BCHFS_MAGIC;",
        ""
      ]
    },
    {
      "file": "linux\\fs\\befs\\datastream.c",
      "line": 192,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Double indir block, plus all the indirect block",
      "context": [
        "\t\tmetablocks += ds->indirect.len;",
        "",
        "\t/*",
        "\t * Double indir block, plus all the indirect blocks it maps.",
        "\t * In the double-indirect range, all block runs of data are",
        "\t * BEFS_DBLINDIR_BRUN_LEN blocks long. Therefore, we know",
        "\t * how many data block runs are in the double-indirect region,"
      ]
    },
    {
      "file": "linux\\fs\\befs\\datastream.c",
      "line": 193,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double-indirect range, all block",
      "context": [
        "",
        "\t/*",
        "\t * Double indir block, plus all the indirect blocks it maps.",
        "\t * In the double-indirect range, all block runs of data are",
        "\t * BEFS_DBLINDIR_BRUN_LEN blocks long. Therefore, we know",
        "\t * how many data block runs are in the double-indirect region,",
        "\t * and from that we know how many indirect blocks it takes to"
      ]
    },
    {
      "file": "linux\\fs\\befs\\datastream.c",
      "line": 396,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double-indirect block",
      "context": [
        " * maps a particular filesystem block.",
        " *",
        " * We do this in two stages. First we calculate which of the",
        " * inode addresses in the double-indirect block will point us",
        " * to the indirect block that contains the mapping for the data,",
        " * then we calculate which of the inode addresses in that",
        " * indirect block maps the data block we are after."
      ]
    },
    {
      "file": "linux\\fs\\befs\\datastream.c",
      "line": 403,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double-indirect run may be several block",
      "context": [
        " *",
        " * Oh, and once we've done that, we actually read in the blocks",
        " * that contain the inode addresses we calculated above. Even",
        " * though the double-indirect run may be several blocks long,",
        " * we can calculate which of those blocks will contain the index",
        " * we are after and only read that one. We then follow it to",
        " * the indirect block and perform a similar process to find"
      ]
    },
    {
      "file": "linux\\fs\\befs\\datastream.c",
      "line": 439,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double indirect block",
      "context": [
        "\toff_t dbl_indir_off = blockno - indir_start_blk;",
        "",
        "\t/* number of data blocks mapped by each of the iaddrs in",
        "\t * the indirect block pointed to by the double indirect block",
        "\t */",
        "\tsize_t iblklen = BEFS_DBLINDIR_BRUN_LEN;",
        ""
      ]
    },
    {
      "file": "linux\\fs\\befs\\datastream.c",
      "line": 444,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double indirect block",
      "context": [
        "\tsize_t iblklen = BEFS_DBLINDIR_BRUN_LEN;",
        "",
        "\t/* number of data blocks mapped by each of the iaddrs in",
        "\t * the double indirect block",
        "\t */",
        "\tsize_t diblklen = iblklen * befs_iaddrs_per_block(sb)",
        "\t    * BEFS_DBLINDIR_BRUN_LEN;"
      ]
    },
    {
      "file": "linux\\fs\\befs\\datastream.c",
      "line": 451,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_indir->indir block",
      "context": [
        "",
        "\tbefs_debug(sb, \"---> %s find %lu\", __func__, (unsigned long)blockno);",
        "",
        "\t/* First, discover which of the double_indir->indir blocks",
        "\t * contains pos. Then figure out how much of pos that",
        "\t * accounted for. Then discover which of the iaddrs in",
        "\t * the indirect block contains pos."
      ]
    },
    {
      "file": "linux\\fs\\befs\\datastream.c",
      "line": 461,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double indirect block",
      "context": [
        "\tdblindir_leftover = dbl_indir_off % diblklen;",
        "\tindir_indx = dblindir_leftover / diblklen;",
        "",
        "\t/* Read double indirect block */",
        "\tdbl_which_block = dblindir_indx / befs_iaddrs_per_block(sb);",
        "\tif (dbl_which_block > data->double_indirect.len) {",
        "\t\tbefs_error(sb, \"The double-indirect index calculated by \""
      ]
    },
    {
      "file": "linux\\fs\\befs\\datastream.c",
      "line": 466,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double-indirect block",
      "context": [
        "\tif (dbl_which_block > data->double_indirect.len) {",
        "\t\tbefs_error(sb, \"The double-indirect index calculated by \"",
        "\t\t\t   \"%s, %d, is outside the range \"",
        "\t\t\t   \"of the double-indirect block\", __func__,",
        "\t\t\t   dblindir_indx);",
        "\t\treturn BEFS_ERR;",
        "\t}"
      ]
    },
    {
      "file": "linux\\fs\\befs\\datastream.c",
      "line": 476,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double-indirect block at block",
      "context": [
        "\t\t\t\t\tdbl_which_block);",
        "\tif (dbl_indir_block == NULL) {",
        "\t\tbefs_error(sb, \"%s couldn't read the \"",
        "\t\t\t   \"double-indirect block at blockno %lu\", __func__,",
        "\t\t\t   (unsigned long)",
        "\t\t\t   iaddr2blockno(sb, &data->double_indirect) +",
        "\t\t\t   dbl_which_block);"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\acl.c",
      "line": 83,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tsize = posix_acl_xattr_size(acl->a_count);",
        "\t\t/*",
        "\t\t * We're holding a transaction handle, so use a NOFS memory",
        "\t\t * allocation context to avoid deadlock if reclaim happens.",
        "\t\t */",
        "\t\tnofs_flag = memalloc_nofs_save();",
        "\t\tvalue = kmalloc(size, GFP_KERNEL);"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\async-thread.c",
      "line": 270,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t * on another Btrfs filesystem via, e.g., a loop device.",
        "\t\t\t * Therefore, we must not allow the current work item to",
        "\t\t\t * be recycled until we are really done, otherwise we",
        "\t\t\t * break the above assumption and can deadlock.",
        "\t\t\t */",
        "\t\t\tfree_self = true;",
        "\t\t} else {"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\block-group.c",
      "line": 164,
      "pattern": "null.*pointer.*dereference",
      "rule": "memory_management",
      "severity": "high",
      "match": "NULL pointer dereference",
      "context": [
        "\t\t/*",
        "\t\t * A block_group shouldn't be on the discard_list anymore.",
        "\t\t * Remove the block_group from the discard_list to prevent us",
        "\t\t * from causing a panic due to NULL pointer dereference.",
        "\t\t */",
        "\t\tif (WARN_ON(!list_empty(&cache->discard_list)))",
        "\t\t\tbtrfs_discard_cancel_work(&cache->fs_info->discard_ctl,"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\block-group.c",
      "line": 729,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\twakeup = false;",
        "#endif",
        "\t/*",
        "\t * We don't want to deadlock with somebody trying to allocate a new",
        "\t * extent for the extent root while also trying to search the extent",
        "\t * root to add free space.  So we skip locking and search the commit",
        "\t * root, since its read-only"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\block-group.c",
      "line": 4031,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *    group item to the extent btree and the device extent items to the devices",
        " *    btree.",
        " *",
        " * This is done to prevent deadlocks. For example when COWing a node from the",
        " * extent btree we are holding a write lock on the node's parent and if we",
        " * trigger chunk allocation and attempted to insert the new block group item",
        " * in the extent btree right way, we could deadlock because the path for the"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\block-group.c",
      "line": 4034,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * This is done to prevent deadlocks. For example when COWing a node from the",
        " * extent btree we are holding a write lock on the node's parent and if we",
        " * trigger chunk allocation and attempted to insert the new block group item",
        " * in the extent btree right way, we could deadlock because the path for the",
        " * insertion can include that parent node. At first glance it seems impossible",
        " * to trigger chunk allocation after starting a transaction since tasks should",
        " * reserve enough transaction units (metadata space), however while that is true"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\block-group.c",
      "line": 4108,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * as all the updates and insertions into the chunk btree must be done while",
        " * holding fs_info->chunk_mutex. This is important to guarantee that while COWing",
        " * an extent buffer from the chunks btree we never trigger allocation of a new",
        " * system chunk, which would result in a deadlock (trying to lock twice an",
        " * extent buffer of the chunk btree, first time before triggering the chunk",
        " * allocation and the second time during chunk allocation while attempting to",
        " * update the chunks btree). The system chunk array is also updated while holding"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\block-group.c",
      "line": 4149,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\treturn -ENOSPC;",
        "\t/*",
        "\t * Allocation of system chunks can not happen through this path, as we",
        "\t * could end up in a deadlock if we are allocating a data or metadata",
        "\t * chunk and there is another task modifying the chunk btree.",
        "\t *",
        "\t * This is because while we are holding the chunk mutex, we will attempt"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\block-group.c",
      "line": 4157,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * device item in the chunk btree, while the other task that is modifying",
        "\t * the chunk btree is attempting to COW an extent buffer while holding a",
        "\t * lock on it and on its parent - if the COW operation triggers a system",
        "\t * chunk allocation, then we can deadlock because we are holding the",
        "\t * chunk mutex and we may need to access that extent buffer or its parent",
        "\t * in order to add the chunk item or update a device item.",
        "\t *"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\block-group.c",
      "line": 4380,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *\t\t\tof an existing item.",
        " *",
        " * This is used in a context where we need to update the chunk btree outside",
        " * block group allocation and removal, to avoid a deadlock with a concurrent",
        " * task that is allocating a metadata or data block group and therefore needs to",
        " * update the chunk btree while holding the chunk mutex. After the update to the",
        " * chunk btree is done, btrfs_trans_release_chunk_metadata() should be called."
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\backref.c",
      "line": 1668,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t\t\t * We have transferred the inode list ownership from",
        "\t\t\t * this ref to the ref we added to the 'refs' ulist.",
        "\t\t\t * So set this ref's inode list to NULL to avoid",
        "\t\t\t * use-after-free when our caller uses it or double",
        "\t\t\t * frees in case an error happens before we return.",
        "\t\t\t */",
        "\t\t\tref->inode_list = NULL;"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\backref.c",
      "line": 1635,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double free",
      "context": [
        "\t\t\t\tref->inode_list = eie;",
        "\t\t\t\t/*",
        "\t\t\t\t * We transferred the list ownership to the ref,",
        "\t\t\t\t * so set to NULL to avoid a double free in case",
        "\t\t\t\t * an error happens after this.",
        "\t\t\t\t */",
        "\t\t\t\teie = NULL;"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\backref.c",
      "line": 1564,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing_keys(ctx->fs_info, &preftrees, path->skip_lock",
      "context": [
        "",
        "\tbtrfs_release_path(path);",
        "",
        "\tret = add_missing_keys(ctx->fs_info, &preftrees, path->skip_locking == 0);",
        "\tif (ret)",
        "\t\tgoto out;",
        ""
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\backref.c",
      "line": 2119,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer would overflow",
      "context": [
        " * \"size\" bytes in \"dest\". the dest buffer will be filled backwards. finally,",
        " * the start point of the resulting string is returned. this pointer is within",
        " * dest, normally.",
        " * in case the path buffer would overflow, the pointer is decremented further",
        " * as if output was written to the buffer, though no more output is actually",
        " * generated. that way, the caller can determine how much space would be",
        " * required for the path to fit into the buffer. in that case, the returned"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\compression.c",
      "line": 882,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * time is bounded so we get to a workspace eventually. This",
        "\t\t * makes our caller's life easier.",
        "\t\t *",
        "\t\t * To prevent silent and low-probability deadlocks (when the",
        "\t\t * initial preallocation fails), check if there are any",
        "\t\t * workspaces at all.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\defrag.c",
      "line": 493,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * We don't need a lock on a leaf. btrfs_realloc_node() will lock all",
        "\t * leafs from path->nodes[1], so set lowest_level to 1 to avoid later",
        "\t * a deadlock (attempting to write lock an already write locked leaf).",
        "\t */",
        "\tpath->lowest_level = 1;",
        "\twret = btrfs_search_slot(trans, root, &key, path, 0, 1);"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\defrag.c",
      "line": 1016,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * If this range of the extent map is already flagged for delalloc,",
        "\t\t * skip it, because:",
        "\t\t *",
        "\t\t * 1) We could deadlock later, when trying to reserve space for",
        "\t\t *    delalloc, because in case we can't immediately reserve space",
        "\t\t *    the flusher can start delalloc and wait for the respective",
        "\t\t *    ordered extents to complete. The deadlock would happen"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\defrag.c",
      "line": 1019,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * 1) We could deadlock later, when trying to reserve space for",
        "\t\t *    delalloc, because in case we can't immediately reserve space",
        "\t\t *    the flusher can start delalloc and wait for the respective",
        "\t\t *    ordered extents to complete. The deadlock would happen",
        "\t\t *    because we do the space reservation while holding the range",
        "\t\t *    locked, and starting writeback, or finishing an ordered",
        "\t\t *    extent, requires locking the range;"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\defrag.c",
      "line": 1246,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * which range really needs to be defragged.",
        "\t *",
        "\t * And this time we have extent locked already, pass @locked = true",
        "\t * so that we won't relock the extent range and cause deadlock.",
        "\t */",
        "\tret = defrag_collect_targets(inode, start, len, extent_thresh,",
        "\t\t\t\t     newer_than, do_compress, true,"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\delalloc-space.c",
      "line": 333,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * lockdep shut its filthy mouth.",
        "\t *",
        "\t * If we have a transaction open (can happen if we call truncate_block",
        "\t * from truncate), then we need FLUSH_LIMIT so we don't deadlock.",
        "\t */",
        "\tif (noflush || btrfs_is_free_space_inode(inode)) {",
        "\t\tflush = BTRFS_RESERVE_NO_FLUSH;"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\delayed-inode.c",
      "line": 1168,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t}",
        "",
        "\t/*",
        "\t * Release the path to avoid a potential deadlock and lockdep splat when",
        "\t * releasing the delayed node, as that requires taking the delayed node's",
        "\t * mutex. If another task starts running delayed items before we take",
        "\t * the mutex, it will first lock the mutex and then it may try to lock"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\direct-io.c",
      "line": 93,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t * If we are doing a DIO read and the ordered extent we",
        "\t\t\t * found is for a buffered write, we can not wait for it",
        "\t\t\t * to complete and retry, because if we do so we can",
        "\t\t\t * deadlock with concurrent buffered writes on page",
        "\t\t\t * locks. This happens only if our DIO read covers more",
        "\t\t\t * than one extent map, if at this point has already",
        "\t\t\t * created an ordered extent for a previous extent map"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\direct-io.c",
      "line": 115,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t * We could trigger writeback for this range (and wait",
        "\t\t\t * for it to complete) and then invalidate the pages for",
        "\t\t\t * this range (through invalidate_inode_pages2_range()),",
        "\t\t\t * but that can lead us to a deadlock with a concurrent",
        "\t\t\t * call to readahead (a buffered read or a defrag call",
        "\t\t\t * triggered a readahead) on a page lock due to an",
        "\t\t\t * ordered dio extent we created before but did not have"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\direct-io.c",
      "line": 429,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * We always try to allocate data space and must do it before locking",
        "\t * the file range, to avoid deadlocks with concurrent writes to the same",
        "\t * range if the range has several extents and the writes don't expand the",
        "\t * current i_size (the inode lock is taken in shared mode). If we fail to",
        "\t * allocate data space here we continue and later, after locking the"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\direct-io.c",
      "line": 730,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * Check if we are doing a partial write.  If we are, we need to split",
        "\t * the ordered extent to match the submitted bio.  Hang on to the",
        "\t * remaining unfinishable ordered_extent in dio_data so that it can be",
        "\t * cancelled in iomap_end to avoid a deadlock wherein faulting the",
        "\t * remaining pages is blocked on the outstanding ordered extent.",
        "\t */",
        "\tif (iter->flags & IOMAP_WRITE) {"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\direct-io.c",
      "line": 877,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * The iov_iter can be mapped to the same file range we are writing to.",
        "\t * If that's the case, then we will deadlock in the iomap code, because",
        "\t * it first calls our callback btrfs_dio_iomap_begin(), which will create",
        "\t * an ordered extent, and after that it will fault in the pages that the",
        "\t * iov_iter refers to. During the fault in we end up in the readahead"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\direct-io.c",
      "line": 883,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * iov_iter refers to. During the fault in we end up in the readahead",
        "\t * pages code (starting at btrfs_readahead()), which will lock the range,",
        "\t * find that ordered extent and then wait for it to complete (at",
        "\t * btrfs_lock_and_flush_ordered_range()), resulting in a deadlock since",
        "\t * obviously the ordered extent can never complete as we didn't submit",
        "\t * yet the respective bio(s). This always happens when the buffer is",
        "\t * memory mapped to the same file range, since the iomap DIO code always"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\direct-io.c",
      "line": 904,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t/*",
        "\t\t * If we have a synchronous write, we must make sure the fsync",
        "\t\t * triggered by the iomap_dio_complete() call below doesn't",
        "\t\t * deadlock on the inode lock - we are already holding it and we",
        "\t\t * can't call it after unlocking because we may need to complete",
        "\t\t * partial writes due to the input buffer (or parts of it) not",
        "\t\t * being already faulted in."
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\direct-io.c",
      "line": 1038,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * which can still trigger page fault ins despite having set ->nofault",
        "\t * to true of our 'to' iov_iter.",
        "\t *",
        "\t * The difference to direct IO writes is that we deadlock when trying",
        "\t * to lock the extent range in the inode's tree during he page reads",
        "\t * triggered by the fault in (while for writes it is due to waiting for",
        "\t * our own ordered extent). This is because for direct IO reads,"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\disk-io.c",
      "line": 4262,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t * Wait for any fixup workers to complete.",
        "\t * If we don't wait for them here and they are still running by the time",
        "\t * we call kthread_stop() against the cleaner kthread further below, we",
        "\t * get an use-after-free on the cleaner because the fixup worker adds an",
        "\t * inode to the list of delayed iputs and then attempts to wakeup the",
        "\t * cleaner kthread, which was already stopped and destroyed. We parked",
        "\t * already the cleaner, but below we run all pending delayed iputs."
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\disk-io.c",
      "line": 1386,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double free",
      "context": [
        "\t/*",
        "\t * If our caller provided us an anonymous device, then it's his",
        "\t * responsibility to free it in case we fail. So we have to set our",
        "\t * root's anon_dev to 0 to avoid a double free, once by btrfs_put_root()",
        "\t * and once again by our caller.",
        "\t */",
        "\tif (anon_dev && *anon_dev)"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\disk-io.c",
      "line": 852,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * We're holding a transaction handle, so use a NOFS memory allocation",
        "\t * context to avoid deadlock if reclaim happens.",
        "\t */",
        "\tnofs_flag = memalloc_nofs_save();",
        "\troot = btrfs_alloc_root(fs_info, objectid, GFP_KERNEL);"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\disk-io.c",
      "line": 4367,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * and then a transaction commit runs the same delayed nodes",
        "\t\t * before any delayed worker has done something with the nodes.",
        "\t\t * We must wait for any worker here and not at transaction",
        "\t\t * commit time since that could cause a deadlock.",
        "\t\t * This is a very rare case.",
        "\t\t */",
        "\t\tbtrfs_flush_workqueue(fs_info->delayed_workers);"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\extent_io.c",
      "line": 2223,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t * If something went wrong, don't allow any metadata write bio to be",
        "\t * submitted.",
        "\t *",
        "\t * This would prevent use-after-free if we had dirty pages not",
        "\t * cleaned up, which can still happen by fuzzed images.",
        "\t *",
        "\t * - Bad extent tree"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\extent_io.c",
      "line": 2431,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t/*",
        "\t\t * If we're looping we could run into a page that is locked by a",
        "\t\t * writer and that writer could be waiting on writeback for a",
        "\t\t * page in our current bio, and thus deadlock, so flush the",
        "\t\t * write bio here.",
        "\t\t */",
        "\t\tsubmit_write_bio(bio_ctrl, 0);"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\extent-tree.c",
      "line": 3407,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tgoto out;",
        "",
        "\t/*",
        "\t * waiting for the lock here would deadlock.  If someone else has it",
        "\t * locked they are already in the process of dropping it anyway",
        "\t */",
        "\tif (!mutex_trylock(&head->mutex))"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\extent-tree.c",
      "line": 4079,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * We already reached the max active zones. Try to finish one block",
        "\t * group to make a room for a new block group. This is only possible",
        "\t * for a data block group because btrfs_zone_finish() may need to wait",
        "\t * for a running transaction which can cause a deadlock for metadata",
        "\t * allocation.",
        "\t */",
        "\tif (ffe_ctl->flags & BTRFS_BLOCK_GROUP_DATA) {"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\fiemap.c",
      "line": 35,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * - Store extents ready to be written to the fiemap buffer in an intermediary",
        " *   buffer. This intermediary buffer is to ensure that in case the fiemap",
        " *   buffer is memory mapped to the fiemap target file, we don't deadlock",
        " *   during btrfs_page_mkwrite(). This is because during fiemap we are locking",
        " *   an extent range in order to prevent races with delalloc flushing and",
        " *   ordered extent completion, which is needed in order to reliably detect"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\fiemap.c",
      "line": 39,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *   during btrfs_page_mkwrite(). This is because during fiemap we are locking",
        " *   an extent range in order to prevent races with delalloc flushing and",
        " *   ordered extent completion, which is needed in order to reliably detect",
        " *   delalloc in holes and prealloc extents. And this can lead to a deadlock",
        " *   if the fiemap buffer is memory mapped to the file we are running fiemap",
        " *   against (a silly, useless in practice scenario, but possible) because",
        " *   btrfs_page_mkwrite() will try to lock the same extent range."
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\fiemap.c",
      "line": 863,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * may have a non-cloned leaf and if the fiemap buffer is memory mapped",
        "\t * to a file, a write into it (through btrfs_page_mkwrite()) may trigger",
        "\t * waiting for an ordered extent that in order to complete needs to",
        "\t * modify that leaf, therefore leading to a deadlock.",
        "\t */",
        "\tbtrfs_free_path(path);",
        "\tpath = NULL;"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\file-item.c",
      "line": 392,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * the free space stuff is only read when it hasn't been",
        "\t * updated in the current transaction.  So, we can safely",
        "\t * read from the commit root and sidestep a nasty deadlock",
        "\t * between reading the free space cache and updating the csum tree.",
        "\t */",
        "\tif (btrfs_is_free_space_inode(inode)) {"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\file.c",
      "line": 1310,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\t * offset is >= i_size, we might still have a non-NULL cached extent",
        "\t * state, acquired while marking the extent range as delalloc through",
        "\t * btrfs_dirty_page(). Therefore free any possible cached extent state",
        "\t * to avoid a memory leak.",
        "\t */",
        "\tif (extents_locked)",
        "\t\tbtrfs_unlock_extent(&inode->io_tree, lockstart, lockend, &cached_state);"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\file.c",
      "line": 1762,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t *",
        "\t * If we didn't do a full sync we have to stop the trans handle, wait on",
        "\t * the ordered extents, start it again and commit the transaction.  If",
        "\t * we attempt to wait on the ordered extents here we could deadlock with",
        "\t * something like fallocate() that is holding the extent lock trying to",
        "\t * start a transaction while some other thread is trying to commit the",
        "\t * transaction while we (fsync) are currently holding the transaction"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\file.c",
      "line": 1859,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Reserving delalloc space after obtaining the page lock can lead to",
        "\t * deadlock. For example, if a dirty page is locked by this function",
        "\t * and the call to btrfs_delalloc_reserve_space() ends up triggering",
        "\t * dirty page write out, then the btrfs_writepages() function could",
        "\t * end up waiting indefinitely to get a lock on the page currently"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\free-space-tree.c",
      "line": 1670,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\treturn -ENOMEM;",
        "",
        "\t/*",
        "\t * Just like caching_thread() doesn't want to deadlock on the extent",
        "\t * tree, we don't want to deadlock on the free space tree.",
        "\t */",
        "\tpath->skip_locking = 1;"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\free-space-tree.c",
      "line": 1671,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Just like caching_thread() doesn't want to deadlock on the extent",
        "\t * tree, we don't want to deadlock on the free space tree.",
        "\t */",
        "\tpath->skip_locking = 1;",
        "\tpath->search_commit_root = 1;"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\free-space-cache.c",
      "line": 116,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * We are often under a trans handle at this point, so we need to make",
        "\t * sure NOFS is set to keep us from deadlocking.",
        "\t */",
        "\tnofs_flag = memalloc_nofs_save();",
        "\tinode = btrfs_iget_path(location.objectid, root, path);"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\free-space-cache.c",
      "line": 976,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * We must pass a path with search_commit_root set to btrfs_iget in",
        "\t * order to avoid a deadlock when allocating extents for the tree root.",
        "\t *",
        "\t * When we are COWing an extent buffer from the tree root, when looking",
        "\t * for a free extent, at extent-tree.c:find_free_extent(), we can find"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\free-space-cache.c",
      "line": 984,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * we must load its space cache which requires reading its free space",
        "\t * cache's inode item from the root tree. If this inode item is located",
        "\t * in the same leaf that we started COWing before, then we end up in",
        "\t * deadlock on the extent buffer (trying to read lock it when we",
        "\t * previously write locked it).",
        "\t *",
        "\t * It's safe to read the inode item using the commit root because"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\ioctl.c",
      "line": 804,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double free",
      "context": [
        "\tret = 0;",
        "\tpending_snapshot->anon_dev = 0;",
        "fail:",
        "\t/* Prevent double freeing of anon_dev */",
        "\tif (ret && pending_snapshot->snap)",
        "\t\tpending_snapshot->snap->anon_dev = 0;",
        "\tbtrfs_put_root(pending_snapshot->snap);"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\ioctl.c",
      "line": 1907,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t\t\t/*",
        "\t\t\t * We don't need the path anymore, so release it and",
        "\t\t\t * avoid deadlocks and lockdep warnings in case",
        "\t\t\t * btrfs_iget() needs to lookup the inode from its root",
        "\t\t\t * btree and lock the same leaf.",
        "\t\t\t */"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\ioctl.c",
      "line": 3698,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * cleaner_mutex -> inode_lock -> subvol_sem",
        "\t\t *",
        "\t\t * so we must take the cleaner_mutex here before we take the",
        "\t\t * subvol_sem.  The deadlock can't actually happen, but this",
        "\t\t * quiets lockdep.",
        "\t\t */",
        "\t\tmutex_lock(&fs_info->cleaner_mutex);"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\locking.c",
      "line": 28,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * roots have separate keysets.",
        " *",
        " * Lock-nesting across peer nodes is always done with the immediate parent",
        " * node locked thus preventing deadlock.  As lockdep doesn't know this, use",
        " * subclass to avoid triggering lockdep warning in such cases.",
        " *",
        " * The key is set by the readpage_end_io_hook after the buffer has passed"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\locking.c",
      "line": 304,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double-reader-writer-exclusion lock",
      "context": [
        " * DREW locks",
        " * ==========",
        " *",
        " * DREW stands for double-reader-writer-exclusion lock. It's used in situation",
        " * where you want to provide A-B exclusion but not AA or BB.",
        " *",
        " * Currently implementation gives more priority to reader. If a reader and a"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\inode.c",
      "line": 5346,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t * anyone else holding locked ranges without having bumped the inode's",
        "\t * reference count - if we don't do it, when they access the inode's",
        "\t * io_tree to unlock a range it may be too late, leading to an",
        "\t * use-after-free issue.",
        "\t */",
        "\tspin_lock(&io_tree->lock);",
        "\twhile (!RB_EMPTY_ROOT(&io_tree->state)) {"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\inode.c",
      "line": 7360,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use use-after-free",
      "context": [
        "/*",
        " * For release_folio() and invalidate_folio() we have a race window where",
        " * folio_end_writeback() is called but the subpage spinlock is not yet released.",
        " * If we continue to release/invalidate the page, we could cause use-after-free",
        " * for subpage spinlock.  So this function is to spin and wait for subpage",
        " * spinlock.",
        " */"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\inode.c",
      "line": 2849,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * As a precaution, do a delayed iput in case it would be the last iput",
        "\t * that could need flushing space. Recursing back to fixup worker would",
        "\t * deadlock.",
        "\t */",
        "\tbtrfs_add_delayed_iput(inode);",
        "}"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\inode.c",
      "line": 3123,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * inserting/replacing file extent items and unpinning an extent map.",
        "\t * This must be taken before joining a transaction, as it's a higher",
        "\t * level lock (like the inode's VFS lock), otherwise we can run into an",
        "\t * ABBA deadlock with other tasks (transactions work like a lock,",
        "\t * depending on their current state).",
        "\t */",
        "\tif (!test_bit(BTRFS_ORDERED_NOCOW, &ordered_extent->flags)) {"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\inode.c",
      "line": 3463,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * btrfs_put_ordered_extent() can run in irq context (see bio.c), which",
        "\t * calls btrfs_add_delayed_iput() and that needs to lock",
        "\t * fs_info->delayed_iput_lock. So we need to disable irqs here to",
        "\t * prevent a deadlock.",
        "\t */",
        "\tspin_lock_irq(&fs_info->delayed_iput_lock);",
        "\twhile (!list_empty(&fs_info->delayed_iputs)) {"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\inode.c",
      "line": 4166,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tint ret;",
        "",
        "\t/*",
        "\t * If the inode is a free space inode, we can deadlock during commit",
        "\t * if we put it into the delayed code.",
        "\t *",
        "\t * The data relocation inode should also be directly updated"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\inode.c",
      "line": 5398,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Eviction should be taking place at some place safe because of our",
        "\t * delayed iputs.  However the normal flushing code will run delayed",
        "\t * iputs, so we cannot use FLUSH_ALL otherwise we'll deadlock.",
        "\t *",
        "\t * We reserve the delayed_refs_extra here again because we can't use",
        "\t * btrfs_start_transaction(root, 0) for the same deadlocky reason as"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\inode.c",
      "line": 5401,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * iputs, so we cannot use FLUSH_ALL otherwise we'll deadlock.",
        "\t *",
        "\t * We reserve the delayed_refs_extra here again because we can't use",
        "\t * btrfs_start_transaction(root, 0) for the same deadlocky reason as",
        "\t * above.  We reserve our extra bit here because we generate a ton of",
        "\t * delayed refs activity by truncating.",
        "\t *"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\inode.c",
      "line": 7740,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * We can't call btrfs_truncate_block inside a trans handle as we could",
        "\t * deadlock with freeze, if we got BTRFS_NEED_TRUNCATE_BLOCK then we",
        "\t * know we've truncated everything except the last little bit, and can",
        "\t * do btrfs_truncate_block and then update the disk_i_size.",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\inode.c",
      "line": 10231,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tbackref_ctx->curr_leaf_bytenr = leaf->start;",
        "",
        "\t\t/*",
        "\t\t * Don't need the path anymore, release to avoid deadlocks when",
        "\t\t * calling btrfs_is_data_extent_shared() because when joining a",
        "\t\t * transaction it can block waiting for the current one's commit",
        "\t\t * which in turn may be trying to lock the same leaf to flush"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\messages.c",
      "line": 178,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Note that a running device replace operation is not canceled here",
        "\t * although there is no way to update the progress. It would add the",
        "\t * risk of a deadlock, therefore the canceling is omitted. The only",
        "\t * penalty is that some I/O remains active until the procedure",
        "\t * completes. The next time when the filesystem is mounted writable",
        "\t * again, the device replace operation continues."
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\print-tree.c",
      "line": 220,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "/*",
        " * Helper to output refs and locking status of extent buffer.  Useful to debug",
        " * race condition related problems.",
        " */",
        "static void print_eb_refs_lock(const struct extent_buffer *eb)",
        "{"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\raid56.c",
      "line": 2209,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t *   Then we are doing IO for tree blocks, no need to search csums.",
        "\t *",
        "\t * - The rbio belongs to mixed block groups",
        "\t *   This is to avoid deadlock, as we're already holding the full",
        "\t *   stripe lock, if we trigger a metadata read, and it needs to do",
        "\t *   raid56 recovery, we will deadlock.",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\raid56.c",
      "line": 2211,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * - The rbio belongs to mixed block groups",
        "\t *   This is to avoid deadlock, as we're already holding the full",
        "\t *   stripe lock, if we trigger a metadata read, and it needs to do",
        "\t *   raid56 recovery, we will deadlock.",
        "\t */",
        "\tif (!(rbio->bioc->map_type & BTRFS_BLOCK_GROUP_DATA) ||",
        "\t    rbio->bioc->map_type & BTRFS_BLOCK_GROUP_METADATA)"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\qgroup.c",
      "line": 3000,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t/*",
        "\t * We're done using the iterator, release all its qgroups while holding",
        "\t * fs_info->qgroup_lock so that we don't race with btrfs_remove_qgroup()",
        "\t * and trigger use-after-free accesses to qgroups.",
        "\t */",
        "\tqgroup_iterator_nested_clean(&qgroups);",
        ""
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\qgroup.c",
      "line": 652,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double free",
      "context": [
        "\t/*",
        "\t * We call btrfs_free_qgroup_config() when unmounting",
        "\t * filesystem and disabling quota, so we set qgroup_ulist",
        "\t * to be null here to avoid double free.",
        "\t */",
        "\tulist_free(fs_info->qgroup_ulist);",
        "\tfs_info->qgroup_ulist = NULL;"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\qgroup.c",
      "line": 4326,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double free",
      "context": [
        "\t\t * the modification.",
        "\t\t *",
        "\t\t * However as long as we free qgroup reserved according to",
        "\t\t * EXTENT_QGROUP_RESERVED, we won't double free.",
        "\t\t * So not need to rush.",
        "\t\t */",
        "\t\tret = btrfs_clear_record_extent_bits(&inode->io_tree, free_start,"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\qgroup.c",
      "line": 1219,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tmutex_unlock(&fs_info->qgroup_ioctl_lock);",
        "\t/*",
        "\t * Commit the transaction while not holding qgroup_ioctl_lock, to avoid",
        "\t * a deadlock with tasks concurrently doing other qgroup operations, such",
        "\t * adding/removing qgroups or adding/deleting qgroup relations for example,",
        "\t * because all qgroup operations first start or join a transaction and then",
        "\t * lock the qgroup_ioctl_lock mutex."
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\qgroup.c",
      "line": 1234,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Set quota enabled flag after committing the transaction, to avoid",
        "\t * deadlocks on fs_info->qgroup_ioctl_lock with concurrent snapshot",
        "\t * creation.",
        "\t */",
        "\tspin_lock(&fs_info->qgroup_lock);"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\qgroup.c",
      "line": 1341,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Unlock the qgroup_ioctl_lock mutex before waiting for the rescan worker to",
        "\t * complete. Otherwise we can deadlock because btrfs_remove_qgroup() needs",
        "\t * to lock that mutex while holding a transaction handle and the rescan",
        "\t * worker needs to commit a transaction.",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\qgroup.c",
      "line": 1350,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Request qgroup rescan worker to complete and wait for it. This wait",
        "\t * must be done before transaction start for quota disable since it may",
        "\t * deadlock with transaction by the qgroup rescan worker.",
        "\t */",
        "\tclear_bit(BTRFS_FS_QUOTA_ENABLED, &fs_info->flags);",
        "\tbtrfs_qgroup_wait_for_completion(fs_info, false);"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\qgroup.c",
      "line": 2083,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * So we want btrfs_find_all_roots() to not acquire the commit_root_sem",
        "\t * but we can't pass it a non-NULL transaction handle, because otherwise",
        "\t * it would not use commit roots and would lock extent buffers, causing",
        "\t * a deadlock if it ends up trying to read lock the same extent buffer",
        "\t * that was previously write locked at btrfs_truncate_inode_items().",
        "\t *",
        "\t * So pass a NULL transaction handle to btrfs_find_all_roots() and"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\qgroup.c",
      "line": 4171,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "{",
        "\tint ret;",
        "",
        "\t/* Can't hold an open transaction or we run the risk of deadlocking. */",
        "\tASSERT(current->journal_info == NULL);",
        "\tif (WARN_ON(current->journal_info))",
        "\t\treturn 0;"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\qgroup.c",
      "line": 2661,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Missing extent block",
      "context": [
        "\t\treturn -ENOMEM;",
        "",
        "\t/*",
        "\t * Walk down the tree.  Missing extent blocks are filled in as",
        "\t * we go. Metadata is accounted every time we read a new",
        "\t * extent block.",
        "\t *"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\ref-verify.c",
      "line": 424,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing root in new block",
      "context": [
        "\tre = lookup_root_entry(&be->roots, ref_root);",
        "\tif (!re) {",
        "\t\tspin_unlock(&fs_info->ref_verify_lock);",
        "\t\tbtrfs_err(fs_info, \"missing root in new block entry?\");",
        "\t\treturn -EINVAL;",
        "\t}",
        "\tre->num_refs += num_refs;"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\reflink.c",
      "line": 79,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * We have flushed and locked the ranges of the source and destination",
        "\t * inodes, we also have locked the inodes, so we are safe to do a",
        "\t * reservation here. Also we must not do the reservation while holding",
        "\t * a transaction open, otherwise we would deadlock.",
        "\t */",
        "\tret = btrfs_delalloc_reserve_space(inode, &data_reserved, file_offset,",
        "\t\t\t\t\t   block_size);"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\reflink.c",
      "line": 109,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * and if we are low on metadata free space, that can cause flushing of",
        "\t * delalloc for all inodes in order to get metadata space released.",
        "\t * However we are holding the range locked for the whole duration of",
        "\t * the clone/dedupe operation, so we may deadlock if that happens and no",
        "\t * other task releases enough space. So mark this inode as not being",
        "\t * possible to flush to avoid such deadlock. We will clear that flag",
        "\t * when we finish cloning all extents, since a transaction is started"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\reflink.c",
      "line": 111,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * However we are holding the range locked for the whole duration of",
        "\t * the clone/dedupe operation, so we may deadlock if that happens and no",
        "\t * other task releases enough space. So mark this inode as not being",
        "\t * possible to flush to avoid such deadlock. We will clear that flag",
        "\t * when we finish cloning all extents, since a transaction is started",
        "\t * after finding each extent to clone.",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\reflink.c",
      "line": 314,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * Release our path because we don't need it anymore and also because",
        "\t * copy_inline_to_page() needs to reserve data and metadata, which may",
        "\t * need to flush delalloc when we are low on available space and",
        "\t * therefore cause a deadlock if writeback of an inline extent needs to",
        "\t * write to the same leaf or an ordered extent completion needs to write",
        "\t * to the same leaf.",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\reflink.c",
      "line": 619,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_mmap_lock",
      "context": [
        "\treturn ret;",
        "}",
        "",
        "static void btrfs_double_mmap_lock(struct btrfs_inode *inode1, struct btrfs_inode *inode2)",
        "{",
        "\tif (inode1 < inode2)",
        "\t\tswap(inode1, inode2);"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\reflink.c",
      "line": 627,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_mmap_unlock",
      "context": [
        "\tdown_write_nested(&inode2->i_mmap_lock, SINGLE_DEPTH_NESTING);",
        "}",
        "",
        "static void btrfs_double_mmap_unlock(struct btrfs_inode *inode1, struct btrfs_inode *inode2)",
        "{",
        "\tup_write(&inode1->i_mmap_lock);",
        "\tup_write(&inode2->i_mmap_lock);"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\reflink.c",
      "line": 877,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_mmap_lock",
      "context": [
        "\t\tbtrfs_inode_lock(src_inode, BTRFS_ILOCK_MMAP);",
        "\t} else {",
        "\t\tlock_two_nondirectories(&src_inode->vfs_inode, &dst_inode->vfs_inode);",
        "\t\tbtrfs_double_mmap_lock(src_inode, dst_inode);",
        "\t}",
        "",
        "\tret = btrfs_remap_file_range_prep(src_file, off, dst_file, destoff,"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\reflink.c",
      "line": 895,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_mmap_unlock",
      "context": [
        "\tif (same_inode) {",
        "\t\tbtrfs_inode_unlock(src_inode, BTRFS_ILOCK_MMAP);",
        "\t} else {",
        "\t\tbtrfs_double_mmap_unlock(src_inode, dst_inode);",
        "\t\tunlock_two_nondirectories(&src_inode->vfs_inode,",
        "\t\t\t\t\t  &dst_inode->vfs_inode);",
        "\t}"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\relocation.c",
      "line": 2688,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t\t/*",
        "\t\t * Subpage can't handle page with DIRTY but without UPTODATE",
        "\t\t * bit as it can lead to the following deadlock:",
        "\t\t *",
        "\t\t * btrfs_read_folio()",
        "\t\t * | Page already *locked*"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\relocation.c",
      "line": 3934,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Relocation of a data block group creates ordered extents.  Without",
        "\t * sb_start_write(), we can freeze the filesystem while unfinished",
        "\t * ordered extents are left. Such ordered extents can cause a deadlock",
        "\t * e.g. when syncfs() is waiting for their completion but they can't",
        "\t * finish because they block when joining a transaction, due to the",
        "\t * fact that the freeze locks are being held in write mode."
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\scrub.c",
      "line": 222,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "Use a ref counter to avoid use-after-free",
      "context": [
        "\tspinlock_t\t\tstat_lock;",
        "",
        "\t/*",
        "\t * Use a ref counter to avoid use-after-free issues. Scrub workers",
        "\t * decrement bios_in_flight and workers_pending and then do a wakeup",
        "\t * on the list_wait wait queue. We must ensure the main scrub task",
        "\t * doesn't free the scrub context before or while the workers are"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\scrub.c",
      "line": 2722,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t\t/*",
        "\t\t * we need call btrfs_inc_block_group_ro() with scrubs_paused,",
        "\t\t * to avoid deadlock caused by:",
        "\t\t * btrfs_inc_block_group_ro()",
        "\t\t * -> btrfs_wait_for_commit()",
        "\t\t * -> btrfs_commit_transaction()"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\scrub.c",
      "line": 3101,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tmutex_unlock(&fs_info->scrub_lock);",
        "",
        "\t/*",
        "\t * In order to avoid deadlock with reclaim when there is a transaction",
        "\t * trying to pause scrub, make sure we use GFP_NOFS for all the",
        "\t * allocations done at btrfs_scrub_sectors() and scrub_sectors_for_parity()",
        "\t * invoked by our callees. The pausing request is done when the"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\send.c",
      "line": 7172,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * We can not hold the commit root semaphore here. This is because in",
        "\t * the case of sending and receiving to the same filesystem, using a",
        "\t * pipe, could result in a deadlock:",
        "\t *",
        "\t * 1) The task running send blocks on the pipe because it's full;",
        "\t *"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\space-info.c",
      "line": 99,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *   Same as the above, except we add ourselves to the",
        " *   space_info->priority_tickets, and we do not use ticket->wait, we simply",
        " *   call flush_space() ourselves for the states that are safe for us to call",
        " *   without deadlocking and hope for the best.",
        " *",
        " * THE FLUSHING STATES",
        " *"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\space-info.c",
      "line": 1745,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * If have a transaction handle (current->journal_info != NULL), then",
        "\t * the flush method can not be neither BTRFS_RESERVE_FLUSH_ALL* nor",
        "\t * BTRFS_RESERVE_FLUSH_EVICT, as we could deadlock because those",
        "\t * flushing methods can trigger transaction commits.",
        "\t */",
        "\tif (current->journal_info) {"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\subpage.c",
      "line": 59,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * - Metadata",
        " *   Since we have multiple tree blocks inside one page, we can't rely on page",
        " *   locking anymore, or we will have greatly reduced concurrency or even",
        " *   deadlocks (hold one tree lock while trying to lock another tree lock in",
        " *   the same page).",
        " *",
        " *   Thus for metadata locking, subpage support relies on io_tree locking only."
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\super.c",
      "line": 1197,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t}",
        "\t\tif (subvol_objectid && root_objectid != subvol_objectid) {",
        "\t\t\t/*",
        "\t\t\t * This will also catch a race condition where a",
        "\t\t\t * subvolume which was passed by ID is renamed and",
        "\t\t\t * another subvolume is renamed over the old location.",
        "\t\t\t */"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\super.c",
      "line": 1023,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t\treturn 0;",
        "\t\t\t/*",
        "\t\t\t * A non-blocking test if the fs is frozen. We must not",
        "\t\t\t * start a new transaction here otherwise a deadlock",
        "\t\t\t * happens. The pending operations are delayed to the",
        "\t\t\t * next commit after thawing.",
        "\t\t\t */"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\super.c",
      "line": 2491,
      "pattern": "long.*functions",
      "rule": "code_quality",
      "severity": "low",
      "match": "long init/exit functions",
      "context": [
        "\tunregister_filesystem(&btrfs_fs_type);",
        "}",
        "",
        "/* Helper structure for long init/exit functions. */",
        "struct init_sequence {",
        "\tint (*init_func)(void);",
        "\t/* Can be NULL if the init_func doesn't need cleanup. */"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\sysfs.c",
      "line": 1861,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Setup a NOFS context because kobject_add(), deep in its call chain,",
        "\t * does GFP_KERNEL allocations, and we are often called in a context",
        "\t * where if reclaim is triggered we can deadlock (we are either holding",
        "\t * a transaction handle or some lock required for a transaction",
        "\t * commit).",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\transaction.c",
      "line": 2051,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t * Now that we know no one else is still using the transaction we can",
        "\t * remove the transaction from the list of transactions. This avoids",
        "\t * the transaction kthread from cleaning up the transaction while some",
        "\t * other task is still using it, which could result in a use-after-free",
        "\t * on things like log trees, as it forces the transaction kthread to",
        "\t * wait for this transaction to be cleaned up by us.",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\transaction.c",
      "line": 693,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * waiting on this guy, so we don't need to do the sb_start_intwrite",
        "\t * because we're already holding a ref.  We need this because we could",
        "\t * have raced in and did an fsync() on a file which can kick a commit",
        "\t * and then we deadlock with somebody doing a freeze.",
        "\t *",
        "\t * If we are ATTACH, it means we just want to catch the current",
        "\t * transaction and commit it, so we needn't do sb_start_intwrite(). "
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\transaction.c",
      "line": 777,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * transaction.",
        "\t *",
        "\t * Thus it need to be called after current->journal_info initialized,",
        "\t * or we can deadlock.",
        "\t */",
        "\tret = btrfs_record_root_in_trans(h, root);",
        "\tif (ret) {"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\transaction.c",
      "line": 2078,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * If relocation is running, we can't cancel scrub because that will",
        "\t * result in a deadlock. Before relocating a block group, relocation",
        "\t * pauses scrub, then starts and commits a transaction before unpausing",
        "\t * scrub. If the transaction commit is being done by the relocation",
        "\t * task or triggered by another task and the relocation task is waiting"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\transaction.c",
      "line": 2083,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * scrub. If the transaction commit is being done by the relocation",
        "\t * task or triggered by another task and the relocation task is waiting",
        "\t * for the commit, and we end up here due to an error in the commit",
        "\t * path, then calling btrfs_scrub_cancel() will deadlock, as we are",
        "\t * asking for scrub to stop while having it asked to be paused higher",
        "\t * above in relocation code.",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\transaction.c",
      "line": 2119,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "{",
        "\t/*",
        "\t * We use try_to_writeback_inodes_sb() here because if we used",
        "\t * btrfs_start_delalloc_roots we would deadlock with fs freeze.",
        "\t * Currently are holding the fs freeze lock, if we do an async flush",
        "\t * we'll do btrfs_join_transaction() and deadlock because we need to",
        "\t * wait for the fs freeze lock.  Using the direct flushing we benefit"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\transaction.c",
      "line": 2121,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * We use try_to_writeback_inodes_sb() here because if we used",
        "\t * btrfs_start_delalloc_roots we would deadlock with fs freeze.",
        "\t * Currently are holding the fs freeze lock, if we do an async flush",
        "\t * we'll do btrfs_join_transaction() and deadlock because we need to",
        "\t * wait for the fs freeze lock.  Using the direct flushing we benefit",
        "\t * from already being in a transaction and our join_transaction doesn't",
        "\t * have to re-take the fs freeze lock."
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\tree-log.c",
      "line": 151,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * replaying a log tree, so we must make sure NOFS semantics apply",
        "\t * because btrfs_alloc_inode() may be triggered and it uses GFP_KERNEL",
        "\t * to allocate an inode, which can recurse back into the filesystem and",
        "\t * attempt a transaction commit, resulting in a deadlock.",
        "\t */",
        "\tnofs_flag = memalloc_nofs_save();",
        "\tinode = btrfs_iget(objectid, root);"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\tree-log.c",
      "line": 3103,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * As described above, -EAGAIN indicates a hole in the extents. We",
        "\t * cannot wait for these write outs since the waiting cause a",
        "\t * deadlock. Bail out to the full commit instead.",
        "\t */",
        "\tif (ret == -EAGAIN && btrfs_is_zoned(fs_info)) {",
        "\t\tbtrfs_set_log_full_commit(trans);"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\tree-log.c",
      "line": 4347,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tconst u64 i_size = i_size_read(&inode->vfs_inode);",
        "",
        "\t/*",
        "\t * To keep lockdep happy and avoid deadlocks, clone the source leaf and",
        "\t * use the clone. This is because otherwise we would be changing the log",
        "\t * tree, to insert items from the subvolume tree or insert csum items,",
        "\t * while holding a read lock on a leaf from the subvolume tree, which"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\tree-log.c",
      "line": 4369,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t *    on the parent extent buffer in the log tree.",
        "\t *",
        "\t * So one task in scenario 1) running in parallel with another task in",
        "\t * scenario 2) could lead to a deadlock, one wanting to lock a delayed",
        "\t * node mutex while having a read lock on a leaf from the subvolume,",
        "\t * while the other is holding the delayed node's mutex and wants to",
        "\t * write lock the same subvolume leaf for flushing delayed items."
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\tree-log.c",
      "line": 5179,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\tconst u64 hole_len = key.offset - prev_extent_end;",
        "",
        "\t\t\t/*",
        "\t\t\t * Release the path to avoid deadlocks with other code",
        "\t\t\t * paths that search the root while holding locks on",
        "\t\t\t * leafs from the log root.",
        "\t\t\t */"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\tree-log.c",
      "line": 5410,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * directory, that directory's new entries are logged too (same behaviour as",
        " * ext3/4, xfs, f2fs, reiserfs, nilfs2). Note that when logging the inodes",
        " * the dentries point to we do not acquire their VFS lock, otherwise lockdep",
        " * complains about the following circular lock dependency / possible deadlock:",
        " *",
        " *        CPU0                                        CPU1",
        " *        ----                                        ----"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\tree-log.c",
      "line": 6322,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tint ret = 0;",
        "",
        "\t/*",
        "\t * No need for the log mutex, plus to avoid potential deadlocks or",
        "\t * lockdep annotations due to nesting of delayed inode mutexes and log",
        "\t * mutexes.",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\tree-log.c",
      "line": 7020,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t\t/*",
        "\t\t * Logging ancestors needs to do more searches on the fs/subvol",
        "\t\t * tree, so it releases the path as needed to avoid deadlocks.",
        "\t\t * Keep track of the last inode ref key and resume from that key",
        "\t\t * after logging all new ancestors for the current hard link.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\volumes.c",
      "line": 940,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t\t *",
        "\t\t * NOTE: the device->fs_info may not be reliable here so pass",
        "\t\t * in a NULL to message helpers instead. This avoids a possible",
        "\t\t * use-after-free when the fs_info and fs_info->sb are already",
        "\t\t * torn down.",
        "\t\t */",
        "\t\tif (device->bdev) {"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\volumes.c",
      "line": 3262,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * We take the device_list_mutex to avoid racing with the finishing phase",
        "\t * of a device replace operation. See the comment below before acquiring",
        "\t * fs_info->chunk_mutex. Note that here we do not acquire the chunk_mutex",
        "\t * because that can result in a deadlock when deleting the device extent",
        "\t * items from the devices btree - COWing an extent buffer from the btree",
        "\t * may result in allocating a new metadata chunk, which would attempt to",
        "\t * lock again fs_info->chunk_mutex."
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\xattr.c",
      "line": 509,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * We're holding a transaction handle, so use a NOFS memory allocation",
        "\t * context to avoid deadlock if reclaim happens.",
        "\t */",
        "\tnofs_flag = memalloc_nofs_save();",
        "\tfor (xattr = xattr_array; xattr->name != NULL; xattr++) {"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\zoned.c",
      "line": 1225,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * For new a block group, this function is called from",
        "\t * btrfs_make_block_group() which is already taking the chunk mutex.",
        "\t * Thus, we cannot call calculate_alloc_pointer() which takes extent",
        "\t * buffer locks to avoid deadlock.",
        "\t */",
        "\tif (new) {",
        "\t\t*offset_ret = 0;"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\zoned.c",
      "line": 1966,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tif (tgt) {",
        "\t\t\t/*",
        "\t\t\t * If there is an unsent IO left in the allocated area,",
        "\t\t\t * we cannot wait for them as it may cause a deadlock.",
        "\t\t\t */",
        "\t\t\tif (tgt->meta_write_pointer < tgt->start + tgt->alloc_offset) {",
        "\t\t\t\tif (wbc->sync_mode == WB_SYNC_NONE ||"
      ]
    },
    {
      "file": "linux\\fs\\ceph\\caps.c",
      "line": 3150,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t}",
        "\t\t\t/*",
        "\t\t\t * drop cap refs first because getattr while",
        "\t\t\t * holding * caps refs can cause deadlock.",
        "\t\t\t */",
        "\t\t\tceph_put_cap_refs(ci, _got);",
        "\t\t\t_got = 0;"
      ]
    },
    {
      "file": "linux\\fs\\ceph\\file.c",
      "line": 2759,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Since we're already holding the FILE_WR capability for the dst file,",
        "\t * we would risk a deadlock by using ceph_get_caps.  Thus, we'll do some",
        "\t * retry dance instead to try to get both capabilities.",
        "\t */",
        "\tret = ceph_try_get_caps(file_inode(src_filp),"
      ]
    },
    {
      "file": "linux\\fs\\ceph\\inode.c",
      "line": 2062,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\tunlock_new_inode(in);",
        "",
        "\t\tif (d_really_is_negative(dn)) {",
        "\t\t\tif (ceph_security_xattr_deadlock(in)) {",
        "\t\t\t\tdoutc(cl, \" skip splicing dn %p to inode %p\"",
        "\t\t\t\t      \" (security xattr deadlock)\\n\", dn, in);",
        "\t\t\t\tiput(in);"
      ]
    },
    {
      "file": "linux\\fs\\ceph\\inode.c",
      "line": 2064,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tif (d_really_is_negative(dn)) {",
        "\t\t\tif (ceph_security_xattr_deadlock(in)) {",
        "\t\t\t\tdoutc(cl, \" skip splicing dn %p to inode %p\"",
        "\t\t\t\t      \" (security xattr deadlock)\\n\", dn, in);",
        "\t\t\t\tiput(in);",
        "\t\t\t\tskipped++;",
        "\t\t\t\tgoto next_item;"
      ]
    },
    {
      "file": "linux\\fs\\ceph\\locks.c",
      "line": 303,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\tif (err) {",
        "\t\t\t\t/* undo! This should only happen if",
        "\t\t\t\t * the kernel detects local",
        "\t\t\t\t * deadlock. */",
        "\t\t\t\tceph_lock_message(CEPH_LOCK_FCNTL, op, inode,",
        "\t\t\t\t\t\t  CEPH_LOCK_UNLOCK, 0, fl);",
        "\t\t\t\tdoutc(cl, \"got %d on posix_lock_file, undid lock\\n\","
      ]
    },
    {
      "file": "linux\\fs\\ceph\\mds_client.c",
      "line": 3877,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t\t       session->s_con.peer_features);",
        "\tmutex_unlock(&mdsc->mutex);",
        "",
        "\t/* Must find target inode outside of mutexes to avoid deadlocks */",
        "\trinfo = &req->r_reply_info;",
        "\tif ((err >= 0) && rinfo->head->is_target) {",
        "\t\tstruct inode *in = xchg(&req->r_new_inode, NULL);"
      ]
    },
    {
      "file": "linux\\fs\\ceph\\xattr.c",
      "line": 1361,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\treturn in->i_security != NULL;",
        "}",
        "",
        "bool ceph_security_xattr_deadlock(struct inode *in)",
        "{",
        "\tstruct ceph_inode_info *ci;",
        "\tbool ret;"
      ]
    },
    {
      "file": "linux\\fs\\configfs\\symlink.c",
      "line": 177,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * attempts to resolve the target (which might very well",
        "\t * not even exist yet) done prior to locking the parent",
        "\t * directory.  This perversion, OTOH, needs to resolve",
        "\t * the target, which would lead to obvious deadlocks if",
        "\t * attempted with any directories locked.",
        "\t *",
        "\t * Unfortunately, that garbage is userland ABI and we should've"
      ]
    },
    {
      "file": "linux\\fs\\crypto\\bio.c",
      "line": 145,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * from a mempool, with __GFP_DIRECT_RECLAIM set so that it can't fail.",
        "\t *",
        "\t * Any additional page allocations are allowed to fail, as they only",
        "\t * help performance, and waiting on the mempool for them could deadlock.",
        "\t */",
        "\tfor (i = 0; i < nr_pages; i++) {",
        "\t\tpages[i] = fscrypt_alloc_bounce_page(i == 0 ? GFP_NOFS :"
      ]
    },
    {
      "file": "linux\\fs\\crypto\\crypto.c",
      "line": 176,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * The bounce page allocation is mempool-backed, so it will always succeed when",
        " * @gfp_flags includes __GFP_DIRECT_RECLAIM, e.g. when it's GFP_NOFS.  However,",
        " * only the first page of each bio can be allocated this way.  To prevent",
        " * deadlocks, for any additional pages a mask like GFP_NOWAIT must be used.",
        " *",
        " * Return: the new encrypted bounce page on success; an ERR_PTR() on failure",
        " */"
      ]
    },
    {
      "file": "linux\\fs\\crypto\\policy.c",
      "line": 525,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t * think that size can be 0 here (despite the check above!) *and* that",
        "\t * it's a compile-time constant.  Thus it would think copy_from_user()",
        "\t * is passed compile-time constant ULONG_MAX, causing the compile-time",
        "\t * buffer overflow check to fail, breaking the build. This only occurred",
        "\t * when building an i386 kernel with -Os and branch profiling enabled.",
        "\t *",
        "\t * Work around it by just copying the first byte again..."
      ]
    },
    {
      "file": "linux\\fs\\debugfs\\file.c",
      "line": 211,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * operations to complete. However, the operation itself may need",
        " * to wait for hardware or completion of some asynchronous process",
        " * or similar. As such, it may need to be cancelled to avoid long",
        " * waits or even deadlocks.",
        " *",
        " * This function can be used inside a debugfs handler that may",
        " * need to be cancelled. As soon as this function is called, the"
      ]
    },
    {
      "file": "linux\\fs\\dlm\\lock.c",
      "line": 298,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););",
        "",
        "\tif (rv == -DLM_ECANCEL &&",
        "\t    test_and_clear_bit(DLM_IFL_DEADLOCK_CANCEL_BIT, &lkb->lkb_iflags))",
        "\t\trv = -EDEADLK;",
        "",
        "\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, dlm_sbflags_val(lkb));"
      ]
    },
    {
      "file": "linux\\fs\\dlm\\lock.c",
      "line": 2104,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "   change the granted/requested modes.  We're munging things accordingly in",
        "   the process copy.",
        "   CONVDEADLK: our grmode may have been forced down to NL to resolve a",
        "   conversion deadlock",
        "   ALTPR/ALTCW: our rqmode may have been changed to PR or CW to become",
        "   compatible with other granted locks */",
        ""
      ]
    },
    {
      "file": "linux\\fs\\dlm\\lock.c",
      "line": 2164,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "}",
        "",
        "/*",
        " * \"A conversion deadlock arises with a pair of lock requests in the converting",
        " * queue for one resource.  The granted mode of each lock blocks the requested",
        " * mode of the other lock.\"",
        " *"
      ]
    },
    {
      "file": "linux\\fs\\dlm\\lock.c",
      "line": 2191,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * That second condition meant we'd only say there was conv-deadlk if",
        " * resolving it (by demotion) would lead to the first lock on the convert",
        " * queue being granted right away.  It allowed conversion deadlocks to exist",
        " * between locks on the convert queue while they couldn't be granted anyway.",
        " *",
        " * Now, we detect and take action on conversion deadlocks immediately when"
      ]
    },
    {
      "file": "linux\\fs\\dlm\\lock.c",
      "line": 2194,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * queue being granted right away.  It allowed conversion deadlocks to exist",
        " * between locks on the convert queue while they couldn't be granted anyway.",
        " *",
        " * Now, we detect and take action on conversion deadlocks immediately when",
        " * they're created, even if they may not be immediately consequential.  If",
        " * lkb1 exists anywhere in the convert queue and lkb2 comes in with a granted",
        " * mode that would prevent lkb1's conversion from being granted, we do a"
      ]
    },
    {
      "file": "linux\\fs\\dlm\\lock.c",
      "line": 2204,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * both already on the convert queue.",
        " */",
        "",
        "static int conversion_deadlock_detect(struct dlm_rsb *r, struct dlm_lkb *lkb2)",
        "{",
        "\tstruct dlm_lkb *lkb1;",
        "\tint lkb_is_ahead = 0;"
      ]
    },
    {
      "file": "linux\\fs\\dlm\\lock.c",
      "line": 2229,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "/*",
        " * Return 1 if the lock can be granted, 0 otherwise.",
        " * Also detect and resolve conversion deadlocks.",
        " *",
        " * lkb is the lock to be granted",
        " *"
      ]
    },
    {
      "file": "linux\\fs\\dlm\\lock.c",
      "line": 2294,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * order than they were in on the previous master.  So, granting",
        "\t * queued conversions in order after recovery doesn't make sense",
        "\t * since the order hasn't been preserved anyway.  The new order",
        "\t * could also have created a new \"in place\" conversion deadlock.",
        "\t * (e.g. old, failed master held granted EX, with PR->EX, NL->EX.",
        "\t * After recovery, there would be no granted locks, and possibly",
        "\t * NL->EX, PR->EX, an in-place conversion deadlock.)  So, after"
      ]
    },
    {
      "file": "linux\\fs\\dlm\\lock.c",
      "line": 2297,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * could also have created a new \"in place\" conversion deadlock.",
        "\t * (e.g. old, failed master held granted EX, with PR->EX, NL->EX.",
        "\t * After recovery, there would be no granted locks, and possibly",
        "\t * NL->EX, PR->EX, an in-place conversion deadlock.)  So, after",
        "\t * recovery, grant conversions without considering order.",
        "\t */",
        ""
      ]
    },
    {
      "file": "linux\\fs\\dlm\\lock.c",
      "line": 2405,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * The CONVDEADLK flag is non-standard and tells the dlm to resolve",
        "\t * conversion deadlocks by demoting grmode to NL, otherwise the dlm",
        "\t * cancels one of the locks.",
        "\t */",
        ""
      ]
    },
    {
      "file": "linux\\fs\\dlm\\lock.c",
      "line": 2410,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t */",
        "",
        "\tif (is_convert && can_be_queued(lkb) &&",
        "\t    conversion_deadlock_detect(r, lkb)) {",
        "\t\tif (lkb->lkb_exflags & DLM_LKF_CONVDEADLK) {",
        "\t\t\tlkb->lkb_grmode = DLM_LOCK_NL;",
        "\t\t\tset_bit(DLM_SBF_DEMOTED_BIT, &lkb->lkb_sbflags);"
      ]
    },
    {
      "file": "linux\\fs\\dlm\\lock.c",
      "line": 2417,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t} else if (err) {",
        "\t\t\t*err = -EDEADLK;",
        "\t\t} else {",
        "\t\t\tlog_print(\"can_be_granted deadlock %x now %d\",",
        "\t\t\t\t  lkb->lkb_id, now);",
        "\t\t\tdlm_dump_rsb(r);",
        "\t\t}"
      ]
    },
    {
      "file": "linux\\fs\\dlm\\lock.c",
      "line": 2487,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tif (deadlk) {",
        "\t\t\t/*",
        "\t\t\t * If DLM_LKB_NODLKWT flag is set and conversion",
        "\t\t\t * deadlock is detected, we request blocking AST and",
        "\t\t\t * down (or cancel) conversion.",
        "\t\t\t */",
        "\t\t\tif (lkb->lkb_exflags & DLM_LKF_NODLCKWT) {"
      ]
    },
    {
      "file": "linux\\fs\\dlm\\lock.c",
      "line": 2496,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t\t\tlkb->lkb_highbast = lkb->lkb_rqmode;",
        "\t\t\t\t}",
        "\t\t\t} else {",
        "\t\t\t\tlog_print(\"WARN: pending deadlock %x node %d %s\",",
        "\t\t\t\t\t  lkb->lkb_id, lkb->lkb_nodeid,",
        "\t\t\t\t\t  r->res_name);",
        "\t\t\t\tdlm_dump_rsb(r);"
      ]
    },
    {
      "file": "linux\\fs\\dlm\\lock.c",
      "line": 3087,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t}",
        "",
        "\t/* can_be_granted() detected that this lock would block in a conversion",
        "\t   deadlock, so we leave it on the granted queue and return EDEADLK in",
        "\t   the ast for the convert. */",
        "",
        "\tif (deadlk && !(lkb->lkb_exflags & DLM_LKF_NODLCKWT)) {"
      ]
    },
    {
      "file": "linux\\fs\\dlm\\lock.c",
      "line": 6037,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\treturn error;",
        "}",
        "",
        "int dlm_user_deadlock(struct dlm_ls *ls, uint32_t flags, uint32_t lkid)",
        "{",
        "\tstruct dlm_lkb *lkb;",
        "\tstruct dlm_args args;"
      ]
    },
    {
      "file": "linux\\fs\\dlm\\lock.c",
      "line": 6059,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\tif (error)",
        "\t\tgoto out_put;",
        "",
        "\t/* same as cancel_lock(), but set DEADLOCK_CANCEL after lock_rsb */",
        "",
        "\tr = lkb->lkb_resource;",
        "\thold_rsb(r);"
      ]
    },
    {
      "file": "linux\\fs\\dlm\\lock.c",
      "line": 6068,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\terror = validate_unlock_args(lkb, &args);",
        "\tif (error)",
        "\t\tgoto out_r;",
        "\tset_bit(DLM_IFL_DEADLOCK_CANCEL_BIT, &lkb->lkb_iflags);",
        "",
        "\terror = _cancel_lock(r, lkb);",
        " out_r:"
      ]
    },
    {
      "file": "linux\\fs\\dlm\\lock.c",
      "line": 6129,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "}",
        "",
        "/* We have to release clear_proc_locks mutex before calling unlock_proc_lock()",
        "   (which does lock_rsb) due to deadlock with receiving a message that does",
        "   lock_rsb followed by dlm_user_add_cb() */",
        "",
        "static struct dlm_lkb *del_proc_lock(struct dlm_ls *ls,"
      ]
    },
    {
      "file": "linux\\fs\\dlm\\lowcomms.c",
      "line": 1512,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tbreak;",
        "\tcase DLM_IO_FLUSH:",
        "\t\t/* we can't flush the process_workqueue here because a",
        "\t\t * WQ_MEM_RECLAIM workequeue can occurr a deadlock for a non",
        "\t\t * WQ_MEM_RECLAIM workqueue such as process_workqueue. Instead",
        "\t\t * we have a waitqueue to wait until all messages are",
        "\t\t * processed."
      ]
    },
    {
      "file": "linux\\fs\\dlm\\midcomms.c",
      "line": 1117,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use after free",
      "context": [
        "\t\t/* held rcu read lock here, because we sending the",
        "\t\t * dlm message out, when we do that we could receive",
        "\t\t * an ack back which releases the mhandle and we",
        "\t\t * get a use after free.",
        "\t\t */",
        "\t\trcu_read_lock();",
        "\t\tdlm_midcomms_commit_msg_3_2(mh, name, namelen);"
      ]
    },
    {
      "file": "linux\\fs\\dlm\\user.c",
      "line": 368,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double-free",
      "context": [
        "\tif (error) {",
        "\t\tkfree(ls->ls_device.name);",
        "\t\t/* this has to be set to NULL",
        "\t\t * to avoid a double-free in dlm_device_deregister",
        "\t\t */",
        "\t\tls->ls_device.name = NULL;",
        "\t}"
      ]
    },
    {
      "file": "linux\\fs\\dlm\\user.c",
      "line": 328,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\treturn error;",
        "}",
        "",
        "static int device_user_deadlock(struct dlm_user_proc *proc,",
        "\t\t\t\tstruct dlm_lock_params *params)",
        "{",
        "\tstruct dlm_ls *ls;"
      ]
    },
    {
      "file": "linux\\fs\\dlm\\user.c",
      "line": 338,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tif (!ls)",
        "\t\treturn -ENOENT;",
        "",
        "\terror = dlm_user_deadlock(ls, params->flags, params->lkid);",
        "",
        "\tdlm_put_lockspace(ls);",
        "\treturn error;"
      ]
    },
    {
      "file": "linux\\fs\\dlm\\user.c",
      "line": 593,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t\terror = device_user_unlock(proc, &kbuf->i.lock);",
        "\t\tbreak;",
        "",
        "\tcase DLM_USER_DEADLOCK:",
        "\t\tif (!proc) {",
        "\t\t\tlog_print(\"no locking on control device\");",
        "\t\t\tgoto out_free;"
      ]
    },
    {
      "file": "linux\\fs\\dlm\\user.c",
      "line": 598,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\tlog_print(\"no locking on control device\");",
        "\t\t\tgoto out_free;",
        "\t\t}",
        "\t\terror = device_user_deadlock(proc, &kbuf->i.lock);",
        "\t\tbreak;",
        "",
        "\tcase DLM_USER_CREATE_LOCKSPACE:"
      ]
    },
    {
      "file": "linux\\fs\\erofs\\decompressor_lzma.c",
      "line": 97,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\treturn -EINVAL;",
        "\t}",
        "",
        "\t/* in case 2 z_erofs_load_lzma_config() race to avoid deadlock */",
        "\tmutex_lock(&lzma_resize_mutex);",
        "",
        "\tif (z_erofs_lzma_max_dictsize >= dict_size) {"
      ]
    },
    {
      "file": "linux\\fs\\erofs\\decompressor_zstd.c",
      "line": 95,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t}",
        "\tdict_size = 1U << (zstd->windowlog + 10);",
        "",
        "\t/* in case 2 z_erofs_load_zstd_config() race to avoid deadlock */",
        "\tmutex_lock(&zstd_resize_mutex);",
        "\tif (z_erofs_zstd_max_dictsize >= dict_size) {",
        "\t\tmutex_unlock(&zstd_resize_mutex);"
      ]
    },
    {
      "file": "linux\\fs\\erofs\\zdata.c",
      "line": 896,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\t/*",
        "\t * It's impossible to fail after the pcluster is freezed, but in order",
        "\t * to avoid some race conditions, add a DBG_BUGON to observe this.",
        "\t */",
        "\tDBG_BUGON(__xa_erase(&sbi->managed_pslots, pcl->pos) != pcl);",
        ""
      ]
    },
    {
      "file": "linux\\fs\\ext2\\ialloc.c",
      "line": 92,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "/*",
        " * NOTE! When we get the inode, we're the only people",
        " * that have access to it, and as such there are no",
        " * race conditions we have to worry about. The inode",
        " * is not on the hash-lists, and it cannot be reached",
        " * through the filesystem because the directory entry",
        " * has been deleted earlier."
      ]
    },
    {
      "file": "linux\\fs\\ext2\\inode.c",
      "line": 170,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_block",
      "context": [
        "\tint ptrs_bits = EXT2_ADDR_PER_BLOCK_BITS(inode->i_sb);",
        "\tconst long direct_blocks = EXT2_NDIR_BLOCKS,",
        "\t\tindirect_blocks = ptrs,",
        "\t\tdouble_blocks = (1 << (ptrs_bits * 2));",
        "\tint n = 0;",
        "\tint final = 0;",
        ""
      ]
    },
    {
      "file": "linux\\fs\\ext2\\inode.c",
      "line": 184,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_block",
      "context": [
        "\t\toffsets[n++] = EXT2_IND_BLOCK;",
        "\t\toffsets[n++] = i_block;",
        "\t\tfinal = ptrs;",
        "\t} else if ((i_block -= indirect_blocks) < double_blocks) {",
        "\t\toffsets[n++] = EXT2_DIND_BLOCK;",
        "\t\toffsets[n++] = i_block >> ptrs_bits;",
        "\t\toffsets[n++] = i_block & (ptrs - 1);"
      ]
    },
    {
      "file": "linux\\fs\\ext2\\inode.c",
      "line": 189,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_block",
      "context": [
        "\t\toffsets[n++] = i_block >> ptrs_bits;",
        "\t\toffsets[n++] = i_block & (ptrs - 1);",
        "\t\tfinal = ptrs;",
        "\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {",
        "\t\toffsets[n++] = EXT2_TIND_BLOCK;",
        "\t\toffsets[n++] = i_block >> (ptrs_bits * 2);",
        "\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);"
      ]
    },
    {
      "file": "linux\\fs\\ext2\\super.c",
      "line": 781,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double indirect block",
      "context": [
        "\t/* indirect blocks */",
        "\tmeta_blocks = 1;",
        "\tupper_limit -= ppb;",
        "\t/* double indirect blocks */",
        "\tif (upper_limit < ppb * ppb) {",
        "\t\tmeta_blocks += 1 + DIV_ROUND_UP(upper_limit, ppb);",
        "\t\tres -= meta_blocks;"
      ]
    },
    {
      "file": "linux\\fs\\ext2\\xattr.c",
      "line": 54,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * holding xattr_sem also means that nothing but the EA block's reference",
        " * count will change. Multiple writers to an EA block are synchronized",
        " * by the bh lock. No more than a single bh lock is held at any time",
        " * to avoid deadlocks.",
        " */",
        "",
        "#include <linux/buffer_head.h>"
      ]
    },
    {
      "file": "linux\\fs\\ext4\\extents_status.c",
      "line": 802,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t\t\t\t       struct extent_status *es)",
        "{",
        "\t/*",
        "\t * We don't need to worry about the race condition because",
        "\t * caller takes i_data_sem locking.",
        "\t */",
        "\tBUG_ON(!rwsem_is_locked(&EXT4_I(inode)->i_data_sem));"
      ]
    },
    {
      "file": "linux\\fs\\ext4\\extents.c",
      "line": 95,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "static int ext4_ext_trunc_restart_fn(struct inode *inode, int *dropped)",
        "{",
        "\t/*",
        "\t * Drop i_data_sem to avoid deadlock with ext4_map_blocks.  At this",
        "\t * moment, get_block can be called only for blocks inside i_size since",
        "\t * page cache has been already dropped and writes are blocked by",
        "\t * i_rwsem. So we can safely drop the i_data_sem here."
      ]
    },
    {
      "file": "linux\\fs\\ext4\\fsync.c",
      "line": 18,
      "pattern": "code.*duplication",
      "rule": "code_quality",
      "severity": "low",
      "match": "code duplication",
      "context": [
        " *  Big-endian to little-endian byte-swapping/bitmaps by",
        " *        David S. Miller (davem@caip.rutgers.edu), 1995",
        " *",
        " *  Removed unnecessary code duplication for little endian machines",
        " *  and excessive __inline__s.",
        " *        Andi Kleen, 1997",
        " *"
      ]
    },
    {
      "file": "linux\\fs\\ext4\\indirect.c",
      "line": 704,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tif (unlikely(err))",
        "\t\treturn err;",
        "\t/*",
        "\t * Drop i_data_sem to avoid deadlock with ext4_map_blocks.  At this",
        "\t * moment, get_block can be called only for blocks inside i_size since",
        "\t * page cache has been already dropped and writes are blocked by",
        "\t * i_rwsem. So we can safely drop the i_data_sem here."
      ]
    },
    {
      "file": "linux\\fs\\ext4\\indirect.c",
      "line": 82,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_block",
      "context": [
        "\tint ptrs_bits = EXT4_ADDR_PER_BLOCK_BITS(inode->i_sb);",
        "\tconst long direct_blocks = EXT4_NDIR_BLOCKS,",
        "\t\tindirect_blocks = ptrs,",
        "\t\tdouble_blocks = (1 << (ptrs_bits * 2));",
        "\tint n = 0;",
        "\tint final = 0;",
        ""
      ]
    },
    {
      "file": "linux\\fs\\ext4\\indirect.c",
      "line": 93,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_block",
      "context": [
        "\t\toffsets[n++] = EXT4_IND_BLOCK;",
        "\t\toffsets[n++] = i_block;",
        "\t\tfinal = ptrs;",
        "\t} else if ((i_block -= indirect_blocks) < double_blocks) {",
        "\t\toffsets[n++] = EXT4_DIND_BLOCK;",
        "\t\toffsets[n++] = i_block >> ptrs_bits;",
        "\t\toffsets[n++] = i_block & (ptrs - 1);"
      ]
    },
    {
      "file": "linux\\fs\\ext4\\indirect.c",
      "line": 98,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_block",
      "context": [
        "\t\toffsets[n++] = i_block >> ptrs_bits;",
        "\t\toffsets[n++] = i_block & (ptrs - 1);",
        "\t\tfinal = ptrs;",
        "\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {",
        "\t\toffsets[n++] = EXT4_TIND_BLOCK;",
        "\t\toffsets[n++] = i_block >> (ptrs_bits * 2);",
        "\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);"
      ]
    },
    {
      "file": "linux\\fs\\ext4\\indirect.c",
      "line": 107,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_block",
      "context": [
        "\t} else {",
        "\t\text4_warning(inode->i_sb, \"block %lu > max in inode %lu\",",
        "\t\t\t     i_block + direct_blocks +",
        "\t\t\t     indirect_blocks + double_blocks, inode->i_ino);",
        "\t}",
        "\tif (boundary)",
        "\t\t*boundary = final - 1 - (i_block & (ptrs - 1));"
      ]
    },
    {
      "file": "linux\\fs\\ext4\\indirect.c",
      "line": 504,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double-indirect i_block",
      "context": [
        "",
        "/*",
        " * The ext4_ind_map_blocks() function handles non-extents inodes",
        " * (i.e., using the traditional indirect/double-indirect i_blocks",
        " * scheme) for ext4_map_blocks().",
        " *",
        " * Allocation strategy is simple: if we have to allocate something, we will"
      ]
    },
    {
      "file": "linux\\fs\\ext4\\ialloc.c",
      "line": 222,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "/*",
        " * NOTE! When we get the inode, we're the only people",
        " * that have access to it, and as such there are no",
        " * race conditions we have to worry about. The inode",
        " * is not on the hash-lists, and it cannot be reached",
        " * through the filesystem because the directory entry",
        " * has been deleted earlier."
      ]
    },
    {
      "file": "linux\\fs\\ext4\\inode.c",
      "line": 315,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use inode use-after-free",
      "context": [
        "no_delete:",
        "\t/*",
        "\t * Check out some where else accidentally dirty the evicting inode,",
        "\t * which may probably cause inode use-after-free issues later.",
        "\t */",
        "\tWARN_ON_ONCE(!list_empty_careful(&inode->i_io_list));",
        ""
      ]
    },
    {
      "file": "linux\\fs\\ext4\\mballoc.c",
      "line": 2161,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double allocate block",
      "context": [
        "\t * take the page reference. We want the page to be pinned",
        "\t * so that we don't get a ext4_mb_init_cache_call for this",
        "\t * group until we update the bitmap. That would mean we",
        "\t * double allocate blocks. The reference is dropped",
        "\t * in ext4_mb_release_context",
        "\t */",
        "\tac->ac_bitmap_folio = e4b->bd_bitmap_folio;"
      ]
    },
    {
      "file": "linux\\fs\\ext4\\move_extent.c",
      "line": 676,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\tcur_len = blocks_per_page - offset_in_page;",
        "\t\t/*",
        "\t\t * Up semaphore to avoid following problems:",
        "\t\t * a. transaction deadlock among ext4_journal_start,",
        "\t\t *    ->write_begin via pagefault, and jbd2_journal_commit",
        "\t\t * b. racing with ->read_folio, ->write_begin, and",
        "\t\t *    ext4_get_block in move_extent_per_page"
      ]
    },
    {
      "file": "linux\\fs\\ext4\\move_extent.c",
      "line": 40,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_down_write_data_sem() - write lock",
      "context": [
        "}",
        "",
        "/**",
        " * ext4_double_down_write_data_sem() - write lock two inodes's i_data_sem",
        " * @first: inode to be locked",
        " * @second: inode to be locked",
        " *"
      ]
    },
    {
      "file": "linux\\fs\\ext4\\move_extent.c",
      "line": 60,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_up_write_data_sem - Release two inodes' write lock",
      "context": [
        "}",
        "",
        "/**",
        " * ext4_double_up_write_data_sem - Release two inodes' write lock of i_data_sem",
        " *",
        " * @orig_inode:\t\toriginal inode structure to be released its lock first",
        " * @donor_inode:\tdonor inode structure to be released its lock second"
      ]
    },
    {
      "file": "linux\\fs\\ext4\\move_extent.c",
      "line": 111,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock - Grab and lock",
      "context": [
        "}",
        "",
        "/**",
        " * mext_folio_double_lock - Grab and lock folio on both @inode1 and @inode2",
        " *",
        " * @inode1:\tthe inode structure",
        " * @inode2:\tthe inode structure"
      ]
    },
    {
      "file": "linux\\fs\\ext4\\move_extent.c",
      "line": 122,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        " * Grab two locked folio for inode's by inode order",
        " */",
        "static int",
        "mext_folio_double_lock(struct inode *inode1, struct inode *inode2,",
        "\t\t      pgoff_t index1, pgoff_t index2, struct folio *folio[2])",
        "{",
        "\tstruct address_space *mapping[2];"
      ]
    },
    {
      "file": "linux\\fs\\ext4\\move_extent.c",
      "line": 315,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "",
        "\treplaced_size = data_size;",
        "",
        "\t*err = mext_folio_double_lock(orig_inode, donor_inode, orig_page_offset,",
        "\t\t\t\t     donor_page_offset, folio);",
        "\tif (unlikely(*err < 0))",
        "\t\tgoto stop_journal;"
      ]
    },
    {
      "file": "linux\\fs\\ext4\\readpage.c",
      "line": 104,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * fsverity_verify_bio() may call readahead() again, and although verity",
        "\t * will be disabled for that, decryption may still be needed, causing",
        "\t * another bio_post_read_ctx to be allocated.  So to guarantee that",
        "\t * mempool_alloc() never deadlocks we must free the current ctx first.",
        "\t * This is safe because verity is the last post-read step.",
        "\t */",
        "\tBUILD_BUG_ON(STEP_VERITY + 1 != STEP_MAX);"
      ]
    },
    {
      "file": "linux\\fs\\ext4\\page-io.c",
      "line": 547,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t/*",
        "\t\t * Since bounce page allocation uses a mempool, we can only use",
        "\t\t * a waiting mask (i.e. request guaranteed allocation) on the",
        "\t\t * first page of the bio.  Otherwise it can deadlock.",
        "\t\t */",
        "\t\tif (io->io_bio)",
        "\t\t\tgfp_flags = GFP_NOWAIT | __GFP_NOWARN;"
      ]
    },
    {
      "file": "linux\\fs\\ext4\\resize.c",
      "line": 810,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double indirect block",
      "context": [
        "/*",
        " * Called when we need to bring a reserved group descriptor table block into",
        " * use from the resize inode.  The primary copy of the new GDT block currently",
        " * is an indirect block (under the double indirect block in the resize inode).",
        " * The new backup GDT blocks will be stored as leaf blocks in this indirect",
        " * block, in group order.  Even though we know all the block numbers we need,",
        " * we check to ensure that the resize inode has actually reserved these blocks."
      ]
    },
    {
      "file": "linux\\fs\\ext4\\resize.c",
      "line": 901,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double-indirect block",
      "context": [
        "\t/*",
        "\t * Finally, we have all of the possible failures behind us...",
        "\t *",
        "\t * Remove new GDT block from inode double-indirect block and clear out",
        "\t * the new GDT block for use (which also \"frees\" the backup GDT blocks",
        "\t * from the reserved inode).  We don't need to change the bitmaps for",
        "\t * these blocks, because they are marked as in-use from being in the"
      ]
    },
    {
      "file": "linux\\fs\\ext4\\resize.c",
      "line": 1015,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double-indirect block",
      "context": [
        " * Each reserved backup GDT block will go into a different indirect block.",
        " * The indirect blocks are actually the primary reserved GDT blocks,",
        " * so we know in advance what their block numbers are.  We only get the",
        " * double-indirect block to verify it is pointing to the primary reserved",
        " * GDT blocks so we don't overwrite a data block by accident.  The reserved",
        " * backup GDT blocks are stored in their reserved primary GDT block.",
        " */"
      ]
    },
    {
      "file": "linux\\fs\\ext4\\super.c",
      "line": 729,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * We don't set SB_RDONLY because that requires sb->s_umount",
        "\t * semaphore and setting it without proper remount procedure is",
        "\t * confusing code such as freeze_super() leading to deadlocks",
        "\t * and other problems.",
        "\t */",
        "\tset_bit(EXT4_FLAGS_EMERGENCY_RO, &EXT4_SB(sb)->s_ext4_flags);"
      ]
    },
    {
      "file": "linux\\fs\\ext4\\super.c",
      "line": 6948,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Trying to sb_start_intwrite() in a running transaction",
        "\t * can result in a deadlock. Further, running transactions",
        "\t * are already protected from freezing.",
        "\t */",
        "\tif (!ext4_journal_current_handle()) {"
      ]
    },
    {
      "file": "linux\\fs\\ext4\\super.c",
      "line": 3480,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double indirect block",
      "context": [
        "\t/* indirect blocks */",
        "\tmeta_blocks = 1;",
        "\tupper_limit -= ppb;",
        "\t/* double indirect blocks */",
        "\tif (upper_limit < ppb * ppb) {",
        "\t\tmeta_blocks += 1 + DIV_ROUND_UP_ULL(upper_limit, ppb);",
        "\t\tres -= meta_blocks;"
      ]
    },
    {
      "file": "linux\\fs\\f2fs\\compress.c",
      "line": 1308,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t/*",
        "\t\t * We need to wait for node_write to avoid block allocation during",
        "\t\t * checkpoint. This can only happen to quota writes which can cause",
        "\t\t * the below discard race condition.",
        "\t\t */",
        "\t\tf2fs_down_read(&sbi->node_write);",
        "\t} else if (!f2fs_trylock_op(sbi)) {"
      ]
    },
    {
      "file": "linux\\fs\\f2fs\\compress.c",
      "line": 1571,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t\tret = 0;",
        "\t\t\t\t/*",
        "\t\t\t\t * for quota file, just redirty left pages to",
        "\t\t\t\t * avoid deadlock caused by cluster update race",
        "\t\t\t\t * from foreground operation.",
        "\t\t\t\t */",
        "\t\t\t\tif (IS_NOQUOTA(cc->inode))"
      ]
    },
    {
      "file": "linux\\fs\\f2fs\\compress.c",
      "line": 1836,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\tif (!failed && dic->need_verity) {",
        "\t\t/*",
        "\t\t * Note that to avoid deadlocks, the verity work can't be done",
        "\t\t * on the decompression workqueue.  This is because verifying",
        "\t\t * the data pages can involve reading metadata pages from the",
        "\t\t * file, and these metadata pages may be compressed."
      ]
    },
    {
      "file": "linux\\fs\\f2fs\\data.c",
      "line": 2845,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t/*",
        "\t\t * We need to wait for node_write to avoid block allocation during",
        "\t\t * checkpoint. This can only happen to quota writes which can cause",
        "\t\t * the below discard race condition.",
        "\t\t */",
        "\t\tif (quota_inode)",
        "\t\t\tf2fs_down_read(&sbi->node_write);"
      ]
    },
    {
      "file": "linux\\fs\\f2fs\\data.c",
      "line": 173,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * fsverity_verify_bio() may call readahead() again, and while verity",
        "\t * will be disabled for this, decryption and/or decompression may still",
        "\t * be needed, resulting in another bio_post_read_ctx being allocated.",
        "\t * So to prevent deadlocks we need to release the current ctx to the",
        "\t * mempool first.  This assumes that verity is the last post-read step.",
        "\t */",
        "\tmempool_free(ctx, bio_post_read_ctx_pool);"
      ]
    },
    {
      "file": "linux\\fs\\f2fs\\data.c",
      "line": 207,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * If the bio's data needs to be verified with fs-verity, then enqueue the",
        " * verity work for the bio.  Otherwise finish the bio now.",
        " *",
        " * Note that to avoid deadlocks, the verity work can't be done on the",
        " * decryption/decompression workqueue.  This is because verifying the data pages",
        " * can involve reading verity metadata pages from the file, and these verity",
        " * metadata pages may be encrypted and/or compressed."
      ]
    },
    {
      "file": "linux\\fs\\f2fs\\data.c",
      "line": 2673,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Deadlock",
      "context": [
        "\t\tgoto got_it;",
        "\t}",
        "",
        "\t/* Deadlock due to between page->lock and f2fs_lock_op */",
        "\tif (fio->need_lock == LOCK_REQ && !f2fs_trylock_op(fio->sbi))",
        "\t\treturn -EAGAIN;",
        ""
      ]
    },
    {
      "file": "linux\\fs\\f2fs\\data.c",
      "line": 3218,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "static inline bool __should_serialize_io(struct inode *inode,",
        "\t\t\t\t\tstruct writeback_control *wbc)",
        "{",
        "\t/* to avoid deadlock in path of data flush */",
        "\tif (F2FS_I(inode)->wb_task)",
        "\t\treturn false;",
        ""
      ]
    },
    {
      "file": "linux\\fs\\f2fs\\data.c",
      "line": 3270,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tif (wbc->sync_mode == WB_SYNC_ALL)",
        "\t\tatomic_inc(&sbi->wb_sync_req[DATA]);",
        "\telse if (atomic_read(&sbi->wb_sync_req[DATA])) {",
        "\t\t/* to avoid potential deadlock */",
        "\t\tif (current->plug)",
        "\t\t\tblk_finish_plug(current->plug);",
        "\t\tgoto skip_write;"
      ]
    },
    {
      "file": "linux\\fs\\f2fs\\data.c",
      "line": 3542,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t}",
        "",
        "\t/*",
        "\t * We should check this at this moment to avoid deadlock on inode page",
        "\t * and #0 page. The locking rule for inline_data conversion should be:",
        "\t * folio_lock(folio #0) -> folio_lock(inode_page)",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\f2fs\\data.c",
      "line": 3576,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "repeat:",
        "\t/*",
        "\t * Do not use FGP_STABLE to avoid deadlock.",
        "\t * Will wait that below with our IO control.",
        "\t */",
        "\tfolio = __filemap_get_folio(mapping, index,"
      ]
    },
    {
      "file": "linux\\fs\\f2fs\\dir.c",
      "line": 794,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\treturn err;",
        "",
        "\t/*",
        "\t * An immature stackable filesystem shows a race condition between lookup",
        "\t * and create. If we have same task when doing lookup and create, it's",
        "\t * definitely fine as expected by VFS normally. Otherwise, let's just",
        "\t * verify on-disk dentry one more time, which guarantees filesystem"
      ]
    },
    {
      "file": "linux\\fs\\f2fs\\gc.c",
      "line": 1554,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t/*",
        "\t\t * stop BG_GC if there is not enough free sections.",
        "\t\t * Or, stop GC if the segment becomes fully valid caused by",
        "\t\t * race condition along with SSR block allocation.",
        "\t\t */",
        "\t\tif ((gc_type == BG_GC && has_not_enough_free_secs(sbi, 0, 0)) ||",
        "\t\t\t(!force_migrate && get_valid_blocks(sbi, segno, true) =="
      ]
    },
    {
      "file": "linux\\fs\\f2fs\\gc.c",
      "line": 1813,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t}",
        "",
        "\t\t/*",
        "\t\t * this is to avoid deadlock:",
        "\t\t * - lock_page(sum_page)         - f2fs_replace_block",
        "\t\t *  - check_valid_map()            - down_write(sentry_lock)",
        "\t\t *   - down_read(sentry_lock)     - change_curseg()"
      ]
    },
    {
      "file": "linux\\fs\\f2fs\\gc.c",
      "line": 1109,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double indirect node block",
      "context": [
        " * Calculate start block index indicating the given node offset.",
        " * Be careful, caller should give this node offset only indicating direct node",
        " * blocks. If any node offsets, which point the other types of node blocks such",
        " * as indirect or double indirect node blocks, are given, it must be a caller's",
        " * bug.",
        " */",
        "block_t f2fs_start_bidx_of_node(unsigned int node_ofs, struct inode *inode)"
      ]
    },
    {
      "file": "linux\\fs\\f2fs\\inline.c",
      "line": 446,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory is leak",
      "context": [
        "",
        "\t/*",
        "\t * Start by zeroing the full block, to ensure that all unused space is",
        "\t * zeroed and no uninitialized memory is leaked to disk.",
        "\t */",
        "\tmemset(dentry_blk, 0, F2FS_BLKSIZE);",
        ""
      ]
    },
    {
      "file": "linux\\fs\\f2fs\\iostat.c",
      "line": 122,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double check under the lock",
      "context": [
        "\tif (time_is_after_jiffies(sbi->iostat_next_period))",
        "\t\treturn;",
        "",
        "\t/* Need double check under the lock */",
        "\tspin_lock_irqsave(&sbi->iostat_lock, flags);",
        "\tif (time_is_after_jiffies(sbi->iostat_next_period)) {",
        "\t\tspin_unlock_irqrestore(&sbi->iostat_lock, flags);"
      ]
    },
    {
      "file": "linux\\fs\\f2fs\\node.c",
      "line": 2172,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tif (wbc->sync_mode == WB_SYNC_ALL)",
        "\t\tatomic_inc(&sbi->wb_sync_req[NODE]);",
        "\telse if (atomic_read(&sbi->wb_sync_req[NODE])) {",
        "\t\t/* to avoid potential deadlock */",
        "\t\tif (current->plug)",
        "\t\t\tblk_finish_plug(current->plug);",
        "\t\tgoto skip_write;"
      ]
    },
    {
      "file": "linux\\fs\\f2fs\\super.c",
      "line": 1478,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t}",
        "",
        "\t/*",
        "\t * This is to avoid a deadlock condition like below.",
        "\t * writeback_single_inode(inode)",
        "\t *  - f2fs_write_data_page",
        "\t *    - f2fs_gc -> iput -> evict"
      ]
    },
    {
      "file": "linux\\fs\\f2fs\\super.c",
      "line": 1772,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\tsbi->umount_lock_holder = NULL;",
        "",
        "\t/* to avoid deadlock on f2fs_evict_inode->SB_FREEZE_FS */",
        "\tset_sbi_flag(sbi, SBI_IS_FREEZING);",
        "\treturn 0;",
        "}"
      ]
    },
    {
      "file": "linux\\fs\\f2fs\\super.c",
      "line": 4277,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t\t/*",
        "\t\t * always create an asynchronous task to record stop_reason",
        "\t\t * in order to avoid potential deadlock when running into",
        "\t\t * f2fs_record_stop_reason() synchronously.",
        "\t\t */",
        "\t\tschedule_work(&sbi->s_error_work);"
      ]
    },
    {
      "file": "linux\\fs\\f2fs\\super.c",
      "line": 4316,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * to filesystem, so it doesn't need to set SB_RDONLY flag here",
        "\t * because the flag should be set covered w/ sb->s_umount semaphore",
        "\t * via remount procedure, otherwise, it will confuse code like",
        "\t * freeze_super() which will lead to deadlocks and other problems.",
        "\t */",
        "}",
        ""
      ]
    },
    {
      "file": "linux\\fs\\f2fs\\super.c",
      "line": 3412,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double indirect node block",
      "context": [
        "\tleaf_count *= NIDS_PER_BLOCK;",
        "\tresult += (leaf_count * 2);",
        "",
        "\t/* one double indirect node block */",
        "\tleaf_count *= NIDS_PER_BLOCK;",
        "\tresult += leaf_count;",
        ""
      ]
    },
    {
      "file": "linux\\fs\\fuse\\dax.c",
      "line": 373,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * It is called from evict_inode() and by that time inode is going away. So",
        " * this function does not take any locks like fi->dax->sem for traversing",
        " * that fuse inode interval tree. If that lock is taken then lock validator",
        " * complains of deadlock situation w.r.t fs_reclaim lock.",
        " */",
        "void fuse_dax_inode_cleanup(struct inode *inode)",
        "{"
      ]
    },
    {
      "file": "linux\\fs\\fuse\\dax.c",
      "line": 1013,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * had a reference or some other temporary failure,",
        "\t\t * Try again. We want to give up inline reclaim only",
        "\t\t * if there is no range assigned to this node. Otherwise",
        "\t\t * if a deadlock is possible if we sleep with",
        "\t\t * mapping->invalidate_lock held and worker to free memory",
        "\t\t * can't make progress due to unavailability of",
        "\t\t * mapping->invalidate_lock.  So sleep only if fi->dax->nr=0"
      ]
    },
    {
      "file": "linux\\fs\\fuse\\dev.c",
      "line": 2391,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * Abort all requests.",
        " *",
        " * Emergency exit in case of a malicious or accidental deadlock, or just a hung",
        " * filesystem.",
        " *",
        " * The same effect is usually achievable through killing the filesystem daemon"
      ]
    },
    {
      "file": "linux\\fs\\fuse\\dev.c",
      "line": 2396,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * The same effect is usually achievable through killing the filesystem daemon",
        " * and all users of the filesystem.  The exception is the combination of an",
        " * asynchronous request and the tricky deadlock (see",
        " * Documentation/filesystems/fuse.rst).",
        " *",
        " * Aborting requests under I/O goes as follows: 1: Separate out unlocked"
      ]
    },
    {
      "file": "linux\\fs\\fuse\\dir.c",
      "line": 2099,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Only call invalidate_inode_pages2() after removing",
        "\t * FUSE_NOWRITE, otherwise fuse_launder_folio() would deadlock.",
        "\t */",
        "\tif ((is_truncate || !is_wb) &&",
        "\t    S_ISREG(inode->i_mode) && oldsize != outarg.attr.size) {"
      ]
    },
    {
      "file": "linux\\fs\\fuse\\file.c",
      "line": 1935,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * Inode is always written before the last reference is dropped and",
        "\t * hence this should not be reached from reclaim.",
        "\t *",
        "\t * Writing back the inode from reclaim can deadlock if the request",
        "\t * processing itself needs an allocation.  Allocations triggering",
        "\t * reclaim while serving a request can't be prevented, because it can",
        "\t * involve any number of unrelated userspace processes."
      ]
    },
    {
      "file": "linux\\fs\\fuse\\file.c",
      "line": 3163,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tinode->i_fop = &fuse_file_operations;",
        "\tinode->i_data.a_ops = &fuse_file_aops;",
        "\tif (fc->writeback_cache)",
        "\t\tmapping_set_writeback_may_deadlock_on_reclaim(&inode->i_data);",
        "",
        "\tINIT_LIST_HEAD(&fi->write_files);",
        "\tINIT_LIST_HEAD(&fi->queued_writes);"
      ]
    },
    {
      "file": "linux\\fs\\gfs2\\glock.c",
      "line": 633,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t}",
        "\t\t}",
        "\t\tswitch(state) {",
        "\t\t/* Unlocked due to conversion deadlock, try again */",
        "\t\tcase LM_ST_UNLOCKED:",
        "\t\t\tdo_xmote(gl, gh, gl->gl_target);",
        "\t\t\tbreak;"
      ]
    },
    {
      "file": "linux\\fs\\gfs2\\glock.c",
      "line": 1777,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "}",
        "",
        "/**",
        " * nq_m_sync - synchronously acquire more than one glock in deadlock free order",
        " * @num_gh: the number of structures",
        " * @ghs: an array of struct gfs2_holder structures",
        " * @p: placeholder for the holder structure to pass back"
      ]
    },
    {
      "file": "linux\\fs\\gfs2\\lock_dlm.c",
      "line": 145,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Deadlock",
      "context": [
        "\t\tret |= LM_OUT_CANCELED;",
        "\t\tgoto out;",
        "\tcase -EAGAIN: /* Try lock fails */",
        "\tcase -EDEADLK: /* Deadlock detected */",
        "\t\tgoto out;",
        "\tcase -ETIMEDOUT: /* Canceled due to timeout */",
        "\t\tret |= LM_OUT_ERROR;"
      ]
    },
    {
      "file": "linux\\fs\\gfs2\\super.c",
      "line": 1036,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * When under memory pressure when an inode's link count has dropped to",
        "\t * zero, defer deleting the inode to the delete workqueue.  This avoids",
        "\t * calling into DLM under memory pressure, which can deadlock.",
        "\t */",
        "\tif (!inode->i_nlink &&",
        "\t    unlikely(current->flags & PF_MEMALLOC) &&"
      ]
    },
    {
      "file": "linux\\fs\\gfs2\\super.c",
      "line": 1177,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * @gl:\tThe glock to put",
        " *",
        " * When under memory pressure, trigger a deferred glock put to make sure we",
        " * won't call into DLM and deadlock.  Otherwise, put the glock directly.",
        " */",
        "",
        "static void gfs2_glock_put_eventually(struct gfs2_glock *gl)"
      ]
    },
    {
      "file": "linux\\fs\\hfs\\bitmap.c",
      "line": 118,
      "pattern": "long.*functions",
      "rule": "code_quality",
      "severity": "low",
      "match": "longer free, when this functions",
      "context": [
        " * Description:",
        " *   Search for 'num_bits' consecutive cleared bits in the bitmap blocks of",
        " *   the hfs MDB. 'mdb' had better be locked or the returned range",
        " *   may be no longer free, when this functions returns!",
        " *   XXX Currently the search starts from bit 0, but it should start with",
        " *   the bit number stored in 's_alloc_ptr' of the MDB.",
        " * Input Variable(s):"
      ]
    },
    {
      "file": "linux\\fs\\hfsplus\\part_tbl.c",
      "line": 25,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "#define HFS_PMAP_BLK\t\t1 /* First block of partition map */",
        "#define HFS_MDB_BLK\t\t2 /* Block (w/i partition) of MDB */",
        "",
        "/* magic numbers for various disk blocks */",
        "#define HFS_DRVR_DESC_MAGIC\t0x4552 /* \"ER\": driver descriptor map */",
        "#define HFS_OLD_PMAP_MAGIC\t0x5453 /* \"TS\": old-type partition map */",
        "#define HFS_NEW_PMAP_MAGIC\t0x504D /* \"PM\": new-type partition map */"
      ]
    },
    {
      "file": "linux\\fs\\hpfs\\anode.c",
      "line": 271,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "stack overflow",
      "context": [
        "",
        "/*",
        " * Remove allocation tree. Recursion would look much nicer but",
        " * I want to avoid it because it can cause stack overflow.",
        " */",
        "",
        "void hpfs_remove_btree(struct super_block *s, struct bplus_header *btree)"
      ]
    },
    {
      "file": "linux\\fs\\iomap\\buffered-io.c",
      "line": 966,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t\t/*",
        "\t\t * Bring in the user page that we'll copy from _first_.",
        "\t\t * Otherwise there's a nasty deadlock on copying from the",
        "\t\t * same page as we're writing to, without it being marked",
        "\t\t * up-to-date.",
        "\t\t *"
      ]
    },
    {
      "file": "linux\\fs\\iomap\\direct-io.c",
      "line": 261,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * Try to avoid another context switch for the completion given",
        "\t\t * that we are already called from the ioend completion",
        "\t\t * workqueue, but never invalidate pages from this thread to",
        "\t\t * avoid deadlocks with buffered I/O completions.  Tough luck if",
        "\t\t * you hit the tiny race with someone dirtying the range now",
        "\t\t * between this check and the actual completion.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\fs\\jbd2\\journal.c",
      "line": 494,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "/*",
        " * Force and wait any uncommitted transactions.  We can only force the running",
        " * transaction if we don't have an active handle, otherwise, we will deadlock.",
        " * Returns: <0 in case of error,",
        " *           0 if nothing to commit,",
        " *           1 if transaction was successfully committed."
      ]
    },
    {
      "file": "linux\\fs\\jbd2\\journal.c",
      "line": 552,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * @journal: journal to force",
        " *",
        " * Caller want unconditional commit. We can only force the running transaction",
        " * if we don't have an active handle, otherwise, we will deadlock.",
        " */",
        "int jbd2_journal_force_commit(journal_t *journal)",
        "{"
      ]
    },
    {
      "file": "linux\\fs\\jbd2\\journal.c",
      "line": 308,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing word can then be restored when the block",
      "context": [
        " * this case, we copy the data and replace the first word with 0, and we",
        " * return a result code which indicates that this buffer needs to be",
        " * marked as an escaped buffer in the corresponding log descriptor",
        " * block.  The missing word can then be restored when the block is read",
        " * during recovery.",
        " *",
        " * If the source buffer has already been modified by a new transaction"
      ]
    },
    {
      "file": "linux\\fs\\jbd2\\transaction.c",
      "line": 829,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free of old free",
      "context": [
        "\t\t * release j_state_lock -> schedule() -> acquire j_state_lock.",
        "\t\t * Hence we should everytime retrieve new j_running_transaction",
        "\t\t * value (after j_state_lock release acquire cycle), else it may",
        "\t\t * lead to use-after-free of old freed transaction.",
        "\t\t */",
        "\t\ttransaction_t *transaction = journal->j_running_transaction;",
        ""
      ]
    },
    {
      "file": "linux\\fs\\jbd2\\transaction.c",
      "line": 265,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * The commit code assumes that it can get enough log space",
        "\t * without forcing a checkpoint.  This is *critical* for",
        "\t * correctness: a checkpoint of a buffer which is also",
        "\t * associated with a committing transaction creates a deadlock,",
        "\t * so commit simply cannot force through checkpoints.",
        "\t *",
        "\t * We must therefore ensure the necessary space in the journal"
      ]
    },
    {
      "file": "linux\\fs\\jbd2\\transaction.c",
      "line": 376,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Wait on the journal's transaction barrier if necessary. Specifically",
        "\t * we allow reserved handles to proceed because otherwise commit could",
        "\t * deadlock on page writeback not being able to complete.",
        "\t */",
        "\tif (!handle->h_reserved && journal->j_barrier_count) {",
        "\t\tread_unlock(&journal->j_state_lock);"
      ]
    },
    {
      "file": "linux\\fs\\jffs2\\dir.c",
      "line": 200,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t   space and taking c-alloc_sem. If we keep it locked here,",
        "\t   lockdep gets unhappy (although it's a false positive;",
        "\t   nothing else will be looking at this inode yet so there's",
        "\t   no chance of AB-BA deadlock involving its f->sem). */",
        "\tmutex_unlock(&f->sem);",
        "",
        "\tret = jffs2_do_create(c, dir_f, f, ri, &dentry->d_name);"
      ]
    },
    {
      "file": "linux\\fs\\jffs2\\file.c",
      "line": 204,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * While getting a page and reading data in, lock c->alloc_sem until",
        "\t * the page is Uptodate. Otherwise GC task may attempt to read the same",
        "\t * page in read_cache_page(), which causes a deadlock.",
        "\t */",
        "\tmutex_lock(&c->alloc_sem);",
        "\tfolio = __filemap_get_folio(mapping, index, FGP_WRITEBEGIN,"
      ]
    },
    {
      "file": "linux\\fs\\jffs2\\file.c",
      "line": 260,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t  __func__, inode->i_ino, folio_pos(folio),",
        "\t\t  start, end, folio->flags);",
        "",
        "\t/* We need to avoid deadlock with page_cache_read() in",
        "\t   jffs2_garbage_collect_pass(). So the folio must be",
        "\t   up to date to prevent page_cache_read() from trying",
        "\t   to re-lock it. */"
      ]
    },
    {
      "file": "linux\\fs\\jffs2\\gc.c",
      "line": 1327,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * It is important to note that jffs2_write_begin() will ensure that its",
        "\t * folio is marked uptodate before allocating space. That means that if we",
        "\t * end up here trying to GC the *same* folio that jffs2_write_begin() is",
        "\t * trying to write out, read_cache_folio() will not deadlock. */",
        "\tmutex_unlock(&f->sem);",
        "\tfolio = read_cache_folio(inode->i_mapping, start >> PAGE_SHIFT,",
        "\t\t\t       __jffs2_read_folio, NULL);"
      ]
    },
    {
      "file": "linux\\fs\\jffs2\\readinode.c",
      "line": 1225,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "\tif (ret || retlen != sizeof(*latest_node)) {",
        "\t\tJFFS2_ERROR(\"failed to read from flash: error %d, %zd of %zd bytes read\\n\",",
        "\t\t\tret, retlen, sizeof(*latest_node));",
        "\t\t/* FIXME: If this fails, there seems to be a memory leak. Find it. */",
        "\t\treturn ret ? ret : -EIO;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\fs\\jfs\\jfs_dtree.c",
      "line": 2651,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing_indices: Invalid stbl[%d] = %d for inode %ld, block",
      "context": [
        "\tstbl = DT_GETSTBL(p);",
        "\tfor (i = 0; i < p->header.nextindex; i++) {",
        "\t\tif (stbl[i] < 0) {",
        "\t\t\tjfs_err(\"jfs: add_missing_indices: Invalid stbl[%d] = %d for inode %ld, block = %lld\",",
        "\t\t\t\ti, stbl[i], (long)inode->i_ino, (long long)bn);",
        "\t\t\trc = -EIO;",
        ""
      ]
    },
    {
      "file": "linux\\fs\\jfs\\jfs_imap.c",
      "line": 22,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *\tlevel information is modified or an atomic operation needs to be used.",
        " *",
        " *\tIf more than one IAG is read at one time, the read lock may not",
        " *\tbe given up until all of the IAG's are read.  Otherwise, a deadlock",
        " *\tmay occur when trying to obtain the read lock while another thread",
        " *\tholding the read lock is waiting on the IAG already being held.",
        " *"
      ]
    },
    {
      "file": "linux\\fs\\jfs\\jfs_imap.c",
      "line": 1083,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * list.  before reading these iags, we must make",
        "\t\t * sure that we already don't have them in hand",
        "\t\t * from up above, since re-reading an iag (buffer)",
        "\t\t * we are currently holding would cause a deadlock.",
        "\t\t */",
        "\t\tif (inofreefwd >= 0) {",
        ""
      ]
    },
    {
      "file": "linux\\fs\\jfs\\jfs_logmgr.c",
      "line": 1807,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * the page cache (for the log).  This would be bad, since page",
        "\t * allocation waits on the kswapd thread that may be committing inodes",
        "\t * which would cause log activity.  Was that clear?  I'm trying to",
        "\t * avoid deadlock here.",
        "\t */",
        "\tinit_waitqueue_head(&log->free_wait);",
        ""
      ]
    },
    {
      "file": "linux\\fs\\jfs\\jfs_txnmgr.c",
      "line": 346,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * RETURN:\ttid\t- transaction id",
        " *",
        " * note: flag force allows to start tx for nested tx",
        " * to prevent deadlock on logsync barrier;",
        " */",
        "tid_t txBegin(struct super_block *sb, int flag)",
        "{"
      ]
    },
    {
      "file": "linux\\fs\\jfs\\jfs_txnmgr.c",
      "line": 1191,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * on the on-disk inode of file object",
        "\t *",
        "\t * sort the inodes array by inode number in descending order",
        "\t * to prevent deadlock when acquiring transaction lock",
        "\t * of on-disk inodes on multiple on-disk inode pages by",
        "\t * multiple concurrent transactions",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\jfs\\jfs_txnmgr.c",
      "line": 1219,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t *",
        "\t\t * The problem now is that we are holding the IWRITELOCK",
        "\t\t * on the inode, and calling filemap_fdatawrite on an",
        "\t\t * unmapped page will cause a deadlock in jfs_get_block.",
        "\t\t *",
        "\t\t * The long term solution is to pare down the use of",
        "\t\t * IWRITELOCK.  We are currently holding it too long."
      ]
    },
    {
      "file": "linux\\fs\\jfs\\jfs_txnmgr.c",
      "line": 1273,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tif (tblk->xflag & COMMIT_DELETE) {",
        "\t\tihold(tblk->u.ip);",
        "\t\t/*",
        "\t\t * Avoid a rare deadlock",
        "\t\t *",
        "\t\t * If the inode is locked, we may be blocked in",
        "\t\t * jfs_commit_inode.  If so, we don't want the"
      ]
    },
    {
      "file": "linux\\fs\\jfs\\jfs_txnmgr.c",
      "line": 1285,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t/*",
        "\t\t * I believe this code is no longer needed.  Splitting I_LOCK",
        "\t\t * into two bits, I_NEW and I_SYNC should prevent this",
        "\t\t * deadlock as well.  But since I don't have a JFS testload",
        "\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.",
        "\t\t * Joern",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\fs\\jfs\\jfs_txnmgr.c",
      "line": 2808,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *\tcompletion",
        " *",
        " *\tThis does almost the same thing as jfs_sync below.  We don't",
        " *\tworry about deadlocking when jfs_tlocks_low is set, since we would",
        " *\texpect jfs_sync to get us out of that jam.",
        " */",
        "void txQuiesce(struct super_block *sb)"
      ]
    },
    {
      "file": "linux\\fs\\jfs\\jfs_xtree.c",
      "line": 2128,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "",
        "/*",
        " * We can run into a deadlock truncating a file with a large number of",
        " * xtree pages (large fragmented file).  A robust fix would entail a",
        " * reservation system where we would reserve a number of metadata pages",
        " * and tlocks which we would be guaranteed without a deadlock.  Without"
      ]
    },
    {
      "file": "linux\\fs\\jfs\\jfs_xtree.c",
      "line": 2131,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * We can run into a deadlock truncating a file with a large number of",
        " * xtree pages (large fragmented file).  A robust fix would entail a",
        " * reservation system where we would reserve a number of metadata pages",
        " * and tlocks which we would be guaranteed without a deadlock.  Without",
        " * this, a partial fix is to limit number of metadata pages we will lock",
        " * in a single transaction.  Currently we will truncate the file so that",
        " * no more than 50 leaf pages will be locked.  The caller of xtTruncate"
      ]
    },
    {
      "file": "linux\\fs\\jfs\\jfs_xtree.c",
      "line": 2739,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * note:",
        " *",
        " *\tTo avoid deadlock by holding too many transaction locks, the",
        " *\ttruncation may be broken up into multiple transactions.",
        " *\tThe committed_size keeps track of part of the file has been",
        " *\tfreed from the pmaps."
      ]
    },
    {
      "file": "linux\\fs\\jfs\\namei.c",
      "line": 88,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Deadlock",
      "context": [
        "\t\tgoto out1;",
        "",
        "\t/*",
        "\t * Either iAlloc() or txBegin() may block.  Deadlock can occur if we",
        "\t * block there while holding dtree page, so we allocate the inode &",
        "\t * begin the transaction before we search the directory.",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\jfs\\namei.c",
      "line": 221,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Deadlock",
      "context": [
        "\t\tgoto out1;",
        "",
        "\t/*",
        "\t * Either iAlloc() or txBegin() may block.  Deadlock can occur if we",
        "\t * block there while holding dtree page, so we allocate the inode &",
        "\t * begin the transaction before we search the directory.",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\jfs\\namei.c",
      "line": 1157,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\ttid = txBegin(new_dir->i_sb, 0);",
        "",
        "\t/*",
        "\t * How do we know the locking is safe from deadlocks?",
        "\t * The vfs does the hard part for us.  Any time we are taking nested",
        "\t * commit_mutexes, the vfs already has i_mutex held on the parent.",
        "\t * Here, the vfs has already taken i_mutex on both old_dir and new_dir."
      ]
    },
    {
      "file": "linux\\fs\\kernfs\\dir.c",
      "line": 24,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * Don't use rename_lock to piggy back on pr_cont_buf. We don't want to",
        " * call pr_cont() while holding rename_lock. Because sometimes pr_cont()",
        " * will perform wakeups when releasing console_sem. Holding rename_lock",
        " * will introduce deadlock if the scheduler reads the kernfs_name in the",
        " * wakeup path.",
        " */",
        "static DEFINE_SPINLOCK(kernfs_pr_cont_lock);"
      ]
    },
    {
      "file": "linux\\fs\\kernfs\\mount.c",
      "line": 72,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * writing to various files in /sys/power/. As filesystems may",
        "\t * be automatically frozen during suspend/hibernate implementing",
        "\t * freeze/thaw support for kernfs generically will cause",
        "\t * deadlocks as the suspending/hibernation initiating task will",
        "\t * hold a VFS lock that it will then wait upon to be released.",
        "\t * If freeze/thaw for kernfs is needed talk to the VFS.",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\lockd\\svc4proc.c",
      "line": 56,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing parts of the file_lock",
      "context": [
        "\t\t\tgoto no_locks;",
        "\t\t*filp = file;",
        "",
        "\t\t/* Set up the missing parts of the file_lock structure */",
        "\t\tlock->fl.c.flc_file = file->f_file[mode];",
        "\t\tlock->fl.c.flc_pid = current->tgid;",
        "\t\tlock->fl.fl_start = (loff_t)lock->lock_start;"
      ]
    },
    {
      "file": "linux\\fs\\lockd\\svclock.c",
      "line": 12,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * of the worst ideas Sun ever had. Except maybe for the idea of doing",
        " * NFS file locking at all.",
        " *",
        " * I'm trying hard to avoid race conditions by protecting most accesses",
        " * to a file's list of blocked locks through a semaphore. The global",
        " * list of blocked locks is not protected in this fashion however.",
        " * Therefore, some functions (such as the RPC callback for the async grant"
      ]
    },
    {
      "file": "linux\\fs\\lockd\\svclock.c",
      "line": 37,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "#define NLMDBG_FACILITY\t\tNLMDBG_SVCLOCK",
        "",
        "#ifdef CONFIG_LOCKD_V4",
        "#define nlm_deadlock\tnlm4_deadlock",
        "#else",
        "#define nlm_deadlock\tnlm_lck_denied",
        "#endif"
      ]
    },
    {
      "file": "linux\\fs\\lockd\\svclock.c",
      "line": 37,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "#define NLMDBG_FACILITY\t\tNLMDBG_SVCLOCK",
        "",
        "#ifdef CONFIG_LOCKD_V4",
        "#define nlm_deadlock\tnlm4_deadlock",
        "#else",
        "#define nlm_deadlock\tnlm_lck_denied",
        "#endif"
      ]
    },
    {
      "file": "linux\\fs\\lockd\\svclock.c",
      "line": 39,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "#ifdef CONFIG_LOCKD_V4",
        "#define nlm_deadlock\tnlm4_deadlock",
        "#else",
        "#define nlm_deadlock\tnlm_lck_denied",
        "#endif",
        "",
        "static void nlmsvc_release_block(struct nlm_block *block);"
      ]
    },
    {
      "file": "linux\\fs\\lockd\\svclock.c",
      "line": 589,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\tgoto out;",
        "\t\tcase -EDEADLK:",
        "\t\t\tnlmsvc_remove_block(block);",
        "\t\t\tret = nlm_deadlock;",
        "\t\t\tgoto out;",
        "\t\tdefault:\t\t\t/* includes ENOLCK */",
        "\t\t\tnlmsvc_remove_block(block);"
      ]
    },
    {
      "file": "linux\\fs\\lockd\\svcproc.c",
      "line": 33,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tcase nlm_lck_denied_grace_period:",
        "\t\tcase nlm_drop_reply:",
        "\t\t\tbreak;",
        "\t\tcase nlm4_deadlock:",
        "\t\t\tstatus = nlm_lck_denied;",
        "\t\t\tbreak;",
        "\t\tdefault:"
      ]
    },
    {
      "file": "linux\\fs\\lockd\\svcproc.c",
      "line": 78,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing parts of the file_lock",
      "context": [
        "\t\t\tgoto no_locks;",
        "\t\t*filp = file;",
        "",
        "\t\t/* Set up the missing parts of the file_lock structure */",
        "\t\tmode = lock_to_openmode(&lock->fl);",
        "\t\tlock->fl.c.flc_flags = FL_POSIX;",
        "\t\tlock->fl.c.flc_file  = file->f_file[mode];"
      ]
    },
    {
      "file": "linux\\fs\\netfs\\buffered_write.c",
      "line": 155,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tpart = min(max_chunk - offset, iov_iter_count(iter));",
        "",
        "\t\t/* Bring in the user pages that we will copy from _first_ lest",
        "\t\t * we hit a nasty deadlock on copying from the same page as",
        "\t\t * we're writing to, without it being marked uptodate.",
        "\t\t *",
        "\t\t * Not only is this an optimisation, but it is also required to"
      ]
    },
    {
      "file": "linux\\fs\\netfs\\write_collect.c",
      "line": 54,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "/*",
        " * Successful completion of write of a folio to the server and/or cache.  Note",
        " * that we are not allowed to lock the folio here on pain of deadlocking with",
        " * truncate.",
        " */",
        "int netfs_folio_written_back(struct folio *folio)"
      ]
    },
    {
      "file": "linux\\fs\\nfs\\delegation.c",
      "line": 721,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * Note that this function is designed to be called by the state",
        " * manager thread. For this reason, it cannot flush the dirty data,",
        " * since that could deadlock in case of a state recovery error.",
        " *",
        " * Returns zero on success, or a negative errno value.",
        " */"
      ]
    },
    {
      "file": "linux\\fs\\nfs\\callback_xdr.c",
      "line": 1003,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "Buffer overflow",
      "context": [
        "\t\tnops++;",
        "\t}",
        "",
        "\t/* Buffer overflow in decode_ops_hdr or encode_ops_hdr. Return",
        "\t* resource error in cb_compound status without returning op */",
        "\tif (unlikely(status == htonl(NFS4ERR_RESOURCE_HDR))) {",
        "\t\tstatus = htonl(NFS4ERR_RESOURCE);"
      ]
    },
    {
      "file": "linux\\fs\\nfs\\inode.c",
      "line": 1481,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double-checks with spinlock",
      "context": [
        "\t\t/* pairs with nfs_set_cache_invalid()'s smp_store_release() */",
        "\t\tif (!(smp_load_acquire(&nfsi->cache_validity) & NFS_INO_INVALID_DATA))",
        "\t\t\tgoto out;",
        "\t\t/* Slow-path that double-checks with spinlock held */",
        "\t\tspin_lock(&inode->i_lock);",
        "\t\tif (test_bit(NFS_INO_INVALIDATING, bitlock)) {",
        "\t\t\tspin_unlock(&inode->i_lock);"
      ]
    },
    {
      "file": "linux\\fs\\nfs\\nfs4state.c",
      "line": 2604,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tconst char *section = \"\", *section_sep = \"\";",
        "",
        "\t/*",
        "\t * State recovery can deadlock if the direct reclaim code tries",
        "\t * start NFS writeback. So ensure memory allocations are all",
        "\t * GFP_NOFS.",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\nfs\\nfs4proc.c",
      "line": 4516,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * Got race?",
        " * Because OPEN is always done by name in nfsv4, it is",
        " * possible that we opened a different file by the same",
        " * name.  We can recognize this race condition, but we",
        " * can't do anything about it besides returning an error.",
        " *",
        " * This will be fixed with VFS changes (lookup-intent)."
      ]
    },
    {
      "file": "linux\\fs\\nfs\\nfs4proc.c",
      "line": 654,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t}",
        "\tif (exception->recovering) {",
        "\t\tif (exception->task_is_privileged)",
        "\t\t\treturn -EDEADLOCK;",
        "\t\tret = nfs4_wait_clnt_recover(clp);",
        "\t\tif (test_bit(NFS_MIG_FAILED, &server->mig_status))",
        "\t\t\treturn -EIO;"
      ]
    },
    {
      "file": "linux\\fs\\nfs\\nfs4proc.c",
      "line": 695,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t}",
        "\tif (exception->recovering) {",
        "\t\tif (exception->task_is_privileged)",
        "\t\t\treturn -EDEADLOCK;",
        "\t\trpc_sleep_on(&clp->cl_rpcwaitq, task, NULL);",
        "\t\tif (test_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) == 0)",
        "\t\t\trpc_wake_up_queued_task(&clp->cl_rpcwaitq, task);"
      ]
    },
    {
      "file": "linux\\fs\\nfs\\nfs4proc.c",
      "line": 2836,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\treturn PTR_ERR(opendata);",
        "\t/*",
        "\t * We're not recovering a delegation, so ask for no delegation.",
        "\t * Otherwise the recovery thread could deadlock with an outstanding",
        "\t * delegation return.",
        "\t */",
        "\topendata->o_arg.open_flags = O_DIRECT;"
      ]
    },
    {
      "file": "linux\\fs\\nfs\\nfs4proc.c",
      "line": 6521,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Since this string is allocated at mount time, and held until the",
        "\t * nfs_client is destroyed, we can use GFP_KERNEL here w/o worrying",
        "\t * about a memory-reclaim deadlock.",
        "\t */",
        "\tstr = kmalloc(len, GFP_KERNEL);",
        "\tif (!str)"
      ]
    },
    {
      "file": "linux\\fs\\nfs\\nfs4proc.c",
      "line": 6568,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Since this string is allocated at mount time, and held until the",
        "\t * nfs_client is destroyed, we can use GFP_KERNEL here w/o worrying",
        "\t * about a memory-reclaim deadlock.",
        "\t */",
        "\tstr = kmalloc(len, GFP_KERNEL);",
        "\tif (!str)"
      ]
    },
    {
      "file": "linux\\fs\\nfs\\pagelist.c",
      "line": 1424,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * @index: page index",
        " *",
        " * It is important to ensure that processes don't try to take locks",
        " * on non-contiguous ranges of pages as that might deadlock. This",
        " * function should be called before attempting to wait on a locked",
        " * nfs_page. It will complete the I/O if the page index 'index'",
        " * is not contiguous with the existing list of pages in 'desc'."
      ]
    },
    {
      "file": "linux\\fs\\nfs\\nfs4xdr.c",
      "line": 5409,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer.  We just have to do overflow",
      "context": [
        "\t/*",
        "\t * The XDR encode routine has set things up so that",
        "\t * the link text will be copied directly into the",
        "\t * buffer.  We just have to do overflow-checking,",
        "\t * and null-terminate the text (the VFS expects",
        "\t * null-termination).",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\nfs\\nfs4xdr.c",
      "line": 5500,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\tres->acl_data_offset = xdr_page_pos(xdr);",
        "\tres->acl_len = attrlen;",
        "",
        "\t/* Check for receive buffer overflow */",
        "\tif (res->acl_len > xdr_stream_remaining(xdr) ||",
        "\t    res->acl_len + res->acl_data_offset > xdr->buf->page_len) {",
        "\t\tres->acl_flags |= NFS4_ACL_TRUNC;"
      ]
    },
    {
      "file": "linux\\fs\\nfs\\pnfs.c",
      "line": 1417,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tsend = pnfs_prepare_layoutreturn(lo, &stateid, &cred, &iomode);",
        "\t\tspin_unlock(&inode->i_lock);",
        "\t\tif (send) {",
        "\t\t\t/* Send an async layoutreturn so we dont deadlock */",
        "\t\t\tpnfs_send_layoutreturn(lo, &stateid, &cred, iomode,",
        "\t\t\t\t\t       PNFS_FL_LAYOUTRETURN_ASYNC);",
        "\t\t}"
      ]
    },
    {
      "file": "linux\\fs\\nfs\\pnfs.c",
      "line": 3181,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tstruct nfs_pageio_descriptor pgio;",
        "",
        "\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {",
        "\t\t/* Prevent deadlocks with layoutreturn! */",
        "\t\tpnfs_put_lseg(hdr->lseg);",
        "\t\thdr->lseg = NULL;",
        ""
      ]
    },
    {
      "file": "linux\\fs\\nfsd\\nfs4callback.c",
      "line": 218,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t{ NFS4ERR_RESOURCE,\t-EREMOTEIO\t},",
        "\t{ NFS4ERR_SYMLINK,\t-ELOOP\t\t},",
        "\t{ NFS4ERR_OP_ILLEGAL,\t-EOPNOTSUPP\t},",
        "\t{ NFS4ERR_DEADLOCK,\t-EDEADLK\t},",
        "\t{ -1,\t\t\t-EIO\t\t}",
        "};",
        ""
      ]
    },
    {
      "file": "linux\\fs\\nfsd\\nfs4state.c",
      "line": 5332,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * @rqstp: the RPC transaction being executed",
        " * @inode: in-core inode of the file being waited for",
        " *",
        " * The timeout prevents deadlock if all nfsd threads happen to be",
        " * tied up waiting for returning delegations.",
        " *",
        " * Return values:"
      ]
    },
    {
      "file": "linux\\fs\\nfsd\\nfs4state.c",
      "line": 8306,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tnfs4_set_lock_denied(conflock, &lock->lk_denied);",
        "\t\tbreak;",
        "\tcase -EDEADLK:",
        "\t\tstatus = nfserr_deadlock;",
        "\t\tbreak;",
        "\tdefault:",
        "\t\tdprintk(\"NFSD: nfsd4_lock: vfs_lock_file() failed! status %d\\n\",err);"
      ]
    },
    {
      "file": "linux\\fs\\nfsd\\vfs.c",
      "line": 2116,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * We do this buffering because we must not call back into the file",
        " * system's ->lookup() method from the filldir callback. That may well",
        " * deadlock a number of file systems.",
        " *",
        " * This is based heavily on the implementation of same in XFS.",
        " */"
      ]
    },
    {
      "file": "linux\\fs\\nfs_common\\common.c",
      "line": 105,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t{ NFS4ERR_TOOSMALL,\t-ETOOSMALL\t},",
        "\t{ NFS4ERR_BADTYPE,\t-EBADTYPE\t},",
        "\t{ NFS4ERR_SYMLINK,\t-ELOOP\t\t},",
        "\t{ NFS4ERR_DEADLOCK,\t-EDEADLK\t},",
        "};",
        "",
        "static const struct {"
      ]
    },
    {
      "file": "linux\\fs\\nilfs2\\cpfile.c",
      "line": 170,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing header block",
      "context": [
        "",
        "\tif (unlikely(err == -ENOENT)) {",
        "\t\tnilfs_error(cpfile->i_sb,",
        "\t\t\t    \"missing header block in checkpoint metadata\");",
        "\t\terr = -EIO;",
        "\t}",
        "\treturn err;"
      ]
    },
    {
      "file": "linux\\fs\\nilfs2\\inode.c",
      "line": 111,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t\t\t * be locked in this case.",
        "\t\t\t\t */",
        "\t\t\t\tnilfs_warn(inode->i_sb,",
        "\t\t\t\t\t   \"%s (ino=%lu): a race condition while inserting a data block at offset=%llu\",",
        "\t\t\t\t\t   __func__, inode->i_ino,",
        "\t\t\t\t\t   (unsigned long long)blkoff);",
        "\t\t\t\terr = -EAGAIN;"
      ]
    },
    {
      "file": "linux\\fs\\nilfs2\\sufile.c",
      "line": 98,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing header block",
      "context": [
        "",
        "\tif (unlikely(err == -ENOENT)) {",
        "\t\tnilfs_error(sufile->i_sb,",
        "\t\t\t    \"missing header block in segment usage metadata\");",
        "\t\terr = -EIO;",
        "\t}",
        "\treturn err;"
      ]
    },
    {
      "file": "linux\\fs\\nilfs2\\sufile.c",
      "line": 1247,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing header block",
      "context": [
        "\tif (unlikely(err)) {",
        "\t\tif (err == -ENOENT) {",
        "\t\t\tnilfs_err(sb,",
        "\t\t\t\t  \"missing header block in segment usage metadata\");",
        "\t\t\terr = -EINVAL;",
        "\t\t}",
        "\t\tgoto failed;"
      ]
    },
    {
      "file": "linux\\fs\\nilfs2\\segment.c",
      "line": 2039,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t\tgoto retry;",
        "\t\t}",
        "",
        "\t\t// Always redirty the buffer to avoid race condition",
        "\t\tmark_buffer_dirty(ii->i_bh);",
        "\t\tnilfs_mdt_mark_dirty(ifile);",
        ""
      ]
    },
    {
      "file": "linux\\fs\\nilfs2\\segment.c",
      "line": 184,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * the segment semaphore, to make a segment construction and write tasks",
        " * exclusive.  The function is used with nilfs_transaction_commit() in pairs.",
        " * The region enclosed by these two functions can be nested.  To avoid a",
        " * deadlock, the semaphore is only acquired or released in the outermost call.",
        " *",
        " * This function allocates a nilfs_transaction_info struct to keep context",
        " * information on it.  It is initialized and hooked onto the current task in"
      ]
    },
    {
      "file": "linux\\fs\\nilfs2\\segment.c",
      "line": 2071,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tlist_del_init(&ii->i_dirty);",
        "\t\tif (!ii->vfs_inode.i_nlink || during_mount) {",
        "\t\t\t/*",
        "\t\t\t * Defer calling iput() to avoid deadlocks if",
        "\t\t\t * i_nlink == 0 or mount is not yet finished.",
        "\t\t\t */",
        "\t\t\tlist_add_tail(&ii->i_dirty, &sci->sc_iput_queue);"
      ]
    },
    {
      "file": "linux\\fs\\nilfs2\\segment.c",
      "line": 2323,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tif (sb_rdonly(sb) || unlikely(!sci))",
        "\t\treturn -EROFS;",
        "",
        "\t/* A call inside transactions causes a deadlock. */",
        "\tBUG_ON((ti = current->journal_info) && ti->ti_magic == NILFS_TI_MAGIC);",
        "",
        "\treturn nilfs_segctor_sync(sci);"
      ]
    },
    {
      "file": "linux\\fs\\ntfs3\\index.c",
      "line": 2145,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "used indexes after current free",
      "context": [
        "\t\treturn 0;",
        "",
        "\t/*",
        "\t * If there are no used indexes after current free index",
        "\t * then we can truncate allocation and bitmap.",
        "\t * Use bitmap to estimate the case.",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\ntfs3\\namei.c",
      "line": 94,
      "pattern": "null.*pointer.*dereference",
      "rule": "memory_management",
      "severity": "high",
      "match": "null pointer dereference",
      "context": [
        "\t/*",
        "\t * Check for a null pointer",
        "\t * If the MFT record of ntfs inode is not a base record, inode->i_op can be NULL.",
        "\t * This causes null pointer dereference in d_splice_alias().",
        "\t */",
        "\tif (!IS_ERR_OR_NULL(inode) && !inode->i_op) {",
        "\t\tiput(inode);"
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\aops.c",
      "line": 1823,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * The mmapped page won't be unlocked in ocfs2_free_write_ctxt(),",
        "\t * even in case of error here like ENOSPC and ENOMEM. So, we need",
        "\t * to unlock the target page manually to prevent deadlocks when",
        "\t * retrying again on ENOSPC, or when returning non-VM_FAULT_LOCKED",
        "\t * to VM code.",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\aops.c",
      "line": 2033,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "out:",
        "\t/* unlock pages before dealloc since it needs acquiring j_trans_barrier",
        "\t * lock, or it will cause a deadlock since journal commit threads holds",
        "\t * this lock and will ask for the page lock when flushing the data.",
        "\t * put it here to preserve the unlock order.",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\alloc.c",
      "line": 6035,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double free",
      "context": [
        "\t * two separated transactions. They can be both committed but not",
        "\t * checkpointed. If crash occurs then, both two transaction will be",
        "\t * replayed with several already released to global bitmap clusters.",
        "\t * Then truncate log will be replayed resulting in cluster double free.",
        "\t */",
        "\tjbd2_journal_lock_updates(journal->j_journal);",
        "\tstatus = jbd2_journal_flush(journal->j_journal, 0);"
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\alloc.c",
      "line": 6392,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * These structures allow the delay of block de-allocation until a",
        " * later time, when locking of multiple cluster inodes won't cause",
        " * deadlock.",
        " */",
        "",
        "/*"
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\dcache.c",
      "line": 393,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing cluster lock",
      "context": [
        "\t\t\tunsigned long long ino = 0ULL;",
        "\t\t\tif (inode)",
        "\t\t\t\tino = (unsigned long long)OCFS2_I(inode)->ip_blkno;",
        "\t\t\tmlog(ML_ERROR, \"Dentry is missing cluster lock. \"",
        "\t\t\t     \"inode: %llu, d_flags: 0x%x, d_name: %pd\\n\",",
        "\t\t\t     ino, dentry->d_flags, dentry);",
        "\t\t}"
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\dlmglue.c",
      "line": 1966,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *   no-lock at unlock time. This also means flock locks never go on",
        " *   the blocking list).",
        " *",
        " * - Since userspace can trivially deadlock itself with flock, we make",
        " *   sure to allow cancellation of a misbehaving applications flock()",
        " *   request.",
        " *"
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\dlmglue.c",
      "line": 2042,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tret = ocfs2_wait_for_mask_interruptible(&mw, lockres);",
        "\tif (ret == -ERESTARTSYS) {",
        "\t\t/*",
        "\t\t * Userspace can cause deadlock itself with",
        "\t\t * flock(). Current behavior locally is to allow the",
        "\t\t * deadlock, but abort the system call if a signal is",
        "\t\t * received. We follow this example, otherwise a"
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\dlmglue.c",
      "line": 2044,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t/*",
        "\t\t * Userspace can cause deadlock itself with",
        "\t\t * flock(). Current behavior locally is to allow the",
        "\t\t * deadlock, but abort the system call if a signal is",
        "\t\t * received. We follow this example, otherwise a",
        "\t\t * poorly written program could sit in kernel until",
        "\t\t * reboot."
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\dlmglue.c",
      "line": 3521,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * because we are the downconvert thread and processing",
        "\t\t * different lock. So we can just remove the lock from the",
        "\t\t * queue. This is not only an optimization but also a way",
        "\t\t * to avoid the following deadlock:",
        "\t\t *   ocfs2_dentry_post_unlock()",
        "\t\t *     ocfs2_dentry_lock_put()",
        "\t\t *       ocfs2_drop_dentry_lock()"
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\dlmglue.c",
      "line": 3541,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t/*",
        "\t\t * Warn if we recurse into another post_unlock call.  Strictly",
        "\t\t * speaking it isn't a problem but we need to be careful if",
        "\t\t * that happens (stack overflow, deadlocks, ...) so warn if",
        "\t\t * ocfs2 grows a path for which this can happen.",
        "\t\t */",
        "\t\tWARN_ON_ONCE(lockres->l_ops->post_unlock);"
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\dlmglue.c",
      "line": 3541,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "stack overflow",
      "context": [
        "\t\t/*",
        "\t\t * Warn if we recurse into another post_unlock call.  Strictly",
        "\t\t * speaking it isn't a problem but we need to be careful if",
        "\t\t * that happens (stack overflow, deadlocks, ...) so warn if",
        "\t\t * ocfs2 grows a path for which this can happen.",
        "\t\t */",
        "\t\tWARN_ON_ONCE(lockres->l_ops->post_unlock);"
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\file.c",
      "line": 1161,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tif (size_change) {",
        "\t\t/*",
        "\t\t * Here we should wait dio to finish before inode lock",
        "\t\t * to avoid a deadlock between ocfs2_setattr() and",
        "\t\t * ocfs2_dio_end_io_write()",
        "\t\t */",
        "\t\tinode_dio_wait(inode);"
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\journal.c",
      "line": 425,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * WARNING: This will not release any semaphores or disk locks taken",
        " * during the transaction, so make sure they were taken *before*",
        " * start_trans or we'll have ordering deadlocks.",
        " *",
        " * WARNING2: Note that we do *not* drop j_trans_barrier here. This is",
        " * good because transaction ids haven't yet been recorded on the"
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\journal.c",
      "line": 2286,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * - We grab as many inodes as we can under the orphan dir lock -",
        " *   doing iget() outside the orphan dir risks getting a reference on",
        " *   an invalid inode.",
        " * - We must be sure not to deadlock with other processes on the",
        " *   system wanting to run delete_inode(). This can happen when they go",
        " *   to lock the orphan dir and the orphan recovery process attempts to",
        " *   iget() inside the orphan dir lock. This can be avoided by"
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\inode.c",
      "line": 447,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t *",
        "\t * 3) If the process doing the iget() is responsible for",
        "\t *    orphan dir recovery. We're holding the orphan dir lock and",
        "\t *    can get into a deadlock with another process on another",
        "\t *    node in ->delete_inode().",
        "\t *",
        "\t * #1 and #2 can be simply solved by never taking the lock"
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\inode.c",
      "line": 730,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * Serialize with orphan dir recovery. If the process doing",
        " * recovery on this orphan dir does an iget() with the dir",
        " * i_rwsem held, we'll deadlock here. Instead we detect this",
        " * and exit early - recovery will wipe this inode for us.",
        " */",
        "static int ocfs2_check_orphan_recovery_state(struct ocfs2_super *osb,"
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\inode.c",
      "line": 872,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * If we're coming from downconvert_thread we can't go into our own",
        "\t * voting [hello, deadlock city!] so we cannot delete the inode. But",
        "\t * since we dropped last inode ref when downconverting dentry lock,",
        "\t * we cannot have the file open and thus the node doing unlink will",
        "\t * take care of deleting the inode."
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\inode.c",
      "line": 972,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * is no longer live and can be deleted.",
        "\t *",
        "\t * Though we call this with the meta data lock held, the",
        "\t * trylock keeps us from ABBA deadlock.",
        "\t */",
        "\tstatus = ocfs2_try_open_lock(inode, 1);",
        "\tif (status == -EAGAIN) {"
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\localalloc.c",
      "line": 1266,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double free",
      "context": [
        "",
        "\t/* We want to clear the local alloc before doing anything",
        "\t * else, so that if we error later during this operation,",
        "\t * local alloc shutdown won't try to double free main bitmap",
        "\t * bits. Make a copy so the sync function knows which bits to",
        "\t * free. */",
        "\talloc_copy = kmemdup(alloc, osb->local_alloc_bh->b_size, GFP_NOFS);"
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\namei.c",
      "line": 85,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "\t\t\t\t     struct inode *inode,",
        "\t\t\t\t     const char *symname);",
        "",
        "static int ocfs2_double_lock(struct ocfs2_super *osb,",
        "\t\t\t     struct buffer_head **bh1,",
        "\t\t\t     struct inode *inode1,",
        "\t\t\t     struct buffer_head **bh2,"
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\namei.c",
      "line": 92,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\t\t\t     struct inode *inode2,",
        "\t\t\t     int rename);",
        "",
        "static void ocfs2_double_unlock(struct inode *inode1, struct inode *inode2);",
        "/* An orphan dir name is an 8 byte value, printed as a hex string */",
        "#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))",
        ""
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\namei.c",
      "line": 710,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "\t\treturn err;",
        "\t}",
        "",
        "\terr = ocfs2_double_lock(osb, &old_dir_bh, old_dir,",
        "\t\t\t&parent_fe_bh, dir, 0);",
        "\tif (err < 0) {",
        "\t\tif (err != -ENOENT)"
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\namei.c",
      "line": 830,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\tocfs2_inode_unlock(inode, 1);",
        "",
        "out:",
        "\tocfs2_double_unlock(old_dir, dir);",
        "",
        "\tbrelse(fe_bh);",
        "\tbrelse(parent_fe_bh);"
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\namei.c",
      "line": 1111,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        " * The only place this should be used is rename and link!",
        " * if they have the same id, then the 1st one is the only one locked.",
        " */",
        "static int ocfs2_double_lock(struct ocfs2_super *osb,",
        "\t\t\t     struct buffer_head **bh1,",
        "\t\t\t     struct inode *inode1,",
        "\t\t\t     struct buffer_head **bh2,"
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\namei.c",
      "line": 1123,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "\tstruct ocfs2_inode_info *oi1 = OCFS2_I(inode1);",
        "\tstruct ocfs2_inode_info *oi2 = OCFS2_I(inode2);",
        "",
        "\ttrace_ocfs2_double_lock((unsigned long long)oi1->ip_blkno,",
        "\t\t\t\t(unsigned long long)oi2->ip_blkno);",
        "",
        "\tif (*bh1)"
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\namei.c",
      "line": 1183,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "\t\t\tmlog_errno(status);",
        "\t}",
        "",
        "\ttrace_ocfs2_double_lock_end(",
        "\t\t\t(unsigned long long)oi1->ip_blkno,",
        "\t\t\t(unsigned long long)oi2->ip_blkno);",
        ""
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\namei.c",
      "line": 1193,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\treturn status;",
        "}",
        "",
        "static void ocfs2_double_unlock(struct inode *inode1, struct inode *inode2)",
        "{",
        "\tocfs2_inode_unlock(inode1, 1);",
        ""
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\namei.c",
      "line": 1295,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "\t}",
        "",
        "\t/* if old and new are the same, this'll just do one lock. */",
        "\tstatus = ocfs2_double_lock(osb, &old_dir_bh, old_dir,",
        "\t\t\t\t   &new_dir_bh, new_dir, 1);",
        "\tif (status < 0) {",
        "\t\tmlog_errno(status);"
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\namei.c",
      "line": 1677,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\t\tocfs2_inode_unlock(old_inode, 1);",
        "",
        "\tif (parents_locked)",
        "\t\tocfs2_double_unlock(old_dir, new_dir);",
        "",
        "\tif (rename_lock)",
        "\t\tocfs2_rename_unlock(osb);"
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\quota_global.c",
      "line": 653,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tstruct super_block *sb = oinfo->dqi_gqinode->i_sb;",
        "",
        "\t/*",
        "\t * We have to be careful here not to deadlock on s_umount as umount",
        "\t * disabling quotas may be in progress and it waits for this work to",
        "\t * complete. If trylock fails, we'll do the sync next time...",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\quota_global.c",
      "line": 726,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * Called when the last reference to dquot is dropped. If we are called from",
        " * downconvert thread, we cannot do all the handling here because grabbing",
        " * quota lock could deadlock (the node holding the quota lock could need some",
        " * other cluster lock to proceed but with blocked downconvert thread we cannot",
        " * release any lock).",
        " */"
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\refcounttree.c",
      "line": 4735,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "\toi1 = OCFS2_I(inode1);",
        "\toi2 = OCFS2_I(inode2);",
        "",
        "\ttrace_ocfs2_double_lock((unsigned long long)oi1->ip_blkno,",
        "\t\t\t\t(unsigned long long)oi2->ip_blkno);",
        "",
        "\t/* We always want to lock the one with the lower lockid first. */"
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\refcounttree.c",
      "line": 4773,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "\t*bh_s = bh1;",
        "\t*bh_t = bh2;",
        "",
        "\ttrace_ocfs2_double_lock_end(",
        "\t\t\t(unsigned long long)oi1->ip_blkno,",
        "\t\t\t(unsigned long long)oi2->ip_blkno);",
        ""
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\stack_o2cb.c",
      "line": 133,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t[DLM_ABORT]\t\t\t= -EINVAL,",
        "\t[DLM_CANCEL]\t\t\t= -DLM_ECANCEL,\t/* Successful cancel */",
        "\t[DLM_IVRESHANDLE]\t\t= -EINVAL,",
        "\t[DLM_DEADLOCK]\t\t\t= -EDEADLK,",
        "\t[DLM_DENIED_NOASTS]\t\t= -EINVAL,",
        "\t[DLM_FORWARD]\t\t\t= -EINVAL,",
        "\t[DLM_TIMEOUT]\t\t\t= -ETIMEDOUT,"
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\xattr.c",
      "line": 5749,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * We have to do CoW before ocfs2_init_xattr_set_ctxt since",
        " * currently CoW is a completed transaction, while this function",
        " * will also lock the allocators and let us deadlock. So we will",
        " * CoW the whole xattr value.",
        " */",
        "static int ocfs2_prepare_refcount_xattr(struct inode *inode,"
      ]
    },
    {
      "file": "linux\\fs\\orangefs\\devorangefs-req.c",
      "line": 576,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "{",
        "\t/* Check for valid ioctl codes */",
        "\tif (_IOC_TYPE(command) != ORANGEFS_DEV_MAGIC) {",
        "\t\tgossip_err(\"device ioctl magic numbers don't match! Did you rebuild pvfs2-client-core/libpvfs2? [cmd %x, magic %x != %x]\\n\",",
        "\t\t\tcommand,",
        "\t\t\t_IOC_TYPE(command),",
        "\t\t\tORANGEFS_DEV_MAGIC);"
      ]
    },
    {
      "file": "linux\\fs\\orangefs\\orangefs-utils.c",
      "line": 466,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\tEFAULT, EBUSY, EEXIST, ENODEV, ENOTDIR, EISDIR, EINVAL, EMFILE,",
        "\tEFBIG, ENOSPC, EROFS, EMLINK, EPIPE, EDEADLK, ENAMETOOLONG,",
        "\tENOLCK, ENOSYS, ENOTEMPTY, ELOOP, EWOULDBLOCK, ENOMSG, EUNATCH,",
        "\tEBADR, EDEADLOCK, ENODATA, ETIME, ENONET, EREMOTE, ECOMM,",
        "\tEPROTO, EBADMSG, EOVERFLOW, ERESTART, EMSGSIZE, EPROTOTYPE,",
        "\tENOPROTOOPT, EPROTONOSUPPORT, EOPNOTSUPP, EADDRINUSE,",
        "\tEADDRNOTAVAIL, ENETDOWN, ENETUNREACH, ENETRESET, ENOBUFS,"
      ]
    },
    {
      "file": "linux\\fs\\overlayfs\\file.c",
      "line": 410,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "}",
        "",
        "/*",
        " * Calling iter_file_splice_write() directly from overlay's f_op may deadlock",
        " * due to lock order inversion between pipe->mutex in iter_file_splice_write()",
        " * and file_start_write(realfile) in ovl_write_iter().",
        " *"
      ]
    },
    {
      "file": "linux\\fs\\proc\\base.c",
      "line": 10,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magical inumbers",
      "context": [
        " *  proc base directory handling functions",
        " *",
        " *  1999, Al Viro. Rewritten. Now it covers the whole per-process part.",
        " *  Instead of using magical inumbers to determine the kind of object",
        " *  we allocate and fill in-core inodes upon lookup. They don't even",
        " *  go into icache. We cache the reference to task_struct upon lookup too.",
        " *  Eventually it should become a filesystem in its own. We don't use the"
      ]
    },
    {
      "file": "linux\\fs\\quota\\dquot.c",
      "line": 26,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *\t\tinvalidate_dquots() now writes modified dquots.",
        " *\t\tSerialized quota_off() and quota_on() for mount point.",
        " *\t\tFixed a few bugs in grow_dquots().",
        " *\t\tFixed deadlock in write_dquot() - we no longer account quotas on",
        " *\t\tquota files",
        " *\t\tremove_dquot_ref() moved to inode.c - it now traverses through inodes",
        " *\t\tadd_dquot_ref() restarts after blocking"
      ]
    },
    {
      "file": "linux\\fs\\quota\\dquot.c",
      "line": 2389,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tif (!dqopt->files[type])",
        "\t\treturn -EIO;",
        "\tif (!(dqopt->flags & DQUOT_QUOTA_SYS_FILE)) {",
        "\t\t/* We don't want quota and atime on quota files (deadlocks",
        "\t\t * possible) Also nobody should write to the file - we use",
        "\t\t * special IO operations which ignore the immutable bit. */",
        "\t\tinode_lock(inode);"
      ]
    },
    {
      "file": "linux\\fs\\quota\\netlink.c",
      "line": 49,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/* We have to allocate using GFP_NOFS as we are called from a",
        "\t * filesystem performing write and thus further recursion into",
        "\t * the fs to free some data could cause deadlocks. */",
        "\tskb = genlmsg_new(msg_size, GFP_NOFS);",
        "\tif (!skb) {",
        "\t\tprintk(KERN_ERR"
      ]
    },
    {
      "file": "linux\\fs\\quota\\quota.c",
      "line": 945,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Path for quotaon has to be resolved before grabbing superblock",
        "\t * because that gets s_umount sem which is also possibly needed by path",
        "\t * resolution (think about autofs) and thus deadlocks could arise.",
        "\t */",
        "\tif (cmds == Q_QUOTAON) {",
        "\t\tret = user_path_at(AT_FDCWD, addr, LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT, &path);"
      ]
    },
    {
      "file": "linux\\fs\\quota\\quota_tree.c",
      "line": 436,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "}",
        "",
        "/*",
        " * We don't have to be afraid of deadlocks as we never have quotas on quota",
        " * files...",
        " */",
        "int qtree_write_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot)"
      ]
    },
    {
      "file": "linux\\fs\\resctrl\\rdtgroup.c",
      "line": 4283,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * &mm->mmap_lock --> rdtgroup_mutex for the latter that can cause",
        "\t * issues considering the other two lock dependencies.",
        "\t * By creating the debugfs directory here we avoid a dependency",
        "\t * that may cause deadlock (even though file operations cannot",
        "\t * occur until the filesystem is mounted, but I do not know how to",
        "\t * tell lockdep that).",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\resctrl\\pseudo_lock.c",
      "line": 861,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * pseudo-locked region will still be here on return.",
        "\t *",
        "\t * The mutex has to be released temporarily to avoid a potential",
        "\t * deadlock with the mm->mmap_lock which is obtained in the",
        "\t * device_create() and debugfs_create_dir() callpath below as well as",
        "\t * before the mmap() callback is called.",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\romfs\\super.c",
      "line": 28,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double unlock",
      "context": [
        " *\t\t\t\t\tlookup shouldn't return -ENOENT",
        " *\t\t\t\t\tfrom Horst von Brand:",
        " *\t\t\t\t\t  fail on wrong checksum",
        " *\t\t\t\t\t  double unlock_super was possible",
        " *\t\t\t\t\t  correct namelen for statfs",
        " *\t\t\t\t\tspotted by Bill Hawes:",
        " *\t\t\t\t\t  readlink shouldn't iput()"
      ]
    },
    {
      "file": "linux\\fs\\tracefs\\event_inode.c",
      "line": 710,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * NB. @callback is called while holding internal locks of the eventfs",
        " *     system. The callback must not call any code that might also call into",
        " *     the tracefs or eventfs system or it will risk creating a deadlock.",
        " */",
        "struct eventfs_inode *eventfs_create_dir(const char *name, struct eventfs_inode *parent,",
        "\t\t\t\t\t const struct eventfs_entry *entries,"
      ]
    },
    {
      "file": "linux\\fs\\ubifs\\dir.c",
      "line": 1429,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\twht_req.new_ino = 1;",
        "\t\twht_req.new_ino_d = ALIGN(whiteout_ui->data_len, 8);",
        "\t\t/*",
        "\t\t * To avoid deadlock between space budget (holds ui_mutex and",
        "\t\t * waits wb work) and writeback work(waits ui_mutex), do space",
        "\t\t * budget before ubifs inodes locked.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\fs\\ubifs\\file.c",
      "line": 221,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * At the slow path we have to budget before locking the folio, because",
        "\t * budgeting may force write-back, which would wait on locked folios and",
        "\t * deadlock if we had the folio locked. At this point we do not know",
        "\t * anything about the folio, so assume that this is a new folio which is",
        "\t * written to a hole. This corresponds to largest budget. Later the",
        "\t * budget will be amended if this is not true."
      ]
    },
    {
      "file": "linux\\fs\\ubifs\\file.c",
      "line": 468,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * Budgeting failed which means it would have to force",
        "\t\t * write-back but didn't, because we set the @fast flag in the",
        "\t\t * request. Write-back cannot be done now, while we have the",
        "\t\t * page locked, because it would deadlock. Unlock and free",
        "\t\t * everything and fall-back to slow-path.",
        "\t\t */",
        "\t\tif (appending) {"
      ]
    },
    {
      "file": "linux\\fs\\ubifs\\file.c",
      "line": 960,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * we have to call 'truncate_setsize()', which first changes @inode->i_size,",
        " * then drops the truncated pages. And while dropping the pages, it takes the",
        " * page lock. This means that 'do_truncation()' cannot call 'truncate_setsize()'",
        " * with @ui_mutex locked, because it would deadlock with 'ubifs_writepage()'.",
        " * This means that @inode->i_size is changed while @ui_mutex is unlocked.",
        " *",
        " * XXX(truncate): with the new truncate sequence this is not true anymore,"
      ]
    },
    {
      "file": "linux\\fs\\ubifs\\file.c",
      "line": 1506,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * We have not locked @folio so far so we may budget for changing the",
        "\t * folio. Note, we cannot do this after we locked the folio, because",
        "\t * budgeting may cause write-back which would cause deadlock.",
        "\t *",
        "\t * At the moment we do not know whether the folio is dirty or not, so we",
        "\t * assume that it is not and budget for a new folio. We could look at"
      ]
    },
    {
      "file": "linux\\fs\\udf\\misc.c",
      "line": 162,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t\tgaf = (struct genericFormat *)&ea[offset];",
        "\t\t\tattrLength = le32_to_cpu(gaf->attrLength);",
        "",
        "\t\t\t/* Detect undersized elements and buffer overflows */",
        "\t\t\tif ((attrLength < sizeof(*gaf)) ||",
        "\t\t\t    (attrLength > (iinfo->i_lenEAttr - offset)))",
        "\t\t\t\tbreak;"
      ]
    },
    {
      "file": "linux\\fs\\ufs\\ialloc.c",
      "line": 44,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "/*",
        " * NOTE! When we get the inode, we're the only people",
        " * that have access to it, and as such there are no",
        " * race conditions we have to worry about. The inode",
        " * is not on the hash-lists, and it cannot be reached",
        " * through the filesystem because the directory entry",
        " * has been deleted earlier."
      ]
    },
    {
      "file": "linux\\fs\\ufs\\inode.c",
      "line": 54,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_block",
      "context": [
        "\tint ptrs_bits = uspi->s_apbshift;",
        "\tconst long direct_blocks = UFS_NDADDR,",
        "\t\tindirect_blocks = ptrs,",
        "\t\tdouble_blocks = (1 << (ptrs_bits * 2));",
        "\tint n = 0;",
        "",
        ""
      ]
    },
    {
      "file": "linux\\fs\\ufs\\inode.c",
      "line": 58,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_blocks=%ld \\n\",ptrs,double_block",
      "context": [
        "\tint n = 0;",
        "",
        "",
        "\tUFSD(\"ptrs=uspi->s_apb = %d,double_blocks=%ld \\n\",ptrs,double_blocks);",
        "\tif (i_block < direct_blocks) {",
        "\t\toffsets[n++] = i_block;",
        "\t} else if ((i_block -= direct_blocks) < indirect_blocks) {"
      ]
    },
    {
      "file": "linux\\fs\\ufs\\inode.c",
      "line": 64,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_block",
      "context": [
        "\t} else if ((i_block -= direct_blocks) < indirect_blocks) {",
        "\t\toffsets[n++] = UFS_IND_BLOCK;",
        "\t\toffsets[n++] = i_block;",
        "\t} else if ((i_block -= indirect_blocks) < double_blocks) {",
        "\t\toffsets[n++] = UFS_DIND_BLOCK;",
        "\t\toffsets[n++] = i_block >> ptrs_bits;",
        "\t\toffsets[n++] = i_block & (ptrs - 1);"
      ]
    },
    {
      "file": "linux\\fs\\ufs\\inode.c",
      "line": 68,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_block",
      "context": [
        "\t\toffsets[n++] = UFS_DIND_BLOCK;",
        "\t\toffsets[n++] = i_block >> ptrs_bits;",
        "\t\toffsets[n++] = i_block & (ptrs - 1);",
        "\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {",
        "\t\toffsets[n++] = UFS_TIND_BLOCK;",
        "\t\toffsets[n++] = i_block >> (ptrs_bits * 2);",
        "\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);"
      ]
    },
    {
      "file": "linux\\fs\\verity\\enable.c",
      "line": 382,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\t/*",
        "\t * We no longer drop the inode's pagecache after enabling verity.  This",
        "\t * used to be done to try to avoid a race condition where pages could be",
        "\t * evicted after being used in the Merkle tree construction, then",
        "\t * re-instantiated by a concurrent read.  Such pages are unverified, and",
        "\t * the backing storage could have filled them with different content, so"
      ]
    },
    {
      "file": "linux\\fs\\verity\\enable.c",
      "line": 389,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * they shouldn't be used to fulfill reads once verity is enabled.",
        "\t *",
        "\t * But, dropping the pagecache has a big performance impact, and it",
        "\t * doesn't fully solve the race condition anyway.  So for those reasons,",
        "\t * and also because this race condition isn't very important relatively",
        "\t * speaking (especially for small-ish files, where the chance of a page",
        "\t * being used, evicted, *and* re-instantiated all while enabling verity"
      ]
    },
    {
      "file": "linux\\fs\\verity\\enable.c",
      "line": 390,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t *",
        "\t * But, dropping the pagecache has a big performance impact, and it",
        "\t * doesn't fully solve the race condition anyway.  So for those reasons,",
        "\t * and also because this race condition isn't very important relatively",
        "\t * speaking (especially for small-ish files, where the chance of a page",
        "\t * being used, evicted, *and* re-instantiated all while enabling verity",
        "\t * is quite small), we no longer drop the inode's pagecache."
      ]
    },
    {
      "file": "linux\\fs\\verity\\enable.c",
      "line": 30,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\tint err;",
        "",
        "\t/*",
        "\t * Safety check to prevent a buffer overflow in case of a filesystem bug",
        "\t * that allows the file size to change despite deny_write_access(), or a",
        "\t * bug in the Merkle tree logic itself",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_aops.c",
      "line": 727,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * because the refcountbt entries for the extents being removed have",
        "\t * not yet been updated.  Hence the swapon call fails unexpectedly.",
        "\t *",
        "\t * The race condition is currently most obvious from the unlink()",
        "\t * operation as extent removal is deferred until after the last",
        "\t * reference to the inode goes away.  We then process the extent",
        "\t * removal asynchronously, hence triggers the \"syscall completed but"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_aops.c",
      "line": 119,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * We can allocate memory here while doing writeback on behalf of",
        "\t * memory reclaim.  To avoid memory allocation deadlocks set the",
        "\t * task-wide nofs context for the following operations.",
        "\t */",
        "\tnofs_flag = memalloc_nofs_save();"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_aops.c",
      "line": 468,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * We can allocate memory here while doing writeback on behalf of",
        "\t * memory reclaim.  To avoid memory allocation deadlocks set the",
        "\t * task-wide nofs context for the following operations.",
        "\t */",
        "\tnofs_flag = memalloc_nofs_save();"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_buf_item.c",
      "line": 402,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * refcount drops to zero, the bli could still be AIL resident and the buffer",
        " * submitted for I/O at any point before we return. This can result in IO",
        " * completion freeing the buffer while we are still trying to access it here.",
        " * This race condition can also occur in shutdown situations where we abort and",
        " * unpin buffers from contexts other that journal IO completion.",
        " *",
        " * Hence we have to hold a buffer reference per pin count to ensure that the"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_buf_item.c",
      "line": 517,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t * If we have just raced with a buffer being pinned and it has",
        "\t\t * been marked stale, we could end up stalling until someone else",
        "\t\t * issues a log force to unpin the stale buffer. Check for the",
        "\t\t * race condition here so xfsaild recognizes the buffer is pinned",
        "\t\t * and queues a log force to move it along.",
        "\t\t */",
        "\t\tif (xfs_buf_ispinned(bp))"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_buf.c",
      "line": 758,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "}",
        "",
        "/*",
        " *\tIf we are not low on memory then do the readahead in a deadlock",
        " *\tsafe manner.",
        " */",
        "void"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_buf_item_recover.c",
      "line": 209,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "Magic numbers",
      "context": [
        "",
        "/*",
        " * Validate the recovered buffer is of the correct type and attach the",
        " * appropriate buffer operations to them for writeback. Magic numbers are in a",
        " * few places:",
        " *\tthe first 16 bits of the buffer (inode buffer, dquot buffer),",
        " *\tthe first 32 bits of the buffer (most blocks),"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_buf_item_recover.c",
      "line": 830,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "\t\tgoto recover_immediately;",
        "",
        "\t/*",
        "\t * realtime bitmap and summary file blocks do not have magic numbers or",
        "\t * UUIDs, so we must recover them immediately.",
        "\t */",
        "\tblft = xfs_blft_from_flags(buf_f);"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_dir2_readdir.c",
      "line": 506,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * Read a directory.",
        " *",
        " * If supplied, the transaction collects locked dir buffers to avoid",
        " * nested buffer deadlocks.  This function does not dirty the",
        " * transaction.  The caller must hold the IOLOCK (shared or exclusive)",
        " * before calling this function.",
        " */"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_dquot.c",
      "line": 1116,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * Release a reference to the dquot (decrement ref-count) and unlock it.",
        " *",
        " * If there is a group quota attached to this dquot, carefully release that",
        " * too without tripping over deadlocks'n'stuff.",
        " */",
        "void",
        "xfs_qm_dqput("
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_dquot.c",
      "line": 1479,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * Lock two xfs_dquot structures.",
        " *",
        " * To avoid deadlocks we always lock the quota structure with",
        " * the lowerd id first.",
        " */",
        "void"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_extent_busy.c",
      "line": 605,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * If we are freeing extents, we might actually be holding the only free extents",
        " * in the transaction busy list and the log force won't resolve that situation.",
        " * In this case, we must return -EAGAIN to avoid a deadlock by informing the",
        " * caller it needs to commit the busy extents it holds before retrying the",
        " * extent free operation.",
        " */"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_extent_busy.c",
      "line": 624,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tif (error)",
        "\t\treturn error;",
        "",
        "\t/* Avoid deadlocks on uncommitted busy extents. */",
        "\tif (!list_empty(&tp->t_busy)) {",
        "\t\tif (alloc_flags & XFS_ALLOC_FLAG_TRYFLUSH)",
        "\t\t\treturn 0;"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_file.c",
      "line": 573,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * We can allocate memory here while doing writeback on behalf of",
        "\t * memory reclaim.  To avoid memory allocation deadlocks set the",
        "\t * task-wide nofs context for the following operations.",
        "\t */",
        "\tnofs_flag = memalloc_nofs_save();"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_file.c",
      "line": 1657,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * If we can't get the iolock just skip truncating the blocks past EOF",
        "\t * because we could deadlock with the mmap_lock otherwise. We'll get",
        "\t * another chance to drop them once the last reference to the inode is",
        "\t * dropped, so we'll never leak blocks permanently.",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_fsmap.c",
      "line": 1271,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t/*",
        "\t\t * Grab an empty transaction so that we can use its recursive",
        "\t\t * buffer locking abilities to detect cycles in the rmapbt",
        "\t\t * without deadlocking.",
        "\t\t */",
        "\t\terror = xfs_trans_alloc_empty(mp, &tp);",
        "\t\tif (error)"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_icache.c",
      "line": 545,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * previously marked the inode as free on disk but hasn't finished",
        "\t * updating the incore state yet.  The AGI buffer will be dirty and",
        "\t * locked to the icreate transaction, so a synchronous push of the",
        "\t * inodegc workers would result in deadlock.  For a regular iget, the",
        "\t * worker is running already, so we might as well wait.",
        "\t *",
        "\t * XXX(hch): eventually we should do something equivalent to"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_icache.c",
      "line": 1972,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * We can allocate memory here while doing writeback on behalf of",
        "\t * memory reclaim.  To avoid memory allocation deadlocks set the",
        "\t * task-wide nofs context for the following operations.",
        "\t */",
        "\tnofs_flag = memalloc_nofs_save();"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_icache.c",
      "line": 2142,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * Note: If we are in a NOFS context here (e.g. current thread is running a",
        " * transaction) the we don't want to block here as inodegc progress may require",
        " * filesystem resources we hold to make progress and that could result in a",
        " * deadlock. Hence we skip out of here if we are in a scoped NOFS context.",
        " */",
        "static inline bool",
        "xfs_inodegc_want_flush_work("
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_inode.c",
      "line": 115,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * various combinations of the locks to be obtained.",
        " *",
        " * The 3 locks should always be ordered so that the IO lock is obtained first,",
        " * the mmap lock second and the ilock last in order to prevent deadlock.",
        " *",
        " * Basic locking order:",
        " *"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_inode.c",
      "line": 370,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * The following routine will lock n inodes in exclusive mode.  We assume the",
        " * caller calls us with the inodes in i_ino order.",
        " *",
        " * We need to detect deadlock where an inode that we lock is in the AIL and we",
        " * start waiting for another inode that is locked by a thread in a long running",
        " * transaction (such as truncate). This can result in deadlock since the long",
        " * running trans might need to wait for the inode we just locked in order to"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_inode.c",
      "line": 372,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * We need to detect deadlock where an inode that we lock is in the AIL and we",
        " * start waiting for another inode that is locked by a thread in a long running",
        " * transaction (such as truncate). This can result in deadlock since the long",
        " * running trans might need to wait for the inode we just locked in order to",
        " * push the tail and free space in the log.",
        " *"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_inode.c",
      "line": 773,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Wait until after the current transaction is aborted to finish the",
        "\t * setup of the inode and release the inode.  This prevents recursive",
        "\t * transactions and deadlocks from xfs_inactive.",
        "\t */",
        "\tif (du.ip) {",
        "\t\txfs_iunlock(du.ip, XFS_ILOCK_EXCL);"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_inode.c",
      "line": 865,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Wait until after the current transaction is aborted to finish the",
        "\t * setup of the inode and release the inode.  This prevents recursive",
        "\t * transactions and deadlocks from xfs_inactive.",
        "\t */",
        "\tif (ip) {",
        "\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_inode.c",
      "line": 1875,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * Hence the ordering that is imposed by other parts of the code is AGI before",
        " * AGF. This means we cannot remove the directory entry before we drop the inode",
        " * reference count and put it on the unlinked list as this results in a lock",
        " * order of AGF then AGI, and this can deadlock against inode allocation and",
        " * freeing. Therefore we must drop the link counts before we remove the",
        " * directory entry.",
        " *"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_inode.c",
      "line": 478,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double-lock",
      "context": [
        "",
        "/*",
        " * xfs_lock_two_inodes() can only be used to lock ilock. The iolock and",
        " * mmaplock must be double-locked separately since we use i_rwsem and",
        " * invalidate_lock for that. We now support taking one lock EXCL and the",
        " * other SHARED.",
        " */"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_inode_item.c",
      "line": 829,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * simply return the given lsn.",
        " *",
        " * If the inode has been marked stale because the cluster is being freed, we",
        " * don't want to (re-)insert this inode into the AIL. There is a race condition",
        " * where the cluster buffer may be unpinned before the inode is inserted into",
        " * the AIL during transaction committed processing. If the buffer is unpinned",
        " * before the inode item has been committed and inserted, then it is possible"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_itable.c",
      "line": 240,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Grab an empty transaction so that we can use its recursive buffer",
        "\t * locking abilities to detect cycles in the inobt without deadlocking.",
        "\t */",
        "\terror = xfs_trans_alloc_empty(breq->mp, &tp);",
        "\tif (error)"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_itable.c",
      "line": 332,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Grab an empty transaction so that we can use its recursive buffer",
        "\t * locking abilities to detect cycles in the inobt without deadlocking.",
        "\t */",
        "\terror = xfs_trans_alloc_empty(breq->mp, &tp);",
        "\tif (error)"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_itable.c",
      "line": 465,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Grab an empty transaction so that we can use its recursive buffer",
        "\t * locking abilities to detect cycles in the inobt without deadlocking.",
        "\t */",
        "\terror = xfs_trans_alloc_empty(breq->mp, &tp);",
        "\tif (error)"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_iomap.c",
      "line": 648,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t *",
        "\t\t * Note that we can't risk to recursing back into the filesystem",
        "\t\t * here as we might be asked to write out the same inode that we",
        "\t\t * complete here and might deadlock on the iolock.",
        "\t\t */",
        "\t\terror = xfs_trans_alloc_inode(ip, &M_RES(mp)->tr_write, resblks,",
        "\t\t\t\t0, true, &tp);"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_iops.c",
      "line": 966,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * it already held by the VFS.  So for now chicken out and try to",
        "\t * allocate space under it.",
        "\t *",
        "\t * To avoid deadlocks this means we can't block waiting for space, which",
        "\t * can lead to spurious -ENOSPC if there are no directly available",
        "\t * blocks.  We mitigate this a bit by allowing zeroing to dip into the",
        "\t * reserved pool, but eventually the VFS calling convention needs to"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_iops.c",
      "line": 1458,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Ensure all page cache allocations are done from GFP_NOFS context to",
        "\t * prevent direct reclaim recursion back into the filesystem and blowing",
        "\t * stacks or deadlocking.",
        "\t */",
        "\tgfp_mask = mapping_gfp_mask(inode->i_mapping);",
        "\tmapping_set_gfp_mask(inode->i_mapping, (gfp_mask & ~(__GFP_FS)));"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_iwalk.c",
      "line": 618,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tgoto out;",
        "\t/*",
        "\t * Grab an empty transaction so that we can use its recursive buffer",
        "\t * locking abilities to detect cycles in the inobt without deadlocking.",
        "\t */",
        "\terror = xfs_trans_alloc_empty(mp, &iwag->tp);",
        "\tif (error)"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_log_recover.c",
      "line": 2798,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * This behaviour is bad for latency on single CPU and non-preemptible kernels,",
        " * and can prevent other filesystem work (such as CIL pushes) from running. This",
        " * can lead to deadlocks if the recovery process runs out of log reservation",
        " * space. Hence we need to yield the CPU when there is other kernel work",
        " * scheduled on this CPU to ensure other scheduled work can run without undue",
        " * latency."
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_log_cil.c",
      "line": 238,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " *",
        " * To avoid this, we need to move the memory allocation outside the",
        " * xc_ctx_lock, but because the log vector buffers are disposable, that opens",
        " * up a TOCTOU race condition w.r.t. the CIL committing and removing the log",
        " * vector buffers between the check and the formatting of the item into the",
        " * log vector buffer within the xc_ctx_lock.",
        " *"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_log_cil.c",
      "line": 232,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * If we do this allocation within xlog_cil_insert_format_items(), it is done",
        " * under the xc_ctx_lock, which means that a CIL push cannot occur during",
        " * the memory allocation. This means that we have a potential deadlock situation",
        " * under low memory conditions when we have lots of dirty metadata pinned in",
        " * the CIL and we need a CIL commit to occur to free memory.",
        " *"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_log_cil.c",
      "line": 1746,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Do all necessary memory allocation before we lock the CIL.",
        "\t * This ensures the allocation does not deadlock with a CIL",
        "\t * push in memory reclaim (e.g. from kswapd).",
        "\t */",
        "\txlog_cil_alloc_shadow_bufs(log, tp);"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_log.c",
      "line": 1128,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * If there are any items in the AIl or CIL, then we do not want to attempt to",
        " * cover the log as we may be in a situation where there isn't log space",
        " * available to run a dummy transaction and this can lead to deadlocks when the",
        " * tail of the log is pinned by an item that is modified in the CIL.  Hence",
        " * there's no point in running a dummy transaction at this point because we",
        " * can't start trying to idle the log until both the CIL and AIL are empty."
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_log.c",
      "line": 3440,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Ensure that there is only ever one log shutdown being processed.",
        "\t * If we allow the log force below on a second pass after shutting",
        "\t * down the log, we risk deadlocking the CIL push as it may require",
        "\t * locks on objects the current shutdown context holds (e.g. taking",
        "\t * buffer locks to abort buffers on last unpin of buf log items).",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_log.c",
      "line": 3309,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        " *",
        " * 1. Make sure the iclogs are still circular",
        " * 2. Make sure we have a good magic number",
        " * 3. Make sure we don't have magic numbers in the data",
        " * 4. Check fields of each log operation header for:",
        " *\tA. Valid client identifier",
        " *\tB. tid ptr value falls in valid ptr space (user space code)"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_log.c",
      "line": 3344,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "\t\txfs_emerg(log->l_mp, \"%s: corrupt iclog ring\", __func__);",
        "\tspin_unlock(&log->l_icloglock);",
        "",
        "\t/* check log magic numbers */",
        "\tif (iclog->ic_header.h_magicno != cpu_to_be32(XLOG_HEADER_MAGIC_NUM))",
        "\t\txfs_emerg(log->l_mp, \"%s: invalid magic num\", __func__);",
        ""
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_qm.c",
      "line": 1995,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t * takes priority over what's sent in the uid argument.",
        "\t\t\t * We must unlock inode here before calling dqget if",
        "\t\t\t * we're not sending the inode, because otherwise",
        "\t\t\t * we'll deadlock by doing trans_reserve while",
        "\t\t\t * holding ilock.",
        "\t\t\t */",
        "\t\t\txfs_iunlock(ip, lockflags);"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_rtalloc.c",
      "line": 1611,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * Read in the bmbt of an rt metadata inode so that we never have to load them",
        " * at runtime.  This enables the use of shared ILOCKs for rtbitmap scans.  Use",
        " * an empty transaction to avoid deadlocking on loops in the bmbt.",
        " */",
        "static inline int",
        "xfs_rtmount_iread_extents("
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_super.c",
      "line": 1015,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * The filesystem is now frozen far enough that memory reclaim",
        "\t * cannot safely operate on the filesystem. Hence we need to",
        "\t * set a GFP_NOFS context here to avoid recursion deadlocks.",
        "\t */",
        "\tflags = memalloc_nofs_save();",
        "\txfs_save_resvblks(mp);"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_super.c",
      "line": 2104,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Cancel background eofb scanning so it cannot race with the final",
        "\t * log force+buftarg wait and deadlock the remount.",
        "\t */",
        "\txfs_blockgc_stop(mp);",
        ""
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_symlink.c",
      "line": 231,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Wait until after the current transaction is aborted to finish the",
        "\t * setup of the inode and release the inode.  This prevents recursive",
        "\t * transactions and deadlocks from xfs_inactive.",
        "\t */",
        "\tif (du.ip) {",
        "\t\txfs_iunlock(du.ip, XFS_ILOCK_EXCL);"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_trans_ail.c",
      "line": 337,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use after free",
      "context": [
        " * about reference counts because the only active reference counts on the buffer",
        " * may be the failed log items. Hence if we clear the log item failed state",
        " * before queuing the buffer for IO we can release all active references to",
        " * the buffer and free it, leading to use after free problems in",
        " * xfs_buf_delwri_queue. It makes no difference to the buffer or log items which",
        " * order we process them in - the buffer is locked, and we own the buffer list",
        " * so nothing on them is going to change while we are performing this action."
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_trans_ail.c",
      "line": 344,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        " *",
        " * Hence we can safely queue the buffer for IO before we clear the failed log",
        " * item state, therefore  always having an active reference to the buffer and",
        " * avoiding the transient zero-reference state that leads to use-after-free.",
        " */",
        "static inline int",
        "xfsaild_resubmit_item("
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_trans.c",
      "line": 315,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * Create an empty transaction with no reservation.  This is a defensive",
        " * mechanism for routines that query metadata without actually modifying them --",
        " * if the metadata being queried is somehow cross-linked (think a btree block",
        " * pointer that points higher in the tree), we risk deadlock.  However, blocks",
        " * grabbed as part of a transaction can be re-grabbed.  The verifiers will",
        " * notice the corrupt block and the operation will fail back to userspace",
        " * without deadlocking."
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_trans.c",
      "line": 318,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * pointer that points higher in the tree), we risk deadlock.  However, blocks",
        " * grabbed as part of a transaction can be re-grabbed.  The verifiers will",
        " * notice the corrupt block and the operation will fail back to userspace",
        " * without deadlocking.",
        " *",
        " * Note the zero-length reservation; this transaction MUST be cancelled without",
        " * any dirty data."
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_trans.c",
      "line": 810,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tint\t\t\terror = 0;",
        "",
        "\t/*",
        "\t * Sort the item list to avoid ABBA deadlocks with other transactions",
        "\t * running precommit operations that lock multiple shared items such as",
        "\t * inode cluster buffers.",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_zone_alloc.c",
      "line": 1147,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * If the device doesn't report an open zone limit and there is no override,",
        " * allow to hold about a quarter of the zones open.  In theory we could allow",
        " * all to be open, but at that point we run into GC deadlocks because we can't",
        " * reclaim open zones.",
        " *",
        " * When used on conventional SSDs a lower open limit is advisable as we'll"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\xfs_zone_gc.c",
      "line": 646,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t *",
        "\t * If we'd take them from the normal pool we could be stealing blocks",
        "\t * from a regular writer, which would then have to wait for GC and",
        "\t * deadlock.",
        "\t */",
        "\tspin_lock(&mp->m_sb_lock);",
        "\t*count_fsb = min(*count_fsb,"
      ]
    },
    {
      "file": "linux\\fs\\zonefs\\super.c",
      "line": 395,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * Memory allocations in blkdev_report_zones() can trigger a memory",
        "\t * reclaim which may in turn cause a recursion into zonefs as well as",
        "\t * struct request allocations for the same device. The former case may",
        "\t * end up in a deadlock on the inode truncate mutex, while the latter",
        "\t * may prevent IO forward progress. Executing the report zones under",
        "\t * the GFP_NOIO context avoids both problems.",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\btrfs\\tests\\inode-tests.c",
      "line": 275,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "\tbtrfs_drop_extent_map_range(BTRFS_I(inode), 0, (u64)-1, false);",
        "",
        "\t/*",
        "\t * All of the magic numbers are based on the mapping setup in",
        "\t * setup_file_extents, so if you change anything there you need to",
        "\t * update the comment and update the expected values below.",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\notify\\fanotify\\fanotify_user.c",
      "line": 1767,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Some filesystems such as 'proc' acquire unusual locks when opening",
        "\t * files. For them fanotify permission events have high chances of",
        "\t * deadlocking the system - open done when reporting fanotify event",
        "\t * blocks on this \"unusual\" lock while another process holding the lock",
        "\t * waits for fanotify permission event to be answered. Just disallow",
        "\t * permission events for such filesystems."
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\dlm\\dlmdebug.c",
      "line": 154,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t[DLM_ABORT] =\t\t\t\"DLM_ABORT\",",
        "\t[DLM_CANCEL] =\t\t\t\"DLM_CANCEL\",",
        "\t[DLM_IVRESHANDLE] =\t\t\"DLM_IVRESHANDLE\",",
        "\t[DLM_DEADLOCK] =\t\t\"DLM_DEADLOCK\",",
        "\t[DLM_DENIED_NOASTS] =\t\t\"DLM_DENIED_NOASTS\",",
        "\t[DLM_FORWARD] =\t\t\t\"DLM_FORWARD\",",
        "\t[DLM_TIMEOUT] =\t\t\t\"DLM_TIMEOUT\","
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\dlm\\dlmdebug.c",
      "line": 154,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t[DLM_ABORT] =\t\t\t\"DLM_ABORT\",",
        "\t[DLM_CANCEL] =\t\t\t\"DLM_CANCEL\",",
        "\t[DLM_IVRESHANDLE] =\t\t\"DLM_IVRESHANDLE\",",
        "\t[DLM_DEADLOCK] =\t\t\"DLM_DEADLOCK\",",
        "\t[DLM_DENIED_NOASTS] =\t\t\"DLM_DENIED_NOASTS\",",
        "\t[DLM_FORWARD] =\t\t\t\"DLM_FORWARD\",",
        "\t[DLM_TIMEOUT] =\t\t\t\"DLM_TIMEOUT\","
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\dlm\\dlmdomain.c",
      "line": 508,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double spinlock! I need domain_lock",
      "context": [
        "",
        "static void dlm_mark_domain_leaving(struct dlm_ctxt *dlm)",
        "{",
        "\t/* Yikes, a double spinlock! I need domain_lock for the dlm",
        "\t * state and the dlm spinlock for join state... Sorry! */",
        "again:",
        "\tspin_lock(&dlm_domain_lock);"
      ]
    },
    {
      "file": "linux\\fs\\ocfs2\\dlm\\dlmdomain.c",
      "line": 36,
      "pattern": "long.*functions",
      "rule": "code_quality",
      "severity": "low",
      "match": "long ints to byte arrays. Following 3 routines are helper functions",
      "context": [
        "/*",
        " * ocfs2 node maps are array of long int, which limits to send them freely",
        " * across the wire due to endianness issues. To workaround this, we convert",
        " * long ints to byte arrays. Following 3 routines are helper functions to",
        " * set/test/copy bits within those array of bytes",
        " */",
        "static inline void byte_set_bit(u8 nr, u8 map[])"
      ]
    },
    {
      "file": "linux\\fs\\smb\\client\\connect.c",
      "line": 1719,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\tif (from_reconnect)",
        "\t\t/*",
        "\t\t * Avoid deadlock here: reconnect work calls",
        "\t\t * cifs_put_tcp_session() at its end. Need to be sure",
        "\t\t * that reconnect work does nothing with server pointer after",
        "\t\t * that step."
      ]
    },
    {
      "file": "linux\\fs\\smb\\client\\dir.c",
      "line": 708,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t}",
        "",
        "\t/* can not grab the rename sem here since it would",
        "\tdeadlock in the cases (beginning of sys_rename itself)",
        "\tin which we already have the sb rename sem */",
        "\tpage = alloc_dentry_path();",
        "\tfull_path = build_path_from_dentry(direntry, page);"
      ]
    },
    {
      "file": "linux\\fs\\smb\\client\\file.c",
      "line": 1396,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t\t\t    delayed_work_pending(&cfile->deferred)) {",
        "\t\t\t\t/*",
        "\t\t\t\t * If there is no pending work, mod_delayed_work queues new work.",
        "\t\t\t\t * So, Increase the ref count to avoid use-after-free.",
        "\t\t\t\t */",
        "\t\t\t\tif (!mod_delayed_work(deferredclose_wq,",
        "\t\t\t\t\t\t&cfile->deferred, cifs_sb->ctx->closetimeo))"
      ]
    },
    {
      "file": "linux\\fs\\smb\\client\\file.c",
      "line": 1321,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t}",
        "\t}",
        "\t/*",
        "\t * Else we are writing out data to server already and could deadlock if",
        "\t * we tried to flush data, and since we do not know if we have data that",
        "\t * would invalidate the current end of file on the server we can not go",
        "\t * to the server to get the new inode info."
      ]
    },
    {
      "file": "linux\\fs\\smb\\client\\netmisc.c",
      "line": 638,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\tERRHRD, ERRgeneral, NT_STATUS_MUTANT_LIMIT_EXCEEDED}, {",
        "\tERRDOS, ERRnetlogonNotStarted, NT_STATUS_NETLOGON_NOT_STARTED}, {",
        "\tERRSRV, ERRaccountexpired, NT_STATUS_ACCOUNT_EXPIRED}, {",
        "\tERRHRD, ERRgeneral, NT_STATUS_POSSIBLE_DEADLOCK}, {",
        "\tERRHRD, ERRgeneral, NT_STATUS_NETWORK_CREDENTIAL_CONFLICT}, {",
        "\tERRHRD, ERRgeneral, NT_STATUS_REMOTE_SESSION_LIMIT}, {",
        "\tERRHRD, ERRgeneral, NT_STATUS_EVENTLOG_FILE_CHANGED}, {"
      ]
    },
    {
      "file": "linux\\fs\\smb\\client\\netmisc.c",
      "line": 483,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "STACK_OVERFLOW",
      "context": [
        "\tERRDOS, 87, NT_STATUS_INVALID_PARAMETER_12}, {",
        "\tERRDOS, ERRbadpath, NT_STATUS_REDIRECTOR_NOT_STARTED}, {",
        "\tERRHRD, ERRgeneral, NT_STATUS_REDIRECTOR_STARTED}, {",
        "\tERRHRD, ERRgeneral, NT_STATUS_STACK_OVERFLOW}, {",
        "\tERRHRD, ERRgeneral, NT_STATUS_NO_SUCH_PACKAGE}, {",
        "\tERRHRD, ERRgeneral, NT_STATUS_BAD_FUNCTION_TABLE}, {",
        "\tERRDOS, 203, 0xc0000100}, {"
      ]
    },
    {
      "file": "linux\\fs\\smb\\client\\netmisc.c",
      "line": 689,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "STACK_OVERFLOW",
      "context": [
        "\tERRHRD, ERRgeneral, NT_STATUS_NOT_FOUND}, {",
        "\tERRHRD, ERRgeneral, NT_STATUS_NOT_TINY_STREAM}, {",
        "\tERRHRD, ERRgeneral, NT_STATUS_RECOVERY_FAILURE}, {",
        "\tERRHRD, ERRgeneral, NT_STATUS_STACK_OVERFLOW_READ}, {",
        "\tERRHRD, ERRgeneral, NT_STATUS_FAIL_CHECK}, {",
        "\tERRHRD, ERRgeneral, NT_STATUS_DUPLICATE_OBJECTID}, {",
        "\tERRHRD, ERRgeneral, NT_STATUS_OBJECTID_EXISTS}, {"
      ]
    },
    {
      "file": "linux\\fs\\smb\\client\\nterr.c",
      "line": 532,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t NT_STATUS_MUTANT_LIMIT_EXCEEDED},",
        "\t{\"NT_STATUS_NETLOGON_NOT_STARTED\", NT_STATUS_NETLOGON_NOT_STARTED},",
        "\t{\"NT_STATUS_ACCOUNT_EXPIRED\", NT_STATUS_ACCOUNT_EXPIRED},",
        "\t{\"NT_STATUS_POSSIBLE_DEADLOCK\", NT_STATUS_POSSIBLE_DEADLOCK},",
        "\t{\"NT_STATUS_NETWORK_CREDENTIAL_CONFLICT\",",
        "\t NT_STATUS_NETWORK_CREDENTIAL_CONFLICT},",
        "\t{\"NT_STATUS_REMOTE_SESSION_LIMIT\", NT_STATUS_REMOTE_SESSION_LIMIT},"
      ]
    },
    {
      "file": "linux\\fs\\smb\\client\\nterr.c",
      "line": 532,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t NT_STATUS_MUTANT_LIMIT_EXCEEDED},",
        "\t{\"NT_STATUS_NETLOGON_NOT_STARTED\", NT_STATUS_NETLOGON_NOT_STARTED},",
        "\t{\"NT_STATUS_ACCOUNT_EXPIRED\", NT_STATUS_ACCOUNT_EXPIRED},",
        "\t{\"NT_STATUS_POSSIBLE_DEADLOCK\", NT_STATUS_POSSIBLE_DEADLOCK},",
        "\t{\"NT_STATUS_NETWORK_CREDENTIAL_CONFLICT\",",
        "\t NT_STATUS_NETWORK_CREDENTIAL_CONFLICT},",
        "\t{\"NT_STATUS_REMOTE_SESSION_LIMIT\", NT_STATUS_REMOTE_SESSION_LIMIT},"
      ]
    },
    {
      "file": "linux\\fs\\smb\\client\\nterr.c",
      "line": 28,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW\", NT_STATUS_BUFFER_OVERFLOW",
      "context": [
        "\t{\"NT_STATUS_INVALID_INFO_CLASS\", NT_STATUS_INVALID_INFO_CLASS},",
        "\t{\"NT_STATUS_INFO_LENGTH_MISMATCH\", NT_STATUS_INFO_LENGTH_MISMATCH},",
        "\t{\"NT_STATUS_ACCESS_VIOLATION\", NT_STATUS_ACCESS_VIOLATION},",
        "\t{\"NT_STATUS_BUFFER_OVERFLOW\", NT_STATUS_BUFFER_OVERFLOW},",
        "\t{\"NT_STATUS_IN_PAGE_ERROR\", NT_STATUS_IN_PAGE_ERROR},",
        "\t{\"NT_STATUS_PAGEFILE_QUOTA\", NT_STATUS_PAGEFILE_QUOTA},",
        "\t{\"NT_STATUS_INVALID_HANDLE\", NT_STATUS_INVALID_HANDLE},"
      ]
    },
    {
      "file": "linux\\fs\\smb\\client\\nterr.c",
      "line": 345,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "STACK_OVERFLOW\", NT_STATUS_STACK_OVERFLOW",
      "context": [
        "\t{\"NT_STATUS_REDIRECTOR_NOT_STARTED\",",
        "\t NT_STATUS_REDIRECTOR_NOT_STARTED},",
        "\t{\"NT_STATUS_REDIRECTOR_STARTED\", NT_STATUS_REDIRECTOR_STARTED},",
        "\t{\"NT_STATUS_STACK_OVERFLOW\", NT_STATUS_STACK_OVERFLOW},",
        "\t{\"NT_STATUS_NO_SUCH_PACKAGE\", NT_STATUS_NO_SUCH_PACKAGE},",
        "\t{\"NT_STATUS_BAD_FUNCTION_TABLE\", NT_STATUS_BAD_FUNCTION_TABLE},",
        "\t{\"NT_STATUS_DIRECTORY_NOT_EMPTY\", NT_STATUS_DIRECTORY_NOT_EMPTY},"
      ]
    },
    {
      "file": "linux\\fs\\smb\\client\\nterr.c",
      "line": 604,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "STACK_OVERFLOW_READ\", NT_STATUS_STACK_OVERFLOW",
      "context": [
        "\t{\"NT_STATUS_NOT_FOUND\", NT_STATUS_NOT_FOUND},",
        "\t{\"NT_STATUS_NOT_TINY_STREAM\", NT_STATUS_NOT_TINY_STREAM},",
        "\t{\"NT_STATUS_RECOVERY_FAILURE\", NT_STATUS_RECOVERY_FAILURE},",
        "\t{\"NT_STATUS_STACK_OVERFLOW_READ\", NT_STATUS_STACK_OVERFLOW_READ},",
        "\t{\"NT_STATUS_FAIL_CHECK\", NT_STATUS_FAIL_CHECK},",
        "\t{\"NT_STATUS_DUPLICATE_OBJECTID\", NT_STATUS_DUPLICATE_OBJECTID},",
        "\t{\"NT_STATUS_OBJECTID_EXISTS\", NT_STATUS_OBJECTID_EXISTS},"
      ]
    },
    {
      "file": "linux\\fs\\smb\\client\\smb1ops.c",
      "line": 357,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer to overflow",
      "context": [
        "",
        "\tbyte_count = be32_to_cpu(target_hdr->smb_buf_length);",
        "\tbyte_count += total_in_src;",
        "\t/* don't allow buffer to overflow */",
        "\tif (byte_count > CIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4) {",
        "\t\tcifs_dbg(FYI, \"coalesced BCC exceeds buffer size (%u)\\n\",",
        "\t\t\t byte_count);"
      ]
    },
    {
      "file": "linux\\fs\\smb\\client\\smb2maperror.c",
      "line": 723,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t{STATUS_MUTANT_LIMIT_EXCEEDED, -EIO, \"STATUS_MUTANT_LIMIT_EXCEEDED\"},",
        "\t{STATUS_NETLOGON_NOT_STARTED, -EIO, \"STATUS_NETLOGON_NOT_STARTED\"},",
        "\t{STATUS_ACCOUNT_EXPIRED, -EKEYEXPIRED, \"STATUS_ACCOUNT_EXPIRED\"},",
        "\t{STATUS_POSSIBLE_DEADLOCK, -EIO, \"STATUS_POSSIBLE_DEADLOCK\"},",
        "\t{STATUS_NETWORK_CREDENTIAL_CONFLICT, -EIO,",
        "\t\"STATUS_NETWORK_CREDENTIAL_CONFLICT\"},",
        "\t{STATUS_REMOTE_SESSION_LIMIT, -EIO, \"STATUS_REMOTE_SESSION_LIMIT\"},"
      ]
    },
    {
      "file": "linux\\fs\\smb\\client\\smb2maperror.c",
      "line": 723,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t{STATUS_MUTANT_LIMIT_EXCEEDED, -EIO, \"STATUS_MUTANT_LIMIT_EXCEEDED\"},",
        "\t{STATUS_NETLOGON_NOT_STARTED, -EIO, \"STATUS_NETLOGON_NOT_STARTED\"},",
        "\t{STATUS_ACCOUNT_EXPIRED, -EKEYEXPIRED, \"STATUS_ACCOUNT_EXPIRED\"},",
        "\t{STATUS_POSSIBLE_DEADLOCK, -EIO, \"STATUS_POSSIBLE_DEADLOCK\"},",
        "\t{STATUS_NETWORK_CREDENTIAL_CONFLICT, -EIO,",
        "\t\"STATUS_NETWORK_CREDENTIAL_CONFLICT\"},",
        "\t{STATUS_REMOTE_SESSION_LIMIT, -EIO, \"STATUS_REMOTE_SESSION_LIMIT\"},"
      ]
    },
    {
      "file": "linux\\fs\\smb\\client\\smb2maperror.c",
      "line": 205,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW, -E2BIG, \"STATUS_BUFFER_OVERFLOW",
      "context": [
        "\t{STATUS_DATATYPE_MISALIGNMENT, -EIO, \"STATUS_DATATYPE_MISALIGNMENT\"},",
        "\t{STATUS_BREAKPOINT, -EIO, \"STATUS_BREAKPOINT\"},",
        "\t{STATUS_SINGLE_STEP, -EIO, \"STATUS_SINGLE_STEP\"},",
        "\t{STATUS_BUFFER_OVERFLOW, -E2BIG, \"STATUS_BUFFER_OVERFLOW\"},",
        "\t{STATUS_NO_MORE_FILES, -ENODATA, \"STATUS_NO_MORE_FILES\"},",
        "\t{STATUS_WAKE_SYSTEM_DEBUGGER, -EIO, \"STATUS_WAKE_SYSTEM_DEBUGGER\"},",
        "\t{STATUS_HANDLES_CLOSED, -EIO, \"STATUS_HANDLES_CLOSED\"},"
      ]
    },
    {
      "file": "linux\\fs\\smb\\client\\smb2maperror.c",
      "line": 558,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "STACK_OVERFLOW, -EIO, \"STATUS_STACK_OVERFLOW",
      "context": [
        "\t{STATUS_INVALID_PARAMETER_12, -EINVAL, \"STATUS_INVALID_PARAMETER_12\"},",
        "\t{STATUS_REDIRECTOR_NOT_STARTED, -EIO, \"STATUS_REDIRECTOR_NOT_STARTED\"},",
        "\t{STATUS_REDIRECTOR_STARTED, -EIO, \"STATUS_REDIRECTOR_STARTED\"},",
        "\t{STATUS_STACK_OVERFLOW, -EIO, \"STATUS_STACK_OVERFLOW\"},",
        "\t{STATUS_NO_SUCH_PACKAGE, -EIO, \"STATUS_NO_SUCH_PACKAGE\"},",
        "\t{STATUS_BAD_FUNCTION_TABLE, -EIO, \"STATUS_BAD_FUNCTION_TABLE\"},",
        "\t{STATUS_VARIABLE_NOT_FOUND, -EIO, \"STATUS_VARIABLE_NOT_FOUND\"},"
      ]
    },
    {
      "file": "linux\\fs\\smb\\client\\smb2maperror.c",
      "line": 791,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "STACK_OVERFLOW_READ, -EIO, \"STATUS_STACK_OVERFLOW",
      "context": [
        "\t{STATUS_NOT_FOUND, -ENOENT, \"STATUS_NOT_FOUND\"},",
        "\t{STATUS_NOT_TINY_STREAM, -EIO, \"STATUS_NOT_TINY_STREAM\"},",
        "\t{STATUS_RECOVERY_FAILURE, -EIO, \"STATUS_RECOVERY_FAILURE\"},",
        "\t{STATUS_STACK_OVERFLOW_READ, -EIO, \"STATUS_STACK_OVERFLOW_READ\"},",
        "\t{STATUS_FAIL_CHECK, -EIO, \"STATUS_FAIL_CHECK\"},",
        "\t{STATUS_DUPLICATE_OBJECTID, -EIO, \"STATUS_DUPLICATE_OBJECTID\"},",
        "\t{STATUS_OBJECTID_EXISTS, -EIO, \"STATUS_OBJECTID_EXISTS\"},"
      ]
    },
    {
      "file": "linux\\fs\\smb\\client\\smb2maperror.c",
      "line": 1535,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "STACK_OVERFLOW, -EIO, \"STATUS_ACPI_STACK_OVERFLOW",
      "context": [
        "\t\"STATUS_CLUSTER_NETWORK_NOT_INTERNAL\"},",
        "\t{STATUS_CLUSTER_POISONED, -EIO, \"STATUS_CLUSTER_POISONED\"},",
        "\t{STATUS_ACPI_INVALID_OPCODE, -EIO, \"STATUS_ACPI_INVALID_OPCODE\"},",
        "\t{STATUS_ACPI_STACK_OVERFLOW, -EIO, \"STATUS_ACPI_STACK_OVERFLOW\"},",
        "\t{STATUS_ACPI_ASSERT_FAILED, -EIO, \"STATUS_ACPI_ASSERT_FAILED\"},",
        "\t{STATUS_ACPI_INVALID_INDEX, -EIO, \"STATUS_ACPI_INVALID_INDEX\"},",
        "\t{STATUS_ACPI_INVALID_ARGUMENT, -EIO, \"STATUS_ACPI_INVALID_ARGUMENT\"},"
      ]
    },
    {
      "file": "linux\\fs\\smb\\client\\smb2ops.c",
      "line": 264,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\tspin_lock(&server->req_lock);",
        "\t\t} else {",
        "\t\t\tscredits = server->credits;",
        "\t\t\t/* can deadlock with reopen */",
        "\t\t\tif (scredits <= 8) {",
        "\t\t\t\t*num = SMB2_MAX_BUFFER_SIZE;",
        "\t\t\t\tcredits->value = 0;"
      ]
    },
    {
      "file": "linux\\fs\\smb\\client\\smb2pdu.c",
      "line": 4590,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "#ifdef CONFIG_CIFS_SMB_DIRECT",
        "\t/*",
        "\t * If this rdata has a memory registered, the MR can be freed",
        "\t * MR needs to be freed as soon as I/O finishes to prevent deadlock",
        "\t * because they have limited number and are used for future I/Os",
        "\t */",
        "\tif (rdata->mr) {"
      ]
    },
    {
      "file": "linux\\fs\\smb\\client\\smb2pdu.c",
      "line": 4880,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * If this wdata has a memory registered, the MR can be freed",
        "\t * The number of MRs available is limited, it's important to recover",
        "\t * used MR as soon as I/O is finished. Hold MR longer in the later",
        "\t * I/O process can possibly result in I/O deadlock due to lack of MR",
        "\t * to send request on I/O retry",
        "\t */",
        "\tif (wdata->mr) {"
      ]
    },
    {
      "file": "linux\\fs\\smb\\server\\smb2pdu.c",
      "line": 8042,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "",
        "\t\tnbytes = rpc_resp->payload_sz;",
        "\t\tif (rpc_resp->payload_sz > out_buf_len) {",
        "\t\t\trsp->hdr.Status = STATUS_BUFFER_OVERFLOW;",
        "\t\t\tnbytes = out_buf_len;",
        "\t\t}",
        ""
      ]
    },
    {
      "file": "linux\\fs\\smb\\server\\smb2pdu.c",
      "line": 8342,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "\t\t\tout_buf_len /",
        "\t\t\tsizeof(struct file_allocated_range_buffer), &nbytes);",
        "\t\tif (ret == -E2BIG) {",
        "\t\t\trsp->hdr.Status = STATUS_BUFFER_OVERFLOW;",
        "\t\t} else if (ret < 0) {",
        "\t\t\tnbytes = 0;",
        "\t\t\tgoto out;"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\libxfs\\xfs_alloc.c",
      "line": 99,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * Compute the number of blocks that we set aside to guarantee the ability to",
        " * refill the AGFL and handle a full bmap btree split.",
        " *",
        " * In order to avoid ENOSPC-related deadlock caused by out-of-order locking of",
        " * AGF buffer (PV 947395), we place constraints on the relationship among",
        " * actual allocations for data blocks, freelist blocks, and potential file data",
        " * bmap btree blocks. However, these restrictions may result in no actual space"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\libxfs\\xfs_alloc.c",
      "line": 1755,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t/*",
        "\t\t\t * Our only valid extents must have been busy. Flush and",
        "\t\t\t * retry the allocation again. If we get an -EAGAIN",
        "\t\t\t * error, we're being told that a deadlock was avoided",
        "\t\t\t * and the current transaction needs committing before",
        "\t\t\t * the allocation can be retried.",
        "\t\t\t */"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\libxfs\\xfs_alloc.c",
      "line": 1872,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t/*",
        "\t\t\t * Our only valid extents must have been busy. Flush and",
        "\t\t\t * retry the allocation again. If we get an -EAGAIN",
        "\t\t\t * error, we're being told that a deadlock was avoided",
        "\t\t\t * and the current transaction needs committing before",
        "\t\t\t * the allocation can be retried.",
        "\t\t\t */"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\libxfs\\xfs_alloc.c",
      "line": 1972,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t/*",
        "\t\t\t * Our only valid extents must have been busy. Flush and",
        "\t\t\t * retry the allocation again. If we get an -EAGAIN",
        "\t\t\t * error, we're being told that a deadlock was avoided",
        "\t\t\t * and the current transaction needs committing before",
        "\t\t\t * the allocation can be retried.",
        "\t\t\t */"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\libxfs\\xfs_alloc.c",
      "line": 3515,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t}",
        "",
        "\tif (args->agno != NULLAGNUMBER && *minimum_agno > args->agno) {",
        "\t\ttrace_xfs_alloc_vextent_skip_deadlock(args);",
        "\t\treturn -ENOSPC;",
        "\t}",
        "\treturn 0;"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\libxfs\\xfs_alloc.c",
      "line": 3583,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * to do BMBT block allocation, we have to do a new allocation.",
        "\t *",
        "\t * Hence leaving this function with the AGF locked opens up potential",
        "\t * ABBA AGF deadlocks because a future allocation attempt in this",
        "\t * transaction may attempt to lock a lower number AGF.",
        "\t *",
        "\t * We can't release the AGF until the transaction is commited, so at"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\libxfs\\xfs_alloc.c",
      "line": 3590,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * this point we must update the \"first allocation\" tracker to point at",
        "\t * this AG if the tracker is empty or points to a lower AG. This allows",
        "\t * the next allocation attempt to be modified appropriately to avoid",
        "\t * deadlocks.",
        "\t */",
        "\tif (args->agbp &&",
        "\t    (args->tp->t_highest_agno == NULLAGNUMBER ||"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\libxfs\\xfs_alloc.c",
      "line": 3704,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * When we wrap the AG iteration at the end of the filesystem, we have to be",
        " * careful not to wrap into AGs below ones we already have locked in the",
        " * transaction if we are doing a blocking iteration. This will result in an",
        " * out-of-order locking of AGFs and hence can cause deadlocks.",
        " */",
        "static int",
        "xfs_alloc_vextent_iterate_ags("
      ]
    },
    {
      "file": "linux\\fs\\xfs\\libxfs\\xfs_attr.c",
      "line": 634,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * If there was an out-of-line value, allocate the blocks we",
        "\t * identified for its storage and copy the value.  This is done",
        "\t * after we create the attribute so that we don't overflow the",
        "\t * maximum size of a transaction and/or hit a deadlock.",
        "\t */",
        "\tif (attr->xattri_blkcnt > 0) {",
        "\t\terror = xfs_attr_rmtval_set_blk(attr);"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\libxfs\\xfs_btree_mem.c",
      "line": 263,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * of a transaction.",
        " *",
        " * In other words, online repair only needs the transaction to collect buffer",
        " * pointers and to avoid buffer deadlocks, not to guarantee consistency of",
        " * updates.",
        " */",
        "int"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\libxfs\\xfs_btree.c",
      "line": 3045,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * btree types, just call directly to avoid the context switch overhead here.",
        " *",
        " * Care must be taken here - the work queue rescuer thread introduces potential",
        " * AGF <> worker queue deadlocks if the BMBT block allocation has to lock new",
        " * AGFs to allocate blocks. A task being run by the rescuer could attempt to",
        " * lock an AGF that is already locked by a task queued to run by the rescuer,",
        " * resulting in an ABBA deadlock as the rescuer cannot run the lock holder to"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\libxfs\\xfs_btree.c",
      "line": 3048,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * AGF <> worker queue deadlocks if the BMBT block allocation has to lock new",
        " * AGFs to allocate blocks. A task being run by the rescuer could attempt to",
        " * lock an AGF that is already locked by a task queued to run by the rescuer,",
        " * resulting in an ABBA deadlock as the rescuer cannot run the lock holder to",
        " * release it until the current thread it is running gains the lock.",
        " *",
        " * To avoid this issue, we only ever queue BMBT splits that don't have an AGF"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\libxfs\\xfs_btree.c",
      "line": 41,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "#include \"xfs_rtrefcount_btree.h\"",
        "",
        "/*",
        " * Btree magic numbers.",
        " */",
        "uint32_t",
        "xfs_btree_magic("
      ]
    },
    {
      "file": "linux\\fs\\xfs\\libxfs\\xfs_da_btree.c",
      "line": 895,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double-split op below us, then add the extra block",
      "context": [
        "\t * operation always results in a new block whose hashvals",
        "\t * FOLLOW the current block.",
        "\t *",
        "\t * If we had double-split op below us, then add the extra block too.",
        "\t */",
        "\tnode = oldblk->bp->b_addr;",
        "\txfs_da3_node_hdr_from_disk(dp->i_mount, &nodehdr, node);"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\libxfs\\xfs_da_btree.c",
      "line": 678,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "\t * original block 0 could be at any position in the list of blocks in",
        "\t * the tree.",
        "\t *",
        "\t * Note: the magic numbers and sibling pointers are in the same physical",
        "\t * place for both v2 and v3 headers (by design). Hence it doesn't matter",
        "\t * which version of the xfs_da_intnode structure we use here as the",
        "\t * result will be the same using either structure."
      ]
    },
    {
      "file": "linux\\fs\\xfs\\libxfs\\xfs_dir2_leaf.c",
      "line": 765,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing block",
      "context": [
        "\t\tneedbytes += sizeof(xfs_dir2_data_off_t);",
        "",
        "\t/*",
        "\t * Now kill use_block if it refers to a missing block, so we",
        "\t * can use it as an indication of allocation needed.",
        "\t */",
        "\tif (use_block != -1 && bestsp[use_block] == cpu_to_be16(NULLDATAOFF))"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\libxfs\\xfs_dir2_leaf.c",
      "line": 191,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "}",
        "",
        "/*",
        " * We verify the magic numbers before decoding the leaf header so that on debug",
        " * kernels we don't get assertion failures in xfs_dir3_leaf_hdr_from_disk() due",
        " * to incorrect magic numbers.",
        " */"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\libxfs\\xfs_dir2_leaf.c",
      "line": 193,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        "/*",
        " * We verify the magic numbers before decoding the leaf header so that on debug",
        " * kernels we don't get assertion failures in xfs_dir3_leaf_hdr_from_disk() due",
        " * to incorrect magic numbers.",
        " */",
        "static xfs_failaddr_t",
        "xfs_dir3_leaf_verify("
      ]
    },
    {
      "file": "linux\\fs\\xfs\\libxfs\\xfs_ialloc.c",
      "line": 1975,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * Protect against obviously corrupt allocation btree records. Later",
        "\t * xfs_iget checks will catch re-allocation of other active in-memory",
        "\t * and on-disk inodes. If we don't catch reallocating the parent inode",
        "\t * here we will deadlock in xfs_iget() so we have to do these checks",
        "\t * first.",
        "\t */",
        "\tif (ino == parent || !xfs_verify_dir_ino(mp, ino)) {"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\libxfs\\xfs_inode_util.c",
      "line": 399,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double linked unlinked list, and we don't need any extra lock",
      "context": [
        " *",
        " * Given we have an existence guarantee, we can use lockless inode cache lookups",
        " * to resolve aginos to xfs inodes. This means we only need 8 bytes per inode",
        " * for the double linked unlinked list, and we don't need any extra locking to",
        " * keep the list safe as all manipulations are done under the AGI buffer lock.",
        " * Keeping the list up to date does not require memory allocation, just finding",
        " * the XFS inode and updating the next/prev unlinked list aginos."
      ]
    },
    {
      "file": "linux\\fs\\xfs\\libxfs\\xfs_refcount.c",
      "line": 1379,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * Process one of the deferred refcount operations.  We pass back the",
        " * btree cursor to maintain our lock on the btree between calls.",
        " * This saves time and eliminates a buffer deadlock between the",
        " * superblock and the AGF because we'll always grab them in the same",
        " * order.",
        " */"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\libxfs\\xfs_refcount.c",
      "line": 2096,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * In this first part, we use an empty transaction to gather up",
        "\t * all the leftover CoW extents so that we can subsequently",
        "\t * delete them.  The empty transaction is used to avoid",
        "\t * a buffer lock deadlock if there happens to be a loop in the",
        "\t * refcountbt because we're allowed to re-grab a buffer that is",
        "\t * already attached to our transaction.  When we're done",
        "\t * recording the CoW debris we cancel the (empty) transaction"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\libxfs\\xfs_rmap.c",
      "line": 2675,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * Process one of the deferred rmap operations.  We pass back the",
        " * btree cursor to maintain our lock on the rmapbt between calls.",
        " * This saves time and eliminates a buffer deadlock between the",
        " * superblock and the AGF because we'll always grab them in the same",
        " * order.",
        " */"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\libxfs\\xfs_rtgroup.c",
      "line": 318,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * Most of the time each of the RTG inode locks are only taken one at a time.",
        " * But when committing deferred ops, more than one of a kind can be taken.",
        " * However, deferred rt ops will be committed in rgno order so there is no",
        " * potential for deadlocks.  The code here is needed to tell lockdep about this",
        " * order.",
        " */",
        "static inline void"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\libxfs\\xfs_sb.c",
      "line": 1357,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * filesystem. This procedure uses the non-blocking transaction allocator and",
        " * thus will allow modifications to a frozen fs. This is required because this",
        " * code can be called during the process of freezing where use of the high-level",
        " * allocator would deadlock.",
        " */",
        "int",
        "xfs_sync_sb("
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\alloc_repair.c",
      "line": 874,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t * let's not risk the filesystem.",
        "\t */",
        "\tif (!xfs_extent_busy_list_empty(pag_group(sc->sa.pag), &busy_gen)) {",
        "\t\terror = -EDEADLOCK;",
        "\t\tgoto out_ra;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\attr_repair.c",
      "line": 363,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t */",
        "\terror = xchk_setup_xattr_buf(rx->sc, args.valuelen);",
        "\tif (error == -ENOMEM)",
        "\t\terror = -EDEADLOCK;",
        "\tif (error)",
        "\t\treturn error;",
        ""
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\attr_repair.c",
      "line": 1553,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\tmax_len = xfs_attr_leaf_entsize_local_max(sc->mp->m_attr_geo->blksize);",
        "\terror = xchk_setup_xattr_buf(rx->sc, max_len);",
        "\tif (error == -ENOMEM)",
        "\t\terror = -EDEADLOCK;",
        "\tif (error)",
        "\t\tgoto out_rx;",
        ""
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\attr.c",
      "line": 221,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "",
        "\t/*",
        "\t * Try to allocate enough memory to extract the attr value.  If that",
        "\t * doesn't work, return -EDEADLOCK as a signal to try again with a",
        "\t * maximally sized buffer.",
        "\t */",
        "\terror = xchk_setup_xattr_buf(sc, valuelen);"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\attr.c",
      "line": 226,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t */",
        "\terror = xchk_setup_xattr_buf(sc, valuelen);",
        "\tif (error == -ENOMEM)",
        "\t\terror = -EDEADLOCK;",
        "\tif (error)",
        "\t\treturn error;",
        ""
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\attr.c",
      "line": 652,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t/* Allocate memory for xattr checking. */",
        "\terror = xchk_setup_xattr_buf(sc, 0);",
        "\tif (error == -ENOMEM)",
        "\t\treturn -EDEADLOCK;",
        "\tif (error)",
        "\t\treturn error;",
        ""
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\btree.c",
      "line": 38,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t\treturn true;",
        "",
        "\tswitch (*error) {",
        "\tcase -EDEADLOCK:",
        "\tcase -ECHRNG:",
        "\t\t/* Used to restart an op with deadlock avoidance. */",
        "\t\ttrace_xchk_deadlock_retry(sc->ip, sc->sm, *error);"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\btree.c",
      "line": 40,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tswitch (*error) {",
        "\tcase -EDEADLOCK:",
        "\tcase -ECHRNG:",
        "\t\t/* Used to restart an op with deadlock avoidance. */",
        "\t\ttrace_xchk_deadlock_retry(sc->ip, sc->sm, *error);",
        "\t\tbreak;",
        "\tcase -EFSBADCRC:"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\btree.c",
      "line": 41,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tcase -EDEADLOCK:",
        "\tcase -ECHRNG:",
        "\t\t/* Used to restart an op with deadlock avoidance. */",
        "\t\ttrace_xchk_deadlock_retry(sc->ip, sc->sm, *error);",
        "\t\tbreak;",
        "\tcase -EFSBADCRC:",
        "\tcase -EFSCORRUPTED:"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\common.c",
      "line": 88,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\tswitch (*error) {",
        "\tcase 0:",
        "\t\treturn true;",
        "\tcase -EDEADLOCK:",
        "\tcase -ECHRNG:",
        "\t\t/* Used to restart an op with deadlock avoidance. */",
        "\t\ttrace_xchk_deadlock_retry("
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\common.c",
      "line": 90,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\treturn true;",
        "\tcase -EDEADLOCK:",
        "\tcase -ECHRNG:",
        "\t\t/* Used to restart an op with deadlock avoidance. */",
        "\t\ttrace_xchk_deadlock_retry(",
        "\t\t\t\tsc->ip ? sc->ip : XFS_I(file_inode(sc->file)),",
        "\t\t\t\tsc->sm, *error);"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\common.c",
      "line": 91,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tcase -EDEADLOCK:",
        "\tcase -ECHRNG:",
        "\t\t/* Used to restart an op with deadlock avoidance. */",
        "\t\ttrace_xchk_deadlock_retry(",
        "\t\t\t\tsc->ip ? sc->ip : XFS_I(file_inode(sc->file)),",
        "\t\t\t\tsc->sm, *error);",
        "\t\tbreak;"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\common.c",
      "line": 163,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\tswitch (*error) {",
        "\tcase 0:",
        "\t\treturn true;",
        "\tcase -EDEADLOCK:",
        "\tcase -ECHRNG:",
        "\t\t/* Used to restart an op with deadlock avoidance. */",
        "\t\ttrace_xchk_deadlock_retry(sc->ip, sc->sm, *error);"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\common.c",
      "line": 165,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\treturn true;",
        "\tcase -EDEADLOCK:",
        "\tcase -ECHRNG:",
        "\t\t/* Used to restart an op with deadlock avoidance. */",
        "\t\ttrace_xchk_deadlock_retry(sc->ip, sc->sm, *error);",
        "\t\tbreak;",
        "\tcase -ECANCELED:"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\common.c",
      "line": 166,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tcase -EDEADLOCK:",
        "\tcase -ECHRNG:",
        "\t\t/* Used to restart an op with deadlock avoidance. */",
        "\t\ttrace_xchk_deadlock_retry(sc->ip, sc->sm, *error);",
        "\t\tbreak;",
        "\tcase -ECANCELED:",
        "\t\t/*"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\common.c",
      "line": 682,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * For scrub, grab the perag structure, the AGI, and the AGF headers, in that",
        " * order.  Locking order requires us to get the AGI before the AGF.  We use the",
        " * transaction to avoid deadlocking on crosslinked metadata buffers; either the",
        " * caller passes one in (bmap scrub) or we have to create a transaction",
        " * ourselves.  Returns ENOENT if the perag struct cannot be grabbed.",
        " */"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\common.c",
      "line": 1010,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\treturn error;",
        "",
        "\t/*",
        "\t * Attach the AGI buffer to the scrub transaction to avoid deadlocks",
        "\t * in the iget cache miss path.",
        "\t */",
        "\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, inum));"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\dabtree.c",
      "line": 41,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t\treturn true;",
        "",
        "\tswitch (*error) {",
        "\tcase -EDEADLOCK:",
        "\tcase -ECHRNG:",
        "\t\t/* Used to restart an op with deadlock avoidance. */",
        "\t\ttrace_xchk_deadlock_retry(sc->ip, sc->sm, *error);"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\dabtree.c",
      "line": 43,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tswitch (*error) {",
        "\tcase -EDEADLOCK:",
        "\tcase -ECHRNG:",
        "\t\t/* Used to restart an op with deadlock avoidance. */",
        "\t\ttrace_xchk_deadlock_retry(sc->ip, sc->sm, *error);",
        "\t\tbreak;",
        "\tcase -EFSBADCRC:"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\dabtree.c",
      "line": 44,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tcase -EDEADLOCK:",
        "\tcase -ECHRNG:",
        "\t\t/* Used to restart an op with deadlock avoidance. */",
        "\t\ttrace_xchk_deadlock_retry(sc->ip, sc->sm, *error);",
        "\t\tbreak;",
        "\tcase -EFSBADCRC:",
        "\tcase -EFSCORRUPTED:"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\dirtree_repair.c",
      "line": 212,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "}",
        "",
        "/*",
        " * Figure out what to do with the paths we tried to find.  Returns -EDEADLOCK",
        " * if the scan results have become stale.",
        " */",
        "STATIC void"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\fscounters.c",
      "line": 381,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\tif (fsc->ifree > fsc->icount) {",
        "\t\tif (tries--)",
        "\t\t\tgoto retry;",
        "\t\treturn -EDEADLOCK;",
        "\t}",
        "",
        "\treturn 0;"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\fscounters.c",
      "line": 540,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t */",
        "\tif (fdblocks < 0 || frextents < 0) {",
        "\t\tif (!fsc->frozen)",
        "\t\t\treturn -EDEADLOCK;",
        "",
        "\t\txchk_set_corrupt(sc);",
        "\t\treturn 0;"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\fscounters.c",
      "line": 617,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t}",
        "",
        "\tif (try_again)",
        "\t\treturn -EDEADLOCK;",
        "",
        "\treturn 0;",
        "}"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\ialloc.c",
      "line": 335,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t\t/* Not cached, just read the disk buffer */",
        "\t\tfreemask_ok = irec_free ^ !!(dip->di_mode);",
        "\t\tif (!(bs->sc->flags & XCHK_TRY_HARDER) && !freemask_ok)",
        "\t\t\treturn -EDEADLOCK;",
        "\t} else if (error < 0) {",
        "\t\t/*",
        "\t\t * Inode is only half assembled, or there was an IO error,"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\inode_repair.c",
      "line": 445,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t\t\t * the reason for the delay is an inode from the same",
        "\t\t\t * cluster buffer waiting on the inactivation list.",
        "\t\t\t */",
        "\t\t\terror = -EDEADLOCK;",
        "\t\t}",
        "\t}",
        "\tif (error)"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\inode_repair.c",
      "line": 502,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\tswitch (error) {",
        "\tcase -EINTR:",
        "\tcase -EBUSY:",
        "\tcase -EDEADLOCK:",
        "\t\t/* temporary failure or fatal signal */",
        "\t\treturn error;",
        "\tcase 0:"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\nlinks.c",
      "line": 550,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * the filesystem.",
        "\t *",
        "\t * Create a new empty transaction to eliminate the possibility of the",
        "\t * inode scan deadlocking on cyclical metadata.",
        "\t *",
        "\t * We pass the empty transaction to the file scanning function to avoid",
        "\t * repeatedly cycling empty transactions.  This can be done even though"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\nlinks.c",
      "line": 879,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Create a new empty transaction so that we can advance the iscan",
        "\t * cursor without deadlocking if the inobt has a cycle and push on the",
        "\t * inactivation workqueue.",
        "\t */",
        "\txchk_trans_cancel(sc);"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\nlinks_repair.c",
      "line": 339,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t\t/*",
        "\t\t * Create a new empty transaction so that we can advance the",
        "\t\t * iscan cursor without deadlocking if the inobt has a cycle.",
        "\t\t * We can only push the inactivation workqueues with an empty",
        "\t\t * transaction.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\parent_repair.c",
      "line": 919,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "",
        "\t/*",
        "\t * If we need a larger value buffer, try to allocate one.  If that",
        "\t * fails, return with -EDEADLOCK to try harder.",
        "\t */",
        "\terror = xrep_parent_alloc_xattr_value(rp, valuelen);",
        "\tif (error == -ENOMEM)"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\parent_repair.c",
      "line": 923,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t */",
        "\terror = xrep_parent_alloc_xattr_value(rp, valuelen);",
        "\tif (error == -ENOMEM)",
        "\t\treturn -EDEADLOCK;",
        "\tif (error)",
        "\t\treturn error;",
        ""
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\quotacheck.c",
      "line": 499,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * the filesystem.",
        "\t *",
        "\t * Create a new empty transaction to eliminate the possibility of the",
        "\t * inode scan deadlocking on cyclical metadata.",
        "\t *",
        "\t * We pass the empty transaction to the file scanning function to avoid",
        "\t * repeatedly cycling empty transactions.  This can be done without"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\quotacheck.c",
      "line": 503,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t *",
        "\t * We pass the empty transaction to the file scanning function to avoid",
        "\t * repeatedly cycling empty transactions.  This can be done without",
        "\t * risk of deadlock between sb_internal and the IOLOCK (we take the",
        "\t * IOLOCK to quiesce the file before scanning) because empty",
        "\t * transactions do not take sb_internal.",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\readdir.c",
      "line": 390,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        " *",
        " * If the trylocks succeed, *lockmode will be set to the locks held for @ip;",
        " * @sc->ilock_flags will be set for the locks held for @sc->ip; and zero will",
        " * be returned.  If not, returns -EDEADLOCK to try again; or -ETIMEDOUT if",
        " * XCHK_TRY_HARDER was set.  Returns -EINTR if the process has been killed.",
        " */",
        "int"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\readdir.c",
      "line": 420,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t\treturn -ETIMEDOUT;",
        "\t}",
        "",
        "\treturn -EDEADLOCK;",
        "}",
        ""
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\reap.c",
      "line": 284,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * If there are incore buffers for these blocks, invalidate them.  We",
        "\t * assume that the lack of any other known owners means that the buffer",
        "\t * can be locked without risk of deadlocking.  The buffer cache cannot",
        "\t * detect aliasing, so employ nested loops to scan for incore buffers",
        "\t * of any plausible size.",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\reap.c",
      "line": 1011,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffers are not logged and can overflow",
      "context": [
        "/*",
        " * Decide if this buffer can be joined to a transaction.  This is true for most",
        " * buffers, but there are two cases that we want to catch: large remote xattr",
        " * value buffers are not logged and can overflow the buffer log item dirty",
        " * bitmap size; and oversized cached buffers if things have really gone",
        " * haywire.",
        " */"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\repair.c",
      "line": 95,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t\tsc->flags |= XCHK_NEED_DRAIN;",
        "\t\trun->retries++;",
        "\t\treturn -EAGAIN;",
        "\tcase -EDEADLOCK:",
        "\t\t/* Tell the caller to try again having grabbed all the locks. */",
        "\t\tif (!(sc->flags & XCHK_TRY_HARDER)) {",
        "\t\t\tsc->flags |= XCHK_TRY_HARDER;"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\repair.c",
      "line": 487,
      "pattern": "magic.*numbers",
      "rule": "code_quality",
      "severity": "low",
      "match": "magic numbers",
      "context": [
        " *",
        " * For every rmapbt record matching any of the rmap owners in btree_info,",
        " * read each block referenced by the rmap record.  If the block is a btree",
        " * block from this filesystem matching any of the magic numbers and has a",
        " * level higher than what we've already seen, remember the block and the",
        " * height of the tree required to have such a block.  When the call completes,",
        " * we return the highest block we've found for each btree description; those"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\rmap_repair.c",
      "line": 944,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * the log grant space while we scan the filesystem.",
        "\t *",
        "\t * Create a new empty transaction to eliminate the possibility of the",
        "\t * inode scan deadlocking on cyclical metadata.",
        "\t *",
        "\t * We pass the empty transaction to the file scanning function to avoid",
        "\t * repeatedly cycling empty transactions.  This can be done even though"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\rtrmap_repair.c",
      "line": 574,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * release the log grant space while we scan the filesystem.",
        "\t *",
        "\t * Create a new empty transaction to eliminate the possibility of the",
        "\t * inode scan deadlocking on cyclical metadata.",
        "\t *",
        "\t * We pass the empty transaction to the file scanning function to avoid",
        "\t * repeatedly cycling empty transactions.  This can be done even though"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\scrub.c",
      "line": 63,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * Block maps and b-trees rooted in an inode present a special challenge",
        " * because they can involve extents from any AG.  The general scrubber",
        " * structure of lock -> check -> xref -> unlock still holds, but AG",
        " * locking order rules /must/ be obeyed to avoid deadlocks.  The",
        " * ordering rule, of course, is that we must lock in increasing AG",
        " * order.  Helper functions are provided to track which AG headers we've",
        " * already locked.  If we detect an imminent locking order violation, we"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\scrub.c",
      "line": 67,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * ordering rule, of course, is that we must lock in increasing AG",
        " * order.  Helper functions are provided to track which AG headers we've",
        " * already locked.  If we detect an imminent locking order violation, we",
        " * can signal a potential deadlock, in which case the scrubber can jump",
        " * out to the top level, lock all the AGs in order, and retry the scrub.",
        " *",
        " * For file data (directories, extended attributes, symlinks) scrub, we"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\scrub.c",
      "line": 75,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * (directories and attributes) we follow the same btree-scrubbing",
        " * strategy outlined previously to check the records.",
        " *",
        " * We use a bit of trickery with transactions to avoid buffer deadlocks",
        " * if there is a cycle in the metadata.  The basic problem is that",
        " * travelling down a btree involves locking the current buffer at each",
        " * tree level.  If a pointer should somehow point back to a buffer that"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\scrub.c",
      "line": 79,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * if there is a cycle in the metadata.  The basic problem is that",
        " * travelling down a btree involves locking the current buffer at each",
        " * tree level.  If a pointer should somehow point back to a buffer that",
        " * we've already examined, we will deadlock due to the second buffer",
        " * locking attempt.  Note however that grabbing a buffer in transaction",
        " * context links the locked buffer to the transaction.  If we try to",
        " * re-grab the buffer in the context of the same transaction, we avoid"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\scrub.c",
      "line": 710,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "",
        "\t/* Set up for the operation. */",
        "\terror = sc->ops->setup(sc);",
        "\tif (error == -EDEADLOCK && !(sc->flags & XCHK_TRY_HARDER))",
        "\t\tgoto try_harder;",
        "\tif (error == -ECHRNG && !(sc->flags & XCHK_NEED_DRAIN))",
        "\t\tgoto need_drain;"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\scrub.c",
      "line": 724,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\telse",
        "\t\terror = sc->ops->scrub(sc);",
        "\trun.scrub_ns += xchk_stats_elapsed_ns(check_start);",
        "\tif (error == -EDEADLOCK && !(sc->flags & XCHK_TRY_HARDER))",
        "\t\tgoto try_harder;",
        "\tif (error == -ECHRNG && !(sc->flags & XCHK_NEED_DRAIN))",
        "\t\tgoto need_drain;"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\scrub.c",
      "line": 787,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\tgoto retry_op;",
        "try_harder:",
        "\t/*",
        "\t * Scrubbers return -EDEADLOCK to mean 'try harder'.  Tear down",
        "\t * everything we hold, then set up again with preparation for",
        "\t * worst-case scenarios.",
        "\t */"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\tempfile.c",
      "line": 171,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Wait until after the current transaction is aborted to finish the",
        "\t * setup of the inode and release the inode.  This prevents recursive",
        "\t * transactions and deadlocks from xfs_inactive.",
        "\t */",
        "\tif (sc->tempip) {",
        "\t\txfs_iunlock(sc->tempip, XFS_ILOCK_EXCL);"
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\tempfile.c",
      "line": 310,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * Take the temporary file's IOLOCK while holding a different inode's IOLOCK.",
        " * In theory nobody else should hold the tempfile's IOLOCK, but we use trylock",
        " * to avoid deadlocks and lockdep complaints.",
        " */",
        "int",
        "xrep_tempfile_iolock_polled("
      ]
    },
    {
      "file": "linux\\fs\\xfs\\scrub\\xfarray.c",
      "line": 763,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "stack overflow",
      "context": [
        "\txfarray_idx_t\t\tlo,",
        "\txfarray_idx_t\t\thi)",
        "{",
        "\t/* Check for stack overflows */",
        "\tif (si->stack_depth >= si->max_stack_depth - 1) {",
        "\t\tASSERT(si->stack_depth < si->max_stack_depth - 1);",
        "\t\treturn -EFSCORRUPTED;"
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\arraymap.c",
      "line": 1109,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use after free",
      "context": [
        "\t\t\t *",
        "\t\t\t * 1) We can only ever access aux in this context, but",
        "\t\t\t *    not aux->prog since it might not be stable yet and",
        "\t\t\t *    there could be danger of use after free otherwise.",
        "\t\t\t * 2) Initially when we start tracking aux, the program",
        "\t\t\t *    is not JITed yet and also does not have a kallsyms",
        "\t\t\t *    entry. We skip these as poke->tailcall_target_stable"
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\bpf_local_storage.c",
      "line": 460,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "",
        "\t/* spinlock is needed to avoid racing with the",
        "\t * parallel delete.  Otherwise, publishing an already",
        "\t * deleted sdata to the cache will become a use-after-free",
        "\t * problem in the next bpf_local_storage_lookup().",
        "\t */",
        "\traw_spin_lock_irqsave(&local_storage->lock, flags);"
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\bpf_local_storage.c",
      "line": 792,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "}",
        "",
        "/* When bpf_ma == true, the bpf_mem_alloc is used to allocate and free memory.",
        " * A deadlock free allocator is useful for storage that the bpf prog can easily",
        " * get a hold of the owner PTR_TO_BTF_ID in any context. eg. bpf_get_current_task_btf.",
        " * The task and cgroup storage fall into this case. The bpf_mem_alloc reuses",
        " * memory immediately. To be reuse-immediate safe, the owner destruction"
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\cgroup.c",
      "line": 31,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * cgroup bpf destruction makes heavy use of work items and there can be a lot",
        " * of concurrent destructions.  Use a separate workqueue so that cgroup bpf",
        " * destruction work items don't end up filling up max_active of system_wq",
        " * which may lead to deadlock.",
        " */",
        "static struct workqueue_struct *cgroup_bpf_destroy_wq;",
        ""
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\hashtab.c",
      "line": 46,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * BPF programs can execute in any context including perf, kprobes and",
        " * tracing. As there are almost no limits where perf, kprobes and tracing",
        " * can be invoked from the lock operations need to be protected against",
        " * deadlocks. Deadlocks can be caused by recursion and by an invocation in",
        " * the lock held section when functions which acquire this lock are invoked",
        " * from sys_bpf(). BPF recursion is prevented by incrementing the per CPU",
        " * variable bpf_prog_active, which prevents BPF programs attached to perf"
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\hashtab.c",
      "line": 46,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Deadlock",
      "context": [
        " * BPF programs can execute in any context including perf, kprobes and",
        " * tracing. As there are almost no limits where perf, kprobes and tracing",
        " * can be invoked from the lock operations need to be protected against",
        " * deadlocks. Deadlocks can be caused by recursion and by an invocation in",
        " * the lock held section when functions which acquire this lock are invoked",
        " * from sys_bpf(). BPF recursion is prevented by incrementing the per CPU",
        " * variable bpf_prog_active, which prevents BPF programs attached to perf"
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\hashtab.c",
      "line": 296,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * bpf_lru_pop_free(), which is called by function prealloc_lru_pop(),",
        " * will acquire lru_lock first followed by acquiring bucket_lock.",
        " *",
        " * In hashtab.c, to avoid deadlock, lock acquisition of",
        " * bucket_lock followed by lru_lock is not allowed. In such cases,",
        " * bucket_lock needs to be released first before acquiring lru_lock.",
        " */"
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\hashtab.c",
      "line": 1836,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\thlist_nulls_del_rcu(&l->hash_node);",
        "",
        "\t\t\t/* bpf_lru_push_free() will acquire lru_lock, which",
        "\t\t\t * may cause deadlock. See comments in function",
        "\t\t\t * prealloc_lru_pop(). Let us do bpf_lru_push_free()",
        "\t\t\t * after releasing the bucket lock.",
        "\t\t\t *"
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\helpers.c",
      "line": 1580,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use it to possibly use struct hrtimer after free",
      "context": [
        "\t *",
        "\t * However, it is possible the timer callback_fn calling us armed the",
        "\t * timer _before_ calling us, such that failing to cancel it here will",
        "\t * cause it to possibly use struct hrtimer after freeing bpf_hrtimer.",
        "\t * Therefore, we _need_ to cancel any outstanding timers before we do",
        "\t * kfree_rcu, even though no more timers can be armed.",
        "\t *"
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\helpers.c",
      "line": 1163,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/* bpf_timer_cb() runs in hrtimer_run_softirq. It doesn't migrate and",
        "\t * cannot be preempted by another bpf_timer_cb() on the same cpu.",
        "\t * Remember the timer this callback is servicing to prevent",
        "\t * deadlock if callback_fn() calls bpf_timer_cancel() or",
        "\t * bpf_map_delete_elem() on the same timer.",
        "\t */",
        "\tthis_cpu_write(hrtimer_running, t);"
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\helpers.c",
      "line": 1483,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tcur_t = this_cpu_read(hrtimer_running);",
        "\tif (cur_t == t) {",
        "\t\t/* If bpf callback_fn is trying to bpf_timer_cancel()",
        "\t\t * its own timer the hrtimer_cancel() will deadlock",
        "\t\t * since it waits for callback_fn to finish.",
        "\t\t */",
        "\t\tret = -EDEADLK;"
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\helpers.c",
      "line": 1506,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * attempting to cancel us. In such a case, it might be possible",
        "\t\t * that timer t belongs to the other callback, or some other",
        "\t\t * callback waiting upon it (creating transitive dependencies",
        "\t\t * upon us), and we will enter a deadlock if we continue",
        "\t\t * cancelling and waiting for it synchronously, since it might",
        "\t\t * do the same. Bail!",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\helpers.c",
      "line": 1570,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\treturn;",
        "\t/* We check that bpf_map_delete/update_elem() was called from timer",
        "\t * callback_fn. In such case we don't call hrtimer_cancel() (since it",
        "\t * will deadlock) and don't call hrtimer_try_to_cancel() (since it will",
        "\t * just return -1). Though callback_fn is still running on this cpu it's",
        "\t * safe to do kfree(t) because bpf_timer_cb() read everything it needed",
        "\t * from 't'. The bpf subprog callback_fn won't be able to access 't',"
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\helpers.c",
      "line": 2108,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tBUILD_BUG_ON(__alignof__(struct list_head) > __alignof__(struct bpf_list_head));",
        "",
        "\t/* Do the actual list draining outside the lock to not hold the lock for",
        "\t * too long, and also prevent deadlocks if tracing programs end up",
        "\t * executing on entry/exit of functions called inside the critical",
        "\t * section, and end up doing map ops that call bpf_list_head_free for",
        "\t * the same map value again."
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\memalloc.c",
      "line": 982,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "}",
        "",
        "/* When flags == GFP_KERNEL, it signals that the caller will not cause",
        " * deadlock when using kmalloc. bpf_mem_cache_alloc_flags() will use",
        " * kmalloc if the free_llist is empty.",
        " */",
        "void notrace *bpf_mem_cache_alloc_flags(struct bpf_mem_alloc *ma, gfp_t flags)"
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\rqspinlock.c",
      "line": 99,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\treturn false;",
        "}",
        "",
        "static noinline int check_deadlock_AA(rqspinlock_t *lock, u32 mask,",
        "\t\t\t\t      struct rqspinlock_timeout *ts)",
        "{",
        "\tstruct rqspinlock_held *rqh = this_cpu_ptr(&rqspinlock_held_locks);"
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\rqspinlock.c",
      "line": 117,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "}",
        "",
        "/*",
        " * This focuses on the most common case of ABBA deadlocks (or ABBA involving",
        " * more locks, which reduce to ABBA). This is not exhaustive, and we rely on",
        " * timeouts as the final line of defense.",
        " */"
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\rqspinlock.c",
      "line": 121,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * more locks, which reduce to ABBA). This is not exhaustive, and we rely on",
        " * timeouts as the final line of defense.",
        " */",
        "static noinline int check_deadlock_ABBA(rqspinlock_t *lock, u32 mask,",
        "\t\t\t\t\tstruct rqspinlock_timeout *ts)",
        "{",
        "\tstruct rqspinlock_held *rqh = this_cpu_ptr(&rqspinlock_held_locks);"
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\rqspinlock.c",
      "line": 131,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * Find the CPU holding the lock that we want to acquire. If there is a",
        "\t * deadlock scenario, we will read a stable set on the remote CPU and",
        "\t * find the target. This would be a constant time operation instead of",
        "\t * O(NR_CPUS) if we could determine the owning CPU from a lock value, but",
        "\t * that requires increasing the size of the lock word."
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\rqspinlock.c",
      "line": 151,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t/*",
        "\t\t * Skip ourselves, and CPUs whose count is less than 2, as they need at",
        "\t\t * least one held lock and one acquisition attempt (reflected as top",
        "\t\t * most entry) to participate in an ABBA deadlock.",
        "\t\t *",
        "\t\t * If cnt is more than RES_NR_HELD, it means the current lock being",
        "\t\t * acquired won't appear in the table, and other locks in the table are"
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\rqspinlock.c",
      "line": 162,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t\t/*",
        "\t\t * Obtain the entry at the top, this corresponds to the lock the",
        "\t\t * remote CPU is attempting to acquire in a deadlock situation,",
        "\t\t * and would be one of the locks we hold on the current CPU.",
        "\t\t */",
        "\t\tremote_lock = READ_ONCE(rqh_cpu->locks[cnt - 1]);"
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\rqspinlock.c",
      "line": 167,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t */",
        "\t\tremote_lock = READ_ONCE(rqh_cpu->locks[cnt - 1]);",
        "\t\t/*",
        "\t\t * If it is NULL, we've raced and cannot determine a deadlock",
        "\t\t * conclusively, skip this CPU.",
        "\t\t */",
        "\t\tif (!remote_lock)"
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\rqspinlock.c",
      "line": 175,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t/*",
        "\t\t * Find if the lock we're attempting to acquire is held by this CPU.",
        "\t\t * Don't consider the topmost entry, as that must be the latest lock",
        "\t\t * being held or acquired.  For a deadlock, the target CPU must also",
        "\t\t * attempt to acquire a lock we hold, so for this search only 'cnt - 1'",
        "\t\t * entries are important.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\rqspinlock.c",
      "line": 185,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t/*",
        "\t\t\t * We found our lock as held on the remote CPU.  Is the",
        "\t\t\t * acquisition attempt on the remote CPU for a lock held",
        "\t\t\t * by us?  If so, we have a deadlock situation, and need",
        "\t\t\t * to recover.",
        "\t\t\t */",
        "\t\t\tfor (int i = 0; i < rqh_cnt - 1; i++) {"
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\rqspinlock.c",
      "line": 201,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\treturn 0;",
        "}",
        "",
        "static noinline int check_deadlock(rqspinlock_t *lock, u32 mask,",
        "\t\t\t\t   struct rqspinlock_timeout *ts)",
        "{",
        "\tint ret;"
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\rqspinlock.c",
      "line": 206,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "{",
        "\tint ret;",
        "",
        "\tret = check_deadlock_AA(lock, mask, ts);",
        "\tif (ret)",
        "\t\treturn ret;",
        "\tret = check_deadlock_ABBA(lock, mask, ts);"
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\rqspinlock.c",
      "line": 209,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tret = check_deadlock_AA(lock, mask, ts);",
        "\tif (ret)",
        "\t\treturn ret;",
        "\tret = check_deadlock_ABBA(lock, mask, ts);",
        "\tif (ret)",
        "\t\treturn ret;",
        ""
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\rqspinlock.c",
      "line": 232,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\treturn -ETIMEDOUT;",
        "",
        "\t/*",
        "\t * A millisecond interval passed from last time? Trigger deadlock",
        "\t * checks.",
        "\t */",
        "\tif (prev + NSEC_PER_MSEC < time) {"
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\rqspinlock.c",
      "line": 237,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t */",
        "\tif (prev + NSEC_PER_MSEC < time) {",
        "\t\tts->cur = time;",
        "\t\treturn check_deadlock(lock, mask, ts);",
        "\t}",
        "",
        "\treturn 0;"
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\rqspinlock.c",
      "line": 329,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * Return:",
        " * * 0\t\t- Lock was acquired successfully.",
        " * * -EDEADLK\t- Lock acquisition failed because of AA/ABBA deadlock.",
        " * * -ETIMEDOUT - Lock acquisition failed because of timeout.",
        " *",
        " * (queue tail, pending bit, lock value)"
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\rqspinlock.c",
      "line": 404,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t}",
        "",
        "\t/*",
        "\t * Grab an entry in the held locks array, to enable deadlock detection.",
        "\t */",
        "\tgrab_held_lock_entry(lock);",
        ""
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\rqspinlock.c",
      "line": 455,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "queue:",
        "\tlockevent_inc(lock_slowpath);",
        "\t/*",
        "\t * Grab deadlock detection entry for the queue path.",
        "\t */",
        "\tgrab_held_lock_entry(lock);",
        ""
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\trampoline.c",
      "line": 72,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t *   cleanup_direct_functions_after_ipmodify",
        "\t *",
        "\t * In both cases, direct_mutex is already locked. Use",
        "\t * mutex_trylock(&tr->mutex) to avoid deadlock in race condition",
        "\t * (something else is making changes to this same trampoline).",
        "\t */",
        "\tif (!mutex_trylock(&tr->mutex)) {"
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\trampoline.c",
      "line": 72,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t *   cleanup_direct_functions_after_ipmodify",
        "\t *",
        "\t * In both cases, direct_mutex is already locked. Use",
        "\t * mutex_trylock(&tr->mutex) to avoid deadlock in race condition",
        "\t * (something else is making changes to this same trampoline).",
        "\t */",
        "\tif (!mutex_trylock(&tr->mutex)) {"
      ]
    },
    {
      "file": "linux\\kernel\\cgroup\\cgroup.c",
      "line": 128,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * cgroup destruction makes heavy use of work items and there can be a lot",
        " * of concurrent destructions.  Use a separate workqueue so that cgroup",
        " * destruction work items don't end up filling up max_active of system_wq",
        " * which may lead to deadlock.",
        " */",
        "static struct workqueue_struct *cgroup_destroy_wq;",
        ""
      ]
    },
    {
      "file": "linux\\kernel\\cgroup\\cgroup.c",
      "line": 2463,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * exits by write-locking cgroup_threadgroup_rwsem. However, some ->attach()",
        " * implementations (e.g. cpuset), also need to disable CPU hotplug.",
        " * Unfortunately, letting ->attach() operations acquire cpus_read_lock() can",
        " * lead to deadlocks.",
        " *",
        " * Bringing up a CPU may involve creating and destroying tasks which requires",
        " * read-locking threadgroup_rwsem, so threadgroup_rwsem nests inside"
      ]
    },
    {
      "file": "linux\\kernel\\bpf\\verifier.c",
      "line": 8321,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t}",
        "\t\t} else if (is_res_lock && cur->active_locks) {",
        "\t\t\tif (find_lock_state(env->cur_state, REF_TYPE_RES_LOCK | REF_TYPE_RES_LOCK_IRQ, reg->id, ptr)) {",
        "\t\t\t\tverbose(env, \"Acquiring the same lock again, AA deadlock detected\\n\");",
        "\t\t\t\treturn -EINVAL;",
        "\t\t\t}",
        "\t\t}"
      ]
    },
    {
      "file": "linux\\kernel\\cgroup\\cpuset.c",
      "line": 4305,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * relax locking here to avoid taking global locks - while accepting",
        "\t * there may be rare scenarios where the result may be innaccurate.",
        "\t *",
        "\t * Reclaim and migration are subject to these same race conditions, and",
        "\t * cannot make strong isolation guarantees, so this is acceptable.",
        "\t */",
        "\tcs = container_of(css, struct cpuset, css);"
      ]
    },
    {
      "file": "linux\\kernel\\cgroup\\cpuset.c",
      "line": 235,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double tripping on callback_lock",
      "context": [
        " * takes callback_lock, blocking everyone else.",
        " *",
        " * Calls to the kernel memory allocator can not be made while holding",
        " * callback_lock, as that would risk double tripping on callback_lock",
        " * from one of the callbacks into the cpuset code from within",
        " * __alloc_pages().",
        " *"
      ]
    },
    {
      "file": "linux\\kernel\\debug\\debug_core.c",
      "line": 662,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * For single stepping, try to only enter on the processor",
        "\t * that was single stepping.  To guard against a deadlock, the",
        "\t * kernel will only try for the value of sstep_tries before",
        "\t * giving up and continuing on.",
        "\t */"
      ]
    },
    {
      "file": "linux\\kernel\\dma\\debug.c",
      "line": 411,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * entries into the tree.",
        " *",
        " * Use __GFP_NOWARN because the printk from an OOM, to netconsole, could end",
        " * up right back in the DMA debugging code, leading to a deadlock.",
        " */",
        "static RADIX_TREE(dma_active_cacheline, GFP_ATOMIC | __GFP_NOWARN);",
        "static DEFINE_SPINLOCK(radix_lock);"
      ]
    },
    {
      "file": "linux\\kernel\\dma\\debug.c",
      "line": 636,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "/*",
        " * This should be called outside of free_entries_lock scope to avoid potential",
        " * deadlocks with serial consoles that use DMA.",
        " */",
        "static void __dma_entry_alloc_check_leak(u32 nr_entries)",
        "{"
      ]
    },
    {
      "file": "linux\\kernel\\dma\\debug.c",
      "line": 1048,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tput_hash_bucket(bucket, flags);",
        "",
        "\t/*",
        "\t * Free the entry outside of bucket_lock to avoid ABBA deadlocks",
        "\t * between that and radix_lock.",
        "\t */",
        "\tdma_entry_free(entry);"
      ]
    },
    {
      "file": "linux\\kernel\\events\\hw_breakpoint.c",
      "line": 123,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t/*",
        "\t\t * Fully analogous to the perf_try_init_event() nesting",
        "\t\t * argument in the comment near perf_event_ctx_lock_nested();",
        "\t\t * this child->perf_event_mutex cannot ever deadlock against",
        "\t\t * the parent->perf_event_mutex usage from",
        "\t\t * perf_event_task_{en,dis}able().",
        "\t\t *"
      ]
    },
    {
      "file": "linux\\kernel\\events\\uprobes.c",
      "line": 1356,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t * make sure that we can't call into just unregistered",
        "\t * uprobe_consumer's callbacks anymore. If we don't do that, fast and",
        "\t * unlucky enough caller can free consumer's memory and cause",
        "\t * handler_chain() or handle_uretprobe_chain() to do an use-after-free.",
        "\t */",
        "\tsynchronize_rcu_tasks_trace();",
        "\tsynchronize_srcu(&uretprobes_srcu);"
      ]
    },
    {
      "file": "linux\\kernel\\events\\core.c",
      "line": 5684,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\tif (WARN(atomic_long_cmpxchg(&event->refcount, 1, 0) != 1,",
        "\t\t\t\t     \"unexpected event refcount: %ld; ptr=%p\\n\",",
        "\t\t\t\t     atomic_long_read(&event->refcount), event)) {",
        "\t\t/* leak to avoid use-after-free */",
        "\t\treturn;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\kernel\\events\\core.c",
      "line": 14107,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t\t * Without this copy_process() will unconditionally free this",
        "\t\t * task (irrespective of its reference count) and",
        "\t\t * _free_event()'s put_task_struct(event->hw.target) will be a",
        "\t\t * use-after-free.",
        "\t\t *",
        "\t\t * Wait for all events to drop their context reference.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\kernel\\events\\core.c",
      "line": 1320,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *              perf_init_event()",
        " *                perf_try_init_event()\t[ child , 1 ]",
        " *",
        " * While it appears there is an obvious deadlock here -- the parent and child",
        " * nesting levels are inverted between the two. This is in fact safe because",
        " * life-time rules separate them. That is an exiting task cannot fork, and a",
        " * spawning task cannot (yet) exit."
      ]
    },
    {
      "file": "linux\\kernel\\events\\core.c",
      "line": 11698,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t/*",
        "\t\t * Beware, here be dragons!!",
        "\t\t *",
        "\t\t * the tracepoint muck will deadlock against ctx->mutex, but",
        "\t\t * the tracepoint stuff does not actually need it. So",
        "\t\t * temporarily drop ctx->mutex. As per perf_event_ctx_lock() we",
        "\t\t * already have a reference on ctx."
      ]
    },
    {
      "file": "linux\\kernel\\futex\\core.c",
      "line": 941,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\t/*",
        "\t\t * q->lock_ptr can change between reading it and",
        "\t\t * spin_lock(), causing us to take the wrong lock.  This",
        "\t\t * corrects the race condition.",
        "\t\t *",
        "\t\t * Reasoning goes like this: if we have the wrong lock,",
        "\t\t * q->lock_ptr must have changed (maybe several times)"
      ]
    },
    {
      "file": "linux\\kernel\\futex\\pi.c",
      "line": 864,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * @locked:\tif the attempt to take the rt_mutex succeeded (1) or not (0)",
        " *",
        " * After attempting to lock an rt_mutex, this function is called to cleanup",
        " * the pi_state owner as well as handle race conditions that may allow us to",
        " * acquire the lock. Must be called with the hb lock held.",
        " *",
        " * Return:"
      ]
    },
    {
      "file": "linux\\kernel\\futex\\pi.c",
      "line": 537,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\treturn -EFAULT;",
        "",
        "\t/*",
        "\t * Detect deadlocks.",
        "\t */",
        "\tif ((unlikely((uval & FUTEX_TID_MASK) == vpid)))",
        "\t\treturn -EDEADLK;"
      ]
    },
    {
      "file": "linux\\kernel\\futex\\pi.c",
      "line": 1050,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "cleanup:",
        "\t\t/*",
        "\t\t * If we failed to acquire the lock (deadlock/signal/timeout), we must",
        "\t\t * unwind the above, however we canont lock hb->lock because",
        "\t\t * rt_mutex already has a waiter enqueued and hb->lock can itself try",
        "\t\t * and enqueue an rt_waiter through rtlock."
      ]
    },
    {
      "file": "linux\\kernel\\futex\\requeue.c",
      "line": 48,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * to wait for the requeue side to change the state. Either to DONE/LOCKED",
        " * or to IGNORE. DONE/LOCKED means the waiter q is now on the uaddr2 futex",
        " * and either blocked (DONE) or has acquired it (LOCKED). IGNORE is set by",
        " * the requeue side when the requeue attempt failed via deadlock detection",
        " * and therefore the waiter q is still on the uaddr1 futex.",
        " */",
        "enum {"
      ]
    },
    {
      "file": "linux\\kernel\\futex\\requeue.c",
      "line": 147,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Deadlock",
      "context": [
        "\t\t\t\t     old != Q_REQUEUE_PI_WAIT);",
        "\t\t\tnew = Q_REQUEUE_PI_DONE + locked;",
        "\t\t} else if (old == Q_REQUEUE_PI_IN_PROGRESS) {",
        "\t\t\t/* Deadlock, no early wakeup interleave */",
        "\t\t\tnew = Q_REQUEUE_PI_NONE;",
        "\t\t} else {",
        "\t\t\t/* Deadlock, early wakeup interleave. */"
      ]
    },
    {
      "file": "linux\\kernel\\futex\\requeue.c",
      "line": 150,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Deadlock",
      "context": [
        "\t\t\t/* Deadlock, no early wakeup interleave */",
        "\t\t\tnew = Q_REQUEUE_PI_NONE;",
        "\t\t} else {",
        "\t\t\t/* Deadlock, early wakeup interleave. */",
        "\t\t\tWARN_ON_ONCE(old != Q_REQUEUE_PI_WAIT);",
        "\t\t\tnew = Q_REQUEUE_PI_IGNORE;",
        "\t\t}"
      ]
    },
    {
      "file": "linux\\kernel\\futex\\requeue.c",
      "line": 664,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t} else {",
        "\t\t\t\t/*",
        "\t\t\t\t * rt_mutex_start_proxy_lock() detected a potential",
        "\t\t\t\t * deadlock when we tried to queue that waiter.",
        "\t\t\t\t * Drop the pi_state reference which we took above",
        "\t\t\t\t * and remove the pointer to the state from the",
        "\t\t\t\t * waiters futex_q object."
      ]
    },
    {
      "file": "linux\\kernel\\futex\\requeue.c",
      "line": 461,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "\t\tCLASS(hb, hb2)(&key2);",
        "",
        "\t\tfutex_hb_waiters_inc(hb2);",
        "\t\tdouble_lock_hb(hb1, hb2);",
        "",
        "\t\tif (likely(cmpval != NULL)) {",
        "\t\t\tu32 curval;"
      ]
    },
    {
      "file": "linux\\kernel\\futex\\requeue.c",
      "line": 470,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "",
        "\t\t\tif (unlikely(ret)) {",
        "\t\t\t\tfutex_hb_waiters_dec(hb2);",
        "\t\t\t\tdouble_unlock_hb(hb1, hb2);",
        "",
        "\t\t\t\tret = get_user(curval, uaddr1);",
        "\t\t\t\tif (ret)"
      ]
    },
    {
      "file": "linux\\kernel\\futex\\requeue.c",
      "line": 556,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\t\t\t\t */",
        "\t\t\tcase -EFAULT:",
        "\t\t\t\tfutex_hb_waiters_dec(hb2);",
        "\t\t\t\tdouble_unlock_hb(hb1, hb2);",
        "\t\t\t\tret = fault_in_user_writeable(uaddr2);",
        "\t\t\t\tif (!ret)",
        "\t\t\t\t\tgoto retry;"
      ]
    },
    {
      "file": "linux\\kernel\\futex\\requeue.c",
      "line": 570,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\t\t\t\t * - EAGAIN: The user space value changed.",
        "\t\t\t\t */",
        "\t\t\t\tfutex_hb_waiters_dec(hb2);",
        "\t\t\t\tdouble_unlock_hb(hb1, hb2);",
        "\t\t\t\t/*",
        "\t\t\t\t * Handle the case where the owner is in the middle of",
        "\t\t\t\t * exiting. Wait for the exit to complete otherwise"
      ]
    },
    {
      "file": "linux\\kernel\\futex\\requeue.c",
      "line": 688,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "",
        "out_unlock:",
        "\t\tfutex_hb_waiters_dec(hb2);",
        "\t\tdouble_unlock_hb(hb1, hb2);",
        "\t}",
        "\twake_up_q(&wake_q);",
        "\treturn ret ? ret : task_count;"
      ]
    },
    {
      "file": "linux\\kernel\\futex\\waitwake.c",
      "line": 608,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t * The basic logical guarantee of a futex is that it blocks ONLY",
        "\t * if cond(var) is known to be true at the time of blocking, for",
        "\t * any cond.  If we locked the hash-bucket after testing *uaddr, that",
        "\t * would open a race condition where we could block indefinitely with",
        "\t * cond(var) false, which would violate the guarantee.",
        "\t *",
        "\t * On the other hand, we insert q and release the hash-bucket only"
      ]
    },
    {
      "file": "linux\\kernel\\futex\\waitwake.c",
      "line": 417,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Enqueuing multiple futexes is tricky, because we need to enqueue",
        "\t * each futex on the list before dealing with the next one to avoid",
        "\t * deadlocking on the hash bucket. But, before enqueuing, we need to",
        "\t * make sure that current->state is TASK_INTERRUPTIBLE, so we don't",
        "\t * lose any wake events, which cannot be done before the get_futex_key",
        "\t * of the next key, because it calls get_user_pages, which can sleep."
      ]
    },
    {
      "file": "linux\\kernel\\futex\\waitwake.c",
      "line": 107,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock_hb() and double_unlock",
      "context": [
        " * acquiring the lock. It then decrements them again  after releasing it -",
        " * the code that actually moves the futex(es) between hash buckets (requeue_futex)",
        " * will do the additional required waiter count housekeeping. This is done for",
        " * double_lock_hb() and double_unlock_hb(), respectively.",
        " */",
        "",
        "bool __futex_wake_mark(struct futex_q *q)"
      ]
    },
    {
      "file": "linux\\kernel\\futex\\waitwake.c",
      "line": 272,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "\t\tCLASS(hb, hb1)(&key1);",
        "\t\tCLASS(hb, hb2)(&key2);",
        "",
        "\t\tdouble_lock_hb(hb1, hb2);",
        "\t\top_ret = futex_atomic_op_inuser(op, uaddr2);",
        "\t\tif (unlikely(op_ret < 0)) {",
        "\t\t\tdouble_unlock_hb(hb1, hb2);"
      ]
    },
    {
      "file": "linux\\kernel\\futex\\waitwake.c",
      "line": 275,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\t\tdouble_lock_hb(hb1, hb2);",
        "\t\top_ret = futex_atomic_op_inuser(op, uaddr2);",
        "\t\tif (unlikely(op_ret < 0)) {",
        "\t\t\tdouble_unlock_hb(hb1, hb2);",
        "",
        "\t\t\tif (!IS_ENABLED(CONFIG_MMU) ||",
        "\t\t\t    unlikely(op_ret != -EFAULT && op_ret != -EAGAIN)) {"
      ]
    },
    {
      "file": "linux\\kernel\\futex\\waitwake.c",
      "line": 328,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\t\t}",
        "",
        "out_unlock:",
        "\t\tdouble_unlock_hb(hb1, hb2);",
        "\t}",
        "\twake_up_q(&wake_q);",
        "\treturn ret;"
      ]
    },
    {
      "file": "linux\\kernel\\irq\\irqdomain.c",
      "line": 1726,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * hierarchy.  This will catch gross misuse.  Attempting to",
        "\t * make the check race free would require holding locks across",
        "\t * calls to struct irq_domain_ops->alloc(), which could lead",
        "\t * to deadlock, so we just do a simple check before starting.",
        "\t */",
        "\tdesc = irq_to_desc(virq);",
        "\tif (!desc)"
      ]
    },
    {
      "file": "linux\\kernel\\irq\\irqdomain.c",
      "line": 1807,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * This will catch gross misuse.  Attempting to make the check",
        "\t * race free would require holding locks across calls to",
        "\t * struct irq_domain_ops->free(), which could lead to",
        "\t * deadlock, so we just do a simple check before starting.",
        "\t */",
        "\tdesc = irq_to_desc(virq);",
        "\tif (!desc)"
      ]
    },
    {
      "file": "linux\\kernel\\irq\\manage.c",
      "line": 80,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * This function waits for any pending hard IRQ handlers for this interrupt",
        " * to complete before returning. If you use this function while holding a",
        " * resource the IRQ handler may need you will deadlock. It does not take",
        " * associated threaded handlers into account.",
        " *",
        " * Do not use this for shutdown scenarios where you must be sure that all"
      ]
    },
    {
      "file": "linux\\kernel\\irq\\manage.c",
      "line": 91,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * This function may be called - with care - from IRQ context.",
        " *",
        " * It does not check whether there is an interrupt in flight at the",
        " * hardware level, but not serviced yet, as this might deadlock when called",
        " * with interrupts disabled and the target CPU of the interrupt is the",
        " * current CPU.",
        " */"
      ]
    },
    {
      "file": "linux\\kernel\\irq\\manage.c",
      "line": 124,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * This function waits for any pending IRQ handlers for this interrupt to",
        " * complete before returning. If you use this function while holding a",
        " * resource the IRQ handler may need you will deadlock.",
        " *",
        " * Can only be called from preemptible code as it might sleep when",
        " * an interrupt thread is associated to @irq."
      ]
    },
    {
      "file": "linux\\kernel\\irq\\manage.c",
      "line": 694,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * This function waits for any pending IRQ handlers for this interrupt to",
        " * complete before returning. If you use this function while holding a",
        " * resource the IRQ handler may need you will deadlock.",
        " *",
        " * Can only be called from preemptible code as it might sleep when an",
        " * interrupt thread is associated to @irq."
      ]
    },
    {
      "file": "linux\\kernel\\irq\\manage.c",
      "line": 716,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * This function waits for any pending hard IRQ handlers for this interrupt",
        " * to complete before returning. If you use this function while holding a",
        " * resource the hard IRQ handler may need you will deadlock.",
        " *",
        " * When used to optimistically disable an interrupt from atomic context the",
        " * return value must be checked."
      ]
    },
    {
      "file": "linux\\kernel\\irq\\manage.c",
      "line": 1143,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * Interrupts which are not explicitly requested as threaded",
        " * interrupts rely on the implicit bh/preempt disable of the hard irq",
        " * context. So we need to disable bh here to avoid deadlocks and other",
        " * side effects.",
        " */",
        "static irqreturn_t irq_forced_thread_fn(struct irq_desc *desc, struct irqaction *action)"
      ]
    },
    {
      "file": "linux\\kernel\\irq\\manage.c",
      "line": 1866,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * behind a slow bus (I2C, SPI) before calling synchronize_hardirq().",
        "\t *",
        "\t * Aside of that the bus_lock can also be taken from the threaded",
        "\t * handler in irq_finalize_oneshot() which results in a deadlock",
        "\t * because kthread_stop() would wait forever for the thread to",
        "\t * complete, which is blocked on the bus lock.",
        "\t *"
      ]
    },
    {
      "file": "linux\\kernel\\kcsan\\kcsan_test.c",
      "line": 167,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Doubled-checked lock",
      "context": [
        "\tchar *cur;",
        "\tint i;",
        "",
        "\t/* Doubled-checked locking. */",
        "\tif (!report_available())",
        "\t\treturn false;",
        ""
      ]
    },
    {
      "file": "linux\\kernel\\kcsan\\report.c",
      "line": 57,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t *",
        "\t * We cannot rely on get_task_struct/put_task_struct in case",
        "\t * release_report() races with a task being released, and would have to",
        "\t * free it in release_report(). This may result in deadlock if we want",
        "\t * to use KCSAN on the allocators.",
        "\t *",
        "\t * Since we also want to reliably print held locks for"
      ]
    },
    {
      "file": "linux\\kernel\\kcsan\\report.c",
      "line": 92,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "/*",
        " * Since we also want to be able to debug allocators with KCSAN, to avoid",
        " * deadlock, report_times cannot be dynamically resized with krealloc in",
        " * rate_limit_report.",
        " *",
        " * Therefore, we use a fixed-size array, which at most will occupy a page. This"
      ]
    },
    {
      "file": "linux\\kernel\\kcsan\\report.c",
      "line": 524,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t */",
        "\tconst bool is_running = task_is_running(current);",
        "\t/*",
        "\t * To avoid deadlock in case we are in an interrupt here and this is a",
        "\t * race with a task on the same CPU (KCSAN_INTERRUPT_WATCHER), provide a",
        "\t * timeout to ensure this works in all contexts.",
        "\t *"
      ]
    },
    {
      "file": "linux\\kernel\\kcsan\\report.c",
      "line": 677,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tkcsan_disable_current();",
        "\t/*",
        "\t * Because we may generate reports when we're in scheduler code, the use",
        "\t * of printk() could deadlock. Until such time that all printing code",
        "\t * called in print_report() is scheduler-safe, accept the risk, and just",
        "\t * get our message out. As such, also disable lockdep to hide the",
        "\t * warning, and avoid disabling lockdep for the rest of the kernel."
      ]
    },
    {
      "file": "linux\\kernel\\livepatch\\core.c",
      "line": 751,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "static void klp_free_patch_finish(struct klp_patch *patch)",
        "{",
        "\t/*",
        "\t * Avoid deadlock with enabled_store() sysfs callback by",
        "\t * calling this outside klp_mutex. It is safe because",
        "\t * this is called when the patch gets disabled and it",
        "\t * cannot get enabled again."
      ]
    },
    {
      "file": "linux\\kernel\\livepatch\\transition.c",
      "line": 105,
      "pattern": "long.*functions",
      "rule": "code_quality",
      "severity": "low",
      "match": "longer see functions",
      "context": [
        "\t\tklp_unpatch_objects(klp_transition_patch);",
        "",
        "\t\t/*",
        "\t\t * Make sure klp_ftrace_handler() can no longer see functions",
        "\t\t * from this patch on the ops->func_stack.  Otherwise, after",
        "\t\t * func->transition gets cleared, the handler may choose a",
        "\t\t * removed function."
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 1263,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t/*",
        "\t * If lock debugging is disabled lock_keys_hash[] may contain",
        "\t * pointers to memory that has already been freed. Avoid triggering",
        "\t * a use-after-free in that case by returning early.",
        "\t */",
        "\tif (!debug_locks)",
        "\t\treturn true;"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 3134,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "",
        "\tif (!hlock_class(prev)->key || !hlock_class(next)->key) {",
        "\t\t/*",
        "\t\t * The warning statements below may trigger a use-after-free",
        "\t\t * of the class name. It is better to trigger a use-after free",
        "\t\t * and to have the class name most of the time instead of not",
        "\t\t * having the class name available."
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 3135,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after free",
      "context": [
        "\tif (!hlock_class(prev)->key || !hlock_class(next)->key) {",
        "\t\t/*",
        "\t\t * The warning statements below may trigger a use-after-free",
        "\t\t * of the class name. It is better to trigger a use-after free",
        "\t\t * and to have the class name most of the time instead of not",
        "\t\t * having the class name available.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 3140,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t\t * having the class name available.",
        "\t\t */",
        "\t\tWARN_ONCE(!debug_locks_silent && !hlock_class(prev)->key,",
        "\t\t\t  \"Detected use-after-free of lock class %px/%s\\n\",",
        "\t\t\t  hlock_class(prev),",
        "\t\t\t  hlock_class(prev)->name);",
        "\t\tWARN_ONCE(!debug_locks_silent && !hlock_class(next)->key,"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 3144,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t\t\t  hlock_class(prev),",
        "\t\t\t  hlock_class(prev)->name);",
        "\t\tWARN_ONCE(!debug_locks_silent && !hlock_class(next)->key,",
        "\t\t\t  \"Detected use-after-free of lock class %px/%s\\n\",",
        "\t\t\t  hlock_class(next),",
        "\t\t\t  hlock_class(next)->name);",
        "\t\treturn 2;"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 5842,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t/*",
        "\t * As KASAN instrumentation is disabled and lock_acquire() is usually",
        "\t * the first lockdep call when a task tries to acquire a lock, add",
        "\t * kasan_check_byte() here to check for use-after-free and other",
        "\t * memory errors.",
        "\t */",
        "\tkasan_check_byte(lock);"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 20,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * - hardirq/softirq safe/unsafe locking bugs",
        " *",
        " * Bugs are reported even if the current locking scenario does not cause",
        " * any deadlock at this point.",
        " *",
        " * I.e. if anytime in the past two locks were taken in a different order,",
        " * even if it happened for another task, even if those were different"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 1465,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * The circular_queue and helpers are used to implement graph",
        " * breadth-first search (BFS) algorithm, by which we can determine",
        " * whether there is a path from a lock to another. In deadlock checks,",
        " * a path from the next lock to be acquired to a previous held lock",
        " * indicates that adding the <prev> -> <next> lock dependency will",
        " * produce a circle in the graph. Breadth-first search instead of"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 1721,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * We may have multiple edges (considering different kinds of dependencies,",
        " * e.g. ER and SN) between two nodes in the dependency graph. But",
        " * only the strong dependency path in the graph is relevant to deadlocks. A",
        " * strong dependency path is a dependency path that doesn't have two adjacent",
        " * dependencies as -(*R)-> -(S*)->, please see:",
        " *"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 1875,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "}",
        "",
        "/*",
        " * Print a dependency chain entry (this is only done when a deadlock",
        " * has been detected):",
        " */",
        "static noinline void"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 1903,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * A direct locking problem where unsafe_class lock is taken",
        "\t * directly by safe_class lock, then all we need to show",
        "\t * is the deadlock scenario, as it is obvious that the",
        "\t * unsafe lock is taken under the safe lock.",
        "\t *",
        "\t * But if there is a chain instead, where the safe lock takes"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 1946,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t\tprintk(\"  lock(\");",
        "\t__print_lock_name(src, source);",
        "\tprintk(KERN_CONT \");\\n\");",
        "\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");",
        "}",
        "",
        "/*"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 1986,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * strong dependency path A -> .. -> B is found: hlock_class equals",
        " * entry->class.",
        " *",
        " * We will have a deadlock case (conflict) if A -> .. -> B -> A is a strong",
        " * dependency cycle, that means:",
        " *",
        " * Either"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 2142,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\treturn ret;",
        "}",
        "",
        "static void print_deadlock_bug(struct task_struct *, struct held_lock *, struct held_lock *);",
        "",
        "/*",
        " * Prove that the dependency graph starting at <src> can not"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 2176,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t}",
        "",
        "\t\tif (src->class_idx == target->class_idx)",
        "\t\t\tprint_deadlock_bug(current, src, target);",
        "\t\telse",
        "\t\t\tprint_circular_bug(&src_entry, target_entry, src, target);",
        "\t}"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 2191,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * proving that two subgraphs can be connected by a new dependency",
        " * without creating any illegal irq-safe -> irq-unsafe lock dependency.",
        " *",
        " * A irq safe->unsafe deadlock happens with the following conditions:",
        " *",
        " * 1) We have a strong dependency path A -> ... -> B",
        " *"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 2240,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * There is a strong dependency path in the dependency graph: A -> B, and now",
        " * we need to decide which usage bit of B conflicts with the usage bits of A,",
        " * i.e. which usage bit of B may introduce safe->unsafe deadlocks.",
        " *",
        " * As above, if only_xr is false, which means A -> B has -(*N)-> dependency",
        " * path, any usage of B should be considered. Otherwise, we should only"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 2365,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * After BFS we get a lock dependency path (linked via ->parent of lock_list),",
        " * printing out each lock in the dependency path will help on understanding how",
        " * the deadlock could happen. Here are some details about dependency path",
        " * printing:",
        " *",
        " * 1)\tA lock_list can be either forwards or backwards for a lock dependency,"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 2509,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * A direct locking problem where unsafe_class lock is taken",
        "\t * directly by safe_class lock, then all we need to show",
        "\t * is the deadlock scenario, as it is obvious that the",
        "\t * unsafe lock is taken under the safe lock.",
        "\t *",
        "\t * But if there is a chain instead, where the safe lock takes"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 2546,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\tprintk(\"    lock(\");",
        "\t__print_lock_name(NULL, safe_class);",
        "\tprintk(KERN_CONT \");\\n\");",
        "\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");",
        "}",
        "",
        "static void"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 2691,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "/*",
        " * Note that a LOCK_ENABLED_IRQ_*_READ usage and a LOCK_USED_IN_IRQ_*_READ",
        " * usage may cause deadlock too, for example:",
        " *",
        " * P1\t\t\t\tP2",
        " * <irq disabled>"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 2703,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * , in above case, l1 will be marked as LOCK_USED_IN_IRQ_HARDIRQ_READ and l2",
        " * will marked as LOCK_ENABLE_IRQ_HARDIRQ_READ, and this is a possible",
        " * deadlock.",
        " *",
        " * In fact, all of the following cases may cause deadlocks:",
        " *"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 2705,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * will marked as LOCK_ENABLE_IRQ_HARDIRQ_READ, and this is a possible",
        " * deadlock.",
        " *",
        " * In fact, all of the following cases may cause deadlocks:",
        " *",
        " * \t LOCK_USED_IN_IRQ_* -> LOCK_ENABLED_IRQ_*",
        " * \t LOCK_USED_IN_IRQ_*_READ -> LOCK_ENABLED_IRQ_*"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 2759,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tfor_each_set_bit(bit, &mask, LOCK_USED) {",
        "\t\t/*",
        "\t\t * exclusive_bit() strips the read bit, however,",
        "\t\t * LOCK_ENABLED_IRQ_*_READ may cause deadlocks too, so we need",
        "\t\t * to search excl | LOCK_USAGE_READ_MASK as well.",
        "\t\t */",
        "\t\texcl = exclusive_bit(bit);"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 2838,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * that B -> ... -> M. However M is **softirq-safe**, if we use exact",
        "\t * invert bits of M's usage_mask, we will find another lock N that is",
        "\t * **softirq-unsafe** and N -> ... -> A, however N -> .. -> M will not",
        "\t * cause a inversion deadlock.",
        "\t */",
        "\tbackward_mask = original_mask(target_entry1->class->usage_mask & LOCKF_ENABLED_IRQ_ALL);",
        ""
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 2994,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "}",
        "",
        "static void",
        "print_deadlock_scenario(struct held_lock *nxt, struct held_lock *prv)",
        "{",
        "\tstruct lock_class *next = hlock_class(nxt);",
        "\tstruct lock_class *prev = hlock_class(prv);"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 3008,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\tprintk(\"  lock(\");",
        "\t__print_lock_name(nxt, next);",
        "\tprintk(KERN_CONT \");\\n\");",
        "\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");",
        "\tprintk(\" May be due to missing lock nesting notation\\n\\n\");",
        "}",
        ""
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 3013,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "}",
        "",
        "static void",
        "print_deadlock_bug(struct task_struct *curr, struct held_lock *prev,",
        "\t\t   struct held_lock *next)",
        "{",
        "\tstruct lock_class *class = hlock_class(prev);"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 3040,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t}",
        "",
        "\tpr_warn(\"\\nother info that might help us debug this:\\n\");",
        "\tprint_deadlock_scenario(next, prev);",
        "\tlockdep_print_held_locks(curr);",
        "",
        "\tpr_warn(\"\\nstack backtrace:\\n\");"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 3053,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * Check whether we are holding such a class already.",
        " *",
        " * (Note that this has to be done separately, because the graph cannot",
        " * detect such classes of deadlocks.)",
        " *",
        " * Returns: 0 on deadlock detected, 1 on OK, 2 if another lock with the same",
        " * lock class is held but nest_lock is also held, i.e. we rely on the"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 3055,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * (Note that this has to be done separately, because the graph cannot",
        " * detect such classes of deadlocks.)",
        " *",
        " * Returns: 0 on deadlock detected, 1 on OK, 2 if another lock with the same",
        " * lock class is held but nest_lock is also held, i.e. we rely on the",
        " * nest_lock to avoid the deadlock.",
        " */"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 3057,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * Returns: 0 on deadlock detected, 1 on OK, 2 if another lock with the same",
        " * lock class is held but nest_lock is also held, i.e. we rely on the",
        " * nest_lock to avoid the deadlock.",
        " */",
        "static int",
        "check_deadlock(struct task_struct *curr, struct held_lock *next)"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 3060,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * nest_lock to avoid the deadlock.",
        " */",
        "static int",
        "check_deadlock(struct task_struct *curr, struct held_lock *next)",
        "{",
        "\tstruct lock_class *class;",
        "\tstruct held_lock *prev;"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 3096,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tif (nest)",
        "\t\t\treturn 2;",
        "",
        "\t\tprint_deadlock_bug(curr, prev, next);",
        "\t\treturn 0;",
        "\t}",
        "\treturn 1;"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 3107,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * to a previous lock. We validate the following rules:",
        " *",
        " *  - would the adding of the <prev> -> <next> dependency create a",
        " *    circular dependency in the graph? [== circular deadlock]",
        " *",
        " *  - does the new prev->next dependency connect any hardirq-safe lock",
        " *    (in the full backwards-subgraph starting at <prev>) with any"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 3119,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *    softirq-unsafe lock (in the full forwards-subgraph starting at",
        " *    <next>)? [== illegal lock inversion with softirq contexts]",
        " *",
        " * any of these scenarios could lead to a deadlock.",
        " *",
        " * Then if all the validations pass, we add the forwards and backwards",
        " * dependency."
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 3892,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * - within the current held-lock stack",
        "\t\t * - across our accumulated lock dependency records",
        "\t\t *",
        "\t\t * any of these scenarios could lead to a deadlock.",
        "\t\t */",
        "\t\t/*",
        "\t\t * The simple case: does the current hold the same lock"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 3898,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * The simple case: does the current hold the same lock",
        "\t\t * already?",
        "\t\t */",
        "\t\tint ret = check_deadlock(curr, hlock);",
        "",
        "\t\tif (!ret)",
        "\t\t\treturn 0;"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 3906,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * Add dependency only if this lock is not the head",
        "\t\t * of the chain, and if the new lock introduces no more",
        "\t\t * lock dependency (because we already hold a lock with the",
        "\t\t * same lock class) nor deadlock (because the nest_lock",
        "\t\t * serializes nesting locks), see the comments for",
        "\t\t * check_deadlock().",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 3908,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * lock dependency (because we already hold a lock with the",
        "\t\t * same lock class) nor deadlock (because the nest_lock",
        "\t\t * serializes nesting locks), see the comments for",
        "\t\t * check_deadlock().",
        "\t\t */",
        "\t\tif (!chain_head && ret != 2) {",
        "\t\t\tif (!check_prevs_add(curr, hlock))"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 4006,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\tprintk(\"    lock(\");",
        "\t__print_lock_name(lock, class);",
        "\tprintk(KERN_CONT \");\\n\");",
        "\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");",
        "}",
        "",
        "static void"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 4288,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tif (dir) {",
        "\t\t/*",
        "\t\t * mark ENABLED has to look backwards -- to ensure no dependee",
        "\t\t * has USED_IN state, which, again, would allow  recursion deadlocks.",
        "\t\t */",
        "\t\tif (!check_usage_backwards(curr, this, excl_bit))",
        "\t\t\treturn 0;"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 4295,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t} else {",
        "\t\t/*",
        "\t\t * mark USED_IN has to look forwards -- to ensure no dependency",
        "\t\t * has ENABLED state, which would allow recursion deadlocks.",
        "\t\t */",
        "\t\tif (!check_usage_forwards(curr, this, excl_bit))",
        "\t\t\treturn 0;"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 5785,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * READ locks only conflict with USED, such that if we only ever use",
        "\t * READ locks, there is no deadlock possible -- RCU.",
        "\t */",
        "\tif (!hlock->read)",
        "\t\tmask |= LOCKF_USED_READ;"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 5905,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * No actual critical section is created by the APIs annotated with this: these",
        " * APIs are used to wait for one or multiple critical sections (on other CPUs",
        " * or threads), and it means that calling these APIs inside these critical",
        " * sections is potential deadlock.",
        " */",
        "void lock_sync(struct lockdep_map *lock, unsigned subclass, int read,",
        "\t       int check, struct lockdep_map *nest_lock, unsigned long ip)"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\lockdep.c",
      "line": 3009,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "missing lock",
      "context": [
        "\t__print_lock_name(nxt, next);",
        "\tprintk(KERN_CONT \");\\n\");",
        "\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");",
        "\tprintk(\" May be due to missing lock nesting notation\\n\\n\");",
        "}",
        "",
        "static void"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\mutex-debug.c",
      "line": 8,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " *  Copyright (C) 2004, 2005, 2006 Red Hat, Inc., Ingo Molnar <mingo@redhat.com>",
        " *",
        " * lock debugging, locking tree, deadlock detection started by:",
        " *",
        " *  Copyright (C) 2004, LynuxWorks, Inc., Igor Manyilov, Bill Huey",
        " *  Released under the General Public License (GPL)."
      ]
    },
    {
      "file": "linux\\kernel\\locking\\mutex.c",
      "line": 269,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * (The CONFIG_DEBUG_MUTEXES .config option turns on debugging",
        " * checks that will enforce the restrictions and will also do",
        " * deadlock debugging)",
        " *",
        " * This function is similar to (but not equivalent to) down().",
        " */"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\mutex.c",
      "line": 308,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * by acquiring wait_lock there is a guarantee that",
        "\t * they are not invalid when reading.",
        "\t *",
        "\t * As such, when deadlock detection needs to be",
        "\t * performed the optimistic spinning cannot be done.",
        "\t *",
        "\t * Check this in every inner iteration because we may"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\mutex.c",
      "line": 762,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * @ww: mutex to lock",
        " * @ww_ctx: optional w/w acquire context",
        " *",
        " * Trylocks a mutex with the optional acquire context; no deadlock detection is",
        " * possible. Returns 1 if the mutex has been acquired successfully, 0 otherwise.",
        " *",
        " * Unlike ww_mutex_lock, no deadlock handling is performed. However, if a @ctx is"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\mutex.c",
      "line": 765,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * Trylocks a mutex with the optional acquire context; no deadlock detection is",
        " * possible. Returns 1 if the mutex has been acquired successfully, 0 otherwise.",
        " *",
        " * Unlike ww_mutex_lock, no deadlock handling is performed. However, if a @ctx is",
        " * specified, -EALREADY handling may happen in calls to ww_mutex_trylock.",
        " *",
        " * A mutex acquired with this function must be released with ww_mutex_unlock."
      ]
    },
    {
      "file": "linux\\kernel\\locking\\mutex.c",
      "line": 841,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "EXPORT_SYMBOL_GPL(mutex_lock_io_nested);",
        "",
        "static inline int",
        "ww_mutex_deadlock_injection(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)",
        "{",
        "#ifdef CONFIG_DEBUG_WW_MUTEX_SLOWPATH",
        "\tunsigned tmp;"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\mutex.c",
      "line": 846,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "#ifdef CONFIG_DEBUG_WW_MUTEX_SLOWPATH",
        "\tunsigned tmp;",
        "",
        "\tif (ctx->deadlock_inject_countdown-- == 0) {",
        "\t\ttmp = ctx->deadlock_inject_interval;",
        "\t\tif (tmp > UINT_MAX/4)",
        "\t\t\ttmp = UINT_MAX;"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\mutex.c",
      "line": 847,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tunsigned tmp;",
        "",
        "\tif (ctx->deadlock_inject_countdown-- == 0) {",
        "\t\ttmp = ctx->deadlock_inject_interval;",
        "\t\tif (tmp > UINT_MAX/4)",
        "\t\t\ttmp = UINT_MAX;",
        "\t\telse"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\mutex.c",
      "line": 853,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\telse",
        "\t\t\ttmp = tmp*2 + tmp + tmp/2;",
        "",
        "\t\tctx->deadlock_inject_interval = tmp;",
        "\t\tctx->deadlock_inject_countdown = tmp;",
        "\t\tctx->contending_lock = lock;",
        ""
      ]
    },
    {
      "file": "linux\\kernel\\locking\\mutex.c",
      "line": 854,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\ttmp = tmp*2 + tmp + tmp/2;",
        "",
        "\t\tctx->deadlock_inject_interval = tmp;",
        "\t\tctx->deadlock_inject_countdown = tmp;",
        "\t\tctx->contending_lock = lock;",
        "",
        "\t\tww_mutex_unlock(lock);"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\mutex.c",
      "line": 875,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tret =  __ww_mutex_lock(&lock->base, TASK_UNINTERRUPTIBLE,",
        "\t\t\t       0, _RET_IP_, ctx);",
        "\tif (!ret && ctx && ctx->acquired > 1)",
        "\t\treturn ww_mutex_deadlock_injection(lock, ctx);",
        "",
        "\treturn ret;",
        "}"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\mutex.c",
      "line": 891,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t      0, _RET_IP_, ctx);",
        "",
        "\tif (!ret && ctx && ctx->acquired > 1)",
        "\t\treturn ww_mutex_deadlock_injection(lock, ctx);",
        "",
        "\treturn ret;",
        "}"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\percpu-rwsem.c",
      "line": 44,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use after free",
      "context": [
        "",
        "\trcu_sync_dtor(&sem->rss);",
        "\tfree_percpu(sem->read_count);",
        "\tsem->read_count = NULL; /* catch use after free bugs */",
        "}",
        "EXPORT_SYMBOL_GPL(percpu_free_rwsem);",
        ""
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex_api.c",
      "line": 280,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * @task:\t\tthe task to prepare",
        " * @wake_q:\t\tthe wake_q to wake tasks after we release the wait_lock",
        " *",
        " * Starts the rt_mutex acquire; it enqueues the @waiter and does deadlock",
        " * detection. It does not wait, see rt_mutex_wait_proxy_lock() for that.",
        " *",
        " * NOTE: does _NOT_ remove the @waiter on failure; must either call"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex_api.c",
      "line": 305,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tif (try_to_take_rt_mutex(lock, task, NULL))",
        "\t\treturn 1;",
        "",
        "\t/* We enforce deadlock detection for futexes */",
        "\tret = task_blocks_on_rt_mutex(lock, waiter, task, NULL,",
        "\t\t\t\t      RT_MUTEX_FULL_CHAINWALK, wake_q);",
        ""
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex_api.c",
      "line": 328,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * @waiter:\t\tthe pre-initialized rt_mutex_waiter",
        " * @task:\t\tthe task to prepare",
        " *",
        " * Starts the rt_mutex acquire; it enqueues the @waiter and does deadlock",
        " * detection. It does not wait, see rt_mutex_wait_proxy_lock() for that.",
        " *",
        " * NOTE: unlike __rt_mutex_start_proxy_lock this _DOES_ remove the @waiter"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 579,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Deadlock",
      "context": [
        "}",
        "",
        "/*",
        " * Deadlock detection is conditional:",
        " *",
        " * If CONFIG_DEBUG_RT_MUTEXES=n, deadlock detection is only conducted",
        " * if the detect argument is == RT_MUTEX_FULL_CHAINWALK."
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 581,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * Deadlock detection is conditional:",
        " *",
        " * If CONFIG_DEBUG_RT_MUTEXES=n, deadlock detection is only conducted",
        " * if the detect argument is == RT_MUTEX_FULL_CHAINWALK.",
        " *",
        " * If CONFIG_DEBUG_RT_MUTEXES=y, deadlock detection is always"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 584,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * If CONFIG_DEBUG_RT_MUTEXES=n, deadlock detection is only conducted",
        " * if the detect argument is == RT_MUTEX_FULL_CHAINWALK.",
        " *",
        " * If CONFIG_DEBUG_RT_MUTEXES=y, deadlock detection is always",
        " * conducted independent of the detect argument.",
        " *",
        " * If the waiter argument is NULL this indicates the deboost path and"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 588,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * conducted independent of the detect argument.",
        " *",
        " * If the waiter argument is NULL this indicates the deboost path and",
        " * deadlock detection is disabled independent of the detect argument",
        " * and the config settings.",
        " */",
        "static __always_inline bool"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 592,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * and the config settings.",
        " */",
        "static __always_inline bool",
        "rt_mutex_cond_detect_deadlock(struct rt_mutex_waiter *waiter,",
        "\t\t\t      enum rtmutex_chainwalk chwalk)",
        "{",
        "\tif (IS_ENABLED(CONFIG_DEBUG_RT_MUTEXES))"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 606,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "}",
        "",
        "/*",
        " * Adjust the priority chain. Also used for deadlock detection.",
        " * Decreases task's usage by one - may thus free the task.",
        " *",
        " * @task:\tthe task owning the mutex (owner) for which a chain walk is"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 611,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * @task:\tthe task owning the mutex (owner) for which a chain walk is",
        " *\t\tprobably needed",
        " * @chwalk:\tdo we have to carry out deadlock detection?",
        " * @orig_lock:\tthe mutex (can be NULL if we are walking the chain to recheck",
        " *\t\tthings for a task that has just got its priority adjusted, and",
        " *\t\tis waiting on a mutex)"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 689,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tstruct rt_mutex_waiter *prerequeue_top_waiter;",
        "\tint ret = 0, depth = 0;",
        "\tstruct rt_mutex_base *lock;",
        "\tbool detect_deadlock;",
        "\tbool requeue = true;",
        "",
        "\tdetect_deadlock = rt_mutex_cond_detect_deadlock(orig_waiter, chwalk);"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 692,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tbool detect_deadlock;",
        "\tbool requeue = true;",
        "",
        "\tdetect_deadlock = rt_mutex_cond_detect_deadlock(orig_waiter, chwalk);",
        "",
        "\t/*",
        "\t * The (de)boosting is a step by step approach with a lot of"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 692,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tbool detect_deadlock;",
        "\tbool requeue = true;",
        "",
        "\tdetect_deadlock = rt_mutex_cond_detect_deadlock(orig_waiter, chwalk);",
        "",
        "\t/*",
        "\t * The (de)boosting is a step by step approach with a lot of"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 780,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t *",
        "\t * P3 should not return -EDEADLK because it gets trapped in the cycle",
        "\t * created by P1 and P2 (which will resolve -- and runs into",
        "\t * max_lock_depth above). Therefore disable detect_deadlock such that",
        "\t * the below termination condition can trigger once all relevant tasks",
        "\t * are boosted.",
        "\t *"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 784,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * the below termination condition can trigger once all relevant tasks",
        "\t * are boosted.",
        "\t *",
        "\t * Even when we start with ww_mutex we can disable deadlock detection,",
        "\t * since we would supress a ww_mutex induced deadlock at [6] anyway.",
        "\t * Supressing it here however is not sufficient since we might still",
        "\t * hit [6] due to adjustment driven iteration."
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 785,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * are boosted.",
        "\t *",
        "\t * Even when we start with ww_mutex we can disable deadlock detection,",
        "\t * since we would supress a ww_mutex induced deadlock at [6] anyway.",
        "\t * Supressing it here however is not sufficient since we might still",
        "\t * hit [6] due to adjustment driven iteration.",
        "\t *"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 789,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * Supressing it here however is not sufficient since we might still",
        "\t * hit [6] due to adjustment driven iteration.",
        "\t *",
        "\t * NOTE: if someone were to create a deadlock between 2 ww_classes we'd",
        "\t * utterly fail to report it; lockdep should.",
        "\t */",
        "\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && waiter->ww_ctx && detect_deadlock)"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 792,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * NOTE: if someone were to create a deadlock between 2 ww_classes we'd",
        "\t * utterly fail to report it; lockdep should.",
        "\t */",
        "\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && waiter->ww_ctx && detect_deadlock)",
        "\t\tdetect_deadlock = false;",
        "",
        "\t/*"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 793,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * utterly fail to report it; lockdep should.",
        "\t */",
        "\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && waiter->ww_ctx && detect_deadlock)",
        "\t\tdetect_deadlock = false;",
        "",
        "\t/*",
        "\t * Drop out, when the task has no waiters. Note,"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 804,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tif (!task_has_pi_waiters(task))",
        "\t\t\tgoto out_unlock_pi;",
        "\t\t/*",
        "\t\t * If deadlock detection is off, we stop here if we",
        "\t\t * are not the top pi waiter of the task. If deadlock",
        "\t\t * detection is enabled we continue, but stop the",
        "\t\t * requeueing in the chain walk."
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 805,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\tgoto out_unlock_pi;",
        "\t\t/*",
        "\t\t * If deadlock detection is off, we stop here if we",
        "\t\t * are not the top pi waiter of the task. If deadlock",
        "\t\t * detection is enabled we continue, but stop the",
        "\t\t * requeueing in the chain walk.",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 810,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * requeueing in the chain walk.",
        "\t\t */",
        "\t\tif (top_waiter != task_top_pi_waiter(task)) {",
        "\t\t\tif (!detect_deadlock)",
        "\t\t\t\tgoto out_unlock_pi;",
        "\t\t\telse",
        "\t\t\t\trequeue = false;"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 820,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * If the waiter priority is the same as the task priority",
        "\t * then there is no further priority adjustment necessary.  If",
        "\t * deadlock detection is off, we stop the chain walk. If its",
        "\t * enabled we continue, but stop the requeueing in the chain",
        "\t * walk.",
        "\t */"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 825,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * walk.",
        "\t */",
        "\tif (rt_waiter_node_equal(&waiter->tree, task_to_waiter_node(task))) {",
        "\t\tif (!detect_deadlock)",
        "\t\t\tgoto out_unlock_pi;",
        "\t\telse",
        "\t\t\trequeue = false;"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 855,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Deadlock",
      "context": [
        "\t * [6] check_exit_conditions_2() protected by task->pi_lock and",
        "\t * lock->wait_lock.",
        "\t *",
        "\t * Deadlock detection. If the lock is the same as the original",
        "\t * lock which caused us to walk the lock chain or if the",
        "\t * current lock is owned by the task which initiated the chain",
        "\t * walk, we detected a deadlock."
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 858,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * Deadlock detection. If the lock is the same as the original",
        "\t * lock which caused us to walk the lock chain or if the",
        "\t * current lock is owned by the task which initiated the chain",
        "\t * walk, we detected a deadlock.",
        "\t */",
        "\tif (lock == orig_lock || rt_mutex_owner(lock) == top_task) {",
        "\t\tret = -EDEADLK;"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 864,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tret = -EDEADLK;",
        "",
        "\t\t/*",
        "\t\t * When the deadlock is due to ww_mutex; also see above. Don't",
        "\t\t * report the deadlock and instead let the ww_mutex wound/die",
        "\t\t * logic pick which of the contending threads gets -EDEADLK.",
        "\t\t *"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 865,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t\t/*",
        "\t\t * When the deadlock is due to ww_mutex; also see above. Don't",
        "\t\t * report the deadlock and instead let the ww_mutex wound/die",
        "\t\t * logic pick which of the contending threads gets -EDEADLK.",
        "\t\t *",
        "\t\t * NOTE: assumes the cycle only contains a single ww_class; any"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 880,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t}",
        "",
        "\t/*",
        "\t * If we just follow the lock chain for deadlock detection, no",
        "\t * need to do all the requeue operations. To avoid a truckload",
        "\t * of conditionals around the various places below, just do the",
        "\t * minimum chain walk checks."
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 906,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\traw_spin_lock(&task->pi_lock);",
        "",
        "\t\t/*",
        "\t\t * No requeue [11] here. We just do deadlock detection.",
        "\t\t *",
        "\t\t * [12] Store whether owner is blocked",
        "\t\t * itself. Decision is made after dropping the locks"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 1061,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * If the current waiter is not the top waiter on the lock,",
        "\t * then we can stop the chain walk here if we are not in full",
        "\t * deadlock detection mode.",
        "\t */",
        "\tif (!detect_deadlock && waiter != top_waiter)",
        "\t\tgoto out_put_task;"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 1063,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * then we can stop the chain walk here if we are not in full",
        "\t * deadlock detection mode.",
        "\t */",
        "\tif (!detect_deadlock && waiter != top_waiter)",
        "\t\tgoto out_put_task;",
        "",
        "\tgoto again;"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 1218,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tlockdep_assert_held(&lock->wait_lock);",
        "",
        "\t/*",
        "\t * Early deadlock detection. We really don't want the task to",
        "\t * enqueue on itself just to untangle the mess later. It's not",
        "\t * only an optimization. We drop the locks, so another waiter",
        "\t * can come in before the chain walk detects the deadlock. So"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 1221,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * Early deadlock detection. We really don't want the task to",
        "\t * enqueue on itself just to untangle the mess later. It's not",
        "\t * only an optimization. We drop the locks, so another waiter",
        "\t * can come in before the chain walk detects the deadlock. So",
        "\t * the other will detect the deadlock and return -EDEADLOCK,",
        "\t * which is wrong, as the other waiter is not in a deadlock",
        "\t * situation."
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 1222,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * enqueue on itself just to untangle the mess later. It's not",
        "\t * only an optimization. We drop the locks, so another waiter",
        "\t * can come in before the chain walk detects the deadlock. So",
        "\t * the other will detect the deadlock and return -EDEADLOCK,",
        "\t * which is wrong, as the other waiter is not in a deadlock",
        "\t * situation.",
        "\t *"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 1222,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t * enqueue on itself just to untangle the mess later. It's not",
        "\t * only an optimization. We drop the locks, so another waiter",
        "\t * can come in before the chain walk detects the deadlock. So",
        "\t * the other will detect the deadlock and return -EDEADLOCK,",
        "\t * which is wrong, as the other waiter is not in a deadlock",
        "\t * situation.",
        "\t *"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 1223,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * only an optimization. We drop the locks, so another waiter",
        "\t * can come in before the chain walk detects the deadlock. So",
        "\t * the other will detect the deadlock and return -EDEADLOCK,",
        "\t * which is wrong, as the other waiter is not in a deadlock",
        "\t * situation.",
        "\t *",
        "\t * Except for ww_mutex, in that case the chain walk must already deal"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 1273,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\trt_mutex_adjust_prio(lock, owner);",
        "\t\tif (owner->pi_blocked_on)",
        "\t\t\tchain_walk = 1;",
        "\t} else if (rt_mutex_cond_detect_deadlock(waiter, chwalk)) {",
        "\t\tchain_walk = 1;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 1282,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\traw_spin_unlock(&owner->pi_lock);",
        "\t/*",
        "\t * Even if full deadlock detection is on, if the owner is not",
        "\t * blocked itself, we can avoid finding this out in the chain",
        "\t * walk.",
        "\t */"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 1658,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\treturn ret;",
        "}",
        "",
        "static void __sched rt_mutex_handle_deadlock(int res, int detect_deadlock,",
        "\t\t\t\t\t     struct rt_mutex_base *lock,",
        "\t\t\t\t\t     struct rt_mutex_waiter *w)",
        "{"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 1658,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\treturn ret;",
        "}",
        "",
        "static void __sched rt_mutex_handle_deadlock(int res, int detect_deadlock,",
        "\t\t\t\t\t     struct rt_mutex_base *lock,",
        "\t\t\t\t\t     struct rt_mutex_waiter *w)",
        "{"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 1663,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t\t\t\t\t     struct rt_mutex_waiter *w)",
        "{",
        "\t/*",
        "\t * If the result is not -EDEADLOCK or the caller requested",
        "\t * deadlock detection, nothing to do here.",
        "\t */",
        "\tif (res != -EDEADLOCK || detect_deadlock)"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 1664,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "{",
        "\t/*",
        "\t * If the result is not -EDEADLOCK or the caller requested",
        "\t * deadlock detection, nothing to do here.",
        "\t */",
        "\tif (res != -EDEADLOCK || detect_deadlock)",
        "\t\treturn;"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 1666,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t * If the result is not -EDEADLOCK or the caller requested",
        "\t * deadlock detection, nothing to do here.",
        "\t */",
        "\tif (res != -EDEADLOCK || detect_deadlock)",
        "\t\treturn;",
        "",
        "\tif (build_ww_mutex() && w->ww_ctx)"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 1666,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * If the result is not -EDEADLOCK or the caller requested",
        "\t * deadlock detection, nothing to do here.",
        "\t */",
        "\tif (res != -EDEADLOCK || detect_deadlock)",
        "\t\treturn;",
        "",
        "\tif (build_ww_mutex() && w->ww_ctx)"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 1674,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\traw_spin_unlock_irq(&lock->wait_lock);",
        "",
        "\tWARN(1, \"rtmutex deadlock detected\\n\");",
        "",
        "\twhile (1) {",
        "\t\tset_current_state(TASK_INTERRUPTIBLE);"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 1734,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t} else {",
        "\t\t__set_current_state(TASK_RUNNING);",
        "\t\tremove_waiter(lock, waiter);",
        "\t\trt_mutex_handle_deadlock(ret, chwalk, lock, waiter);",
        "\t\tlockevent_inc(rtmutex_deadlock);",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rtmutex.c",
      "line": 1735,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t__set_current_state(TASK_RUNNING);",
        "\t\tremove_waiter(lock, waiter);",
        "\t\trt_mutex_handle_deadlock(ret, chwalk, lock, waiter);",
        "\t\tlockevent_inc(rtmutex_deadlock);",
        "\t}",
        "",
        "\t/*"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\rwsem.c",
      "line": 597,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "/*",
        " * This function must be called with the sem->wait_lock held to prevent",
        " * race conditions between checking the rwsem wait list and setting the",
        " * sem->count accordingly.",
        " *",
        " * Implies rwsem_del_waiter() on success."
      ]
    },
    {
      "file": "linux\\kernel\\locking\\test-ww_mutex.c",
      "line": 22,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "#ifdef CONFIG_DEBUG_WW_MUTEX_SLOWPATH",
        "#define ww_acquire_init_noinject(a, b) do { \\",
        "\t\tww_acquire_init((a), (b)); \\",
        "\t\t(a)->deadlock_inject_countdown = ~0U; \\",
        "\t} while (0)",
        "#else",
        "#define ww_acquire_init_noinject(a, b) ww_acquire_init((a), (b))"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\test-ww_mutex.c",
      "line": 163,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\tret = ww_mutex_lock(&mutex, &ctx);",
        "\tif (ret != -EALREADY) {",
        "\t\tpr_err(\"%s: missed deadlock for recursing, ret=%d from %s\\n\",",
        "\t\t       __func__, ret, from);",
        "\t\tif (!ret)",
        "\t\t\tww_mutex_unlock(&mutex);"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\test-ww_mutex.c",
      "line": 265,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tret = 0;",
        "\tif (resolve) {",
        "\t\tif (err || abba.result) {",
        "\t\t\tpr_err(\"%s: failed to resolve ABBA deadlock, A err=%d, B err=%d\\n\",",
        "\t\t\t       __func__, err, abba.result);",
        "\t\t\tret = -EINVAL;",
        "\t\t}"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\test-ww_mutex.c",
      "line": 271,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t}",
        "\t} else {",
        "\t\tif (err != -EDEADLK && abba.result != -EDEADLK) {",
        "\t\t\tpr_err(\"%s: missed ABBA deadlock, A err=%d, B err=%d\\n\",",
        "\t\t\t       __func__, err, abba.result);",
        "\t\t\tret = -EINVAL;",
        "\t\t}"
      ]
    },
    {
      "file": "linux\\kernel\\locking\\test-ww_mutex.c",
      "line": 358,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tif (!cycle->result)",
        "\t\t\tcontinue;",
        "",
        "\t\tpr_err(\"cyclic deadlock not resolved, ret[%d/%d] = %d\\n\",",
        "\t\t       n, nthreads, cycle->result);",
        "\t\tret = -EINVAL;",
        "\t\tbreak;"
      ]
    },
    {
      "file": "linux\\kernel\\module\\kallsyms.c",
      "line": 319,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "/*",
        " * For kallsyms to ask for address resolution.  NULL means not found.  Careful",
        " * not to lock to avoid deadlock on oopses, RCU is enough.",
        " */",
        "int module_address_lookup(unsigned long addr,",
        "\t\t\t  unsigned long *size,"
      ]
    },
    {
      "file": "linux\\kernel\\module\\kmod.c",
      "line": 141,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * We don't allow synchronous module loading from async.  Module",
        "\t * init may invoke async_synchronize_full() which will end up",
        "\t * waiting for this task which already is waiting for the module",
        "\t * loading to complete, leading to a deadlock.",
        "\t */",
        "\tWARN_ON_ONCE(wait && current_is_async());",
        ""
      ]
    },
    {
      "file": "linux\\kernel\\module\\main.c",
      "line": 3035,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * We need to finish all async code before the module init sequence",
        "\t * is done. This has potential to deadlock if synchronous module",
        "\t * loading is requested from async (which is not allowed!).",
        "\t *",
        "\t * See commit 0fdff3ec6d87 (\"async, kmod: warn on synchronous"
      ]
    },
    {
      "file": "linux\\kernel\\module\\stats.c",
      "line": 60,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * failures.",
        " *",
        " * All counters are designed to be incremental. Atomic counters are used so to",
        " * remain simple and avoid delays and deadlocks.",
        " */",
        "",
        "/**"
      ]
    },
    {
      "file": "linux\\kernel\\power\\autosleep.c",
      "line": 19,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "static struct workqueue_struct *autosleep_wq;",
        "/*",
        " * Note: it is only safe to mutex_lock(&autosleep_lock) if a wakeup_source",
        " * is active, otherwise a deadlock with try_to_suspend() is possible.",
        " * Alternatively mutex_lock_interruptible() can be used.  This will then fail",
        " * if an auto_sleep cycle tries to freeze processes.",
        " */"
      ]
    },
    {
      "file": "linux\\kernel\\power\\main.c",
      "line": 757,
      "pattern": "long.*functions",
      "rule": "code_quality",
      "severity": "low",
      "match": "long with the functions",
      "context": [
        "",
        "#ifdef CONFIG_PM_SLEEP",
        "/*",
        " * The 'wakeup_count' attribute, along with the functions defined in",
        " * drivers/base/power/wakeup.c, provides a means by which wakeup events can be",
        " * handled in a non-racy way.",
        " *"
      ]
    },
    {
      "file": "linux\\kernel\\power\\user.c",
      "line": 341,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * SNAPSHOT_FREE.  In that case, if kernel threads were not",
        "\t\t * thawed, the preallocation of memory carried out by",
        "\t\t * hibernation_snapshot() might run into problems (i.e. it",
        "\t\t * might fail or even deadlock).",
        "\t\t */",
        "\t\tthaw_kernel_threads();",
        "\t\tbreak;"
      ]
    },
    {
      "file": "linux\\kernel\\printk\\nbcon.c",
      "line": 1537,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * Atomic flushing does not use console driver synchronization (i.e.",
        "\t * it does not hold the port lock for uart consoles). Therefore IRQs",
        "\t * must be disabled to avoid being interrupted and then calling into",
        "\t * a driver that will deadlock trying to acquire console ownership.",
        "\t */",
        "\tlocal_irq_save(flags);",
        ""
      ]
    },
    {
      "file": "linux\\kernel\\printk\\nbcon.c",
      "line": 1550,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * responsible for completing.",
        "\t *",
        "\t * Do not wait for records not yet finalized (-ENOENT) to avoid a",
        "\t * possible deadlock. They will either get flushed by the writer or",
        "\t * eventually skipped on panic CPU.",
        "\t */",
        "\tif (err)"
      ]
    },
    {
      "file": "linux\\kernel\\printk\\printk.c",
      "line": 323,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * Here and in __up_console_sem() we need to be in safe mode,",
        "\t * because spindump/WARN/etc from under console ->lock will",
        "\t * deadlock in printk()->down_trylock_console_sem() otherwise.",
        "\t */",
        "\tprintk_safe_enter_irqsave(flags);",
        "\tlock_failed = down_trylock(&console_sem);"
      ]
    },
    {
      "file": "linux\\kernel\\printk\\printk.c",
      "line": 1911,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * Non-panic CPUs abandon the flush anyway.",
        "\t *",
        "\t * Just keep the lockdep annotation. The panic-CPU should avoid",
        "\t * taking console_owner_lock because it might cause a deadlock.",
        "\t * This looks like the easiest way how to prevent false lockdep",
        "\t * reports without handling races a lockless way.",
        "\t */"
      ]
    },
    {
      "file": "linux\\kernel\\printk\\printk.c",
      "line": 3388,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\treturn;",
        "",
        "\t\t/*",
        "\t\t * Attempting to trylock the console lock can deadlock",
        "\t\t * if another CPU was stopped while modifying the",
        "\t\t * semaphore. \"Hope and pray\" that this is not the",
        "\t\t * current situation."
      ]
    },
    {
      "file": "linux\\kernel\\printk\\printk_safe.c",
      "line": 3,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "// SPDX-License-Identifier: GPL-2.0-or-later",
        "/*",
        " * printk_safe.c - Safe printk for printk-deadlock-prone contexts",
        " */",
        "",
        "#include <linux/preempt.h>"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcuscale.c",
      "line": 709,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double, false, \"Do we run a kfree",
      "context": [
        "torture_param(int, kfree_nthreads, -1, \"Number of threads running loops of kfree_rcu().\");",
        "torture_param(int, kfree_alloc_num, 8000, \"Number of allocations and frees done in an iteration.\");",
        "torture_param(int, kfree_loops, 10, \"Number of loops doing kfree_alloc_num allocations and frees.\");",
        "torture_param(bool, kfree_rcu_test_double, false, \"Do we run a kfree_rcu() double-argument scale test?\");",
        "torture_param(bool, kfree_rcu_test_single, false, \"Do we run a kfree_rcu() single-argument scale test?\");",
        "",
        "static struct task_struct **kfree_reader_tasks;"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcuscale.c",
      "line": 865,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double=%d kfree",
      "context": [
        "\tunsigned long orig_jif;",
        "",
        "\tpr_alert(\"%s\" SCALE_FLAG",
        "\t\t \"--- kfree_rcu_test: kfree_mult=%d kfree_by_call_rcu=%d kfree_nthreads=%d kfree_alloc_num=%d kfree_loops=%d kfree_rcu_test_double=%d kfree_rcu_test_single=%d\\n\",",
        "\t\t scale_type, kfree_mult, kfree_by_call_rcu, kfree_nthreads, kfree_alloc_num, kfree_loops, kfree_rcu_test_double, kfree_rcu_test_single);",
        "",
        "\t// Also, do a quick self-test to ensure laziness is as much as"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcuscale.c",
      "line": 866,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double, kfree",
      "context": [
        "",
        "\tpr_alert(\"%s\" SCALE_FLAG",
        "\t\t \"--- kfree_rcu_test: kfree_mult=%d kfree_by_call_rcu=%d kfree_nthreads=%d kfree_alloc_num=%d kfree_loops=%d kfree_rcu_test_double=%d kfree_rcu_test_single=%d\\n\",",
        "\t\t scale_type, kfree_mult, kfree_by_call_rcu, kfree_nthreads, kfree_alloc_num, kfree_loops, kfree_rcu_test_double, kfree_rcu_test_single);",
        "",
        "\t// Also, do a quick self-test to ensure laziness is as much as",
        "\t// expected."
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcutorture.c",
      "line": 3904,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double-free",
      "context": [
        "}",
        "",
        "/*",
        " * Verify that double-free causes debug-objects to complain, but only",
        " * if CONFIG_DEBUG_OBJECTS_RCU_HEAD=y.  Otherwise, say that the test",
        " * cannot be carried out.",
        " */"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcutorture.c",
      "line": 1284,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "/*",
        " * RCU torture force-quiescent-state kthread.  Repeatedly induces",
        " * bursts of calls to force_quiescent_state(), increasing the probability",
        " * of occurrence of some important types of race conditions.",
        " */",
        "static int",
        "rcu_torture_fqs(void *arg)"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcutorture.c",
      "line": 3892,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "static void rcu_torture_err_cb(struct rcu_head *rhp)",
        "{",
        "\t/*",
        "\t * This -might- happen due to race conditions, but is unlikely.",
        "\t * The scenario that leads to this happening is that the",
        "\t * first of the pair of duplicate callbacks is queued,",
        "\t * someone else starts a grace period that includes that"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcutorture.c",
      "line": 146,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "torture_param(int, test_boost_interval, 7, \"Interval between boost tests, seconds.\");",
        "torture_param(int, test_nmis, 0, \"End-test NMI tests, 0 to disable.\");",
        "torture_param(bool, test_no_idle_hz, true, \"Test support for tickless idle CPUs\");",
        "torture_param(int, test_srcu_lockdep, 0, \"Test specified SRCU deadlock scenario.\");",
        "torture_param(int, verbose, 1, \"Enable verbose debugging printk()s\");",
        "",
        "static char *torture_type = \"rcu\";"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcutorture.c",
      "line": 2664,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\trcu_torture_enable_rt_throttle();",
        "\tmutex_unlock(&boost_mutex);",
        "",
        "\t/* This must be outside of the mutex, otherwise deadlock! */",
        "\ttorture_stop_kthread(rcu_torture_boost, t);",
        "\treturn 0;",
        "}"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcutorture.c",
      "line": 3991,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "DEFINE_STATIC_SRCU(srcu9);",
        "",
        "static int srcu_lockdep_next(const char *f, const char *fl, const char *fs, const char *fu, int i,",
        "\t\t\t     int cyclelen, int deadlock)",
        "{",
        "\tint j = i + 1;",
        ""
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcutorture.c",
      "line": 3996,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tint j = i + 1;",
        "",
        "\tif (j >= cyclelen)",
        "\t\tj = deadlock ? 0 : -1;",
        "\tif (j >= 0)",
        "\t\tpr_info(\"%s: %s(%d), %s(%d), %s(%d)\\n\", f, fl, i, fs, j, fu, i);",
        "\telse"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcutorture.c",
      "line": 4004,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\treturn j;",
        "}",
        "",
        "// Test lockdep on SRCU-based deadlock scenarios.",
        "static void rcu_torture_init_srcu_lockdep(void)",
        "{",
        "\tint cyclelen;"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcutorture.c",
      "line": 4008,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "static void rcu_torture_init_srcu_lockdep(void)",
        "{",
        "\tint cyclelen;",
        "\tint deadlock;",
        "\tbool err = false;",
        "\tint i;",
        "\tint j;"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcutorture.c",
      "line": 4024,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tif (!test_srcu_lockdep)",
        "\t\treturn;",
        "",
        "\tdeadlock = test_srcu_lockdep / 1000;",
        "\ttesttype = (test_srcu_lockdep / 10) % 100;",
        "\tcyclelen = test_srcu_lockdep % 10;",
        "\tWARN_ON_ONCE(ARRAY_SIZE(muts) != ARRAY_SIZE(srcus));"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcutorture.c",
      "line": 4028,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\ttesttype = (test_srcu_lockdep / 10) % 100;",
        "\tcyclelen = test_srcu_lockdep % 10;",
        "\tWARN_ON_ONCE(ARRAY_SIZE(muts) != ARRAY_SIZE(srcus));",
        "\tif (WARN_ONCE(deadlock != !!deadlock,",
        "\t\t      \"%s: test_srcu_lockdep=%d and deadlock digit %d must be zero or one.\\n\",",
        "\t\t      __func__, test_srcu_lockdep, deadlock))",
        "\t\terr = true;"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcutorture.c",
      "line": 4028,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\ttesttype = (test_srcu_lockdep / 10) % 100;",
        "\tcyclelen = test_srcu_lockdep % 10;",
        "\tWARN_ON_ONCE(ARRAY_SIZE(muts) != ARRAY_SIZE(srcus));",
        "\tif (WARN_ONCE(deadlock != !!deadlock,",
        "\t\t      \"%s: test_srcu_lockdep=%d and deadlock digit %d must be zero or one.\\n\",",
        "\t\t      __func__, test_srcu_lockdep, deadlock))",
        "\t\terr = true;"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcutorture.c",
      "line": 4029,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tcyclelen = test_srcu_lockdep % 10;",
        "\tWARN_ON_ONCE(ARRAY_SIZE(muts) != ARRAY_SIZE(srcus));",
        "\tif (WARN_ONCE(deadlock != !!deadlock,",
        "\t\t      \"%s: test_srcu_lockdep=%d and deadlock digit %d must be zero or one.\\n\",",
        "\t\t      __func__, test_srcu_lockdep, deadlock))",
        "\t\terr = true;",
        "\tif (WARN_ONCE(cyclelen <= 0,"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcutorture.c",
      "line": 4030,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tWARN_ON_ONCE(ARRAY_SIZE(muts) != ARRAY_SIZE(srcus));",
        "\tif (WARN_ONCE(deadlock != !!deadlock,",
        "\t\t      \"%s: test_srcu_lockdep=%d and deadlock digit %d must be zero or one.\\n\",",
        "\t\t      __func__, test_srcu_lockdep, deadlock))",
        "\t\terr = true;",
        "\tif (WARN_ONCE(cyclelen <= 0,",
        "\t\t      \"%s: test_srcu_lockdep=%d and cycle-length digit %d must be greater than zero.\\n\","
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcutorture.c",
      "line": 4040,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tgoto err_out;",
        "",
        "\tif (testtype == 0) {",
        "\t\tpr_info(\"%s: test_srcu_lockdep = %05d: SRCU %d-way %sdeadlock.\\n\",",
        "\t\t\t__func__, test_srcu_lockdep, cyclelen, deadlock ? \"\" : \"non-\");",
        "\t\tif (deadlock && cyclelen == 1)",
        "\t\t\tpr_info(\"%s: Expect hang.\\n\", __func__);"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcutorture.c",
      "line": 4041,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\tif (testtype == 0) {",
        "\t\tpr_info(\"%s: test_srcu_lockdep = %05d: SRCU %d-way %sdeadlock.\\n\",",
        "\t\t\t__func__, test_srcu_lockdep, cyclelen, deadlock ? \"\" : \"non-\");",
        "\t\tif (deadlock && cyclelen == 1)",
        "\t\t\tpr_info(\"%s: Expect hang.\\n\", __func__);",
        "\t\tfor (i = 0; i < cyclelen; i++) {"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcutorture.c",
      "line": 4042,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tif (testtype == 0) {",
        "\t\tpr_info(\"%s: test_srcu_lockdep = %05d: SRCU %d-way %sdeadlock.\\n\",",
        "\t\t\t__func__, test_srcu_lockdep, cyclelen, deadlock ? \"\" : \"non-\");",
        "\t\tif (deadlock && cyclelen == 1)",
        "\t\t\tpr_info(\"%s: Expect hang.\\n\", __func__);",
        "\t\tfor (i = 0; i < cyclelen; i++) {",
        "\t\t\tj = srcu_lockdep_next(__func__, \"srcu_read_lock\", \"synchronize_srcu\","
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcutorture.c",
      "line": 4046,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\tpr_info(\"%s: Expect hang.\\n\", __func__);",
        "\t\tfor (i = 0; i < cyclelen; i++) {",
        "\t\t\tj = srcu_lockdep_next(__func__, \"srcu_read_lock\", \"synchronize_srcu\",",
        "\t\t\t\t\t      \"srcu_read_unlock\", i, cyclelen, deadlock);",
        "\t\t\tidx = srcu_read_lock(srcus[i]);",
        "\t\t\tif (j >= 0)",
        "\t\t\t\tsynchronize_srcu(srcus[j]);"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcutorture.c",
      "line": 4056,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t}",
        "",
        "\tif (testtype == 1) {",
        "\t\tpr_info(\"%s: test_srcu_lockdep = %05d: SRCU/mutex %d-way %sdeadlock.\\n\",",
        "\t\t\t__func__, test_srcu_lockdep, cyclelen, deadlock ? \"\" : \"non-\");",
        "\t\tfor (i = 0; i < cyclelen; i++) {",
        "\t\t\tpr_info(\"%s: srcu_read_lock(%d), mutex_lock(%d), mutex_unlock(%d), srcu_read_unlock(%d)\\n\","
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcutorture.c",
      "line": 4057,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\tif (testtype == 1) {",
        "\t\tpr_info(\"%s: test_srcu_lockdep = %05d: SRCU/mutex %d-way %sdeadlock.\\n\",",
        "\t\t\t__func__, test_srcu_lockdep, cyclelen, deadlock ? \"\" : \"non-\");",
        "\t\tfor (i = 0; i < cyclelen; i++) {",
        "\t\t\tpr_info(\"%s: srcu_read_lock(%d), mutex_lock(%d), mutex_unlock(%d), srcu_read_unlock(%d)\\n\",",
        "\t\t\t\t__func__, i, i, i, i);"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcutorture.c",
      "line": 4067,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\tsrcu_read_unlock(srcus[i], idx);",
        "",
        "\t\t\tj = srcu_lockdep_next(__func__, \"mutex_lock\", \"synchronize_srcu\",",
        "\t\t\t\t\t      \"mutex_unlock\", i, cyclelen, deadlock);",
        "\t\t\tmutex_lock(muts[i]);",
        "\t\t\tif (j >= 0)",
        "\t\t\t\tsynchronize_srcu(srcus[j]);"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcutorture.c",
      "line": 4077,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t}",
        "",
        "\tif (testtype == 2) {",
        "\t\tpr_info(\"%s: test_srcu_lockdep = %05d: SRCU/rwsem %d-way %sdeadlock.\\n\",",
        "\t\t\t__func__, test_srcu_lockdep, cyclelen, deadlock ? \"\" : \"non-\");",
        "\t\tfor (i = 0; i < cyclelen; i++) {",
        "\t\t\tpr_info(\"%s: srcu_read_lock(%d), down_read(%d), up_read(%d), srcu_read_unlock(%d)\\n\","
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcutorture.c",
      "line": 4078,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\tif (testtype == 2) {",
        "\t\tpr_info(\"%s: test_srcu_lockdep = %05d: SRCU/rwsem %d-way %sdeadlock.\\n\",",
        "\t\t\t__func__, test_srcu_lockdep, cyclelen, deadlock ? \"\" : \"non-\");",
        "\t\tfor (i = 0; i < cyclelen; i++) {",
        "\t\t\tpr_info(\"%s: srcu_read_lock(%d), down_read(%d), up_read(%d), srcu_read_unlock(%d)\\n\",",
        "\t\t\t\t__func__, i, i, i, i);"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcutorture.c",
      "line": 4088,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\tsrcu_read_unlock(srcus[i], idx);",
        "",
        "\t\t\tj = srcu_lockdep_next(__func__, \"down_write\", \"synchronize_srcu\",",
        "\t\t\t\t\t      \"up_write\", i, cyclelen, deadlock);",
        "\t\t\tdown_write(rwsems[i]);",
        "\t\t\tif (j >= 0)",
        "\t\t\t\tsynchronize_srcu(srcus[j]);"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcutorture.c",
      "line": 4099,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "#ifdef CONFIG_TASKS_TRACE_RCU",
        "\tif (testtype == 3) {",
        "\t\tpr_info(\"%s: test_srcu_lockdep = %05d: SRCU and Tasks Trace RCU %d-way %sdeadlock.\\n\",",
        "\t\t\t__func__, test_srcu_lockdep, cyclelen, deadlock ? \"\" : \"non-\");",
        "\t\tif (deadlock && cyclelen == 1)",
        "\t\t\tpr_info(\"%s: Expect hang.\\n\", __func__);"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcutorture.c",
      "line": 4100,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "#ifdef CONFIG_TASKS_TRACE_RCU",
        "\tif (testtype == 3) {",
        "\t\tpr_info(\"%s: test_srcu_lockdep = %05d: SRCU and Tasks Trace RCU %d-way %sdeadlock.\\n\",",
        "\t\t\t__func__, test_srcu_lockdep, cyclelen, deadlock ? \"\" : \"non-\");",
        "\t\tif (deadlock && cyclelen == 1)",
        "\t\t\tpr_info(\"%s: Expect hang.\\n\", __func__);",
        "\t\tfor (i = 0; i < cyclelen; i++) {"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcutorture.c",
      "line": 4101,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tif (testtype == 3) {",
        "\t\tpr_info(\"%s: test_srcu_lockdep = %05d: SRCU and Tasks Trace RCU %d-way %sdeadlock.\\n\",",
        "\t\t\t__func__, test_srcu_lockdep, cyclelen, deadlock ? \"\" : \"non-\");",
        "\t\tif (deadlock && cyclelen == 1)",
        "\t\t\tpr_info(\"%s: Expect hang.\\n\", __func__);",
        "\t\tfor (i = 0; i < cyclelen; i++) {",
        "\t\t\tchar *fl = i == 0 ? \"rcu_read_lock_trace\" : \"srcu_read_lock\";"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcutorture.c",
      "line": 4109,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t\t\t\t     : \"synchronize_srcu\";",
        "\t\t\tchar *fu = i == 0 ? \"rcu_read_unlock_trace\" : \"srcu_read_unlock\";",
        "",
        "\t\t\tj = srcu_lockdep_next(__func__, fl, fs, fu, i, cyclelen, deadlock);",
        "\t\t\tif (i == 0)",
        "\t\t\t\trcu_read_lock_trace();",
        "\t\t\telse"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\rcutorture.c",
      "line": 4132,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Deadlock",
      "context": [
        "err_out:",
        "\tpr_info(\"%s: test_srcu_lockdep = %05d does nothing.\\n\", __func__, test_srcu_lockdep);",
        "\tpr_info(\"%s: test_srcu_lockdep = DNNL.\\n\", __func__);",
        "\tpr_info(\"%s: D: Deadlock if nonzero.\\n\", __func__);",
        "\tpr_info(\"%s: NN: Test number, 0=SRCU, 1=SRCU/mutex, 2=SRCU/rwsem, 3=SRCU/Tasks Trace RCU.\\n\", __func__);",
        "\tpr_info(\"%s: L: Cycle length.\\n\", __func__);",
        "\tif (!IS_ENABLED(CONFIG_TASKS_TRACE_RCU))"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\srcutree.c",
      "line": 1462,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * Wait for an SRCU grace period to elapse, but be more aggressive about",
        " * spinning rather than blocking when waiting.",
        " *",
        " * Note that synchronize_srcu_expedited() has the same deadlock and",
        " * memory-ordering properties as does synchronize_srcu().",
        " */",
        "void synchronize_srcu_expedited(struct srcu_struct *ssp)"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\srcutree.c",
      "line": 1484,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * Can block; must be called from process context.",
        " *",
        " * Note that it is illegal to call synchronize_srcu() from the corresponding",
        " * SRCU read-side critical section; doing so will result in deadlock.",
        " * However, it is perfectly legal to call synchronize_srcu() on one",
        " * srcu_struct from some other srcu_struct's read-side critical section,",
        " * as long as the resulting graph of srcu_structs is acyclic."
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\srcutree.c",
      "line": 333,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Double-checked lock",
      "context": [
        "{",
        "\tunsigned long flags;",
        "",
        "\t/* Double-checked locking on ->srcu_size-state. */",
        "\tif (smp_load_acquire(&ssp->srcu_sup->srcu_size_state) != SRCU_SIZE_SMALL)",
        "\t\treturn;",
        "\tspin_lock_irqsave_rcu_node(ssp->srcu_sup, flags);"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\tiny.c",
      "line": 162,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "doublefree",
      "context": [
        " */",
        "void call_rcu(struct rcu_head *head, rcu_callback_t func)",
        "{",
        "\tstatic atomic_t doublefrees;",
        "\tunsigned long flags;",
        "",
        "\tif (debug_rcu_head_queue(head)) {"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\tiny.c",
      "line": 166,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "doublefree",
      "context": [
        "\tunsigned long flags;",
        "",
        "\tif (debug_rcu_head_queue(head)) {",
        "\t\tif (atomic_inc_return(&doublefrees) < 4) {",
        "\t\t\tpr_err(\"%s(): Double-freed CB %p->%pS()!!!  \", __func__, head, head->func);",
        "\t\t\tmem_dump_obj(head);",
        "\t\t}"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\tiny.c",
      "line": 167,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "Double-free",
      "context": [
        "",
        "\tif (debug_rcu_head_queue(head)) {",
        "\t\tif (atomic_inc_return(&doublefrees) < 4) {",
        "\t\t\tpr_err(\"%s(): Double-freed CB %p->%pS()!!!  \", __func__, head, head->func);",
        "\t\t\tmem_dump_obj(head);",
        "\t\t}",
        "\t\treturn;"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\tree.c",
      "line": 3067,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "doublefree",
      "context": [
        "static void",
        "__call_rcu_common(struct rcu_head *head, rcu_callback_t func, bool lazy_in)",
        "{",
        "\tstatic atomic_t doublefrees;",
        "\tunsigned long flags;",
        "\tbool lazy;",
        "\tstruct rcu_data *rdp;"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\tree.c",
      "line": 3085,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "doublefree",
      "context": [
        "\t\t * Use rcu:rcu_callback trace event to find the previous",
        "\t\t * time callback was passed to call_rcu().",
        "\t\t */",
        "\t\tif (atomic_inc_return(&doublefrees) < 4) {",
        "\t\t\tpr_err(\"%s(): Double-freed CB %p->%pS()!!!  \", __func__, head, head->func);",
        "\t\t\tmem_dump_obj(head);",
        "\t\t}"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\tree.c",
      "line": 3086,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "Double-free",
      "context": [
        "\t\t * time callback was passed to call_rcu().",
        "\t\t */",
        "\t\tif (atomic_inc_return(&doublefrees) < 4) {",
        "\t\t\tpr_err(\"%s(): Double-freed CB %p->%pS()!!!  \", __func__, head, head->func);",
        "\t\t\tmem_dump_obj(head);",
        "\t\t}",
        "\t\tWRITE_ONCE(head->func, rcu_leak_callback);"
      ]
    },
    {
      "file": "linux\\kernel\\rcu\\tree.c",
      "line": 678,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t// from interrupts (as opposed to NMIs).  Therefore, (1) RCU is",
        "\t// already watching and (2) The fact that we are in an interrupt",
        "\t// handler and that the rcu_node lock is an irq-disabled lock",
        "\t// prevents self-deadlock.  So we can safely recheck under the lock.",
        "\t// Note that the nohz_full state currently cannot change.",
        "\traw_spin_lock_rcu_node(rdp->mynode);",
        "\tif (READ_ONCE(rdp->rcu_urgent_qs) && !rdp->rcu_forced_tick) {"
      ]
    },
    {
      "file": "linux\\kernel\\sched\\core.c",
      "line": 2247,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * The caller must ensure that the task *will* unschedule sometime soon,",
        " * else this function might spin for a *long* time. This function can't",
        " * be called with interrupts off, or it may introduce deadlock with",
        " * smp_call_function() if an IPI is sent by the same process we are",
        " * waiting to become inactive.",
        " */"
      ]
    },
    {
      "file": "linux\\kernel\\sched\\core.c",
      "line": 5213,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " *",
        " * Note that we may have delayed dropping an mm in context_switch(). If",
        " * so, we finish that here outside of the runqueue lock. (Doing it",
        " * with the lock held can cause deadlocks; see schedule() for",
        " * details.)",
        " *",
        " * The context switch have flipped the stack from under us and restored the"
      ]
    },
    {
      "file": "linux\\kernel\\sched\\core.c",
      "line": 6833,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * spinlock and rwlock must not flush block requests.  This will",
        "\t * deadlock if the callback attempts to acquire a lock which is",
        "\t * already acquired.",
        "\t */",
        "\tWARN_ON_ONCE(current->__state & TASK_RTLOCK_WAIT);"
      ]
    },
    {
      "file": "linux\\kernel\\sched\\core.c",
      "line": 6840,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * If we are going to sleep and we have plugged IO queued,",
        "\t * make sure to submit it to avoid deadlocks.",
        "\t */",
        "\tblk_flush_plug(tsk->plug, true);",
        ""
      ]
    },
    {
      "file": "linux\\kernel\\sched\\core.c",
      "line": 590,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_rq_lock",
      "context": [
        " *    o move_queued_task()",
        " *    o detach_task()",
        " *",
        " *  - for migration called under double_rq_lock():",
        " *",
        " *    o __migrate_swap_task()",
        " *    o push_rt_task() / pull_rt_task()"
      ]
    },
    {
      "file": "linux\\kernel\\sched\\core.c",
      "line": 655,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_rq_lock - safely lock",
      "context": [
        "",
        "#ifdef CONFIG_SMP",
        "/*",
        " * double_rq_lock - safely lock two runqueues",
        " */",
        "void double_rq_lock(struct rq *rq1, struct rq *rq2)",
        "{"
      ]
    },
    {
      "file": "linux\\kernel\\sched\\core.c",
      "line": 657,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_rq_lock",
      "context": [
        "/*",
        " * double_rq_lock - safely lock two runqueues",
        " */",
        "void double_rq_lock(struct rq *rq1, struct rq *rq2)",
        "{",
        "\tlockdep_assert_irqs_disabled();",
        ""
      ]
    },
    {
      "file": "linux\\kernel\\sched\\core.c",
      "line": 668,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_rq_clock",
      "context": [
        "\tif (__rq_lockp(rq1) != __rq_lockp(rq2))",
        "\t\traw_spin_rq_lock_nested(rq2, SINGLE_DEPTH_NESTING);",
        "",
        "\tdouble_rq_clock_clear_update(rq1, rq2);",
        "}",
        "#endif",
        ""
      ]
    },
    {
      "file": "linux\\kernel\\sched\\core.c",
      "line": 811,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DOUBLE_CLOCK",
      "context": [
        "\tif (rq->clock_update_flags & RQCF_ACT_SKIP)",
        "\t\treturn;",
        "",
        "\tif (sched_feat(WARN_DOUBLE_CLOCK))",
        "\t\tWARN_ON_ONCE(rq->clock_update_flags & RQCF_UPDATED);",
        "\trq->clock_update_flags |= RQCF_UPDATED;",
        ""
      ]
    },
    {
      "file": "linux\\kernel\\sched\\core.c",
      "line": 2694,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\t\tresched_curr(lowest_rq);",
        "\t}",
        "",
        "\tdouble_unlock_balance(rq, lowest_rq);",
        "",
        "out_unlock:",
        "\trq->push_busy = false;"
      ]
    },
    {
      "file": "linux\\kernel\\sched\\core.c",
      "line": 3411,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_raw_spinlock)(&arg->src_task->pi_lock, &arg->dst_task->pi_lock",
      "context": [
        "\tsrc_rq = cpu_rq(arg->src_cpu);",
        "\tdst_rq = cpu_rq(arg->dst_cpu);",
        "",
        "\tguard(double_raw_spinlock)(&arg->src_task->pi_lock, &arg->dst_task->pi_lock);",
        "\tguard(double_rq_lock)(src_rq, dst_rq);",
        "",
        "\tif (task_cpu(arg->dst_task) != arg->dst_cpu)"
      ]
    },
    {
      "file": "linux\\kernel\\sched\\core.c",
      "line": 3412,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_rq_lock",
      "context": [
        "\tdst_rq = cpu_rq(arg->dst_cpu);",
        "",
        "\tguard(double_raw_spinlock)(&arg->src_task->pi_lock, &arg->dst_task->pi_lock);",
        "\tguard(double_rq_lock)(src_rq, dst_rq);",
        "",
        "\tif (task_cpu(arg->dst_task) != arg->dst_cpu)",
        "\t\treturn -EAGAIN;"
      ]
    },
    {
      "file": "linux\\kernel\\sched\\core.c",
      "line": 6356,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_rq_lock",
      "context": [
        "\tbool success = false;",
        "",
        "\tguard(irq)();",
        "\tguard(double_rq_lock)(dst, src);",
        "",
        "\tcookie = dst->core->core_cookie;",
        "\tif (!cookie)"
      ]
    },
    {
      "file": "linux\\kernel\\sched\\cpufreq.c",
      "line": 52,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        " *",
        " * Callers must use RCU callbacks to free any memory that might be",
        " * accessed via the old update_util_data pointer or invoke synchronize_rcu()",
        " * right after this function to avoid use-after-free.",
        " */",
        "void cpufreq_remove_update_util_hook(int cpu)",
        "{"
      ]
    },
    {
      "file": "linux\\kernel\\sched\\deadline.c",
      "line": 394,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * inactive timer fired (and running_bw has been decreased) the",
        " * task's utilization has to be added to running_bw again.",
        " * A flag in the deadline scheduling entity (dl_non_contending)",
        " * is used to avoid race conditions between the inactive timer handler",
        " * and task wakeups.",
        " *",
        " * The following diagram shows how running_bw is updated. A task is"
      ]
    },
    {
      "file": "linux\\kernel\\sched\\deadline.c",
      "line": 715,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "\t\t\tcpu = cpumask_any(cpu_active_mask);",
        "\t\t}",
        "\t\tlater_rq = cpu_rq(cpu);",
        "\t\tdouble_lock_balance(rq, later_rq);",
        "\t}",
        "",
        "\tif (p->dl.dl_non_contending || p->dl.dl_throttled) {"
      ]
    },
    {
      "file": "linux\\kernel\\sched\\deadline.c",
      "line": 751,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\traw_spin_unlock(&dl_b->lock);",
        "",
        "\tset_task_cpu(p, later_rq->cpu);",
        "\tdouble_unlock_balance(later_rq, rq);",
        "",
        "\treturn later_rq;",
        "}"
      ]
    },
    {
      "file": "linux\\kernel\\sched\\deadline.c",
      "line": 2648,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "\t\t}",
        "",
        "\t\t/* Retry if something changed. */",
        "\t\tif (double_lock_balance(rq, later_rq)) {",
        "\t\t\tif (unlikely(task_rq(task) != rq ||",
        "\t\t\t\t     !cpumask_test_cpu(later_rq->cpu, &task->cpus_mask) ||",
        "\t\t\t\t     task_on_cpu(rq, task) ||"
      ]
    },
    {
      "file": "linux\\kernel\\sched\\deadline.c",
      "line": 2655,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\t\t\t\t     !dl_task(task) ||",
        "\t\t\t\t     is_migration_disabled(task) ||",
        "\t\t\t\t     !task_on_rq_queued(task))) {",
        "\t\t\t\tdouble_unlock_balance(rq, later_rq);",
        "\t\t\t\tlater_rq = NULL;",
        "\t\t\t\tbreak;",
        "\t\t\t}"
      ]
    },
    {
      "file": "linux\\kernel\\sched\\deadline.c",
      "line": 2670,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\t\t\tbreak;",
        "",
        "\t\t/* Otherwise we try again. */",
        "\t\tdouble_unlock_balance(rq, later_rq);",
        "\t\tlater_rq = NULL;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\kernel\\sched\\deadline.c",
      "line": 2766,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "",
        "\tresched_curr(later_rq);",
        "",
        "\tdouble_unlock_balance(rq, later_rq);",
        "",
        "out:",
        "\tput_task_struct(next_task);"
      ]
    },
    {
      "file": "linux\\kernel\\sched\\deadline.c",
      "line": 2815,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "",
        "\t\t/* Might drop this_rq->lock */",
        "\t\tpush_task = NULL;",
        "\t\tdouble_lock_balance(this_rq, src_rq);",
        "",
        "\t\t/*",
        "\t\t * If there are no more pullable tasks on the"
      ]
    },
    {
      "file": "linux\\kernel\\sched\\deadline.c",
      "line": 2855,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\t\t\t/* Is there any other task even earlier? */",
        "\t\t}",
        "skip:",
        "\t\tdouble_unlock_balance(this_rq, src_rq);",
        "",
        "\t\tif (push_task) {",
        "\t\t\tpreempt_disable();"
      ]
    },
    {
      "file": "linux\\kernel\\sched\\ext.c",
      "line": 2662,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * dequeues and maintain the invariant that @p->scx.dsq can only change while",
        " * @src_rq is locked, which e.g. scx_dump_task() depends on.",
        " *",
        " * We want to grab @src_rq but that can deadlock if we try while locking @dsq,",
        " * so we want to unlink @p from @dsq, drop its lock and then lock @src_rq. As",
        " * this may race with dequeue, which can't drop the rq lock or fail, do a little",
        " * dancing from our side."
      ]
    },
    {
      "file": "linux\\kernel\\sched\\ext.c",
      "line": 7331,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t\t/*",
        "\t\t * When called with an rq lock held, restrict the operation",
        "\t\t * to the corresponding CPU to prevent ABBA deadlocks.",
        "\t\t */",
        "\t\tif (locked_rq && rq != locked_rq) {",
        "\t\t\tscx_kf_error(\"Invalid target CPU %d\", cpu);"
      ]
    },
    {
      "file": "linux\\kernel\\sched\\ext.c",
      "line": 2193,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double lock",
      "context": [
        "",
        "\t/*",
        "\t * We are in the enqueue path with @rq locked and pinned, and thus can't",
        "\t * double lock a remote rq and enqueue to its local DSQ. For",
        "\t * DSQ_LOCAL_ON verdicts targeting the local DSQ of a remote CPU, defer",
        "\t * the enqueue so that it's executed when @rq can be unlocked.",
        "\t */"
      ]
    },
    {
      "file": "linux\\kernel\\sched\\fair.c",
      "line": 3099,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock_irq(&my_grp->lock, &grp->lock",
      "context": [
        "\t\treturn;",
        "",
        "\tWARN_ON_ONCE(irqs_disabled());",
        "\tdouble_lock_irq(&my_grp->lock, &grp->lock);",
        "",
        "\tfor (i = 0; i < NR_NUMA_HINT_FAULT_STATS * nr_node_ids; i++) {",
        "\t\tmy_grp->faults[i] -= p->numa_faults[i];"
      ]
    },
    {
      "file": "linux\\kernel\\sched\\psi.c",
      "line": 1457,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tsynchronize_rcu();",
        "\t/*",
        "\t * Stop kthread 'psimon' after releasing rtpoll_trigger_lock to prevent",
        "\t * a deadlock while waiting for psi_rtpoll_work to acquire",
        "\t * rtpoll_trigger_lock",
        "\t */",
        "\tif (task_to_destroy) {"
      ]
    },
    {
      "file": "linux\\kernel\\sched\\rt.c",
      "line": 1944,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "\t\t}",
        "",
        "\t\t/* if the prio of this runqueue changed, try again */",
        "\t\tif (double_lock_balance(rq, lowest_rq)) {",
        "\t\t\t/*",
        "\t\t\t * We had to unlock the run queue. In",
        "\t\t\t * the mean time, task could have"
      ]
    },
    {
      "file": "linux\\kernel\\sched\\rt.c",
      "line": 1959,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\t\t\t\t     !cpumask_test_cpu(lowest_rq->cpu, &task->cpus_mask) ||",
        "\t\t\t\t     task != pick_next_pushable_task(rq))) {",
        "",
        "\t\t\t\tdouble_unlock_balance(rq, lowest_rq);",
        "\t\t\t\tlowest_rq = NULL;",
        "\t\t\t\tbreak;",
        "\t\t\t}"
      ]
    },
    {
      "file": "linux\\kernel\\sched\\rt.c",
      "line": 1970,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\t\t\tbreak;",
        "",
        "\t\t/* try again */",
        "\t\tdouble_unlock_balance(rq, lowest_rq);",
        "\t\tlowest_rq = NULL;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\kernel\\sched\\rt.c",
      "line": 2093,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\tresched_curr(lowest_rq);",
        "\tret = 1;",
        "",
        "\tdouble_unlock_balance(rq, lowest_rq);",
        "out:",
        "\tput_task_struct(next_task);",
        ""
      ]
    },
    {
      "file": "linux\\kernel\\sched\\rt.c",
      "line": 2326,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "",
        "\t\t/*",
        "\t\t * We can potentially drop this_rq's lock in",
        "\t\t * double_lock_balance, and another CPU could",
        "\t\t * alter this_rq",
        "\t\t */",
        "\t\tpush_task = NULL;"
      ]
    },
    {
      "file": "linux\\kernel\\sched\\rt.c",
      "line": 2330,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "\t\t * alter this_rq",
        "\t\t */",
        "\t\tpush_task = NULL;",
        "\t\tdouble_lock_balance(this_rq, src_rq);",
        "",
        "\t\t/*",
        "\t\t * We can pull only a task, which is pushable"
      ]
    },
    {
      "file": "linux\\kernel\\sched\\rt.c",
      "line": 2371,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\t\t\t */",
        "\t\t}",
        "skip:",
        "\t\tdouble_unlock_balance(this_rq, src_rq);",
        "",
        "\t\tif (push_task) {",
        "\t\t\tpreempt_disable();"
      ]
    },
    {
      "file": "linux\\kernel\\sched\\syscalls.c",
      "line": 533,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Double check policy once rq lock",
      "context": [
        "\t/* The pi code expects interrupts enabled */",
        "\tBUG_ON(pi && in_interrupt());",
        "recheck:",
        "\t/* Double check policy once rq lock held: */",
        "\tif (policy < 0) {",
        "\t\treset_on_fork = p->sched_reset_on_fork;",
        "\t\tpolicy = oldpolicy = p->policy;"
      ]
    },
    {
      "file": "linux\\kernel\\sched\\syscalls.c",
      "line": 1446,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_rq_lock",
      "context": [
        "\t\tif (rq->nr_running == 1 && p_rq->nr_running == 1)",
        "\t\t\treturn -ESRCH;",
        "",
        "\t\tguard(double_rq_lock)(rq, p_rq);",
        "\t\tif (task_rq(p) != p_rq)",
        "\t\t\tgoto again;",
        ""
      ]
    },
    {
      "file": "linux\\kernel\\time\\hrtimer.c",
      "line": 1966,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * can switch to highres and / or nohz mode. The clocksource",
        "\t * switch happens with xtime_lock held. Notification from",
        "\t * there only sets the check bit in the tick_oneshot code,",
        "\t * otherwise we might deadlock vs. xtime_lock.",
        "\t */",
        "\tif (tick_check_oneshot_change(!hrtimer_is_hres_enabled())) {",
        "\t\thrtimer_switch_to_hres();"
      ]
    },
    {
      "file": "linux\\kernel\\time\\hrtimer.c",
      "line": 2288,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * The caller is globally serialized and nobody else",
        "\t * takes two locks at once, deadlock is not possible.",
        "\t */",
        "\traw_spin_lock(&old_base->lock);",
        "\traw_spin_lock_nested(&new_base->lock, SINGLE_DEPTH_NESTING);"
      ]
    },
    {
      "file": "linux\\kernel\\time\\posix-cpu-timers.c",
      "line": 242,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "/*",
        " * Set cputime to sum_cputime if sum_cputime > cputime. Use cmpxchg",
        " * to avoid race conditions with concurrent updates to cputime.",
        " */",
        "static inline void __update_gt_cputime(atomic64_t *cputime, u64 sum_cputime)",
        "{"
      ]
    },
    {
      "file": "linux\\kernel\\time\\tick-broadcast.c",
      "line": 424,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * We run the handler of the local cpu after dropping",
        "\t * tick_broadcast_lock because the handler might deadlock when",
        "\t * trying to switch to oneshot mode.",
        "\t */",
        "\tif (bc_local)"
      ]
    },
    {
      "file": "linux\\kernel\\time\\timer.c",
      "line": 1608,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "#endif",
        "\t/*",
        "\t * don't use it in hardirq context, because it",
        "\t * could lead to deadlock.",
        "\t */",
        "\tWARN_ON(in_hardirq() && !(timer->flags & TIMER_IRQSAFE));",
        ""
      ]
    },
    {
      "file": "linux\\kernel\\time\\timer.c",
      "line": 2524,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tnew_base = get_cpu_ptr(&timer_bases[b]);",
        "\t\t/*",
        "\t\t * The caller is globally serialized and nobody else",
        "\t\t * takes two locks at once, deadlock is not possible.",
        "\t\t */",
        "\t\traw_spin_lock_irq(&new_base->lock);",
        "\t\traw_spin_lock_nested(&old_base->lock, SINGLE_DEPTH_NESTING);"
      ]
    },
    {
      "file": "linux\\kernel\\time\\timer_migration.c",
      "line": 91,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * The groups are built up at init time or when CPUs come online. They are",
        " * not destroyed when a group becomes empty due to offlining. The group",
        " * just won't participate in the hierarchy management anymore. Destroying",
        " * groups would result in interesting race conditions which would just make",
        " * the whole mechanism slow and complex.",
        " *",
        " *"
      ]
    },
    {
      "file": "linux\\kernel\\time\\timer_migration.c",
      "line": 167,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " *    CPUs     0           1              2           3",
        " *             idle    --> active         active      idle",
        " *",
        " * 3. Here is the race condition: CPU1 managed to propagate its changes (from",
        " *    step 2) through the hierarchy to GRP1:0 before CPU0 (step 1) did. The",
        " *    active members of GRP1:0 remain unchanged after the update since it is",
        " *    still valid from CPU1 current point of view:"
      ]
    },
    {
      "file": "linux\\kernel\\trace\\ring_buffer.c",
      "line": 894,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * The events can happen in critical sections where",
        "\t * checking a work queue can cause deadlocks.",
        "\t * After adding a task to the queue, this flag is set",
        "\t * only to notify events to try to wake up the queue",
        "\t * using irq_work."
      ]
    },
    {
      "file": "linux\\kernel\\trace\\ring_buffer.c",
      "line": 5699,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\t/*",
        "\t * If an NMI die dumps out the content of the ring buffer",
        "\t * trylock must be used to prevent a deadlock if the NMI",
        "\t * preempted a task that holds the ring buffer locks. If",
        "\t * we get the lock then all is fine, if not, then continue",
        "\t * to do the read, but this can corrupt the ring buffer,"
      ]
    },
    {
      "file": "linux\\kernel\\trace\\trace.c",
      "line": 1301,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race when some condition",
      "context": [
        " *",
        " * This causes a swap between the snapshot buffer and the current live",
        " * tracing buffer. You can use this to take snapshots of the live",
        " * trace when some condition is triggered, but continue to trace.",
        " *",
        " * Note, make sure to allocate the snapshot with either",
        " * a tracing_snapshot_alloc(), or by doing it manually"
      ]
    },
    {
      "file": "linux\\kernel\\trace\\trace.c",
      "line": 1486,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race when some condition",
      "context": [
        " *",
        " * This causes a swap between the snapshot buffer and the current live",
        " * tracing buffer. You can use this to take snapshots of the live",
        " * trace when some condition is triggered, but continue to trace.",
        " */",
        "void tracing_snapshot_alloc(void)",
        "{"
      ]
    },
    {
      "file": "linux\\kernel\\trace\\trace.c",
      "line": 1985,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/*",
        "\t * We cannot call queue_work(&tr->fsnotify_work) from here because it's",
        "\t * possible that we are called from __schedule() or do_idle(), which",
        "\t * could cause a deadlock.",
        "\t */",
        "\tirq_work_queue(&tr->fsnotify_irqwork);",
        "}"
      ]
    },
    {
      "file": "linux\\kernel\\trace\\trace_branch.c",
      "line": 88,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race_likely_condition",
      "context": [
        "}",
        "",
        "static inline",
        "void trace_likely_condition(struct ftrace_likely_data *f, int val, int expect)",
        "{",
        "\tif (!branch_tracing_enabled)",
        "\t\treturn;"
      ]
    },
    {
      "file": "linux\\kernel\\trace\\trace_branch.c",
      "line": 194,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race_likely_condition",
      "context": [
        "",
        "#else",
        "static inline",
        "void trace_likely_condition(struct ftrace_likely_data *f, int val, int expect)",
        "{",
        "}",
        "#endif /* CONFIG_BRANCH_TRACER */"
      ]
    },
    {
      "file": "linux\\kernel\\trace\\trace_branch.c",
      "line": 215,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race_likely_condition",
      "context": [
        "\t * conditions that the recursive nightmare that exists is too",
        "\t * much to try to get working. At least for now.",
        "\t */",
        "\ttrace_likely_condition(f, val, expect);",
        "",
        "\t/* FIXME: Make this atomic! */",
        "\tif (val == expect)"
      ]
    },
    {
      "file": "linux\\kernel\\trace\\trace_events.c",
      "line": 3254,
      "pattern": "memory.*leak",
      "rule": "memory_management",
      "severity": "high",
      "match": "memory leak",
      "context": [
        "",
        "\t/*",
        "\t * If we failed to allocate memory here, then we'll just",
        "\t * let the str memory leak when the module is removed.",
        "\t * If this fails to allocate, there's worse problems than",
        "\t * a leaked string on module removal.",
        "\t */"
      ]
    },
    {
      "file": "linux\\kernel\\trace\\trace_events_trigger.c",
      "line": 35,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race entry for the event, NULL for uncondition",
      "context": [
        " * event_triggers_call - Call triggers associated with a trace event",
        " * @file: The trace_event_file associated with the event",
        " * @buffer: The ring buffer that the event is being written to",
        " * @rec: The trace entry for the event, NULL for unconditional invocation",
        " * @event: The event meta data in the ring buffer",
        " *",
        " * For each trigger associated with an event, invoke the trigger"
      ]
    },
    {
      "file": "linux\\kernel\\trace\\trace_osnoise.c",
      "line": 783,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t} while (int_counter != local_read(&osn_var->int_counter));",
        "",
        "\t/*",
        "\t * This is an evidence of race conditions that cause",
        "\t * a value to be \"discounted\" too much.",
        "\t */",
        "\tif (duration < 0)"
      ]
    },
    {
      "file": "linux\\kernel\\trace\\trace_osnoise.c",
      "line": 1352,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "racer hit stop condition",
      "context": [
        "\t\t\t\t\"stop tracing hit on cpu %d\\n\", smp_processor_id());",
        "",
        "\t\tif (test_bit(OSN_PANIC_ON_STOP, &osnoise_options))",
        "\t\t\tpanic(\"tracer hit stop condition on CPU %d\\n\", smp_processor_id());",
        "",
        "\t\ttracer_tracing_off(tr);",
        "\t}"
      ]
    },
    {
      "file": "linux\\kernel\\trace\\trace_stack.c",
      "line": 174,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tif (!object_is_on_stack(stack))",
        "\t\treturn;",
        "",
        "\t/* Can't do this from NMI context (can cause deadlocks) */",
        "\tif (in_nmi())",
        "\t\treturn;",
        ""
      ]
    },
    {
      "file": "linux\\kernel\\debug\\kdb\\kdb_io.c",
      "line": 601,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t/*",
        "\t\t * Set oops_in_progress to encourage the console drivers to",
        "\t\t * disregard their internal spin locks: in the current calling",
        "\t\t * context the risk of deadlock is a bigger problem than risks",
        "\t\t * due to re-entering the console driver. We operate directly on",
        "\t\t * oops_in_progress rather than using bust_spinlocks() because",
        "\t\t * the calls bust_spinlocks() makes on exit are not appropriate"
      ]
    },
    {
      "file": "linux\\mm\\kasan\\common.c",
      "line": 239,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "used after free",
      "context": [
        "",
        "\tobject = kasan_reset_tag(object);",
        "",
        "\t/* RCU slabs could be legally used after free within the RCU period. */",
        "\tif (unlikely(still_accessible))",
        "\t\treturn;",
        ""
      ]
    },
    {
      "file": "linux\\mm\\kasan\\common.c",
      "line": 276,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "",
        "\t/*",
        "\t * Note: Keep per-object metadata to allow KASAN print stack traces for",
        "\t * use-after-free-before-realloc bugs.",
        "\t */",
        "",
        "\t/* Let slab put the object onto the freelist. */"
      ]
    },
    {
      "file": "linux\\mm\\kasan\\common.c",
      "line": 225,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "DOUBLE_FREE",
      "context": [
        "\t}",
        "",
        "\tif (!kasan_byte_accessible(tagged_object)) {",
        "\t\tkasan_report_invalid_free(tagged_object, ip, KASAN_REPORT_DOUBLE_FREE);",
        "\t\treturn true;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\mm\\kasan\\common.c",
      "line": 294,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "DOUBLE_FREE",
      "context": [
        "\t}",
        "",
        "\tif (!kasan_byte_accessible(ptr)) {",
        "\t\tkasan_report_invalid_free(ptr, ip, KASAN_REPORT_DOUBLE_FREE);",
        "\t\treturn true;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\mm\\kasan\\kasan_test_c.c",
      "line": 446,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "}",
        "",
        "/*",
        " * Check that krealloc() detects a use-after-free, returns NULL,",
        " * and doesn't unpoison the freed object.",
        " */",
        "static void krealloc_uaf(struct kunit *test)"
      ]
    },
    {
      "file": "linux\\mm\\kasan\\kasan_test_c.c",
      "line": 711,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "}",
        "",
        "/*",
        " * Check that KASAN detects use-after-free when another object was allocated in",
        " * the same slot. Relevant for the tag-based modes, which do not use quarantine.",
        " */",
        "static void kmalloc_uaf3(struct kunit *test)"
      ]
    },
    {
      "file": "linux\\mm\\kasan\\kasan_test_c.c",
      "line": 852,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "}",
        "",
        "/*",
        " * Check that a use-after-free is detected by ksize() and via normal accesses",
        " * after it.",
        " */",
        "static void ksize_uaf(struct kunit *test)"
      ]
    },
    {
      "file": "linux\\mm\\kasan\\kasan_test_c.c",
      "line": 1971,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "}",
        "",
        "/*",
        " * Check that Rust performing a use-after-free using `unsafe` is detected.",
        " * This is a smoke test to make sure that Rust is being sanitized properly.",
        " */",
        "static void rust_uaf(struct kunit *test)"
      ]
    },
    {
      "file": "linux\\mm\\kasan\\kasan_test_c.c",
      "line": 811,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double_kzfree",
      "context": [
        "\tkfree(a2);",
        "}",
        "",
        "static void kmalloc_double_kzfree(struct kunit *test)",
        "{",
        "\tchar *ptr;",
        "\tsize_t size = 16;"
      ]
    },
    {
      "file": "linux\\mm\\kasan\\kasan_test_c.c",
      "line": 981,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double_free",
      "context": [
        "\tkmem_cache_destroy(cache);",
        "}",
        "",
        "static void kmem_cache_double_free(struct kunit *test)",
        "{",
        "\tchar *p;",
        "\tsize_t size = 200;"
      ]
    },
    {
      "file": "linux\\mm\\kasan\\kasan_test_c.c",
      "line": 1151,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double-free and invalid-free",
      "context": [
        "\t/*",
        "\t * Allocate one element to prevent mempool from freeing elements to the",
        "\t * underlying allocator and instead make it add them to the element",
        "\t * list when the tests trigger double-free and invalid-free bugs.",
        "\t * This allows testing KASAN annotations in add_element().",
        "\t */",
        "\telem = mempool_alloc_preallocated(pool);"
      ]
    },
    {
      "file": "linux\\mm\\kasan\\kasan_test_c.c",
      "line": 1174,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double-free",
      "context": [
        "\tKUNIT_ASSERT_EQ(test, ret, 0);",
        "",
        "\t/*",
        "\t * Do not allocate one preallocated element, as we skip the double-free",
        "\t * and invalid-free tests for slab mempool for simplicity.",
        "\t */",
        ""
      ]
    },
    {
      "file": "linux\\mm\\kasan\\kasan_test_c.c",
      "line": 1335,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double_free",
      "context": [
        "\tmempool_exit(&pool);",
        "}",
        "",
        "static void mempool_double_free_helper(struct kunit *test, mempool_t *pool)",
        "{",
        "\tchar *elem;",
        ""
      ]
    },
    {
      "file": "linux\\mm\\kasan\\kasan_test_c.c",
      "line": 1347,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double_free",
      "context": [
        "\tKUNIT_EXPECT_KASAN_FAIL(test, mempool_free(elem, pool));",
        "}",
        "",
        "static void mempool_kmalloc_double_free(struct kunit *test)",
        "{",
        "\tmempool_t pool;",
        "\tsize_t size = 128;"
      ]
    },
    {
      "file": "linux\\mm\\kasan\\kasan_test_c.c",
      "line": 1355,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double_free",
      "context": [
        "",
        "\textra_elem = mempool_prepare_kmalloc(test, &pool, size);",
        "",
        "\tmempool_double_free_helper(test, &pool);",
        "",
        "\tmempool_free(extra_elem, &pool);",
        "\tmempool_exit(&pool);"
      ]
    },
    {
      "file": "linux\\mm\\kasan\\kasan_test_c.c",
      "line": 1361,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double_free",
      "context": [
        "\tmempool_exit(&pool);",
        "}",
        "",
        "static void mempool_kmalloc_large_double_free(struct kunit *test)",
        "{",
        "\tmempool_t pool;",
        "\tsize_t size = KMALLOC_MAX_CACHE_SIZE + 1;"
      ]
    },
    {
      "file": "linux\\mm\\kasan\\kasan_test_c.c",
      "line": 1369,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double_free",
      "context": [
        "",
        "\textra_elem = mempool_prepare_kmalloc(test, &pool, size);",
        "",
        "\tmempool_double_free_helper(test, &pool);",
        "",
        "\tmempool_free(extra_elem, &pool);",
        "\tmempool_exit(&pool);"
      ]
    },
    {
      "file": "linux\\mm\\kasan\\kasan_test_c.c",
      "line": 1375,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double_free",
      "context": [
        "\tmempool_exit(&pool);",
        "}",
        "",
        "static void mempool_page_alloc_double_free(struct kunit *test)",
        "{",
        "\tmempool_t pool;",
        "\tint order = 2;"
      ]
    },
    {
      "file": "linux\\mm\\kasan\\kasan_test_c.c",
      "line": 1383,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double_free",
      "context": [
        "",
        "\textra_elem = mempool_prepare_page(test, &pool, order);",
        "",
        "\tmempool_double_free_helper(test, &pool);",
        "",
        "\tmempool_free(extra_elem, &pool);",
        "\tmempool_exit(&pool);"
      ]
    },
    {
      "file": "linux\\mm\\kasan\\kasan_test_c.c",
      "line": 2090,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double_kzfree",
      "context": [
        "\tKUNIT_CASE(kmalloc_uaf_memset),",
        "\tKUNIT_CASE(kmalloc_uaf2),",
        "\tKUNIT_CASE(kmalloc_uaf3),",
        "\tKUNIT_CASE(kmalloc_double_kzfree),",
        "\tKUNIT_CASE(ksize_unpoisons_memory),",
        "\tKUNIT_CASE(ksize_uaf),",
        "\tKUNIT_CASE(rcu_uaf),"
      ]
    },
    {
      "file": "linux\\mm\\kasan\\kasan_test_c.c",
      "line": 2098,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double_free",
      "context": [
        "\tKUNIT_CASE(kfree_via_page),",
        "\tKUNIT_CASE(kfree_via_phys),",
        "\tKUNIT_CASE(kmem_cache_oob),",
        "\tKUNIT_CASE(kmem_cache_double_free),",
        "\tKUNIT_CASE(kmem_cache_invalid_free),",
        "\tKUNIT_CASE(kmem_cache_rcu_uaf),",
        "\tKUNIT_CASE(kmem_cache_double_destroy),"
      ]
    },
    {
      "file": "linux\\mm\\kasan\\kasan_test_c.c",
      "line": 2111,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double_free",
      "context": [
        "\tKUNIT_CASE(mempool_kmalloc_large_uaf),",
        "\tKUNIT_CASE(mempool_slab_uaf),",
        "\tKUNIT_CASE(mempool_page_alloc_uaf),",
        "\tKUNIT_CASE(mempool_kmalloc_double_free),",
        "\tKUNIT_CASE(mempool_kmalloc_large_double_free),",
        "\tKUNIT_CASE(mempool_page_alloc_double_free),",
        "\tKUNIT_CASE(mempool_kmalloc_invalid_free),"
      ]
    },
    {
      "file": "linux\\mm\\kasan\\kasan_test_c.c",
      "line": 2112,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double_free",
      "context": [
        "\tKUNIT_CASE(mempool_slab_uaf),",
        "\tKUNIT_CASE(mempool_page_alloc_uaf),",
        "\tKUNIT_CASE(mempool_kmalloc_double_free),",
        "\tKUNIT_CASE(mempool_kmalloc_large_double_free),",
        "\tKUNIT_CASE(mempool_page_alloc_double_free),",
        "\tKUNIT_CASE(mempool_kmalloc_invalid_free),",
        "\tKUNIT_CASE(mempool_kmalloc_large_invalid_free),"
      ]
    },
    {
      "file": "linux\\mm\\kasan\\kasan_test_c.c",
      "line": 2113,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double_free",
      "context": [
        "\tKUNIT_CASE(mempool_page_alloc_uaf),",
        "\tKUNIT_CASE(mempool_kmalloc_double_free),",
        "\tKUNIT_CASE(mempool_kmalloc_large_double_free),",
        "\tKUNIT_CASE(mempool_page_alloc_double_free),",
        "\tKUNIT_CASE(mempool_kmalloc_invalid_free),",
        "\tKUNIT_CASE(mempool_kmalloc_large_invalid_free),",
        "\tKUNIT_CASE(kasan_global_oob_right),"
      ]
    },
    {
      "file": "linux\\mm\\kasan\\quarantine.c",
      "line": 150,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "",
        "\t/*",
        "\t * Note: Keep per-object metadata to allow KASAN print stack traces for",
        "\t * use-after-free-before-realloc bugs.",
        "\t */",
        "",
        "\t/*"
      ]
    },
    {
      "file": "linux\\mm\\kasan\\report.c",
      "line": 325,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\tif (IS_ENABLED(CONFIG_KASAN_GENERIC)) {",
        "\t\tif (strcmp(info->bug_type, \"slab-out-of-bounds\") == 0)",
        "\t\t\tregion_state = \"allocated \";",
        "\t\telse if (strcmp(info->bug_type, \"slab-use-after-free\") == 0)",
        "\t\t\tregion_state = \"freed \";",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\mm\\kasan\\report.c",
      "line": 556,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "DOUBLE_FREE",
      "context": [
        "\tcase KASAN_REPORT_INVALID_FREE:",
        "\t\tinfo->bug_type = \"invalid-free\";",
        "\t\tbreak;",
        "\tcase KASAN_REPORT_DOUBLE_FREE:",
        "\t\tinfo->bug_type = \"double-free\";",
        "\t\tbreak;",
        "\tdefault:"
      ]
    },
    {
      "file": "linux\\mm\\kasan\\report.c",
      "line": 557,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double-free",
      "context": [
        "\t\tinfo->bug_type = \"invalid-free\";",
        "\t\tbreak;",
        "\tcase KASAN_REPORT_DOUBLE_FREE:",
        "\t\tinfo->bug_type = \"double-free\";",
        "\t\tbreak;",
        "\tdefault:",
        "\t\t/* bug_type filled in by kasan_complete_mode_report_info. */"
      ]
    },
    {
      "file": "linux\\mm\\kasan\\report_generic.c",
      "line": 110,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t\tbug_type = \"stack-out-of-bounds\";",
        "\t\tbreak;",
        "\tcase KASAN_PAGE_FREE:",
        "\t\tbug_type = \"use-after-free\";",
        "\t\tbreak;",
        "\tcase KASAN_SLAB_FREE:",
        "\tcase KASAN_SLAB_FREE_META:"
      ]
    },
    {
      "file": "linux\\mm\\kasan\\report_generic.c",
      "line": 114,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t\tbreak;",
        "\tcase KASAN_SLAB_FREE:",
        "\tcase KASAN_SLAB_FREE_META:",
        "\t\tbug_type = \"slab-use-after-free\";",
        "\t\tbreak;",
        "\tcase KASAN_ALLOCA_LEFT:",
        "\tcase KASAN_ALLOCA_RIGHT:"
      ]
    },
    {
      "file": "linux\\mm\\kasan\\report_tags.c",
      "line": 80,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "",
        "\t\t\t/*",
        "\t\t\t * If a free entry is found first, the bug is likely",
        "\t\t\t * a use-after-free.",
        "\t\t\t */",
        "\t\t\tif (!info->bug_type)",
        "\t\t\t\tinfo->bug_type = \"slab-use-after-free\";"
      ]
    },
    {
      "file": "linux\\mm\\kasan\\report_tags.c",
      "line": 83,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t\t\t * a use-after-free.",
        "\t\t\t */",
        "\t\t\tif (!info->bug_type)",
        "\t\t\t\tinfo->bug_type = \"slab-use-after-free\";",
        "\t\t} else {",
        "\t\t\t/* Second alloc of the same object. Give up. */",
        "\t\t\tif (alloc_found)"
      ]
    },
    {
      "file": "linux\\mm\\kfence\\core.c",
      "line": 441,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\tif (unlikely(!raw_spin_trylock_irqsave(&meta->lock, flags))) {",
        "\t\t/*",
        "\t\t * This is extremely unlikely -- we are reporting on a",
        "\t\t * use-after-free, which locked meta->lock, and the reporting",
        "\t\t * code via printk calls kmalloc() which ends up in",
        "\t\t * kfence_alloc() and tries to grab the same object that we're",
        "\t\t * reporting on. While it has never been observed, lockdep does"
      ]
    },
    {
      "file": "linux\\mm\\kfence\\core.c",
      "line": 531,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t\treturn;",
        "\t}",
        "",
        "\t/* Detect racy use-after-free, or incorrect reallocation of this page by KFENCE. */",
        "\tkcsan_begin_scoped_access((void *)ALIGN_DOWN((unsigned long)addr, PAGE_SIZE), PAGE_SIZE,",
        "\t\t\t\t  KCSAN_ACCESS_SCOPED | KCSAN_ACCESS_WRITE | KCSAN_ACCESS_ASSERT,",
        "\t\t\t\t  &assert_page_exclusive);"
      ]
    },
    {
      "file": "linux\\mm\\kfence\\core.c",
      "line": 558,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "",
        "\t/*",
        "\t * Clear memory if init-on-free is set. While we protect the page, the",
        "\t * data is still there, and after a use-after-free is detected, we",
        "\t * unprotect the page, so the data is still accessible.",
        "\t */",
        "\tif (!zombie && unlikely(init))"
      ]
    },
    {
      "file": "linux\\mm\\kfence\\core.c",
      "line": 564,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\tif (!zombie && unlikely(init))",
        "\t\tmemzero_explicit(addr, meta->size);",
        "",
        "\t/* Protect to detect use-after-frees. */",
        "\tkfence_protect((unsigned long)addr);",
        "",
        "\tkcsan_end_scoped_access(&assert_page_exclusive);"
      ]
    },
    {
      "file": "linux\\mm\\kfence\\core.c",
      "line": 1148,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "",
        "\t/*",
        "\t * Read locklessly -- if there is a race with __kfence_alloc(), this is",
        "\t * either a use-after-free or invalid access.",
        "\t */",
        "\treturn meta ? meta->size : 0;",
        "}"
      ]
    },
    {
      "file": "linux\\mm\\kfence\\core.c",
      "line": 1159,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "",
        "\t/*",
        "\t * Read locklessly -- if there is a race with __kfence_alloc(), this is",
        "\t * either a use-after-free or invalid access.",
        "\t */",
        "\treturn meta ? (void *)meta->addr : NULL;",
        "}"
      ]
    },
    {
      "file": "linux\\mm\\kfence\\core.c",
      "line": 1247,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t\t/*",
        "\t\t * We may race with __kfence_alloc(), and it is possible that a",
        "\t\t * freed object may be reallocated. We simply report this as a",
        "\t\t * use-after-free, with the stack trace showing the place where",
        "\t\t * the object was re-allocated.",
        "\t\t */",
        "\t}"
      ]
    },
    {
      "file": "linux\\mm\\kfence\\core.c",
      "line": 523,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double-free",
      "context": [
        "\traw_spin_lock_irqsave(&meta->lock, flags);",
        "",
        "\tif (!kfence_obj_allocated(meta) || meta->addr != (unsigned long)addr) {",
        "\t\t/* Invalid or double-free, bail out. */",
        "\t\tatomic_long_inc(&counters[KFENCE_COUNTER_BUGS]);",
        "\t\tkfence_report_error((unsigned long)addr, false, NULL, meta,",
        "\t\t\t\t    KFENCE_ERROR_INVALID_FREE);"
      ]
    },
    {
      "file": "linux\\mm\\kfence\\kfence_test.c",
      "line": 120,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t\t\t\t get_access_type(r));",
        "\t\tbreak;",
        "\tcase KFENCE_ERROR_UAF:",
        "\t\tcur += scnprintf(cur, end - cur, \"BUG: KFENCE: use-after-free %s\",",
        "\t\t\t\t get_access_type(r));",
        "\t\tbreak;",
        "\tcase KFENCE_ERROR_CORRUPTION:"
      ]
    },
    {
      "file": "linux\\mm\\kfence\\kfence_test.c",
      "line": 151,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "Use-after-free",
      "context": [
        "\t\taddr = arch_kfence_test_address(addr);",
        "\t\tbreak;",
        "\tcase KFENCE_ERROR_UAF:",
        "\t\tcur += scnprintf(cur, end - cur, \"Use-after-free %s at\", get_access_type(r));",
        "\t\taddr = arch_kfence_test_address(addr);",
        "\t\tbreak;",
        "\tcase KFENCE_ERROR_CORRUPTION:"
      ]
    },
    {
      "file": "linux\\mm\\kfence\\kfence_test.c",
      "line": 371,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use_after_free",
      "context": [
        "\ttest_free(buf);",
        "}",
        "",
        "static void test_use_after_free_read(struct kunit *test)",
        "{",
        "\tconst size_t size = 32;",
        "\tstruct expect_report expect = {"
      ]
    },
    {
      "file": "linux\\mm\\kfence\\kfence_test.c",
      "line": 376,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use_after_free",
      "context": [
        "\tconst size_t size = 32;",
        "\tstruct expect_report expect = {",
        "\t\t.type = KFENCE_ERROR_UAF,",
        "\t\t.fn = test_use_after_free_read,",
        "\t\t.is_write = false,",
        "\t};",
        ""
      ]
    },
    {
      "file": "linux\\mm\\kfence\\kfence_test.c",
      "line": 387,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use_after_free",
      "context": [
        "\tKUNIT_EXPECT_TRUE(test, report_matches(&expect));",
        "}",
        "",
        "static void test_use_after_free_read_nofault(struct kunit *test)",
        "{",
        "\tconst size_t size = 32;",
        "\tchar *addr;"
      ]
    },
    {
      "file": "linux\\mm\\kfence\\kfence_test.c",
      "line": 397,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "Use after free",
      "context": [
        "\tsetup_test_cache(test, size, 0, NULL);",
        "\taddr = test_alloc(test, size, GFP_KERNEL, ALLOCATE_ANY);",
        "\ttest_free(addr);",
        "\t/* Use after free with *_nofault() */",
        "\tret = copy_from_kernel_nofault(&dst, addr, 1);",
        "\tKUNIT_EXPECT_EQ(test, ret, -EFAULT);",
        "\tKUNIT_EXPECT_FALSE(test, report_available());"
      ]
    },
    {
      "file": "linux\\mm\\kfence\\kfence_test.c",
      "line": 703,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t/* Only after rcu_barrier() is the memory guaranteed to be freed. */",
        "\trcu_barrier();",
        "",
        "\t/* Expect use-after-free. */",
        "\tKUNIT_EXPECT_EQ(test, *expect.addr, (char)42);",
        "\tKUNIT_EXPECT_TRUE(test, report_matches(&expect));",
        "}"
      ]
    },
    {
      "file": "linux\\mm\\kfence\\kfence_test.c",
      "line": 799,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use_after_free",
      "context": [
        "static struct kunit_case kfence_test_cases[] = {",
        "\tKFENCE_KUNIT_CASE(test_out_of_bounds_read),",
        "\tKFENCE_KUNIT_CASE(test_out_of_bounds_write),",
        "\tKFENCE_KUNIT_CASE(test_use_after_free_read),",
        "\tKFENCE_KUNIT_CASE(test_use_after_free_read_nofault),",
        "\tKFENCE_KUNIT_CASE(test_double_free),",
        "\tKFENCE_KUNIT_CASE(test_invalid_addr_free),"
      ]
    },
    {
      "file": "linux\\mm\\kfence\\kfence_test.c",
      "line": 800,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use_after_free",
      "context": [
        "\tKFENCE_KUNIT_CASE(test_out_of_bounds_read),",
        "\tKFENCE_KUNIT_CASE(test_out_of_bounds_write),",
        "\tKFENCE_KUNIT_CASE(test_use_after_free_read),",
        "\tKFENCE_KUNIT_CASE(test_use_after_free_read_nofault),",
        "\tKFENCE_KUNIT_CASE(test_double_free),",
        "\tKFENCE_KUNIT_CASE(test_invalid_addr_free),",
        "\tKFENCE_KUNIT_CASE(test_corruption),"
      ]
    },
    {
      "file": "linux\\mm\\kfence\\kfence_test.c",
      "line": 403,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double_free",
      "context": [
        "\tKUNIT_EXPECT_FALSE(test, report_available());",
        "}",
        "",
        "static void test_double_free(struct kunit *test)",
        "{",
        "\tconst size_t size = 32;",
        "\tstruct expect_report expect = {"
      ]
    },
    {
      "file": "linux\\mm\\kfence\\kfence_test.c",
      "line": 408,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double_free",
      "context": [
        "\tconst size_t size = 32;",
        "\tstruct expect_report expect = {",
        "\t\t.type = KFENCE_ERROR_INVALID_FREE,",
        "\t\t.fn = test_double_free,",
        "\t};",
        "",
        "\tsetup_test_cache(test, size, 0, NULL);"
      ]
    },
    {
      "file": "linux\\mm\\kfence\\kfence_test.c",
      "line": 414,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "Double-free",
      "context": [
        "\tsetup_test_cache(test, size, 0, NULL);",
        "\texpect.addr = test_alloc(test, size, GFP_KERNEL, ALLOCATE_ANY);",
        "\ttest_free(expect.addr);",
        "\ttest_free(expect.addr); /* Double-free. */",
        "\tKUNIT_EXPECT_TRUE(test, report_matches(&expect));",
        "}",
        ""
      ]
    },
    {
      "file": "linux\\mm\\kfence\\kfence_test.c",
      "line": 801,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double_free",
      "context": [
        "\tKFENCE_KUNIT_CASE(test_out_of_bounds_write),",
        "\tKFENCE_KUNIT_CASE(test_use_after_free_read),",
        "\tKFENCE_KUNIT_CASE(test_use_after_free_read_nofault),",
        "\tKFENCE_KUNIT_CASE(test_double_free),",
        "\tKFENCE_KUNIT_CASE(test_invalid_addr_free),",
        "\tKFENCE_KUNIT_CASE(test_corruption),",
        "\tKFENCE_KUNIT_CASE(test_free_bulk),"
      ]
    },
    {
      "file": "linux\\mm\\kfence\\report.c",
      "line": 238,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t\tbreak;",
        "\t}",
        "\tcase KFENCE_ERROR_UAF:",
        "\t\tpr_err(\"BUG: KFENCE: use-after-free %s in %pS\\n\\n\", get_access_type(is_write),",
        "\t\t       (void *)stack_entries[skipnr]);",
        "\t\tpr_err(\"Use-after-free %s at 0x%p (in kfence-#%td):\\n\",",
        "\t\t       get_access_type(is_write), (void *)address, object_index);"
      ]
    },
    {
      "file": "linux\\mm\\kfence\\report.c",
      "line": 240,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "Use-after-free",
      "context": [
        "\tcase KFENCE_ERROR_UAF:",
        "\t\tpr_err(\"BUG: KFENCE: use-after-free %s in %pS\\n\\n\", get_access_type(is_write),",
        "\t\t       (void *)stack_entries[skipnr]);",
        "\t\tpr_err(\"Use-after-free %s at 0x%p (in kfence-#%td):\\n\",",
        "\t\t       get_access_type(is_write), (void *)address, object_index);",
        "\t\tbreak;",
        "\tcase KFENCE_ERROR_CORRUPTION:"
      ]
    },
    {
      "file": "linux\\mm\\kmsan\\hooks.c",
      "line": 76,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "used after free",
      "context": [
        "\tif (!kmsan_enabled || kmsan_in_runtime())",
        "\t\treturn;",
        "",
        "\t/* RCU slabs could be legally used after free within the RCU period */",
        "\tif (unlikely(s->flags & SLAB_TYPESAFE_BY_RCU))",
        "\t\treturn;",
        "\t/*"
      ]
    },
    {
      "file": "linux\\mm\\kmsan\\hooks.c",
      "line": 82,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\t/*",
        "\t * If there's a constructor, freed memory must remain in the same state",
        "\t * until the next allocation. We cannot save its state to detect",
        "\t * use-after-free bugs, instead we just keep it unpoisoned.",
        "\t */",
        "\tif (s->ctor)",
        "\t\treturn;"
      ]
    },
    {
      "file": "linux\\mm\\kmsan\\report.c",
      "line": 174,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\tis_uaf = kmsan_uaf_from_eb(stack_depot_get_extra_bits(origin));",
        "\tswitch (reason) {",
        "\tcase REASON_ANY:",
        "\t\tbug_type = is_uaf ? \"use-after-free\" : \"uninit-value\";",
        "\t\tbreak;",
        "\tcase REASON_COPY_TO_USER:",
        "\t\tbug_type = is_uaf ? \"kernel-infoleak-after-free\" :"
      ]
    },
    {
      "file": "linux\\mm\\kmsan\\kmsan_test.c",
      "line": 161,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "USE_AFTER_FREE",
      "context": [
        "#define EXPECTATION_UNINIT_VALUE_FN(e, fn) \\",
        "\tEXPECTATION_ETYPE_FN(e, \"uninit-value\", fn)",
        "#define EXPECTATION_UNINIT_VALUE(e) EXPECTATION_UNINIT_VALUE_FN(e, __func__)",
        "#define EXPECTATION_USE_AFTER_FREE(e) \\",
        "\tEXPECTATION_ETYPE_FN(e, \"use-after-free\", __func__)",
        "",
        "/* Test case: ensure that kmalloc() returns uninitialized memory. */"
      ]
    },
    {
      "file": "linux\\mm\\kmsan\\kmsan_test.c",
      "line": 162,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\tEXPECTATION_ETYPE_FN(e, \"uninit-value\", fn)",
        "#define EXPECTATION_UNINIT_VALUE(e) EXPECTATION_UNINIT_VALUE_FN(e, __func__)",
        "#define EXPECTATION_USE_AFTER_FREE(e) \\",
        "\tEXPECTATION_ETYPE_FN(e, \"use-after-free\", __func__)",
        "",
        "/* Test case: ensure that kmalloc() returns uninitialized memory. */",
        "static void test_uninit_kmalloc(struct kunit *test)"
      ]
    },
    {
      "file": "linux\\mm\\kmsan\\kmsan_test.c",
      "line": 364,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\tKUNIT_EXPECT_TRUE(test, report_matches(&expect));",
        "}",
        "",
        "/* Test case: ensure that use-after-free reporting works. */",
        "static void test_uaf(struct kunit *test)",
        "{",
        "\tEXPECTATION_USE_AFTER_FREE(expect);"
      ]
    },
    {
      "file": "linux\\mm\\kmsan\\kmsan_test.c",
      "line": 367,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "USE_AFTER_FREE",
      "context": [
        "/* Test case: ensure that use-after-free reporting works. */",
        "static void test_uaf(struct kunit *test)",
        "{",
        "\tEXPECTATION_USE_AFTER_FREE(expect);",
        "\tvolatile int value;",
        "\tvolatile int *var;",
        ""
      ]
    },
    {
      "file": "linux\\mm\\kmsan\\kmsan_test.c",
      "line": 371,
      "pattern": "use.*after.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "use-after-free",
      "context": [
        "\tvolatile int value;",
        "\tvolatile int *var;",
        "",
        "\tkunit_info(test, \"use-after-free in kmalloc-ed buffer (UMR report)\\n\");",
        "\tvar = kmalloc(80, GFP_KERNEL);",
        "\tvar[3] = 0xfeedface;",
        "\tkfree((int *)var);"
      ]
    },
    {
      "file": "linux\\net\\9p\\error.c",
      "line": 75,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t{\"Broken pipe\", EPIPE},",
        "\t{\"Numerical argument out of domain\", EDOM},",
        "\t{\"Numerical result out of range\", ERANGE},",
        "\t{\"Resource deadlock avoided\", EDEADLK},",
        "\t{\"File name too long\", ENAMETOOLONG},",
        "\t{\"No locks available\", ENOLCK},",
        "\t{\"Function not implemented\", ENOSYS},"
      ]
    },
    {
      "file": "linux\\net\\appletalk\\ddp.c",
      "line": 200,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "*                                                                          *",
        "\\**************************************************************************/",
        "",
        "/* Anti-deadlock ordering is atalk_routes_lock --> iface_lock -DaveM */",
        "struct atalk_route *atalk_routes;",
        "DEFINE_RWLOCK(atalk_routes_lock);",
        ""
      ]
    },
    {
      "file": "linux\\net\\atm\\pppoatm.c",
      "line": 143,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "",
        "\t/*",
        "\t * We always used to run the wakeup tasklet unconditionally here, for",
        "\t * fear of race conditions where we clear the BLOCKED flag just as we",
        "\t * refuse another packet in pppoatm_send(). This was quite inefficient.",
        "\t *",
        "\t * In fact it's OK. The PPP core will only ever call pppoatm_send()"
      ]
    },
    {
      "file": "linux\\net\\batman-adv\\bat_iv_ogm.c",
      "line": 804,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tif (!*ogm_buff)",
        "\t\treturn;",
        "",
        "\t/* the interface gets activated here to avoid race conditions between",
        "\t * the moment of activating the interface in",
        "\t * hardif_activate_interface() where the originator mac is set and",
        "\t * outdated packets (especially uninitialized mac addresses) in the"
      ]
    },
    {
      "file": "linux\\net\\batman-adv\\bat_v_elp.c",
      "line": 184,
      "pattern": "hardcoded.*values",
      "rule": "code_quality",
      "severity": "low",
      "match": "hardcoded throughput values",
      "context": [
        "default_throughput:",
        "\tif (!(hard_iface->bat_v.flags & BATADV_WARNING_DEFAULT)) {",
        "\t\tbatadv_info(mesh_iface,",
        "\t\t\t    \"WiFi driver or ethtool info does not provide information about link speeds on interface %s, therefore defaulting to hardcoded throughput values of %u.%1u Mbps. Consider overriding the throughput manually or checking your driver.\\n\",",
        "\t\t\t    hard_iface->net_dev->name,",
        "\t\t\t    BATADV_THROUGHPUT_DEFAULT_VALUE / 10,",
        "\t\t\t    BATADV_THROUGHPUT_DEFAULT_VALUE % 10);"
      ]
    },
    {
      "file": "linux\\net\\bluetooth\\hci_core.c",
      "line": 3249,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t/* Queue all fragments atomically. We need to use spin_lock_bh",
        "\t\t * here because of 6LoWPAN links, as there this function is",
        "\t\t * called from softirq and using normal spin lock could cause",
        "\t\t * deadlocks.",
        "\t\t */",
        "\t\tspin_lock_bh(&queue->lock);",
        ""
      ]
    },
    {
      "file": "linux\\net\\bluetooth\\hci_sync.c",
      "line": 4052,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "Buffer Overflow",
      "context": [
        "\t\t\tif (!hdev->suspended)",
        "\t\t\t\tevents[0] |= 0x10; /* Disconnection Complete */",
        "\t\t\tevents[2] |= 0x04; /* Number of Completed Packets */",
        "\t\t\tevents[3] |= 0x02; /* Data Buffer Overflow */",
        "\t\t}",
        "",
        "\t\t/* If the controller supports the Read Remote Version"
      ]
    },
    {
      "file": "linux\\net\\bluetooth\\iso.c",
      "line": 1216,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\terr = iso_listen_cis(sk);",
        "\t} else {",
        "\t\t/* Drop sock lock to avoid potential",
        "\t\t * deadlock with the hdev lock.",
        "\t\t */",
        "\t\trelease_sock(sk);",
        "\t\terr = iso_listen_bis(sk);"
      ]
    },
    {
      "file": "linux\\net\\bluetooth\\l2cap_core.c",
      "line": 6378,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "{",
        "\t/* l2cap_reassemble_sdu may free skb, hence invalidate control, so store",
        "\t * the txseq field in advance to use it after l2cap_reassemble_sdu",
        "\t * returns and to avoid the race condition, for example:",
        "\t *",
        "\t * The current thread calls:",
        "\t *   l2cap_reassemble_sdu"
      ]
    },
    {
      "file": "linux\\net\\bluetooth\\l2cap_core.c",
      "line": 6714,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffers overflow",
      "context": [
        "\t\tgoto done;",
        "",
        "\tcase L2CAP_MODE_BASIC:",
        "\t\t/* If socket recv buffers overflows we drop data here",
        "\t\t * which is *bad* because L2CAP has to be reliable.",
        "\t\t * But we don't have any other choice. L2CAP doesn't",
        "\t\t * provide flow control mechanism. */"
      ]
    },
    {
      "file": "linux\\net\\bluetooth\\l2cap_core.c",
      "line": 6720,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\t * provide flow control mechanism. */",
        "",
        "\t\tif (chan->imtu < skb->len) {",
        "\t\t\tBT_ERR(\"Dropping L2CAP data: receive buffer overflow\");",
        "\t\t\tgoto drop;",
        "\t\t}",
        ""
      ]
    },
    {
      "file": "linux\\net\\bridge\\br_multicast.c",
      "line": 4694,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * an MLD Report/Leave to be delivered to br_multicast_rcv,",
        "\t * which would in turn call br_multicast_add_group, which would",
        "\t * attempt to acquire multicast_lock. This function should be",
        "\t * called after the lock has been released to avoid deadlocks on",
        "\t * multicast_lock.",
        "\t *",
        "\t * br_multicast_leave_snoopers does not have the problem since"
      ]
    },
    {
      "file": "linux\\net\\ceph\\messenger.c",
      "line": 1399,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "/*",
        " * Process message.  This happens in the worker thread.  The callback should",
        " * be careful not to do anything that waits on other incoming messages or it",
        " * may deadlock.",
        " */",
        "void ceph_con_process_message(struct ceph_connection *con)",
        "{"
      ]
    },
    {
      "file": "linux\\net\\core\\datagram.c",
      "line": 231,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " *\terror was detected.",
        " *",
        " *\t* It does not lock socket since today. This function is",
        " *\t* free of race conditions. This measure should/can improve",
        " *\t* significantly datagram socket latencies at high loads,",
        " *\t* when data copying to user space takes lots of time.",
        " *\t* (BTW I've just killed the last cli() in IP/IPv6/core/netlink/packet"
      ]
    },
    {
      "file": "linux\\net\\core\\dev.c",
      "line": 4609,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * this function. The function can be called from an interrupt.",
        " *",
        " * When calling this method, interrupts MUST be enabled. This is because",
        " * the BH enable code must have IRQs enabled so that it will not deadlock.",
        " *",
        " * Regardless of the return value, the skb is consumed, so it is currently",
        " * difficult to retry a send to this method. (You can bump the ref count"
      ]
    },
    {
      "file": "linux\\net\\core\\dev.c",
      "line": 4692,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * However, it is possible, that they rely on protection",
        "\t * made by us here.",
        "",
        "\t * Check this and shot the lock. It is not prone from deadlocks.",
        "\t *Either shot noqueue qdisc, it is even simpler 8)",
        "\t */",
        "\tif (dev->flags & IFF_UP) {"
      ]
    },
    {
      "file": "linux\\net\\core\\dev.c",
      "line": 11344,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * We are invoked by rtnl_unlock().",
        " * This allows us to deal with problems:",
        " * 1) We can delete sysfs objects which invoke hotplug",
        " *    without deadlocking with linkwatch via keventd.",
        " * 2) Since we run with the RTNL semaphore not held, we can sleep",
        " *    safely in order to wait for the netdev refcnt to drop to zero.",
        " *"
      ]
    },
    {
      "file": "linux\\net\\core\\dev.c",
      "line": 26,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double lock",
      "context": [
        " *\t\tAlan Cox\t:\tdevice private ioctl copies fields back.",
        " *\t\tAlan Cox\t:\tTransmit queue code does relevant",
        " *\t\t\t\t\tstunts to keep the queue safe.",
        " *\t\tAlan Cox\t:\tFixed double lock.",
        " *\t\tAlan Cox\t:\tFixed promisc NULL pointer trap",
        " *\t\t????????\t:\tSupport the full private ioctl range",
        " *\t\tAlan Cox\t:\tMoved ioctl permission check into"
      ]
    },
    {
      "file": "linux\\net\\core\\hwbm.c",
      "line": 65,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffers to the %d current buffers will overflow",
      "context": [
        "\t}",
        "",
        "\tif ((buf_num + bm_pool->buf_num) < bm_pool->buf_num) {",
        "\t\tpr_warn(\"Adding %d buffers to the %d current buffers will overflow\\n\",",
        "\t\t\tbuf_num,  bm_pool->buf_num);",
        "\t\tmutex_unlock(&bm_pool->buf_lock);",
        "\t\treturn 0;"
      ]
    },
    {
      "file": "linux\\net\\core\\neighbour.c",
      "line": 88,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "   - All the scans/updates to hash buckets MUST be made under this lock.",
        "   - NOTHING clever should be made under this lock: no callbacks",
        "     to protocol backends, no attempts to send something to network.",
        "     It will result in deadlocks, if backend/driver wants to use neighbour",
        "     cache.",
        "   - If the entry requires some non-trivial actions, increase",
        "     its reference count and release table lock."
      ]
    },
    {
      "file": "linux\\net\\core\\net-sysfs.c",
      "line": 46,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\treturn READ_ONCE(dev->reg_state) <= NETREG_REGISTERED;",
        "}",
        "",
        "/* There is a possible ABBA deadlock between rtnl_lock and kernfs_node->active,",
        " * when unregistering a net device and accessing associated sysfs files. The",
        " * potential deadlock is as follow:",
        " *"
      ]
    },
    {
      "file": "linux\\net\\core\\net-sysfs.c",
      "line": 48,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "/* There is a possible ABBA deadlock between rtnl_lock and kernfs_node->active,",
        " * when unregistering a net device and accessing associated sysfs files. The",
        " * potential deadlock is as follow:",
        " *",
        " *         CPU 0                                         CPU 1",
        " *"
      ]
    },
    {
      "file": "linux\\net\\core\\net-sysfs.c",
      "line": 98,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * (outside an rtnl lock section).",
        "\t */",
        "\tkn = sysfs_break_active_protection(kobj, attr);",
        "\t/* We can now try to take the rtnl lock. This can't deadlock us as the",
        "\t * unregistration path is able to drain sysfs files (kernfs_node) thanks",
        "\t * to the above dance.",
        "\t */"
      ]
    },
    {
      "file": "linux\\net\\core\\rtnetlink.c",
      "line": 136,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "DEADLOCK",
      "context": [
        "\t *     while (!list_empty(...))",
        "\t *       rtnl_lock()",
        "\t *\t\t\t\t  wiphy_lock()",
        "\t * **** DEADLOCK ****",
        "\t *",
        "\t * However, usage of __rtnl_unlock() is rare, and so we can ensure that",
        "\t * it's not used in cases where something is added to do the list."
      ]
    },
    {
      "file": "linux\\net\\core\\rtnetlink.c",
      "line": 602,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\tstruct rtnl_link_ops *tmp;",
        "\tint err;",
        "",
        "\t/* Sanity-check max sizes to avoid stack buffer overflow. */",
        "\tif (WARN_ON(ops->maxtype > RTNL_MAX_TYPE ||",
        "\t\t    ops->slave_maxtype > RTNL_SLAVE_MAX_TYPE))",
        "\t\treturn -EINVAL;"
      ]
    },
    {
      "file": "linux\\net\\core\\rtnetlink.c",
      "line": 602,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "stack buffer overflow",
      "context": [
        "\tstruct rtnl_link_ops *tmp;",
        "\tint err;",
        "",
        "\t/* Sanity-check max sizes to avoid stack buffer overflow. */",
        "\tif (WARN_ON(ops->maxtype > RTNL_MAX_TYPE ||",
        "\t\t    ops->slave_maxtype > RTNL_SLAVE_MAX_TYPE))",
        "\t\treturn -EINVAL;"
      ]
    },
    {
      "file": "linux\\net\\core\\sock_map.c",
      "line": 1701,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "stack overflow",
      "context": [
        "\t}",
        "",
        "\t/* Make sure we do not recurse. This is a bug.",
        "\t * Leak the socket instead of crashing on a stack overflow.",
        "\t */",
        "\tif (WARN_ON_ONCE(saved_close == sock_map_close))",
        "\t\treturn;"
      ]
    },
    {
      "file": "linux\\net\\devlink\\core.c",
      "line": 183,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * taken during the notification preparation.",
        " * However, since the devlink lock of nested instance is held here,",
        " * we would end with wrong devlink instance lock ordering and",
        " * deadlock. Therefore the work is utilized to avoid that.",
        " */",
        "void devlink_rel_nested_in_notify(struct devlink *devlink)",
        "{"
      ]
    },
    {
      "file": "linux\\net\\devlink\\region.c",
      "line": 391,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " *\tusers of the snapshot id.",
        " *",
        " *\tNote that the caller of this function counts as a 'user', in order to",
        " *\tavoid race conditions. The caller must release its hold on the",
        " *\tsnapshot by using devlink_region_snapshot_id_put.",
        " */",
        "static int __devlink_region_snapshot_id_get(struct devlink *devlink, u32 *id)"
      ]
    },
    {
      "file": "linux\\net\\ipv4\\arp.c",
      "line": 43,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Missing unlock",
      "context": [
        " *\t\t\t\t\teg intelligent arp probing and",
        " *\t\t\t\t\tgeneration",
        " *\t\t\t\t\tof host down events.",
        " *\t\tAlan Cox\t:\tMissing unlock in device events.",
        " *\t\tEckes\t\t:\tARP ioctl control errors.",
        " *\t\tAlexey Kuznetsov:\tArp free fix.",
        " *\t\tManuel Rodriguez:\tGratuitous ARP."
      ]
    },
    {
      "file": "linux\\net\\ipv4\\arp.c",
      "line": 22,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Double lock",
      "context": [
        " *\t\tStephen Henson\t:\tAdd AX25 support to arp_get_info()",
        " *\t\tAlan Cox\t:\tDrop data when a device is downed.",
        " *\t\tAlan Cox\t:\tUse init_timer().",
        " *\t\tAlan Cox\t:\tDouble lock fixes.",
        " *\t\tMartin Seine\t:\tMove the arphdr structure",
        " *\t\t\t\t\tto if_arp.h for compatibility.",
        " *\t\t\t\t\twith BSD based programs."
      ]
    },
    {
      "file": "linux\\net\\ipv4\\inet_connection_sock.c",
      "line": 611,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "EXPORT_SYMBOL_GPL(inet_csk_get_port);",
        "",
        "/*",
        " * Wait for an incoming connection, avoid race conditions. This must be called",
        " * with the socket locked.",
        " */",
        "static int inet_csk_wait_for_connect(struct sock *sk, long timeo)"
      ]
    },
    {
      "file": "linux\\net\\ipv4\\inet_connection_sock.c",
      "line": 1391,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\tBUG_ON(rcu_access_pointer(tcp_sk(child)->fastopen_rsk) != req);",
        "\t\tBUG_ON(sk != req->rsk_listener);",
        "",
        "\t\t/* Paranoid, to prevent race condition if",
        "\t\t * an inbound pkt destined for child is",
        "\t\t * blocked by sock lock in tcp_v4_rcv().",
        "\t\t * Also to satisfy an assertion in"
      ]
    },
    {
      "file": "linux\\net\\ipv4\\inet_connection_sock.c",
      "line": 259,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t/* Conflicts with an existing IPV6_ADDR_ANY (if ipv6) or INADDR_ANY (if",
        "\t * ipv4) should have been checked already. We need to do these two",
        "\t * checks separately because their spinlocks have to be acquired/released",
        "\t * independently of each other, to prevent possible deadlocks",
        "\t */",
        "\tif (inet_use_bhash2_on_bind(sk))",
        "\t\treturn tb2 && inet_bhash2_conflict(sk, tb2, uid, relax,"
      ]
    },
    {
      "file": "linux\\net\\ipv4\\ip_gre.c",
      "line": 55,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "stack overflow",
      "context": [
        "",
        "   1. The most important issue is detecting local dead loops.",
        "   They would cause complete host lockup in transmit, which",
        "   would be \"resolved\" by stack overflow or, if queueing is enabled,",
        "   with infinite looping in net_bh.",
        "",
        "   We cannot track such dead loops during route installation,"
      ]
    },
    {
      "file": "linux\\net\\ipv4\\ip_output.c",
      "line": 22,
      "pattern": "missing.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "Missing nonblock",
      "context": [
        " *\tSee ip_input.c for original log",
        " *",
        " *\tFixes:",
        " *\t\tAlan Cox\t:\tMissing nonblock feature in ip_build_xmit.",
        " *\t\tMike Kilburn\t:\thtons() missing in ip_build_xmit.",
        " *\t\tBradford Johnson:\tFix faulty handling of some frames when",
        " *\t\t\t\t\tno route is found."
      ]
    },
    {
      "file": "linux\\net\\ipv4\\route.c",
      "line": 50,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "Race condition",
      "context": [
        " *\t\t\t\t\troute.c and rewritten from scratch.",
        " *\t\tAndi Kleen\t:\tLoad-limit warning messages.",
        " *\tVitaly E. Lavrov\t:\tTransparent proxy revived after year coma.",
        " *\tVitaly E. Lavrov\t:\tRace condition in ip_route_input_slow.",
        " *\tTobias Ringstrom\t:\tUninitialized res.type in ip_route_output_slow.",
        " *\tVladimir V. Ivanov\t:\tIP rule info (flowid) is really useful.",
        " *\t\tMarc Boucher\t:\trouting by fwmark"
      ]
    },
    {
      "file": "linux\\net\\ipv4\\route.c",
      "line": 1493,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t}",
        "\torig = *p;",
        "",
        "\t/* hold dst before doing cmpxchg() to avoid race condition",
        "\t * on this dst",
        "\t */",
        "\tdst_hold(&rt->dst);"
      ]
    },
    {
      "file": "linux\\net\\ipv4\\tcp_bbr.c",
      "line": 341,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\t\tbbr->idle_restart = 1;",
        "\t\tbbr->ack_epoch_mstamp = tp->tcp_mstamp;",
        "\t\tbbr->ack_epoch_acked = 0;",
        "\t\t/* Avoid pointless buffer overflows: pace at est. bw if we don't",
        "\t\t * need more speed (we're restarting from idle and app-limited).",
        "\t\t */",
        "\t\tif (bbr->mode == BBR_PROBE_BW)"
      ]
    },
    {
      "file": "linux\\net\\ipv4\\tcp_input.c",
      "line": 5894,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * such data and will stay in TCP_URG_NOTYET until will be eaten",
        "\t * by recvmsg(). Seems, we are not obliged to handle such wicked",
        "\t * situations. But it is worth to think about possibility of some",
        "\t * DoSes using some hypothetical application level deadlock.",
        "\t */",
        "\tif (before(ptr, tp->rcv_nxt))",
        "\t\treturn;"
      ]
    },
    {
      "file": "linux\\net\\ipv4\\tcp_ipv4.c",
      "line": 1899,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double-lock",
      "context": [
        "/* The socket must have it's spinlock held when we get",
        " * here, unless it is a TCP_LISTEN socket.",
        " *",
        " * We have a potential double-lock case here, so even when",
        " * doing backlog processing we use the BH locking scheme.",
        " * This is because we cannot sleep with the original spinlock",
        " * held."
      ]
    },
    {
      "file": "linux\\net\\ipv4\\tcp_minisocks.c",
      "line": 933,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * the new socket.",
        " *",
        " * For the vast majority of cases child->sk_state will be TCP_SYN_RECV",
        " * when entering. But other states are possible due to a race condition",
        " * where after __inet_lookup_established() fails but before the listener",
        " * locked is obtained, other packets cause the same connection to",
        " * be created."
      ]
    },
    {
      "file": "linux\\net\\ipv4\\tcp_minisocks.c",
      "line": 517,
      "pattern": "code.*duplication",
      "rule": "code_quality",
      "severity": "low",
      "match": "code duplication",
      "context": [
        "}",
        "",
        "/* This is not only more efficient than what we used to do, it eliminates",
        " * a lot of code duplication between IPv4/IPv6 SYN recv processing. -DaveM",
        " *",
        " * Actually, we could lots of memory writes here. tp of listening",
        " * socket contains all necessary default parameters."
      ]
    },
    {
      "file": "linux\\net\\ipv4\\udp_tunnel_nic.c",
      "line": 293,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\tutn->need_sync = 0;",
        "\t/* Can't replay directly here, in case we come from the tunnel driver's",
        "\t * notification - trying to replay may deadlock inside tunnel driver.",
        "\t */",
        "\tutn->need_replay = udp_tunnel_nic_should_replay(dev, utn);",
        "}"
      ]
    },
    {
      "file": "linux\\net\\ipv6\\tcp_ipv6.c",
      "line": 1587,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double-lock",
      "context": [
        "/* The socket must have it's spinlock held when we get",
        " * here, unless it is a TCP_LISTEN socket.",
        " *",
        " * We have a potential double-lock case here, so even when",
        " * doing backlog processing we use the BH locking scheme.",
        " * This is because we cannot sleep with the original spinlock",
        " * held."
      ]
    },
    {
      "file": "linux\\net\\kcm\\kcmsock.c",
      "line": 1265,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\twrite_lock_bh(&csk->sk_callback_lock);",
        "",
        "\t/* Check if sk_user_data is already by KCM or someone else.",
        "\t * Must be done under lock to prevent race conditions.",
        "\t */",
        "\tif (csk->sk_user_data) {",
        "\t\twrite_unlock_bh(&csk->sk_callback_lock);"
      ]
    },
    {
      "file": "linux\\net\\kcm\\kcmsock.c",
      "line": 1685,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tsock_orphan(sk);",
        "\tkfree_skb(kcm->seq_skb);",
        "",
        "\t/* Purge queue under lock to avoid race condition with tx_work trying",
        "\t * to act when queue is nonempty. If tx_work runs after this point",
        "\t * it will just return.",
        "\t */"
      ]
    },
    {
      "file": "linux\\net\\mac80211\\debugfs_sta.c",
      "line": 1246,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tsnprintf(mac, sizeof(mac), \"%pM\", sta->sta.addr);",
        "",
        "\t/*",
        "\t * This might fail due to a race condition:",
        "\t * When mac80211 unlinks a station, the debugfs entries",
        "\t * remain, but it is already possible to link a new",
        "\t * station with the same address which triggers adding"
      ]
    },
    {
      "file": "linux\\net\\mac80211\\mesh_hwmp.c",
      "line": 231,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * @ra: node this frame is addressed to",
        " *",
        " * Note: This function may be called with driver locks taken that the driver",
        " * also acquires in the TX path.  To avoid a deadlock we don't transmit the",
        " * frame directly but add it to the pending queue instead.",
        " *",
        " * Returns: 0 on success"
      ]
    },
    {
      "file": "linux\\net\\mac80211\\main.c",
      "line": 592,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * hold the notifier rwsem, that's the normal case. And yes,",
        "\t * we also acquire the notifier rwsem again when unregistering",
        "\t * a netdev while we already hold the wiphy mutex, so it does",
        "\t * look like a typical ABBA deadlock.",
        "\t *",
        "\t * However, both of these things happen with the RTNL held",
        "\t * already. Therefore, they can't actually happen, since the"
      ]
    },
    {
      "file": "linux\\net\\mac80211\\sta_info.c",
      "line": 2015,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\t\tint tid, ac;",
        "",
        "\t\t/*",
        "\t\t * For PS-Poll, this can only happen due to a race condition",
        "\t\t * when we set the TIM bit and the station notices it, but",
        "\t\t * before it can poll for the frame we expire it.",
        "\t\t *"
      ]
    },
    {
      "file": "linux\\net\\mac80211\\tx.c",
      "line": 1825,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "/*",
        " * Late handlers can be called while the sta lock is held. Handlers that can",
        " * cause packets to be generated will cause deadlock!",
        " */",
        "static int invoke_tx_handlers_late(struct ieee80211_tx_data *tx)",
        "{"
      ]
    },
    {
      "file": "linux\\net\\mac80211\\tx.c",
      "line": 3529,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "/*",
        " * Can be called while the sta lock is held. Anything that can cause packets to",
        " * be generated will cause deadlock!",
        " */",
        "static ieee80211_tx_result",
        "ieee80211_xmit_fast_finish(struct ieee80211_sub_if_data *sdata,"
      ]
    },
    {
      "file": "linux\\net\\mac80211\\util.c",
      "line": 1802,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * cancel restart work, as we are reconfiguring the device",
        "\t * anyway.",
        "\t * Note that restart_work is scheduled on a frozen workqueue,",
        "\t * so we can't deadlock in this case.",
        "\t */",
        "\tif (suspended && local->in_reconfig && !reconfig_due_to_wowlan)",
        "\t\tcancel_work_sync(&local->restart_work);"
      ]
    },
    {
      "file": "linux\\net\\mptcp\\pm.c",
      "line": 795,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double check after the lock",
      "context": [
        "",
        "\tspin_lock_bh(&msk->pm.lock);",
        "",
        "\t/* double check after the lock is acquired */",
        "\tif (!mptcp_pm_should_add_signal(msk))",
        "\t\tgoto out_unlock;",
        ""
      ]
    },
    {
      "file": "linux\\net\\mptcp\\pm.c",
      "line": 838,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double check after the lock",
      "context": [
        "",
        "\tspin_lock_bh(&msk->pm.lock);",
        "",
        "\t/* double check after the lock is acquired */",
        "\tif (!mptcp_pm_should_rm_signal(msk))",
        "\t\tgoto out_unlock;",
        ""
      ]
    },
    {
      "file": "linux\\net\\mptcp\\protocol.c",
      "line": 730,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "}",
        "",
        "/* In most cases we will be able to lock the mptcp socket.  If its already",
        " * owned, we need to defer to the work queue to avoid ABBA deadlock.",
        " */",
        "static bool move_skbs_to_msk(struct mptcp_sock *msk, struct sock *ssk)",
        "{"
      ]
    },
    {
      "file": "linux\\net\\mptcp\\protocol.c",
      "line": 3363,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t/* the following actions acquire the subflow socket lock",
        "\t\t *",
        "\t\t * 1) can't be invoked in atomic scope",
        "\t\t * 2) must avoid ABBA deadlock with msk socket spinlock: the RX",
        "\t\t *    datapath acquires the msk socket spinlock while helding",
        "\t\t *    the subflow socket lock",
        "\t\t */"
      ]
    },
    {
      "file": "linux\\net\\mptcp\\subflow.c",
      "line": 1894,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\treturn;",
        "",
        "\t/* can't acquire the msk socket lock under the subflow one,",
        "\t * or will cause ABBA deadlock",
        "\t */",
        "\trelease_sock(listener_ssk);",
        ""
      ]
    },
    {
      "file": "linux\\net\\mptcp\\subflow.c",
      "line": 1914,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t__mptcp_unaccepted_force_close(sk);",
        "\t\trelease_sock(sk);",
        "",
        "\t\t/* lockdep will report a false positive ABBA deadlock",
        "\t\t * between cancel_work_sync and the listener socket.",
        "\t\t * The involved locks belong to different sockets WRT",
        "\t\t * the existing AB chain."
      ]
    },
    {
      "file": "linux\\net\\netfilter\\nfnetlink.c",
      "line": 121,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "{",
        "\tu8 cb_id;",
        "",
        "\t/* Sanity-check attr_count size to avoid stack buffer overflow. */",
        "\tfor (cb_id = 0; cb_id < n->cb_count; cb_id++)",
        "\t\tif (WARN_ON(n->cb[cb_id].attr_count > NFNL_MAX_ATTR_COUNT))",
        "\t\t\treturn -EINVAL;"
      ]
    },
    {
      "file": "linux\\net\\netfilter\\nfnetlink.c",
      "line": 121,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "stack buffer overflow",
      "context": [
        "{",
        "\tu8 cb_id;",
        "",
        "\t/* Sanity-check attr_count size to avoid stack buffer overflow. */",
        "\tfor (cb_id = 0; cb_id < n->cb_count; cb_id++)",
        "\t\tif (WARN_ON(n->cb[cb_id].attr_count > NFNL_MAX_ATTR_COUNT))",
        "\t\t\treturn -EINVAL;"
      ]
    },
    {
      "file": "linux\\net\\netfilter\\nf_conntrack_core.c",
      "line": 1657,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tunsigned int ct_count;",
        "\tstruct nf_conn *ct;",
        "",
        "\t/* We don't want any race condition at early drop stage */",
        "\tct_count = atomic_inc_return(&cnet->count);",
        "",
        "\tif (nf_conntrack_max && unlikely(ct_count > nf_conntrack_max)) {"
      ]
    },
    {
      "file": "linux\\net\\netfilter\\nf_conntrack_core.c",
      "line": 129,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "}",
        "EXPORT_SYMBOL_GPL(nf_conntrack_lock);",
        "",
        "static void nf_conntrack_double_unlock(unsigned int h1, unsigned int h2)",
        "{",
        "\th1 %= CONNTRACK_LOCKS;",
        "\th2 %= CONNTRACK_LOCKS;"
      ]
    },
    {
      "file": "linux\\net\\netfilter\\nf_conntrack_core.c",
      "line": 139,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "}",
        "",
        "/* return true if we need to recompute hashes (in case hash table was resized) */",
        "static bool nf_conntrack_double_lock(struct net *net, unsigned int h1,",
        "\t\t\t\t     unsigned int h2, unsigned int sequence)",
        "{",
        "\th1 %= CONNTRACK_LOCKS;"
      ]
    },
    {
      "file": "linux\\net\\netfilter\\nf_conntrack_core.c",
      "line": 155,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\t\t\t\t SINGLE_DEPTH_NESTING);",
        "\t}",
        "\tif (read_seqcount_retry(&nf_conntrack_generation, sequence)) {",
        "\t\tnf_conntrack_double_unlock(h1, h2);",
        "\t\treturn true;",
        "\t}",
        "\treturn false;"
      ]
    },
    {
      "file": "linux\\net\\netfilter\\nf_conntrack_core.c",
      "line": 619,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "\t\treply_hash = hash_conntrack(net,",
        "\t\t\t\t\t   &ct->tuplehash[IP_CT_DIR_REPLY].tuple,",
        "\t\t\t\t\t   nf_ct_zone_id(nf_ct_zone(ct), IP_CT_DIR_REPLY));",
        "\t} while (nf_conntrack_double_lock(net, hash, reply_hash, sequence));",
        "",
        "\tclean_from_lists(ct);",
        "\tnf_conntrack_double_unlock(hash, reply_hash);"
      ]
    },
    {
      "file": "linux\\net\\netfilter\\nf_conntrack_core.c",
      "line": 622,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\t} while (nf_conntrack_double_lock(net, hash, reply_hash, sequence));",
        "",
        "\tclean_from_lists(ct);",
        "\tnf_conntrack_double_unlock(hash, reply_hash);",
        "}",
        "",
        "static void nf_ct_delete_from_lists(struct nf_conn *ct)"
      ]
    },
    {
      "file": "linux\\net\\netfilter\\nf_conntrack_core.c",
      "line": 896,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "\t\treply_hash = hash_conntrack(net,",
        "\t\t\t\t\t   &ct->tuplehash[IP_CT_DIR_REPLY].tuple,",
        "\t\t\t\t\t   nf_ct_zone_id(nf_ct_zone(ct), IP_CT_DIR_REPLY));",
        "\t} while (nf_conntrack_double_lock(net, hash, reply_hash, sequence));",
        "",
        "\tmax_chainlen = MIN_CHAINLEN + get_random_u32_below(MAX_CHAINLEN);",
        ""
      ]
    },
    {
      "file": "linux\\net\\netfilter\\nf_conntrack_core.c",
      "line": 936,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\t/* The caller holds a reference to this object */",
        "\trefcount_set(&ct->ct_general.use, 2);",
        "\t__nf_conntrack_hash_insert(ct, hash, reply_hash);",
        "\tnf_conntrack_double_unlock(hash, reply_hash);",
        "\tNF_CT_STAT_INC(net, insert);",
        "\tlocal_bh_enable();",
        ""
      ]
    },
    {
      "file": "linux\\net\\netfilter\\nf_conntrack_core.c",
      "line": 945,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\tNF_CT_STAT_INC(net, chaintoolong);",
        "\terr = -ENOSPC;",
        "out:",
        "\tnf_conntrack_double_unlock(hash, reply_hash);",
        "\tlocal_bh_enable();",
        "\treturn err;",
        "}"
      ]
    },
    {
      "file": "linux\\net\\netfilter\\nf_conntrack_core.c",
      "line": 1234,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "\t\treply_hash = hash_conntrack(net,",
        "\t\t\t\t\t   &ct->tuplehash[IP_CT_DIR_REPLY].tuple,",
        "\t\t\t\t\t   nf_ct_zone_id(nf_ct_zone(ct), IP_CT_DIR_REPLY));",
        "\t} while (nf_conntrack_double_lock(net, hash, reply_hash, sequence));",
        "",
        "\t/* We're not in hash table, and we refuse to set up related",
        "\t * connections for unconfirmed conns.  But packet copies and"
      ]
    },
    {
      "file": "linux\\net\\netfilter\\nf_conntrack_core.c",
      "line": 1248,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\t */",
        "\tif (unlikely(nf_ct_is_confirmed(ct))) {",
        "\t\tWARN_ON_ONCE(1);",
        "\t\tnf_conntrack_double_unlock(hash, reply_hash);",
        "\t\tlocal_bh_enable();",
        "\t\treturn NF_DROP;",
        "\t}"
      ]
    },
    {
      "file": "linux\\net\\netfilter\\nf_conntrack_core.c",
      "line": 1309,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\t * stores are visible.",
        "\t */",
        "\t__nf_conntrack_hash_insert(ct, hash, reply_hash);",
        "\tnf_conntrack_double_unlock(hash, reply_hash);",
        "\tlocal_bh_enable();",
        "",
        "\t/* ext area is still valid (rcu read lock is held,"
      ]
    },
    {
      "file": "linux\\net\\netfilter\\nf_conntrack_core.c",
      "line": 1333,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "out:",
        "\tret = nf_ct_resolve_clash(skb, h, reply_hash);",
        "dying:",
        "\tnf_conntrack_double_unlock(hash, reply_hash);",
        "\tlocal_bh_enable();",
        "\treturn ret;",
        "}"
      ]
    },
    {
      "file": "linux\\net\\netfilter\\nf_conntrack_ftp.c",
      "line": 413,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t}",
        "\tdatalen = skb->len - dataoff;",
        "",
        "\t/* seqadj (nat) uses ct->lock internally, nf_nat_ftp would cause deadlock */",
        "\tspin_lock_bh(&nf_ftp_lock);",
        "\tfb_ptr = skb->data + dataoff;",
        ""
      ]
    },
    {
      "file": "linux\\net\\netlink\\af_netlink.c",
      "line": 740,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\tnlk->netlink_release(sk, nlk->groups);",
        "",
        "\t/* must not acquire netlink_table_lock in any way again before unbind",
        "\t * and notifying genetlink is done as otherwise it might deadlock",
        "\t */",
        "\tif (nlk->netlink_unbind) {",
        "\t\tint i;"
      ]
    },
    {
      "file": "linux\\net\\rds\\cong.c",
      "line": 236,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t\t * 1. When we get here from the receive path, we",
        "\t\t\t *    are already holding the sock_lock (held by",
        "\t\t\t *    tcp_v4_rcv()). So inlining calls to",
        "\t\t\t *    tcp_setsockopt and/or tcp_sendmsg will deadlock",
        "\t\t\t *    when it tries to get the sock_lock())",
        "\t\t\t * 2. Interrupts are masked so that we can mark the",
        "\t\t\t *    port congested from both send and recv paths."
      ]
    },
    {
      "file": "linux\\net\\rds\\connection.c",
      "line": 377,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t\t * Quiesce the connection mgmt handlers before we start tearing",
        "\t\t * things down. We don't hold the mutex for the entire",
        "\t\t * duration of the shutdown operation, else we may be",
        "\t\t * deadlocking with the CM handler. Instead, the CM event",
        "\t\t * handler is supposed to check for state DISCONNECTING",
        "\t\t */",
        "\t\tmutex_lock(&cp->cp_cm_lock);"
      ]
    },
    {
      "file": "linux\\net\\rds\\tcp.c",
      "line": 163,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * rds_send_xmi() threads through, so ideally we would",
        "\t * synchronize on RDS_CONN_UP after lock_sock(), but cannot",
        "\t * do that: waiting on !RDS_IN_XMIT after lock_sock() may",
        "\t * end up deadlocking with tcp_sendmsg(), and the RDS_IN_XMIT",
        "\t * would not get set. As a result, we set c_state to",
        "\t * RDS_CONN_RESETTTING, to ensure that rds_tcp_state_change",
        "\t * cannot mark rds_conn_path_up() in the window before lock_sock()"
      ]
    },
    {
      "file": "linux\\net\\rfkill\\core.c",
      "line": 96,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        " * The locking here should be made much smarter, we currently have",
        " * a bit of a stupid situation because drivers might want to register",
        " * the rfkill struct under their own lock, and take this lock during",
        " * rfkill method calls -- which will cause an AB-BA deadlock situation.",
        " *",
        " * To fix that, we need to rework this code here to be mostly lock-free",
        " * and only use the mutex for list manipulations, not to protect the"
      ]
    },
    {
      "file": "linux\\net\\rxrpc\\call_object.c",
      "line": 133,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\tmutex_init(&call->user_mutex);",
        "",
        "\t/* Prevent lockdep reporting a deadlock false positive between the afs",
        "\t * filesystem and sys_sendmsg() via the mmap sem.",
        "\t */",
        "\tif (rx->sk.sk_kern_sock)"
      ]
    },
    {
      "file": "linux\\net\\sched\\ematch.c",
      "line": 513,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "stack_overflow",
      "context": [
        "",
        "\t\tif (tcf_em_is_container(cur_match)) {",
        "\t\t\tif (unlikely(stackp >= CONFIG_NET_EMATCH_STACK))",
        "\t\t\t\tgoto stack_overflow;",
        "",
        "\t\t\tstack[stackp++] = match_idx;",
        "\t\t\tmatch_idx = cur_match->data;"
      ]
    },
    {
      "file": "linux\\net\\sched\\ematch.c",
      "line": 546,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "stack_overflow",
      "context": [
        "",
        "\treturn res;",
        "",
        "stack_overflow:",
        "\tnet_warn_ratelimited(\"tc ematch: local stack overflow, increase NET_EMATCH_STACK\\n\");",
        "\treturn -1;",
        "}"
      ]
    },
    {
      "file": "linux\\net\\sched\\ematch.c",
      "line": 547,
      "pattern": "stack.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "stack overflow",
      "context": [
        "\treturn res;",
        "",
        "stack_overflow:",
        "\tnet_warn_ratelimited(\"tc ematch: local stack overflow, increase NET_EMATCH_STACK\\n\");",
        "\treturn -1;",
        "}",
        "EXPORT_SYMBOL(__tcf_em_tree_match);"
      ]
    },
    {
      "file": "linux\\net\\sched\\sch_cake.c",
      "line": 205,
      "pattern": "heap.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "heap_entry overflow",
      "context": [
        "\tstruct tcf_block *block;",
        "\tstruct cake_tin_data *tins;",
        "",
        "\tstruct cake_heap_entry overflow_heap[CAKE_QUEUES * CAKE_MAX_TINS];",
        "\tu16\t\toverflow_timeout;",
        "",
        "\tu16\t\ttin_cnt;"
      ]
    },
    {
      "file": "linux\\net\\sched\\sch_cake.c",
      "line": 1445,
      "pattern": "heap.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "heap_entry ii = q->overflow",
      "context": [
        "",
        "static void cake_heap_swap(struct cake_sched_data *q, u16 i, u16 j)",
        "{",
        "\tstruct cake_heap_entry ii = q->overflow_heap[i];",
        "\tstruct cake_heap_entry jj = q->overflow_heap[j];",
        "",
        "\tq->overflow_heap[i] = jj;"
      ]
    },
    {
      "file": "linux\\net\\sched\\sch_cake.c",
      "line": 1446,
      "pattern": "heap.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "heap_entry jj = q->overflow",
      "context": [
        "static void cake_heap_swap(struct cake_sched_data *q, u16 i, u16 j)",
        "{",
        "\tstruct cake_heap_entry ii = q->overflow_heap[i];",
        "\tstruct cake_heap_entry jj = q->overflow_heap[j];",
        "",
        "\tq->overflow_heap[i] = jj;",
        "\tq->overflow_heap[j] = ii;"
      ]
    },
    {
      "file": "linux\\net\\sched\\sch_cake.c",
      "line": 1457,
      "pattern": "heap.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "heap_entry ii = q->overflow",
      "context": [
        "",
        "static u32 cake_heap_get_backlog(const struct cake_sched_data *q, u16 i)",
        "{",
        "\tstruct cake_heap_entry ii = q->overflow_heap[i];",
        "",
        "\treturn q->tins[ii.t].backlogs[ii.b];",
        "}"
      ]
    },
    {
      "file": "linux\\net\\sched\\sch_cake.c",
      "line": 1855,
      "pattern": "heap.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "heapify_up(q, b->overflow",
      "context": [
        "\t}",
        "",
        "\tif (q->overflow_timeout)",
        "\t\tcake_heapify_up(q, b->overflow_idx[idx]);",
        "",
        "\t/* incoming bandwidth capacity estimate */",
        "\tif (q->rate_flags & CAKE_FLAG_AUTORATE_INGRESS) {"
      ]
    },
    {
      "file": "linux\\net\\sched\\sch_cake.c",
      "line": 1956,
      "pattern": "heap.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "heapify(q, b->overflow",
      "context": [
        "\t\tsch->q.qlen--;",
        "",
        "\t\tif (q->overflow_timeout)",
        "\t\t\tcake_heapify(q, b->overflow_idx[q->cur_flow]);",
        "\t}",
        "\treturn skb;",
        "}"
      ]
    },
    {
      "file": "linux\\net\\sctp\\socket.c",
      "line": 1025,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer to overflow",
      "context": [
        "\t\taf = sctp_get_af_specific(sa_addr->sa_family);",
        "",
        "\t\t/* If the address family is not supported or if this address",
        "\t\t * causes the address buffer to overflow return EINVAL.",
        "\t\t */",
        "\t\tif (!af || (walk_size + af->sockaddr_len) > addrs_size)",
        "\t\t\treturn -EINVAL;"
      ]
    },
    {
      "file": "linux\\net\\sunrpc\\svcsock.c",
      "line": 1410,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        "\tsvsk->sk_odata = inet->sk_data_ready;",
        "\tsvsk->sk_owspace = inet->sk_write_space;",
        "\t/*",
        "\t * This barrier is necessary in order to prevent race condition",
        "\t * with svc_data_ready(), svc_tcp_listen_data_ready(), and others",
        "\t * when calling callbacks above.",
        "\t */"
      ]
    },
    {
      "file": "linux\\net\\sunrpc\\xdr.c",
      "line": 2258,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        " *",
        " * Return values:",
        " *   On success, returns size of object stored in *@ptr",
        " *   %-EBADMSG on XDR buffer overflow",
        " *   %-EMSGSIZE on overflow of storage buffer @ptr",
        " */",
        "ssize_t xdr_stream_decode_opaque(struct xdr_stream *xdr, void *ptr, size_t size)"
      ]
    },
    {
      "file": "linux\\net\\sunrpc\\xdr.c",
      "line": 2283,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        " *",
        " * Return values:",
        " *   On success, returns size of object stored in *@ptr",
        " *   %-EBADMSG on XDR buffer overflow",
        " *   %-EMSGSIZE if the size of the object would exceed @maxlen",
        " *   %-ENOMEM on memory allocation failure",
        " */"
      ]
    },
    {
      "file": "linux\\net\\sunrpc\\xdr.c",
      "line": 2313,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        " *",
        " * Return values:",
        " *   On success, returns length of NUL-terminated string stored in *@str",
        " *   %-EBADMSG on XDR buffer overflow",
        " *   %-EMSGSIZE on overflow of storage buffer @str",
        " */",
        "ssize_t xdr_stream_decode_string(struct xdr_stream *xdr, char *str, size_t size)"
      ]
    },
    {
      "file": "linux\\net\\sunrpc\\xdr.c",
      "line": 2341,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        " *",
        " * Return values:",
        " *   On success, returns length of NUL-terminated string stored in *@ptr",
        " *   %-EBADMSG on XDR buffer overflow",
        " *   %-EMSGSIZE if the size of the string would exceed @maxlen",
        " *   %-ENOMEM on memory allocation failure",
        " */"
      ]
    },
    {
      "file": "linux\\net\\sunrpc\\xdr.c",
      "line": 2374,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        " *",
        " * Return values:",
        " *   On success, returns the number of buffer bytes consumed",
        " *   %-EBADMSG on XDR buffer overflow",
        " *   %-EMSGSIZE if the decoded size of the body field exceeds 400 octets",
        " */",
        "ssize_t xdr_stream_decode_opaque_auth(struct xdr_stream *xdr, u32 *flavor,"
      ]
    },
    {
      "file": "linux\\net\\sunrpc\\xdr.c",
      "line": 2402,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        " *",
        " * Return values:",
        " *   On success, returns length in bytes of XDR buffer consumed",
        " *   %-EBADMSG on XDR buffer overflow",
        " *   %-EMSGSIZE if the size of @body exceeds 400 octets",
        " */",
        "ssize_t xdr_stream_encode_opaque_auth(struct xdr_stream *xdr, u32 flavor,"
      ]
    },
    {
      "file": "linux\\net\\tipc\\socket.c",
      "line": 783,
      "pattern": "race.*condition",
      "rule": "concurrency",
      "severity": "high",
      "match": "race condition",
      "context": [
        " * It appears that the usual socket locking mechanisms are not useful here",
        " * since the pollmask info is potentially out-of-date the moment this routine",
        " * exits.  TCP and other protocols seem to rely on higher level poll routines",
        " * to handle any preventable race conditions, so TIPC will do the same ...",
        " *",
        " * IMPORTANT: The fact that a read or write operation is indicated does NOT",
        " * imply that the operation will succeed, merely that it should be performed"
      ]
    },
    {
      "file": "linux\\net\\tipc\\socket.c",
      "line": 263,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer size to avoid receive queue overflow",
      "context": [
        "\t\treturn;",
        "\tif (!(tsk->peer_caps & TIPC_NAGLE))",
        "\t\treturn;",
        "\t/* Limit node local buffer size to avoid receive queue overflow */",
        "\tif (tsk->max_pkt == MAX_MSG_SIZE)",
        "\t\ttsk->maxnagle = 1500;",
        "\telse"
      ]
    },
    {
      "file": "linux\\net\\unix\\af_unix.c",
      "line": 1694,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t}",
        "",
        "\t/* self connect and simultaneous connect are eliminated",
        "\t * by rejecting TCP_LISTEN socket to avoid deadlock.",
        "\t */",
        "\tstate = READ_ONCE(sk->sk_state);",
        "\tif (unlikely(state != TCP_CLOSE)) {"
      ]
    },
    {
      "file": "linux\\net\\unix\\af_unix.c",
      "line": 175,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "\t\t}",
        "\t}",
        "",
        "\t/* unix_state_double_lock(): ascending address order. */",
        "\treturn cmp_ptr(a, b);",
        "}",
        ""
      ]
    },
    {
      "file": "linux\\net\\unix\\af_unix.c",
      "line": 228,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "\treturn UNIX_HASH_MOD + 1 + (hash & UNIX_HASH_MOD);",
        "}",
        "",
        "static void unix_table_double_lock(struct net *net,",
        "\t\t\t\t   unsigned int hash1, unsigned int hash2)",
        "{",
        "\tif (hash1 == hash2) {"
      ]
    },
    {
      "file": "linux\\net\\unix\\af_unix.c",
      "line": 243,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\tspin_lock(&net->unx.table.locks[hash2]);",
        "}",
        "",
        "static void unix_table_double_unlock(struct net *net,",
        "\t\t\t\t     unsigned int hash1, unsigned int hash2)",
        "{",
        "\tif (hash1 == hash2) {"
      ]
    },
    {
      "file": "linux\\net\\unix\\af_unix.c",
      "line": 1296,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "\tsprintf(addr->name->sun_path + 1, \"%05x\", ordernum);",
        "",
        "\tnew_hash = unix_abstract_hash(addr->name, addr->len, sk->sk_type);",
        "\tunix_table_double_lock(net, old_hash, new_hash);",
        "",
        "\tif (__unix_find_socket_byname(net, addr->name, addr->len, new_hash)) {",
        "\t\tunix_table_double_unlock(net, old_hash, new_hash);"
      ]
    },
    {
      "file": "linux\\net\\unix\\af_unix.c",
      "line": 1299,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\tunix_table_double_lock(net, old_hash, new_hash);",
        "",
        "\tif (__unix_find_socket_byname(net, addr->name, addr->len, new_hash)) {",
        "\t\tunix_table_double_unlock(net, old_hash, new_hash);",
        "",
        "\t\t/* __unix_find_socket_byname() may take long time if many names",
        "\t\t * are already in use."
      ]
    },
    {
      "file": "linux\\net\\unix\\af_unix.c",
      "line": 1317,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\t}",
        "",
        "\t__unix_set_addr_hash(net, sk, addr, new_hash);",
        "\tunix_table_double_unlock(net, old_hash, new_hash);",
        "\terr = 0;",
        "",
        "out:\tmutex_unlock(&u->bindlock);"
      ]
    },
    {
      "file": "linux\\net\\unix\\af_unix.c",
      "line": 1370,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "",
        "\told_hash = sk->sk_hash;",
        "\tnew_hash = unix_bsd_hash(d_backing_inode(dentry));",
        "\tunix_table_double_lock(net, old_hash, new_hash);",
        "\tu->path.mnt = mntget(parent.mnt);",
        "\tu->path.dentry = dget(dentry);",
        "\t__unix_set_addr_hash(net, sk, addr, new_hash);"
      ]
    },
    {
      "file": "linux\\net\\unix\\af_unix.c",
      "line": 1374,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\tu->path.mnt = mntget(parent.mnt);",
        "\tu->path.dentry = dget(dentry);",
        "\t__unix_set_addr_hash(net, sk, addr, new_hash);",
        "\tunix_table_double_unlock(net, old_hash, new_hash);",
        "\tunix_insert_bsd_socket(sk);",
        "\tmutex_unlock(&u->bindlock);",
        "\tdone_path_create(&parent, dentry);"
      ]
    },
    {
      "file": "linux\\net\\unix\\af_unix.c",
      "line": 1417,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "",
        "\told_hash = sk->sk_hash;",
        "\tnew_hash = unix_abstract_hash(addr->name, addr->len, sk->sk_type);",
        "\tunix_table_double_lock(net, old_hash, new_hash);",
        "",
        "\tif (__unix_find_socket_byname(net, addr->name, addr->len, new_hash))",
        "\t\tgoto out_spin;"
      ]
    },
    {
      "file": "linux\\net\\unix\\af_unix.c",
      "line": 1423,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\t\tgoto out_spin;",
        "",
        "\t__unix_set_addr_hash(net, sk, addr, new_hash);",
        "\tunix_table_double_unlock(net, old_hash, new_hash);",
        "\tmutex_unlock(&u->bindlock);",
        "\treturn 0;",
        ""
      ]
    },
    {
      "file": "linux\\net\\unix\\af_unix.c",
      "line": 1428,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\treturn 0;",
        "",
        "out_spin:",
        "\tunix_table_double_unlock(net, old_hash, new_hash);",
        "\terr = -EADDRINUSE;",
        "out_mutex:",
        "\tmutex_unlock(&u->bindlock);"
      ]
    },
    {
      "file": "linux\\net\\unix\\af_unix.c",
      "line": 1459,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "\treturn err;",
        "}",
        "",
        "static void unix_state_double_lock(struct sock *sk1, struct sock *sk2)",
        "{",
        "\tif (unlikely(sk1 == sk2) || !sk2) {",
        "\t\tunix_state_lock(sk1);"
      ]
    },
    {
      "file": "linux\\net\\unix\\af_unix.c",
      "line": 1473,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\tunix_state_lock(sk2);",
        "}",
        "",
        "static void unix_state_double_unlock(struct sock *sk1, struct sock *sk2)",
        "{",
        "\tif (unlikely(sk1 == sk2) || !sk2) {",
        "\t\tunix_state_unlock(sk1);"
      ]
    },
    {
      "file": "linux\\net\\unix\\af_unix.c",
      "line": 1517,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "\t\t\tgoto out;",
        "\t\t}",
        "",
        "\t\tunix_state_double_lock(sk, other);",
        "",
        "\t\t/* Apparently VFS overslept socket death. Retry. */",
        "\t\tif (sock_flag(other, SOCK_DEAD)) {"
      ]
    },
    {
      "file": "linux\\net\\unix\\af_unix.c",
      "line": 1521,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "",
        "\t\t/* Apparently VFS overslept socket death. Retry. */",
        "\t\tif (sock_flag(other, SOCK_DEAD)) {",
        "\t\t\tunix_state_double_unlock(sk, other);",
        "\t\t\tsock_put(other);",
        "\t\t\tgoto restart;",
        "\t\t}"
      ]
    },
    {
      "file": "linux\\net\\unix\\af_unix.c",
      "line": 1541,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "\t\t *\t1003.1g breaking connected state with AF_UNSPEC",
        "\t\t */",
        "\t\tother = NULL;",
        "\t\tunix_state_double_lock(sk, other);",
        "\t}",
        "",
        "\t/*"
      ]
    },
    {
      "file": "linux\\net\\unix\\af_unix.c",
      "line": 1555,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\t\t\tWRITE_ONCE(sk->sk_state, TCP_CLOSE);",
        "\t\tunix_dgram_peer_wake_disconnect_wakeup(sk, old_peer);",
        "",
        "\t\tunix_state_double_unlock(sk, other);",
        "",
        "\t\tif (other != old_peer) {",
        "\t\t\tunix_dgram_disconnected(sk, old_peer);"
      ]
    },
    {
      "file": "linux\\net\\unix\\af_unix.c",
      "line": 1569,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\t\tsock_put(old_peer);",
        "\t} else {",
        "\t\tunix_peer(sk) = other;",
        "\t\tunix_state_double_unlock(sk, other);",
        "\t}",
        "",
        "\treturn 0;"
      ]
    },
    {
      "file": "linux\\net\\unix\\af_unix.c",
      "line": 1575,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_unlock",
      "context": [
        "\treturn 0;",
        "",
        "out_unlock:",
        "\tunix_state_double_unlock(sk, other);",
        "\tsock_put(other);",
        "out:",
        "\treturn err;"
      ]
    },
    {
      "file": "linux\\net\\unix\\af_unix.c",
      "line": 2210,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double_lock",
      "context": [
        "",
        "\t\tif (!sk_locked) {",
        "\t\t\tunix_state_unlock(other);",
        "\t\t\tunix_state_double_lock(sk, other);",
        "\t\t}",
        "",
        "\t\tif (unix_peer(sk) != other ||"
      ]
    },
    {
      "file": "linux\\net\\xdp\\xsk.c",
      "line": 1073,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * the two locks involved. Each map has a lock synchronizing",
        "\t * updates to the entries, and each socket has a lock that",
        "\t * synchronizes access to the list of maps (map_list). For",
        "\t * deadlock avoidance the locks need to be taken in the order",
        "\t * \"map lock\"->\"socket map list lock\". We start off by",
        "\t * accessing the socket map list, and take a reference to the",
        "\t * map to guarantee existence between the"
      ]
    },
    {
      "file": "linux\\net\\bluetooth\\hidp\\core.c",
      "line": 1300,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * If we stopped ourself due to any internal signal, we should try to",
        "\t * unregister our own session here to avoid having it linger until the",
        "\t * parent l2cap_conn dies or user-space cleans it up.",
        "\t * This does not deadlock as we don't do any synchronous shutdown.",
        "\t * Instead, this call has the same semantics as if user-space tried to",
        "\t * delete the session.",
        "\t */"
      ]
    },
    {
      "file": "linux\\net\\bluetooth\\rfcomm\\sock.c",
      "line": 407,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\td->sec_level = rfcomm_pi(sk)->sec_level;",
        "\td->role_switch = rfcomm_pi(sk)->role_switch;",
        "",
        "\t/* Drop sock lock to avoid potential deadlock with the RFCOMM lock */",
        "\trelease_sock(sk);",
        "\terr = rfcomm_dlc_open(d, &rfcomm_pi(sk)->src, &sa->rc_bdaddr,",
        "\t\t\t      sa->rc_channel);"
      ]
    },
    {
      "file": "linux\\net\\sunrpc\\xprtrdma\\rpc_rdma.c",
      "line": 1471,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\tspin_unlock(&xprt->queue_lock);",
        "",
        "\tif (credits == 0)",
        "\t\tcredits = 1;\t/* don't deadlock */",
        "\telse if (credits > r_xprt->rx_ep->re_max_requests)",
        "\t\tcredits = r_xprt->rx_ep->re_max_requests;",
        "\trpcrdma_post_recvs(r_xprt, credits + (buf->rb_bc_srv_max_requests << 1));"
      ]
    },
    {
      "file": "linux\\net\\sunrpc\\xprtrdma\\svc_rdma_backchannel.c",
      "line": 46,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "",
        "\tcredits = be32_to_cpup(rdma_resp + 2);",
        "\tif (credits == 0)",
        "\t\tcredits = 1;\t/* don't deadlock */",
        "\telse if (credits > r_xprt->rx_buf.rb_bc_max_requests)",
        "\t\tcredits = r_xprt->rx_buf.rb_bc_max_requests;",
        "\tspin_lock(&xprt->transport_lock);"
      ]
    },
    {
      "file": "linux\\net\\sunrpc\\xprtrdma\\svc_rdma_pcl.c",
      "line": 262,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        " *",
        " * Returns:",
        " *   On success, zero,",
        " *   %-EMSGSIZE on XDR buffer overflow, or",
        " *   The return value of @actor",
        " */",
        "int pcl_process_nonpayloads(const struct svc_rdma_pcl *pcl,"
      ]
    },
    {
      "file": "linux\\net\\sunrpc\\xprtrdma\\svc_rdma_sendto.c",
      "line": 410,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        " * Return values:",
        " *   On success, returns length in bytes of the Reply XDR buffer",
        " *   that was consumed by the Reply Read list",
        " *   %-EMSGSIZE on XDR buffer overflow",
        " */",
        "static ssize_t svc_rdma_encode_read_list(struct svc_rdma_send_ctxt *sctxt)",
        "{"
      ]
    },
    {
      "file": "linux\\net\\sunrpc\\xprtrdma\\svc_rdma_sendto.c",
      "line": 428,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        " * Return values:",
        " *   On success, returns length in bytes of the Reply XDR buffer",
        " *   that was consumed by the Write segment, and updates @remaining",
        " *   %-EMSGSIZE on XDR buffer overflow",
        " */",
        "static ssize_t svc_rdma_encode_write_segment(struct svc_rdma_send_ctxt *sctxt,",
        "\t\t\t\t\t     const struct svc_rdma_chunk *chunk,"
      ]
    },
    {
      "file": "linux\\net\\sunrpc\\xprtrdma\\svc_rdma_sendto.c",
      "line": 464,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        " * Return values:",
        " *   On success, returns length in bytes of the Reply XDR buffer",
        " *   that was consumed by the Write chunk",
        " *   %-EMSGSIZE on XDR buffer overflow",
        " */",
        "static ssize_t svc_rdma_encode_write_chunk(struct svc_rdma_send_ctxt *sctxt,",
        "\t\t\t\t\t   const struct svc_rdma_chunk *chunk)"
      ]
    },
    {
      "file": "linux\\net\\sunrpc\\xprtrdma\\svc_rdma_sendto.c",
      "line": 502,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        " * Return values:",
        " *   On success, returns length in bytes of the Reply XDR buffer",
        " *   that was consumed by the Reply's Write list",
        " *   %-EMSGSIZE on XDR buffer overflow",
        " */",
        "static ssize_t svc_rdma_encode_write_list(struct svc_rdma_recv_ctxt *rctxt,",
        "\t\t\t\t\t  struct svc_rdma_send_ctxt *sctxt)"
      ]
    },
    {
      "file": "linux\\net\\sunrpc\\xprtrdma\\svc_rdma_sendto.c",
      "line": 535,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        " * Return values:",
        " *   On success, returns length in bytes of the Reply XDR buffer",
        " *   that was consumed by the Reply's Reply chunk",
        " *   %-EMSGSIZE on XDR buffer overflow",
        " *   %-E2BIG if the RPC message is larger than the Reply chunk",
        " */",
        "static ssize_t"
      ]
    },
    {
      "file": "linux\\security\\landlock\\fs.c",
      "line": 848,
      "pattern": "privilege.*escalation",
      "rule": "security",
      "severity": "critical",
      "match": "privilege escalation",
      "context": [
        "\t\t * already allowed on the source, respectively if there is at",
        "\t\t * least as much as restrictions on the destination than on the",
        "\t\t * source, then we can safely refer files from the source to",
        "\t\t * the destination without risking a privilege escalation.",
        "\t\t * This also applies in the case of RENAME_EXCHANGE, which",
        "\t\t * implies checks on both direction.  This is crucial for",
        "\t\t * standalone multilayered security policies.  Furthermore,"
      ]
    },
    {
      "file": "linux\\sound\\drivers\\aloop.c",
      "line": 1311,
      "pattern": "double.*free",
      "rule": "memory_management",
      "severity": "high",
      "match": "double free",
      "context": [
        "\t}",
        "",
        "\t/* loopback_runtime_free() has not to be called if kfree(dpcm) was",
        "\t * already called here. Otherwise it will end up with a double free.",
        "\t */",
        "\truntime->private_free = loopback_runtime_free;",
        "\tif (get_notify(dpcm))"
      ]
    },
    {
      "file": "linux\\sound\\drivers\\aloop.c",
      "line": 863,
      "pattern": "deadlock",
      "rule": "concurrency",
      "severity": "high",
      "match": "deadlock",
      "context": [
        "\t * snd_timer_start()",
        "\t * spin_lock(&timer->lock)",
        "\t * Therefore when using the oposit order of locks here it could result",
        "\t * in a deadlock.",
        "\t */",
        "",
        "\tif (event == SNDRV_TIMER_EVENT_MSTOP) {"
      ]
    },
    {
      "file": "linux\\sound\\soc\\fsl\\fsl_asrc.c",
      "line": 1048,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "BUFFER_OVERFLOW",
      "context": [
        "\t\t}",
        "",
        "\t\tif (status & ASRSTR_AODO(index)) {",
        "\t\t\tasrc->pair[index]->error |= ASRC_OUTPUT_BUFFER_OVERFLOW;",
        "\t\t\tpair_dbg(\"Output Data Buffer has overflowed\\n\");",
        "\t\t}",
        ""
      ]
    },
    {
      "file": "linux\\sound\\soc\\fsl\\fsl_asrc.c",
      "line": 1049,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "Buffer has overflow",
      "context": [
        "",
        "\t\tif (status & ASRSTR_AODO(index)) {",
        "\t\t\tasrc->pair[index]->error |= ASRC_OUTPUT_BUFFER_OVERFLOW;",
        "\t\t\tpair_dbg(\"Output Data Buffer has overflowed\\n\");",
        "\t\t}",
        "",
        "\t\tif (status & ASRSTR_AIDU(index)) {"
      ]
    },
    {
      "file": "linux\\sound\\soc\\fsl\\fsl_spdif.c",
      "line": 283,
      "pattern": "buffer.*overflow",
      "rule": "security",
      "severity": "critical",
      "match": "buffer overflow",
      "context": [
        "\tif (*pos >= size * 2) {",
        "\t\t*pos = 0;",
        "\t} else if (unlikely((*pos % size) + 3 > size)) {",
        "\t\tdev_err(&pdev->dev, \"User bit receive buffer overflow\\n\");",
        "\t\treturn;",
        "\t}",
        ""
      ]
    },
    {
      "file": "linux\\tools\\testing\\selftests\\net\\bind_bhash.c",
      "line": 131,
      "pattern": "double.*lock",
      "rule": "concurrency",
      "severity": "high",
      "match": "double)(end - begin) / CLOCK",
      "context": [
        "",
        "\tend = clock();",
        "",
        "\tprintf(\"time spent = %f\\n\", (double)(end - begin) / CLOCKS_PER_SEC);",
        "",
        "\t/* clean up */",
        "\tclose(sock_fd);"
      ]
    },
    {
      "file": "linux\\tools\\testing\\selftests\\net\\busy_poller.c",
      "line": 91,
      "pattern": "code.*duplication",
      "rule": "code_quality",
      "severity": "low",
      "match": "code duplication",
      "context": [
        "",
        "\twhile ((c = getopt(argc, argv, \"p:m:b:u:P:g:o:d:r:s:i:\")) != -1) {",
        "\t\t/* most options take integer values, except o and b, so reduce",
        "\t\t * code duplication a bit for the common case by calling",
        "\t\t * strtoull here and leave bounds checking and casting per",
        "\t\t * option below.",
        "\t\t */"
      ]
    }
  ],
  "statistics": {
    "total_files": 35588,
    "analyzed_files": 35588,
    "files_with_findings": 1431,
    "total_findings": 3122,
    "findings_by_severity": {
      "critical": 347,
      "high": 2670,
      "medium": 13,
      "low": 92
    },
    "findings_by_rule": {
      "code_quality": 92,
      "concurrency": 2314,
      "security": 347,
      "memory_management": 356,
      "api_usage": 12,
      "error_handling": 1
    }
  }
}