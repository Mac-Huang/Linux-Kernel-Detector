{
  "summary": {
    "total_concurrency_issues": 2314,
    "categories_found": 4,
    "analysis_date": "2025-06-29"
  },
  "categories": {
    "race_condition": {
      "count": 384,
      "description": "Race conditions between concurrent threads/processes",
      "issues": [
        {
          "file": "linux\\fs\\aio.c",
          "line": 1463,
          "match": "race condition",
          "context": [
            "",
            "\t\t/* Pass requests_done to kill_ioctx() where it can be set",
            "\t\t * in a thread-safe way. If we try to set it here then we have",
            "\t\t * a race condition if two io_destroy() called simultaneously.",
            "\t\t */",
            "\t\tret = kill_ioctx(current->mm, ioctx, &wait);",
            "\t\tpercpu_ref_put(&ioctx->users);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\aio.c"
          ]
        },
        {
          "file": "linux\\fs\\select.c",
          "line": 107,
          "match": "race-condition",
          "context": [
            "/*",
            " * Ok, Peter made a complicated, but straightforward multiple_wait() function.",
            " * I have rewritten this, taking some shortcuts: This code may not be easy to",
            " * follow, but it should be free of race-conditions, and it's practical. If you",
            " * understand what I'm doing here, then you understand how the linux",
            " * sleep/wakeup mechanism works.",
            " *"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\select.c"
          ]
        },
        {
          "file": "linux\\net\\socket.c",
          "line": 444,
          "match": "race condition",
          "context": [
            " *\tfunction will increment ref. count on file by 1.",
            " *",
            " *\tIn any case returned fd MAY BE not valid!",
            " *\tThis race condition is unavoidable",
            " *\twith shared fd spaces, we cannot solve it inside kernel,",
            " *\tbut we take care of internal coherence yet.",
            " */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\net\\socket.c"
          ]
        },
        {
          "file": "linux\\arch\\riscv\\kernel\\unaligned_access_speed.c",
          "line": 118,
          "match": "race condition",
          "context": [
            "",
            "\t/*",
            "\t * Set the value of fast_misaligned_access of a CPU. These operations",
            "\t * are atomic to avoid race conditions.",
            "\t */",
            "\tif (speed == RISCV_HWPROBE_MISALIGNED_SCALAR_FAST)",
            "\t\tcpumask_set_cpu(cpu, &fast_misaligned_access);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\arch\\riscv\\kernel\\unaligned_access_speed.c"
          ]
        },
        {
          "file": "linux\\arch\\x86\\kernel\\cpu\\intel.c",
          "line": 228,
          "match": "race condition",
          "context": [
            "\t/*",
            "\t * Atom erratum AAE44/AAF40/AAG38/AAH41:",
            "\t *",
            "\t * A race condition between speculative fetches and invalidating",
            "\t * a large page.  This is worked around in microcode, but we",
            "\t * need the microcode to have already been loaded... so if it is",
            "\t * not, recommend a BIOS update and disable large pages."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\arch\\x86\\kernel\\cpu\\intel.c"
          ]
        },
        {
          "file": "linux\\arch\\x86\\kernel\\cpu\\umwait.c",
          "line": 72,
          "match": "race condition",
          "context": [
            "\t * This code is protected by the CPU hotplug already and",
            "\t * orig_umwait_control_cached is never changed after it caches",
            "\t * the original control MSR value in umwait_init(). So there",
            "\t * is no race condition here.",
            "\t */",
            "\twrmsrq(MSR_IA32_UMWAIT_CONTROL, orig_umwait_control_cached);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\arch\\x86\\kernel\\cpu\\umwait.c"
          ]
        },
        {
          "file": "linux\\drivers\\acpi\\acpi_dbg.c",
          "line": 150,
          "match": "race condition",
          "context": [
            "\tbool ret;",
            "",
            "\t/*",
            "\t * The usage count is prepared to avoid race conditions between the",
            "\t * starts and the stops of the debugger thread.",
            "\t */",
            "\tmutex_lock(&acpi_aml_io.lock);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\acpi\\acpi_dbg.c"
          ]
        },
        {
          "file": "linux\\drivers\\ata\\libata-eh.c",
          "line": 2877,
          "match": "race condition",
          "context": [
            "\t/* postreset() should clear hardware SError.  Although SError",
            "\t * is cleared during link resume, clearing SError here is",
            "\t * necessary as some PHYs raise hotplug events after SRST.",
            "\t * This introduces race condition where hotplug occurs between",
            "\t * reset and here.  This race is mediated by cross checking",
            "\t * link onlineness and classification result later.",
            "\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\ata\\libata-eh.c"
          ]
        },
        {
          "file": "linux\\drivers\\atm\\lanai.c",
          "line": 292,
          "match": "race condition",
          "context": [
            "\tstruct atm_vcc *cbrvcc;",
            "\tint number;",
            "\tint board_rev;",
            "/* TODO - look at race conditions with maintence of conf1/conf2 */",
            "/* TODO - transmit locking: should we use _irq not _irqsave? */",
            "/* TODO - organize above in some rational fashion (see <asm/cache.h>) */",
            "};"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\atm\\lanai.c"
          ]
        },
        {
          "file": "linux\\drivers\\auxdisplay\\ks0108.c",
          "line": 46,
          "match": "race condition",
          "context": [
            " * ks0108 Exported Commands (don't lock)",
            " *",
            " *   You _should_ lock in the top driver: This functions _should not_",
            " *   get race conditions in any way. Locking for each byte here would be",
            " *   so slow and useless.",
            " *",
            " *   There are not bit definitions because they are not flags,"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\auxdisplay\\ks0108.c"
          ]
        },
        {
          "file": "linux\\drivers\\base\\core.c",
          "line": 3368,
          "match": "race condition",
          "context": [
            "",
            "\tmutex_lock(&gdp_mutex);",
            "\t/**",
            "\t * There is a race condition between removing glue directory",
            "\t * and adding a new device under the glue directory.",
            "\t *",
            "\t * CPU1:                                         CPU2:"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\base\\core.c"
          ]
        },
        {
          "file": "linux\\drivers\\base\\dd.c",
          "line": 164,
          "match": "race condition",
          "context": [
            " * list and schedules the deferred probe workqueue to process them.  It",
            " * should be called anytime a driver is successfully bound to a device.",
            " *",
            " * Note, there is a race condition in multi-threaded probe. In the case where",
            " * more than one device is probing at the same time, it is possible for one",
            " * probe to complete successfully while another is about to defer. If the second",
            " * depends on the first, then it will get put on the pending list after the"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\base\\dd.c"
          ]
        },
        {
          "file": "linux\\drivers\\block\\amiflop.c",
          "line": 54,
          "match": "race condition",
          "context": [
            " * - Fixed Bug accessing multiple disks",
            " * - some code cleanup",
            " * - added trackbuffer for each drive to speed things up",
            " * - fixed some race conditions (who finds the next may send it to me ;-)",
            " */",
            "",
            "#include <linux/module.h>"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\block\\amiflop.c"
          ]
        },
        {
          "file": "linux\\drivers\\block\\ataflop.c",
          "line": 1085,
          "match": "race condition",
          "context": [
            "\tlocal_irq_save(flags);",
            "",
            "\tif (!MultReadInProgress) {",
            "\t\t/* This prevents a race condition that could arise if the",
            "\t\t * interrupt is triggered while the calling of this timer",
            "\t\t * callback function takes place. The IRQ function then has",
            "\t\t * already cleared 'MultReadInProgress'  when flow of control"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\block\\ataflop.c"
          ]
        },
        {
          "file": "linux\\drivers\\block\\rbd.c",
          "line": 2089,
          "match": "race condition",
          "context": [
            "",
            "\tif (snap_id == CEPH_NOSNAP) {",
            "\t\t/*",
            "\t\t * Protect against possible race conditions during lock",
            "\t\t * ownership transitions.",
            "\t\t */",
            "\t\tret = ceph_cls_assert_locked(req, which++, RBD_LOCK_NAME,"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\block\\rbd.c"
          ]
        },
        {
          "file": "linux\\drivers\\bluetooth\\btintel_pcie.c",
          "line": 402,
          "match": "race condition",
          "context": [
            "\tstruct rxq *rxq = &data->rxq;",
            "",
            "\t/* Post (BTINTEL_PCIE_RX_DESCS_COUNT - 3) buffers to overcome the",
            "\t * hardware issues leading to race condition at the firmware.",
            "\t */",
            "",
            "\tfor (i = 0; i < rxq->count - 3; i++) {"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\bluetooth\\btintel_pcie.c"
          ]
        },
        {
          "file": "linux\\drivers\\clocksource\\timer-cs5535.c",
          "line": 61,
          "match": "races by clearing CMP1 and CMP2 uncondition",
          "context": [
            "",
            "static void disable_timer(struct cs5535_mfgpt_timer *timer)",
            "{",
            "\t/* avoid races by clearing CMP1 and CMP2 unconditionally */",
            "\tcs5535_mfgpt_write(timer, MFGPT_REG_SETUP,",
            "\t\t\t(uint16_t) ~MFGPT_SETUP_CNTEN | MFGPT_SETUP_CMP1 |",
            "\t\t\t\tMFGPT_SETUP_CMP2);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\clocksource\\timer-cs5535.c"
          ]
        },
        {
          "file": "linux\\drivers\\clocksource\\timer-nxp-stm.c",
          "line": 75,
          "match": "race condition",
          "context": [
            "static int stm_instances;",
            "",
            "/*",
            " * This global lock is used to prevent race conditions with the",
            " * stm_instances in case the driver is using the ASYNC option",
            " */",
            "static DEFINE_MUTEX(stm_instances_lock);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\clocksource\\timer-nxp-stm.c"
          ]
        },
        {
          "file": "linux\\drivers\\clocksource\\timer-tegra.c",
          "line": 190,
          "match": "race condition",
          "context": [
            "/*",
            " * tegra_rtc_read - Reads the Tegra RTC registers",
            " * Care must be taken that this function is not called while the",
            " * tegra_rtc driver could be executing to avoid race conditions",
            " * on the RTC shadow register",
            " */",
            "static u64 tegra_rtc_read_ms(struct clocksource *cs)"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\clocksource\\timer-tegra.c"
          ]
        },
        {
          "file": "linux\\drivers\\counter\\i8254.c",
          "line": 45,
          "match": "race condition",
          "context": [
            "",
            "/**",
            " * struct i8254 - I8254 device private data structure",
            " * @lock:\tsynchronization lock to prevent I/O race conditions",
            " * @preset:\tarray of Counter Register states",
            " * @out_mode:\tarray of mode configuration states",
            " * @map:\tRegmap for the device"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\counter\\i8254.c"
          ]
        },
        {
          "file": "linux\\drivers\\counter\\ti-ecap-capture.c",
          "line": 80,
          "match": "race condition",
          "context": [
            "/**",
            " * struct ecap_cnt_dev - device private data structure",
            " * @enabled: device state",
            " * @lock:    synchronization lock to prevent I/O race conditions",
            " * @clk:     device clock",
            " * @regmap:  device register map",
            " * @nb_ovf:  number of overflows since capture start"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\counter\\ti-ecap-capture.c"
          ]
        },
        {
          "file": "linux\\drivers\\cpufreq\\mediatek-cpufreq.c",
          "line": 52,
          "match": "race condition",
          "context": [
            "\tbool need_voltage_tracking;",
            "\tint vproc_on_boot;",
            "\tint pre_vproc;",
            "\t/* Avoid race condition for regulators between notify and policy */",
            "\tstruct mutex reg_lock;",
            "\tstruct notifier_block opp_nb;",
            "\tunsigned int opp_cpu;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\cpufreq\\mediatek-cpufreq.c"
          ]
        },
        {
          "file": "linux\\drivers\\devfreq\\mtk-cci-devfreq.c",
          "line": 32,
          "match": "race condition",
          "context": [
            "\tstruct clk *inter_clk;",
            "\tint inter_voltage;",
            "\tunsigned long pre_freq;",
            "\t/* Avoid race condition for regulators between notify and policy */",
            "\tstruct mutex reg_lock;",
            "\tstruct notifier_block opp_nb;",
            "\tconst struct mtk_ccifreq_platform_data *soc_data;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\devfreq\\mtk-cci-devfreq.c"
          ]
        },
        {
          "file": "linux\\drivers\\dma\\at_hdmac.c",
          "line": 651,
          "match": "race condition",
          "context": [
            " * removing the number of bytes corresponding to this amount of data.",
            " *",
            " * However, the DSCR and CTRLA registers cannot be read both atomically. Hence a",
            " * race condition may occur: the first read register may refer to one LLI",
            " * whereas the second read may refer to a later LLI in the list because of the",
            " * DMA transfer progression inbetween the two reads.",
            " *"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\dma\\at_hdmac.c"
          ]
        },
        {
          "file": "linux\\drivers\\dma-buf\\dma-fence.c",
          "line": 709,
          "match": "race condition",
          "context": [
            " *",
            " * *WARNING*:",
            " * Cancelling a callback should only be done if you really know what you're",
            " * doing, since deadlocks and race conditions could occur all too easily. For",
            " * this reason, it should only ever be done on hardware lockup recovery,",
            " * with a reference held to the fence.",
            " *"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\dma-buf\\dma-fence.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpio\\gpio-104-dio-48e.c",
          "line": 111,
          "match": "race condition",
          "context": [
            "",
            "/**",
            " * struct dio48e_gpio - GPIO device private data structure",
            " * @lock:\tsynchronization lock to prevent I/O race conditions",
            " * @map:\tRegmap for the device",
            " * @regs:\tvirtual mapping for device registers",
            " * @flags:\tIRQ flags saved during locking"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpio\\gpio-104-dio-48e.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpio\\gpio-aggregator.c",
          "line": 1406,
          "match": "race condition",
          "context": [
            "",
            "\t/*",
            "\t * CAVEAT: This must occur after configfs registration. Otherwise,",
            "\t * a race condition could arise: driver attribute groups might be",
            "\t * exposed and accessed by users before configfs registration",
            "\t * completes. new_device_store() does not expect a partially",
            "\t * initialized configfs state."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpio\\gpio-aggregator.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpio\\gpio-mvebu.c",
          "line": 476,
          "match": "race condition",
          "context": [
            " *\t\t       Interrupt are masked by EDGE_MASK registers.",
            " * Both-edge handlers: Similar to regular Edge handlers, but also swaps",
            " *\t\t       the polarity to catch the next line transaction.",
            " *\t\t       This is a race condition that might not perfectly",
            " *\t\t       work on some use cases.",
            " *",
            " * Every eight GPIO lines are grouped (OR'ed) before going up to main"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpio\\gpio-mvebu.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpio\\gpio-pcie-idio-24.c",
          "line": 149,
          "match": "race condition",
          "context": [
            "/**",
            " * struct idio_24_gpio - GPIO device private data structure",
            " * @map:\tregmap for the device",
            " * @lock:\tsynchronization lock to prevent I/O race conditions",
            " * @irq_type:\ttype configuration for IRQs",
            " */",
            "struct idio_24_gpio {"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpio\\gpio-pcie-idio-24.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpio\\gpio-ws16c48.c",
          "line": 105,
          "match": "race condition",
          "context": [
            "/**",
            " * struct ws16c48_gpio - GPIO device private data structure",
            " * @map:\tregmap for the device",
            " * @lock:\tsynchronization lock to prevent I/O race conditions",
            " * @irq_mask:\tI/O bits affected by interrupts",
            " */",
            "struct ws16c48_gpio {"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpio\\gpio-ws16c48.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpio\\gpiolib.c",
          "line": 1898,
          "match": "race condition",
          "context": [
            "\tstruct irq_domain *domain = gc->irq.domain;",
            "",
            "\t/*",
            "\t * Avoid race condition with other code, which tries to lookup",
            "\t * an IRQ before the irqchip has been properly registered,",
            "\t * i.e. while gpiochip is still being brought up.",
            "\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpio\\gpiolib.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpio\\gpiolib.c",
          "line": 4010,
          "match": "race condition",
          "context": [
            "#ifdef CONFIG_GPIOLIB_IRQCHIP",
            "\tif (gc->irq.chip) {",
            "\t\t/*",
            "\t\t * Avoid race condition with other code, which tries to lookup",
            "\t\t * an IRQ before the irqchip has been properly registered,",
            "\t\t * i.e. while gpiochip is still being brought up.",
            "\t\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpio\\gpiolib.c"
          ]
        },
        {
          "file": "linux\\drivers\\hsi\\hsi_core.c",
          "line": 712,
          "match": "race condition",
          "context": [
            " * @event: The event type",
            " *",
            " * Clients should not be concerned about wake line behavior. However, due",
            " * to a race condition in HSI HW protocol, clients need to be notified",
            " * about wake line changes, so they can implement a workaround for it.",
            " *",
            " * Events:"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hsi\\hsi_core.c"
          ]
        },
        {
          "file": "linux\\drivers\\hv\\channel.c",
          "line": 1165,
          "match": "race condition",
          "context": [
            "/*",
            " * vmbus_next_request_id - Returns a new request id. It is also",
            " * the index at which the guest memory address is stored.",
            " * Uses a spin lock to avoid race conditions.",
            " * @channel: Pointer to the VMbus channel struct",
            " * @rqst_add: Guest memory address to be stored in the array",
            " */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hv\\channel.c"
          ]
        },
        {
          "file": "linux\\drivers\\hv\\channel.c",
          "line": 1267,
          "match": "race condition",
          "context": [
            "",
            "/*",
            " * vmbus_request_addr - Returns the memory address stored at @trans_id",
            " * in @rqstor. Uses a spin lock to avoid race conditions.",
            " * @channel: Pointer to the VMbus channel struct",
            " * @trans_id: Request id sent back from Hyper-V. Becomes the requestor's",
            " * next request id."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hv\\channel.c"
          ]
        },
        {
          "file": "linux\\drivers\\hv\\ring_buffer.c",
          "line": 560,
          "match": "race condition",
          "context": [
            " * inappropriately.",
            " *",
            " * Determining when to signal is tricky. There are three key data inputs",
            " * that must be handled in this order to avoid race conditions:",
            " *",
            " * 1. Update the read_index",
            " * 2. Read the pending_send_sz"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hv\\ring_buffer.c"
          ]
        },
        {
          "file": "linux\\drivers\\hv\\vmbus_drv.c",
          "line": 1952,
          "match": "Race condition",
          "context": [
            " * time, and \"ring\" sysfs is needed only when uio_hv_generic is bound to that device. To avoid",
            " * exposing the ring buffer by default, this function is reponsible to enable visibility of",
            " * ring for userspace to use.",
            " * Note: Race conditions can happen with userspace and it is not encouraged to create new",
            " * use-cases for this. This was added to maintain backward compatibility, while solving",
            " * one of the race conditions in uio_hv_generic while creating sysfs. See comments with",
            " * vmbus_add_dynid() and vmbus_device_register()."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hv\\vmbus_drv.c"
          ]
        },
        {
          "file": "linux\\drivers\\hv\\vmbus_drv.c",
          "line": 1954,
          "match": "race condition",
          "context": [
            " * ring for userspace to use.",
            " * Note: Race conditions can happen with userspace and it is not encouraged to create new",
            " * use-cases for this. This was added to maintain backward compatibility, while solving",
            " * one of the race conditions in uio_hv_generic while creating sysfs. See comments with",
            " * vmbus_add_dynid() and vmbus_device_register().",
            " *",
            " * Returns 0 on success or error code on failure."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hv\\vmbus_drv.c"
          ]
        },
        {
          "file": "linux\\drivers\\hv\\vmbus_drv.c",
          "line": 2101,
          "match": "race condition",
          "context": [
            "\t * here. The race can't result in a kernel failure, but the user space",
            "\t * program may get an error in accessing \"channels\" or its",
            "\t * subdirectories. See also comments with vmbus_add_dynid() about a",
            "\t * related race condition.",
            "\t */",
            "\tchild_device_obj->channels_kset = kset_create_and_add(\"channels\",",
            "\t\t\t\t\t\t\t      NULL, kobj);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hv\\vmbus_drv.c"
          ]
        },
        {
          "file": "linux\\drivers\\hwmon\\asus-ec-sensors.c",
          "line": 820,
          "match": "Race condition",
          "context": [
            "\tif (prev_bank) {",
            "\t\t/* oops... somebody else is working with the EC too */",
            "\t\tdev_warn(dev,",
            "\t\t\t\"Concurrent access to the ACPI EC detected.\\nRace condition possible.\");",
            "\t}",
            "",
            "\t/* read registers minimizing bank switches. */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hwmon\\asus-ec-sensors.c"
          ]
        },
        {
          "file": "linux\\drivers\\i2c\\i2c-core-smbus.c",
          "line": 569,
          "match": "racepoints are condition",
          "context": [
            "\tif (res)",
            "\t\treturn res;",
            "",
            "\t/* If enabled, the following two tracepoints are conditional on",
            "\t * read_write and protocol.",
            "\t */",
            "\ttrace_smbus_write(adapter, addr, flags, read_write,"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\i2c\\i2c-core-smbus.c"
          ]
        },
        {
          "file": "linux\\drivers\\i2c\\i2c-core-smbus.c",
          "line": 612,
          "match": "racepoint is condition",
          "context": [
            "\t\t\t\t      command, protocol, data);",
            "",
            "trace:",
            "\t/* If enabled, the reply tracepoint is conditional on read_write. */",
            "\ttrace_smbus_reply(adapter, addr, flags, read_write,",
            "\t\t\t  command, protocol, data, res);",
            "\ttrace_smbus_result(adapter, addr, flags, read_write,"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\i2c\\i2c-core-smbus.c"
          ]
        },
        {
          "file": "linux\\drivers\\mailbox\\mailbox-th1520.c",
          "line": 304,
          "match": "race condition",
          "context": [
            "\t *    any other devm_ resources are released.",
            "\t *",
            "\t * This ordering guarantees that no interrupts can be triggered from the device",
            "\t * while it is being unbound, preventing race conditions and ensuring system",
            "\t * stability.",
            "\t */",
            "\tret = request_irq(priv->irq, th1520_mbox_isr,"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\mailbox\\mailbox-th1520.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\dm-raid1.c",
          "line": 482,
          "match": "race condition",
          "context": [
            "static void hold_bio(struct mirror_set *ms, struct bio *bio)",
            "{",
            "\t/*",
            "\t * Lock is required to avoid race condition during suspend",
            "\t * process.",
            "\t */",
            "\tspin_lock_irq(&ms->lock);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\dm-raid1.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\dm-stats.c",
          "line": 690,
          "match": "race condition",
          "context": [
            "",
            "\tif (!end) {",
            "\t\t/*",
            "\t\t * A race condition can at worst result in the merged flag being",
            "\t\t * misrepresented, so we don't have to disable preemption here.",
            "\t\t */",
            "\t\tlast = raw_cpu_ptr(stats->last);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\dm-stats.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\dm-thin.c",
          "line": 2766,
          "match": "race condition",
          "context": [
            "\tcase 0:",
            "\t\tif (unlikely(result.shared)) {",
            "\t\t\t/*",
            "\t\t\t * We have a race condition here between the",
            "\t\t\t * result.shared value returned by the lookup and",
            "\t\t\t * snapshot creation, which may cause new",
            "\t\t\t * sharing."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\dm-thin.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\dm-verity-target.c",
          "line": 82,
          "match": "race condition",
          "context": [
            " * The variable hash_verified is set to 0 when allocating the buffer, then",
            " * it can be changed to 1 and it is never reset to 0 again.",
            " *",
            " * There is no lock around this value, a race condition can at worst cause",
            " * that multiple processes verify the hash of the same buffer simultaneously",
            " * and write 1 to hash_verified simultaneously.",
            " * This condition is harmless, so we don't need locking."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\dm-verity-target.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\raid1.c",
          "line": 1071,
          "match": "race condition",
          "context": [
            "\t/*",
            "\t * After holding conf->resync_lock, conf->nr_pending[idx]",
            "\t * should be decreased before waiting for barrier to drop.",
            "\t * Otherwise, we may encounter a race condition because",
            "\t * raise_barrer() might be waiting for conf->nr_pending[idx]",
            "\t * to be 0 at same time.",
            "\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\raid1.c"
          ]
        },
        {
          "file": "linux\\drivers\\parisc\\iosapic.c",
          "line": 642,
          "match": "race condition",
          "context": [
            "\t/*",
            "\t * Issuing I/O SAPIC an EOI causes an interrupt IFF IRQ line is",
            "\t * asserted.  IRQ generally should not be asserted when a driver",
            "\t * enables their IRQ. It can lead to \"interesting\" race conditions",
            "\t * in the driver initialization sequence.",
            "\t */",
            "\tDBG(KERN_DEBUG \"enable_irq(%d): eoi(%p, 0x%x)\\n\", d->irq,"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\parisc\\iosapic.c"
          ]
        },
        {
          "file": "linux\\drivers\\parisc\\lba_pci.c",
          "line": 276,
          "match": "race condition",
          "context": [
            " *\t\tlive with this during our initial bus walk",
            " *\t\tuntil rev 4.0 (no driver activity during",
            " *\t\tinitial bus walk).  The initial bus walk",
            " *\t\thas race conditions concerning the use of",
            " *\t\tsmart mode as well.",
            " */",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\parisc\\lba_pci.c"
          ]
        },
        {
          "file": "linux\\drivers\\perf\\arm_dmc620_pmu.c",
          "line": 380,
          "match": "race condition",
          "context": [
            "",
            "\t\t/*",
            "\t\t * HW doesn't provide a control to atomically disable all counters.",
            "\t\t * To prevent race condition (overflow happens while clearing status register),",
            "\t\t * disable all events before continuing",
            "\t\t */",
            "\t\tfor (idx = 0; idx < DMC620_PMU_MAX_COUNTERS; idx++) {"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\perf\\arm_dmc620_pmu.c"
          ]
        },
        {
          "file": "linux\\drivers\\perf\\riscv_pmu_sbi.c",
          "line": 993,
          "match": "race condition",
          "context": [
            "",
            "\t/*",
            "\t * Overflow interrupt pending bit should only be cleared after stopping",
            "\t * all the counters to avoid any race condition.",
            "\t */",
            "\tALT_SBI_PMU_OVF_CLEAR_PENDING(riscv_pmu_irq_mask);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\perf\\riscv_pmu_sbi.c"
          ]
        },
        {
          "file": "linux\\drivers\\powercap\\idle_inject.c",
          "line": 35,
          "match": "race condition",
          "context": [
            " * kthread activity after its completion is guaranteed.",
            " *",
            " * It is up to the user of this framework to provide a lock for higher-level",
            " * synchronization to prevent race conditions like starting idle injection",
            " * while unregistering from the framework.",
            " */",
            "#define pr_fmt(fmt) \"ii_dev: \" fmt"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\powercap\\idle_inject.c"
          ]
        },
        {
          "file": "linux\\drivers\\rtc\\interface.c",
          "line": 243,
          "match": "race condition",
          "context": [
            "\t * of the -1 fields.",
            "\t *",
            "\t * Reading the alarm and timestamp in the reverse sequence",
            "\t * would have the same race condition, and not solve the issue.",
            "\t *",
            "\t * So, we must first read the RTC timestamp,",
            "\t * then read the RTC alarm value,"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\rtc\\interface.c"
          ]
        },
        {
          "file": "linux\\drivers\\rtc\\rtc-mt6397.c",
          "line": 231,
          "match": "race condition",
          "context": [
            "\t}",
            "",
            "\t/* All alarm time register write to hardware after calling",
            "\t * mtk_rtc_write_trigger. This can avoid race condition if alarm",
            "\t * occur happen during writing alarm time register.",
            "\t */",
            "\tret = mtk_rtc_write_trigger(rtc);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\rtc\\rtc-mt6397.c"
          ]
        },
        {
          "file": "linux\\drivers\\rtc\\rtc-rzn1.c",
          "line": 68,
          "match": "race condition",
          "context": [
            "\tvoid __iomem *base;",
            "\t/*",
            "\t * Protects access to RZN1_RTC_CTL1 reg. rtc_lock with threaded_irqs",
            "\t * would introduce race conditions when switching interrupts because",
            "\t * of potential sleeps",
            "\t */",
            "\tspinlock_t ctl1_access_lock;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\rtc\\rtc-rzn1.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\advansys.c",
          "line": 4259,
          "match": "race condition",
          "context": [
            "",
            "\t/*",
            "\t * Write the idle command value after the idle command parameter",
            "\t * has been written to avoid a race condition. If the order is not",
            "\t * followed, the microcode may process the idle command before the",
            "\t * parameters have been written to LRAM.",
            "\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\advansys.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\ips.c",
          "line": 64,
          "match": "race condition",
          "context": [
            "/*            SCBs                                                           */",
            "/*          - Send all of the commands on the queue at once rather than      */",
            "/*            one at a time since the card will support it.                  */",
            "/* 0.99.04  - Fix race condition in the passthru mechanism -- this required  */",
            "/*            the interface to the utilities to change                       */",
            "/*          - Fix error recovery code                                        */",
            "/* 0.99.05  - Fix an oops when we get certain passthru commands              */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\ips.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\storvsc_drv.c",
          "line": 549,
          "match": "race condition",
          "context": [
            " * We can get incoming messages from the host that are not in response to",
            " * messages that we have sent out. An example of this would be messages",
            " * received by the guest to notify dynamic addition/removal of LUNs. To",
            " * deal with potential race conditions where the driver may be in the",
            " * midst of being unloaded when we might receive an unsolicited message",
            " * from the host, we have implemented a mechanism to gurantee sequential",
            " * consistency:"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\storvsc_drv.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\wd33c93.c",
          "line": 1684,
          "match": "race condition",
          "context": [
            " * Case 4 : If we reached this point, the command was not found in any of",
            " *     the queues.",
            " *",
            " * We probably reached this point because of an unlikely race condition",
            " * between the command completing successfully and the abortion code,",
            " * so we won't panic, but we will notify the user in case something really",
            " * broke."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\wd33c93.c"
          ]
        },
        {
          "file": "linux\\drivers\\soundwire\\cadence_master.c",
          "line": 984,
          "match": "race condition",
          "context": [
            "\t\tint_status &= ~CDNS_MCP_INT_SLAVE_MASK;",
            "",
            "\t\t/*",
            "\t\t * Deal with possible race condition between interrupt",
            "\t\t * handling and disabling interrupts on suspend.",
            "\t\t *",
            "\t\t * If the master is in the process of disabling"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\soundwire\\cadence_master.c"
          ]
        },
        {
          "file": "linux\\drivers\\soundwire\\cadence_master.c",
          "line": 1074,
          "match": "race condition",
          "context": [
            "\t * the deviceB never being detected - until a change of status",
            "\t * is observed on the bus.",
            "\t *",
            "\t * To avoid this race condition, re-check if any device0 needs",
            "\t * attention with PING commands. There is no need to check for",
            "\t * ALERTS since they are not allowed until a non-zero",
            "\t * device_number is assigned."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\soundwire\\cadence_master.c"
          ]
        },
        {
          "file": "linux\\drivers\\target\\target_core_user.c",
          "line": 1675,
          "match": "race condition",
          "context": [
            "\t\txa_erase(&udev->data_pages, dpi);",
            "\t\t/*",
            "\t\t * While reaching here there may be page faults occurring on",
            "\t\t * the to-be-released pages. A race condition may occur if",
            "\t\t * unmap_mapping_range() is called before page faults on these",
            "\t\t * pages have completed; a valid but stale map is created.",
            "\t\t *"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\target\\target_core_user.c"
          ]
        },
        {
          "file": "linux\\drivers\\tty\\tty_io.c",
          "line": 1712,
          "match": "race condition",
          "context": [
            " * careful that the structures are all released at the same time, as interrupts",
            " * might otherwise get the wrong pointers.",
            " *",
            " * WSH 09/09/97: rewritten to avoid some nasty race conditions that could",
            " * lead to double frees or releasing memory still in use.",
            " */",
            "int tty_release(struct inode *inode, struct file *filp)"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\tty\\tty_io.c"
          ]
        },
        {
          "file": "linux\\drivers\\tty\\tty_ioctl.c",
          "line": 118,
          "match": "race condition",
          "context": [
            " *",
            " * Indicate that a @tty should stop transmitting data down the stack.",
            " * tty_throttle_safe() will only attempt throttle if @tty->flow_change is",
            " * %TTY_THROTTLE_SAFE. Prevents an accidental throttle due to race conditions",
            " * when throttling is conditional on factors evaluated prior to throttling.",
            " *",
            " * Returns: %true if @tty is throttled (or was already throttled)"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\tty\\tty_ioctl.c"
          ]
        },
        {
          "file": "linux\\drivers\\tty\\tty_ioctl.c",
          "line": 146,
          "match": "race conditions when unthrottling is condition",
          "context": [
            " *",
            " * Similar to tty_unthrottle() but will only attempt unthrottle if",
            " * @tty->flow_change is %TTY_UNTHROTTLE_SAFE. Prevents an accidental unthrottle",
            " * due to race conditions when unthrottling is conditional on factors evaluated",
            " * prior to unthrottling.",
            " *",
            " * Returns: %true if @tty is unthrottled (or was already unthrottled)"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\tty\\tty_ioctl.c"
          ]
        },
        {
          "file": "linux\\drivers\\tty\\tty_jobctrl.c",
          "line": 319,
          "match": "race condition",
          "context": [
            "\t}",
            "",
            "\t/* If tty->ctrl.pgrp is not NULL, it may be assigned to",
            "\t * current->signal->tty_old_pgrp in a race condition, and",
            "\t * cause pid memleak. Release current->signal->tty_old_pgrp",
            "\t * after tty->ctrl.pgrp set to NULL.",
            "\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\tty\\tty_jobctrl.c"
          ]
        },
        {
          "file": "linux\\drivers\\uio\\uio_sercos3.c",
          "line": 18,
          "match": "Race condition",
          "context": [
            "   a logical OR to make more controlled changes (rather than blindly",
            "   overwriting previous values).",
            "",
            "   Race conditions exist if the userspace-part directly modifies the",
            "   Interrupt Enable Register while in operation. The consequences are",
            "   that certain interrupts would fail to be enabled or disabled. For",
            "   this reason, the userspace-part should only directly modify the"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\uio\\uio_sercos3.c"
          ]
        },
        {
          "file": "linux\\drivers\\watchdog\\smsc37b787_wdt.c",
          "line": 494,
          "match": "race-condition",
          "context": [
            "\t\t\t\t\tunsigned long code, void *unused)",
            "{",
            "\tif (code == SYS_DOWN || code == SYS_HALT) {",
            "\t\t/* set timeout to 0, to avoid possible race-condition */",
            "\t\ttimeout = 0;",
            "\t\twb_smsc_wdt_disable();",
            "\t}"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\watchdog\\smsc37b787_wdt.c"
          ]
        },
        {
          "file": "linux\\drivers\\accel\\qaic\\qaic_timesync.c",
          "line": 259,
          "match": "race condition",
          "context": [
            "\tint ret;",
            "",
            "\tmhi_dev = qdev->qts_ch;",
            "\t/* Queue the response message beforehand to avoid race conditions */",
            "\tret = mhi_queue_buf(mhi_dev, DMA_FROM_DEVICE, &resp->data, sizeof(resp->data), MHI_EOT);",
            "\tif (ret) {",
            "\t\tkfree(resp);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\accel\\qaic\\qaic_timesync.c"
          ]
        },
        {
          "file": "linux\\drivers\\acpi\\acpica\\evxface.c",
          "line": 1034,
          "match": "race condition",
          "context": [
            "\t\treturn (AE_BAD_PARAMETER);",
            "\t}",
            "",
            "\t/* Must lock interpreter to prevent race conditions */",
            "",
            "\tacpi_ex_enter_interpreter();",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\acpi\\acpica\\evxface.c"
          ]
        },
        {
          "file": "linux\\drivers\\acpi\\acpica\\nswalk.c",
          "line": 201,
          "match": "race condition",
          "context": [
            "\t\t/*",
            "\t\t * Ignore all temporary namespace nodes (created during control",
            "\t\t * method execution) unless told otherwise. These temporary nodes",
            "\t\t * can cause a race condition because they can be deleted during",
            "\t\t * the execution of the user function (if the namespace is",
            "\t\t * unlocked before invocation of the user function.) Only the",
            "\t\t * debugger namespace dump will examine the temporary nodes."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\acpi\\acpica\\nswalk.c"
          ]
        },
        {
          "file": "linux\\drivers\\acpi\\acpica\\nsxfeval.c",
          "line": 425,
          "match": "race condition",
          "context": [
            "\tif (info->return_object) {",
            "\t\t/*",
            "\t\t * Delete the internal return object. NOTE: Interpreter must be",
            "\t\t * locked to avoid race condition.",
            "\t\t */",
            "\t\tacpi_ex_enter_interpreter();",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\acpi\\acpica\\nsxfeval.c"
          ]
        },
        {
          "file": "linux\\drivers\\char\\ipmi\\ipmi_msghandler.c",
          "line": 2085,
          "match": "race condition",
          "context": [
            "\t\t * We don't unlock until here, because we need",
            "\t\t * to copy the completed message into the",
            "\t\t * recv_msg before we release the lock.",
            "\t\t * Otherwise, race conditions may bite us.  I",
            "\t\t * know that's pretty paranoid, but I prefer",
            "\t\t * to be correct.",
            "\t\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\char\\ipmi\\ipmi_msghandler.c"
          ]
        },
        {
          "file": "linux\\drivers\\char\\ipmi\\ipmi_msghandler.c",
          "line": 2255,
          "match": "race condition",
          "context": [
            "\t\t * We don't unlock until here, because we need",
            "\t\t * to copy the completed message into the",
            "\t\t * recv_msg before we release the lock.",
            "\t\t * Otherwise, race conditions may bite us.  I",
            "\t\t * know that's pretty paranoid, but I prefer",
            "\t\t * to be correct.",
            "\t\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\char\\ipmi\\ipmi_msghandler.c"
          ]
        },
        {
          "file": "linux\\drivers\\char\\ipmi\\ipmi_msghandler.c",
          "line": 5577,
          "match": "race condition",
          "context": [
            "",
            "\t\t/*",
            "\t\t * Tell the timer to stop, then wait for it to stop.  This",
            "\t\t * avoids problems with race conditions removing the timer",
            "\t\t * here.",
            "\t\t */",
            "\t\tatomic_set(&stop_operation, 1);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\char\\ipmi\\ipmi_msghandler.c"
          ]
        },
        {
          "file": "linux\\drivers\\char\\mwave\\mwavedd.c",
          "line": 344,
          "match": "race condition",
          "context": [
            "\t\t\t\tset_current_state(TASK_INTERRUPTIBLE);",
            "\t\t\t\t/* check whether an event was signalled by */",
            "\t\t\t\t/* the interrupt handler while we were gone */",
            "\t\t\t\tif (pDrvData->IPCs[ipcnum].usIntCount == 1) {\t/* first int has occurred (race condition) */",
            "\t\t\t\t\tpDrvData->IPCs[ipcnum].usIntCount = 2;\t/* first int has been handled */",
            "\t\t\t\t\tPRINTK_2(TRACE_MWAVE,",
            "\t\t\t\t\t\t\"mwavedd::mwave_ioctl\""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\char\\mwave\\mwavedd.c"
          ]
        },
        {
          "file": "linux\\drivers\\char\\xillybus\\xillyusb.c",
          "line": 789,
          "match": "Race condition",
          "context": [
            "\t\tspin_lock_irqsave(&ep->buffers_lock, flags);",
            "",
            "\t\t/*",
            "\t\t * Race conditions might have the FIFO filled while the",
            "\t\t * endpoint is marked as drained here. That doesn't matter,",
            "\t\t * because the sole purpose of @drained is to ensure that",
            "\t\t * certain data has been sent on the USB channel before"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\char\\xillybus\\xillyusb.c"
          ]
        },
        {
          "file": "linux\\drivers\\clk\\mediatek\\clk-mt6765.c",
          "line": 630,
          "match": "race condition",
          "context": [
            "\tGATE_IFR5(CLK_IFR_CCIF3_MD, \"ifr_ccif3_md\", \"axi_ck\", 21),",
            "};",
            "",
            "/* additional CCF control for mipi26M race condition(disp/camera) */",
            "static const struct mtk_gate_regs apmixed_cg_regs = {",
            "\t.set_ofs = 0x14,",
            "\t.clr_ofs = 0x14,"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\clk\\mediatek\\clk-mt6765.c"
          ]
        },
        {
          "file": "linux\\drivers\\comedi\\drivers\\quatech_daqp_cs.c",
          "line": 548,
          "match": "race condition",
          "context": [
            "\t * = 3^3 * 2).  Hmmm... a one-line while loop or prime",
            "\t * decomposition of integers... I'll leave it the way it is.",
            "\t *",
            "\t * I'll also note a mini-race condition before ignoring it in",
            "\t * the code.  Let's say we're taking 4000 samples, as before.",
            "\t * After 1000 samples, we get an interrupt.  But before that",
            "\t * interrupt is completely serviced, another sample is taken"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\comedi\\drivers\\quatech_daqp_cs.c"
          ]
        },
        {
          "file": "linux\\drivers\\dma\\stm32\\stm32-dma.c",
          "line": 1371,
          "match": "race condition",
          "context": [
            "\t * - the sg_req currently transferred",
            "\t * - the Hardware remaining position in this sg (NDTR bits field).",
            "\t *",
            "\t * A race condition may occur if DMA is running in cyclic or double",
            "\t * buffer mode, since the DMA register are automatically reloaded at end",
            "\t * of period transfer. The hardware may have switched to the next",
            "\t * transfer (CT bit updated) just before the position (SxNDTR reg) is"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\dma\\stm32\\stm32-dma.c"
          ]
        },
        {
          "file": "linux\\drivers\\dma\\stm32\\stm32-dma.c",
          "line": 1385,
          "match": "race condition",
          "context": [
            "\t * the next transfer. So we approximate the residue in consequence, by",
            "\t * pointing on the beginning of next transfer.",
            "\t *",
            "\t * This race condition doesn't apply for none cyclic mode, as double",
            "\t * buffer is not used. In such situation registers are updated by the",
            "\t * software.",
            "\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\dma\\stm32\\stm32-dma.c"
          ]
        },
        {
          "file": "linux\\drivers\\firmware\\google\\memconsole-coreboot.c",
          "line": 36,
          "match": "race condition",
          "context": [
            "/*",
            " * The cbmem_console structure is read again on every access because it may",
            " * change at any time if runtime firmware logs new messages. This may rarely",
            " * lead to race conditions where the firmware overwrites the beginning of the",
            " * ring buffer with more lines after we have already read |cursor|. It should be",
            " * rare and harmless enough that we don't spend extra effort working around it.",
            " */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\firmware\\google\\memconsole-coreboot.c"
          ]
        },
        {
          "file": "linux\\drivers\\firmware\\arm_scmi\\transports\\mailbox.c",
          "line": 63,
          "match": "race condition",
          "context": [
            "\t * the ownership of the channel, because the platform at first releases",
            "\t * the SMT channel and then sends the completion interrupt.",
            "\t *",
            "\t * This addresses a possible race condition in which a spurious IRQ from",
            "\t * a previous timed-out reply which arrived late could be wrongly",
            "\t * associated with the next pending transaction.",
            "\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\firmware\\arm_scmi\\transports\\mailbox.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\drm_drv.c",
          "line": 1040,
          "match": "race condition",
          "context": [
            " *",
            " * NOTE: To ensure backward compatibility with existing drivers method this",
            " * function calls the &drm_driver.load method after registering the device",
            " * nodes, creating race conditions. Usage of the &drm_driver.load methods is",
            " * therefore deprecated, drivers must perform all initialization before calling",
            " * drm_dev_register().",
            " *"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\drm_drv.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\i915_perf.c",
          "line": 234,
          "match": "race condition",
          "context": [
            "/**",
            " * DOC: OA Tail Pointer Race",
            " *",
            " * There's a HW race condition between OA unit tail pointer register updates and",
            " * writes to memory whereby the tail pointer can sometimes get ahead of what's",
            " * been written out to the OA buffer so far (in terms of what's visible to the",
            " * CPU)."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\i915_perf.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\lima\\lima_sched.c",
          "line": 435,
          "match": "race condition",
          "context": [
            "",
            "\t/*",
            "\t * The task might still finish while this timeout handler runs.",
            "\t * To prevent a race condition on its completion, mask all irqs",
            "\t * on the running core until the next hard reset completes.",
            "\t */",
            "\tpipe->task_mask_irq(pipe);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\lima\\lima_sched.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\panfrost\\panfrost_gem.c",
          "line": 25,
          "match": "race condition",
          "context": [
            "\t/*",
            "\t * Make sure the BO is no longer inserted in the shrinker list before",
            "\t * taking care of the destruction itself. If we don't do that we have a",
            "\t * race condition between this function and what's done in",
            "\t * panfrost_gem_shrinker_scan().",
            "\t */",
            "\tmutex_lock(&pfdev->shrinker_lock);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\panfrost\\panfrost_gem.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\xen\\xen_drm_front_kms.c",
          "line": 274,
          "match": "race condition",
          "context": [
            "\t/*",
            "\t * Send page flip request to the backend *after* we have event cached",
            "\t * above, so on page flip done event from the backend we can",
            "\t * deliver it and there is no race condition between this code and",
            "\t * event from the backend.",
            "\t * If this is not a page flip, e.g. no flip done event from the backend",
            "\t * is expected, then send now."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\xen\\xen_drm_front_kms.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\amdgpu_fence.c",
          "line": 425,
          "match": "race condition",
          "context": [
            " * @timestamp: the start timestamp to update.",
            " *",
            " * The function called at the time the fence and related ib is about to",
            " * resubmit to gpu in MCBP scenario. Thus we do not consider race condition",
            " * with amdgpu_fence_process to modify the same fence.",
            " */",
            "void amdgpu_fence_update_start_timestamp(struct amdgpu_ring *ring, uint32_t seq, ktime_t timestamp)"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\amdgpu_fence.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\gmc_v9_0.c",
          "line": 2406,
          "match": "race condition",
          "context": [
            "\tadev->gmc.flush_pasid_uses_kiq = true;",
            "",
            "\t/* Vega20+XGMI caches PTEs in TC and TLB. Add a heavy-weight TLB flush",
            "\t * (type 2), which flushes both. Due to a race condition with",
            "\t * concurrent memory accesses using the same TLB cache line, we still",
            "\t * need a second TLB flush after this.",
            "\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\gmc_v9_0.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v1_0.c",
          "line": 1013,
          "match": "race condition",
          "context": [
            "\tjpeg_v1_0_start(adev, 0);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(UVD, 0, mmUVD_STATUS);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v1_0.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v1_0.c",
          "line": 1163,
          "match": "race condition",
          "context": [
            "\tjpeg_v1_0_start(adev, 1);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(UVD, 0, mmUVD_STATUS);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v1_0.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v1_0.c",
          "line": 1231,
          "match": "race condition",
          "context": [
            "\tvcn_1_0_enable_static_power_gating(vinst);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(UVD, 0, mmUVD_STATUS);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v1_0.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v1_0.c",
          "line": 1270,
          "match": "race condition",
          "context": [
            "\t\t\t~UVD_POWER_STATUS__UVD_PG_MODE_MASK);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(UVD, 0, mmUVD_STATUS);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v1_0.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v2_0.c",
          "line": 983,
          "match": "race condition",
          "context": [
            "\t\t0, ~UVD_POWER_STATUS__STALL_DPG_POWER_UP_MASK);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(UVD, 0, mmUVD_STATUS);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v2_0.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v2_0.c",
          "line": 1162,
          "match": "race condition",
          "context": [
            "\tfw_shared->multi_queue.encode_lowlatency_queue_mode &= ~FW_QUEUE_RING_RESET;",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(UVD, 0, mmUVD_STATUS);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v2_0.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v2_0.c",
          "line": 1198,
          "match": "race condition",
          "context": [
            "\t\t\t~UVD_POWER_STATUS__UVD_PG_MODE_MASK);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(UVD, 0, mmUVD_STATUS);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v2_0.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v2_0.c",
          "line": 1268,
          "match": "race condition",
          "context": [
            "\tvcn_v2_0_enable_static_power_gating(vinst);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(VCN, 0, mmUVD_STATUS);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v2_0.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v2_5.c",
          "line": 1162,
          "match": "race condition",
          "context": [
            "\t\t0, ~UVD_POWER_STATUS__STALL_DPG_POWER_UP_MASK);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(VCN, inst_idx, mmUVD_STATUS);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v2_5.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v2_5.c",
          "line": 1352,
          "match": "race condition",
          "context": [
            "\tfw_shared->multi_queue.encode_lowlatency_queue_mode &= ~FW_QUEUE_RING_RESET;",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(VCN, i, mmUVD_STATUS);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v2_5.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v2_5.c",
          "line": 1583,
          "match": "race condition",
          "context": [
            "\t\t\t~UVD_POWER_STATUS__UVD_PG_MODE_MASK);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(VCN, inst_idx, mmUVD_STATUS);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v2_5.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v2_5.c",
          "line": 1654,
          "match": "race condition",
          "context": [
            "\t\t ~UVD_POWER_STATUS__UVD_POWER_STATUS_MASK);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(VCN, i, mmUVD_STATUS);",
            "done:"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v2_5.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v3_0.c",
          "line": 1177,
          "match": "race condition",
          "context": [
            "\t\t0, ~UVD_POWER_STATUS__STALL_DPG_POWER_UP_MASK);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(VCN, inst_idx, mmUVD_STATUS);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v3_0.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v3_0.c",
          "line": 1369,
          "match": "race condition",
          "context": [
            "\t}",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(VCN, i, mmUVD_STATUS);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v3_0.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v3_0.c",
          "line": 1616,
          "match": "race condition",
          "context": [
            "\t\t~UVD_POWER_STATUS__UVD_PG_MODE_MASK);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(VCN, inst_idx, mmUVD_STATUS);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v3_0.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v3_0.c",
          "line": 1693,
          "match": "race condition",
          "context": [
            "\tvcn_v3_0_enable_static_power_gating(vinst);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(VCN, i, mmUVD_STATUS);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v3_0.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0.c",
          "line": 1126,
          "match": "race condition",
          "context": [
            "\t\t\tVCN_RB1_DB_CTRL__EN_MASK);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(VCN, inst_idx, regUVD_STATUS);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0.c",
          "line": 1312,
          "match": "race condition",
          "context": [
            "\tfw_shared->sq.queue_mode &= ~(FW_QUEUE_RING_RESET | FW_QUEUE_DPG_HOLD_OFF);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(VCN, i, regUVD_STATUS);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0.c",
          "line": 1598,
          "match": "race condition",
          "context": [
            "\t\t~UVD_POWER_STATUS__UVD_PG_MODE_MASK);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(VCN, inst_idx, regUVD_STATUS);",
            "}"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0.c",
          "line": 1685,
          "match": "race condition",
          "context": [
            "\tvcn_v4_0_enable_static_power_gating(vinst);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(VCN, i, regUVD_STATUS);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0_5.c",
          "line": 1038,
          "match": "race condition",
          "context": [
            "\t\t\tVCN_RB1_DB_CTRL__EN_MASK);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done, otherwise",
            "\t * it may introduce race conditions */",
            "\tRREG32_SOC15(VCN, inst_idx, regVCN_RB1_DB_CTRL);",
            "",
            "\treturn 0;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0_5.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0_5.c",
          "line": 1224,
          "match": "race condition",
          "context": [
            "\tfw_shared->sq.queue_mode &= ~(FW_QUEUE_RING_RESET | FW_QUEUE_DPG_HOLD_OFF);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done, otherwise",
            "\t * it may introduce race conditions */",
            "\tRREG32_SOC15(VCN, i, regVCN_RB_ENABLE);",
            "",
            "\treturn 0;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0_5.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0_5.c",
          "line": 1259,
          "match": "race condition",
          "context": [
            "\t\t~UVD_POWER_STATUS__UVD_PG_MODE_MASK);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(VCN, inst_idx, regUVD_STATUS);",
            "}"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0_5.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0_5.c",
          "line": 1346,
          "match": "race condition",
          "context": [
            "\tvcn_v4_0_5_enable_static_power_gating(vinst);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(VCN, i, regUVD_STATUS);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0_5.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0_3.c",
          "line": 981,
          "match": "race condition",
          "context": [
            "\tfw_shared->sq.queue_mode &= cpu_to_le32(~FW_QUEUE_RING_RESET);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(VCN, vcn_inst, regUVD_STATUS);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0_3.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0_3.c",
          "line": 1380,
          "match": "race condition",
          "context": [
            "\t\t ~UVD_POWER_STATUS__UVD_PG_MODE_MASK);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(VCN, vcn_inst, regUVD_STATUS);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0_3.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0_3.c",
          "line": 1468,
          "match": "race condition",
          "context": [
            "\tvcn_v4_0_3_enable_clock_gating(vinst);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(VCN, vcn_inst, regUVD_STATUS);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v4_0_3.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v5_0_1.c",
          "line": 1046,
          "match": "race condition",
          "context": [
            "\tfw_shared->sq.queue_mode &= ~(FW_QUEUE_RING_RESET | FW_QUEUE_DPG_HOLD_OFF);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(VCN, vcn_inst, regUVD_STATUS);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v5_0_1.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v5_0_1.c",
          "line": 1086,
          "match": "race condition",
          "context": [
            "\t\t~UVD_POWER_STATUS__UVD_PG_MODE_MASK);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(VCN, vcn_inst, regUVD_STATUS);",
            "}"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v5_0_1.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v5_0_1.c",
          "line": 1165,
          "match": "race condition",
          "context": [
            "\tWREG32_SOC15(VCN, vcn_inst, regUVD_STATUS, 0);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(VCN, vcn_inst, regUVD_STATUS);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v5_0_1.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v5_0_0.c",
          "line": 798,
          "match": "race condition",
          "context": [
            "\t\tVCN_RB1_DB_CTRL__EN_MASK);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(VCN, inst_idx, regUVD_STATUS);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v5_0_0.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v5_0_0.c",
          "line": 955,
          "match": "race condition",
          "context": [
            "\tfw_shared->sq.queue_mode &= ~(FW_QUEUE_RING_RESET | FW_QUEUE_DPG_HOLD_OFF);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(VCN, i, regUVD_STATUS);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v5_0_0.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v5_0_0.c",
          "line": 991,
          "match": "race condition",
          "context": [
            "\t\t~UVD_POWER_STATUS__UVD_PG_MODE_MASK);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(VCN, inst_idx, regUVD_STATUS);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v5_0_0.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v5_0_0.c",
          "line": 1077,
          "match": "race condition",
          "context": [
            "\tvcn_v5_0_0_enable_static_power_gating(vinst);",
            "",
            "\t/* Keeping one read-back to ensure all register writes are done,",
            "\t * otherwise it may introduce race conditions.",
            "\t */",
            "\tRREG32_SOC15(VCN, i, regUVD_STATUS);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\vcn_v5_0_0.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdkfd\\kfd_events.c",
          "line": 1024,
          "match": "race condition",
          "context": [
            "\t\t * case schedule_timeout will not put the task to",
            "\t\t * sleep and we'll get a chance to re-check the",
            "\t\t * updated conditions almost immediately. Otherwise,",
            "\t\t * this race condition would lead to a soft hang or a",
            "\t\t * very long sleep.",
            "\t\t */",
            "\t\tset_current_state(TASK_INTERRUPTIBLE);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdkfd\\kfd_events.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdkfd\\kfd_process.c",
          "line": 1301,
          "match": "race condition",
          "context": [
            "/*",
            " * This code handles the case when driver is being unloaded before all",
            " * mm_struct are released.  We need to safely free the kfd_process and",
            " * avoid race conditions with mmu_notifier that might try to free them.",
            " *",
            " */",
            "void kfd_cleanup_processes(void)"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdkfd\\kfd_process.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdkfd\\kfd_svm.c",
          "line": 3776,
          "match": "race condition",
          "context": [
            "\t/* Flush pending deferred work to avoid racing with deferred actions from",
            "\t * previous memory map changes (e.g. munmap). Concurrent memory map changes",
            "\t * can still race with get_attr because we don't hold the mmap lock. But that",
            "\t * would be a race condition in the application anyway, and undefined",
            "\t * behaviour is acceptable in that case.",
            "\t */",
            "\tflush_work(&p->svms.deferred_list_work);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdkfd\\kfd_svm.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\amdgpu_dm\\amdgpu_dm.c",
          "line": 697,
          "match": "race condition",
          "context": [
            "\t * pending pageflip events from here if a flip is still pending.",
            "\t *",
            "\t * If any planes are enabled, use dm_pflip_high_irq() instead, to",
            "\t * avoid race conditions between flip programming and completion,",
            "\t * which could cause too early flip completion events.",
            "\t */",
            "\tif (adev->family >= AMDGPU_FAMILY_RV &&"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\amdgpu_dm\\amdgpu_dm.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\link\\link_dpms.c",
          "line": 2546,
          "match": "race condition",
          "context": [
            "\tif (pipe_ctx->stream->dpms_off)",
            "\t\treturn;",
            "",
            "\t/* For Dp tunneling link, a pending HPD means that we have a race condition between processing",
            "\t * current link and processing the pending HPD. If we enable the link now, we may end up with a",
            "\t * link that is not actually connected to a sink. So we skip enabling the link in this case.",
            "\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\link\\link_dpms.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\hwss\\dce110\\dce110_hwseq.c",
          "line": 2108,
          "match": "race condition",
          "context": [
            "\t */",
            "\tfor (i = 0; i < num_pipes; i++) {",
            "\t\t/* dc_state_destruct() might null the stream resources, so fetch tg",
            "\t\t * here first to avoid a race condition. The lifetime of the pointee",
            "\t\t * itself (the timing_generator object) is not a problem here.",
            "\t\t */",
            "\t\tstruct timing_generator *tg = pipe_ctx[i]->stream_res.tg;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\hwss\\dce110\\dce110_hwseq.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\hwss\\dcn10\\dcn10_hwseq.c",
          "line": 3334,
          "match": "race condition",
          "context": [
            "\t */",
            "\tfor (i = 0; i < num_pipes; i++) {",
            "\t\t/* dc_state_destruct() might null the stream resources, so fetch tg",
            "\t\t * here first to avoid a race condition. The lifetime of the pointee",
            "\t\t * itself (the timing_generator object) is not a problem here.",
            "\t\t */",
            "\t\tstruct timing_generator *tg = pipe_ctx[i]->stream_res.tg;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\hwss\\dcn10\\dcn10_hwseq.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\hwss\\dcn35\\dcn35_hwseq.c",
          "line": 1494,
          "match": "race condition",
          "context": [
            "",
            "\tfor (i = 0; i < num_pipes; i++) {",
            "\t\t/* dc_state_destruct() might null the stream resources, so fetch tg",
            "\t\t * here first to avoid a race condition. The lifetime of the pointee",
            "\t\t * itself (the timing_generator object) is not a problem here.",
            "\t\t */",
            "\t\tstruct timing_generator *tg = pipe_ctx[i]->stream_res.tg;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\hwss\\dcn35\\dcn35_hwseq.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\link\\protocols\\link_dp_capability.c",
          "line": 2413,
          "match": "race condition",
          "context": [
            "\t\t\tlink->verified_link_cap = last_verified_link_cap;",
            "\t\t}",
            "",
            "\t\t/* For Dp tunneling link, a pending HPD means that we have a race condition between processing",
            "\t\t * current link and processing the pending HPD. Since the training is failed, we should just brak",
            "\t\t * the loop so that we have chance to process the pending HPD.",
            "\t\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\link\\protocols\\link_dp_capability.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\pm\\swsmu\\amdgpu_smu.c",
          "line": 355,
          "match": "race condition",
          "context": [
            " *",
            " * This API uses no smu->mutex lock protection due to:",
            " * 1. It is either called by other IP block(gfx/sdma/vcn/uvd/vce).",
            " *    This is guarded to be race condition free by the caller.",
            " * 2. Or get called on user setting request of power_dpm_force_performance_level.",
            " *    Under this case, the smu->mutex lock protection is already enforced on",
            " *    the parent API smu_force_performance_level of the call path."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\pm\\swsmu\\amdgpu_smu.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\bridge\\analogix\\anx7625.c",
          "line": 43,
          "match": "race condition",
          "context": [
            "",
            "/*",
            " * There is a sync issue while access I2C register between AP(CPU) and",
            " * internal firmware(OCM), to avoid the race condition, AP should access",
            " * the reserved slave address before slave address occurs changes.",
            " */",
            "static int i2c_access_workaround(struct anx7625_data *ctx,"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\bridge\\analogix\\anx7625.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_display_power.c",
          "line": 1097,
          "match": "race condition",
          "context": [
            "\t/*",
            "\t * Might be running this in parallel to gen9_dc_off_power_well_enable",
            "\t * being called from intel_dp_detect for instance,",
            "\t * which causes assertion triggered by race condition,",
            "\t * as gen9_assert_dbuf_enabled might preempt this when registers",
            "\t * were already updated, while dev_priv was not.",
            "\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\display\\intel_display_power.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_vblank.c",
          "line": 144,
          "match": "race condition",
          "context": [
            "\tu32 scan_prev_time, scan_curr_time, scan_post_time;",
            "",
            "\t/*",
            "\t * To avoid the race condition where we might cross into the",
            "\t * next vblank just between the PIPE_FRMTMSTMP and TIMESTAMP_CTR",
            "\t * reads. We make sure we read PIPE_FRMTMSTMP and TIMESTAMP_CTR",
            "\t * during the same frame."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\display\\intel_vblank.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\gem\\i915_gem_wait.c",
          "line": 227,
          "match": "race condition",
          "context": [
            " * non-zero timeout parameter the wait ioctl will wait for the given number of",
            " * nanoseconds on an object becoming unbusy. Since the wait itself does so",
            " * without holding struct_mutex the object may become re-busied before this",
            " * function completes. A similar but shorter * race condition exists in the busy",
            " * ioctl",
            " */",
            "int"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\gem\\i915_gem_wait.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_fw.c",
          "line": 174,
          "match": "race condition",
          "context": [
            "\t * (Higher levels of the driver may decide to reset the GuC and",
            "\t * attempt the ucode load again if this happens.)",
            "\t *",
            "\t * FIXME: There is a known (but exceedingly unlikely) race condition",
            "\t * where the asynchronous frequency management code could reduce",
            "\t * the GT clock while a GuC reload is in progress (during a full",
            "\t * GT reset). A fix is in progress but there are complex locking"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_fw.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_submission.c",
          "line": 3447,
          "match": "race condition",
          "context": [
            "\t * with suspend, so we undo everything if the H2G fails in deregister_context so",
            "\t * that GuC reset will find this context during clean up.",
            "\t *",
            "\t * There is a race condition where the reset code could have altered",
            "\t * this context's state and done a wakeref put before we try to",
            "\t * deregister it here. So check if the context is still set to be",
            "\t * destroyed before undoing earlier changes, to avoid two wakeref puts"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_submission.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_submission.c",
          "line": 3933,
          "match": "race condition",
          "context": [
            "\t/*",
            "\t * Call pin_guc_id here rather than in the pinning step as with",
            "\t * dma_resv, contexts can be repeatedly pinned / unpinned trashing the",
            "\t * guc_id and creating horrible race conditions. This is especially bad",
            "\t * when guc_id are being stolen due to over subscription. By the time",
            "\t * this function is reached, it is guaranteed that the guc_id will be",
            "\t * persistent until the generated request is retired. Thus, sealing these"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_submission.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_submission.c",
          "line": 3937,
          "match": "race condition",
          "context": [
            "\t * when guc_id are being stolen due to over subscription. By the time",
            "\t * this function is reached, it is guaranteed that the guc_id will be",
            "\t * persistent until the generated request is retired. Thus, sealing these",
            "\t * race conditions. It is still safe to fail here if guc_id are",
            "\t * exhausted and return -EAGAIN to the user indicating that they can try",
            "\t * again in the future.",
            "\t *"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_submission.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\nouveau\\nvkm\\subdev\\bios\\init.c",
          "line": 784,
          "match": "race(\"IO_FLAG_CONDITION",
          "context": [
            "\tstruct nvkm_bios *bios = init->subdev->device->bios;",
            "\tu8 cond = nvbios_rd08(bios, init->offset + 1);",
            "",
            "\ttrace(\"IO_FLAG_CONDITION\\t0x%02x\\n\", cond);",
            "\tinit->offset += 2;",
            "",
            "\tif (!init_io_flag_condition_met(init, cond))"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\nouveau\\nvkm\\subdev\\bios\\init.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\nouveau\\nvkm\\subdev\\bios\\init.c",
          "line": 805,
          "match": "race(\"GENERIC_CONDITION",
          "context": [
            "\tu8  ver, hdr, cnt, len;",
            "\tu16 data;",
            "",
            "\ttrace(\"GENERIC_CONDITION\\t0x%02x 0x%02x\\n\", cond, size);",
            "\tinit->offset += 3;",
            "",
            "\tswitch (cond) {"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\nouveau\\nvkm\\subdev\\bios\\init.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\nouveau\\nvkm\\subdev\\bios\\init.c",
          "line": 1244,
          "match": "race(\"CONDITION",
          "context": [
            "\tu8 retry = nvbios_rd08(bios, init->offset + 2);",
            "\tu8  wait = min((u16)retry * 50, 100);",
            "",
            "\ttrace(\"CONDITION_TIME\\t0x%02x 0x%02x\\n\", cond, retry);",
            "\tinit->offset += 3;",
            "",
            "\tif (!init_exec(init))"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\nouveau\\nvkm\\subdev\\bios\\init.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\nouveau\\nvkm\\subdev\\bios\\init.c",
          "line": 1696,
          "match": "race(\"RAM_CONDITION",
          "context": [
            "\tu8  mask = nvbios_rd08(bios, init->offset + 1);",
            "\tu8 value = nvbios_rd08(bios, init->offset + 2);",
            "",
            "\ttrace(\"RAM_CONDITION\\t\"",
            "\t      \"(R[0x100000] & 0x%02x) == 0x%02x\\n\", mask, value);",
            "\tinit->offset += 3;",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\nouveau\\nvkm\\subdev\\bios\\init.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\nouveau\\nvkm\\subdev\\bios\\init.c",
          "line": 1769,
          "match": "race(\"STRAP_CONDITION",
          "context": [
            "\tu32 mask = nvbios_rd32(bios, init->offset + 1);",
            "\tu32 value = nvbios_rd32(bios, init->offset + 5);",
            "",
            "\ttrace(\"STRAP_CONDITION\\t(R[0x101000] & 0x%08x) == 0x%08x\\n\", mask, value);",
            "\tinit->offset += 9;",
            "",
            "\tif ((init_rd32(init, 0x101000) & mask) != value)"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\nouveau\\nvkm\\subdev\\bios\\init.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\nouveau\\nvkm\\subdev\\bios\\init.c",
          "line": 1807,
          "match": "race(\"CONDITION",
          "context": [
            "\tstruct nvkm_bios *bios = init->subdev->device->bios;",
            "\tu8 cond = nvbios_rd08(bios, init->offset + 1);",
            "",
            "\ttrace(\"CONDITION\\t0x%02x\\n\", cond);",
            "\tinit->offset += 2;",
            "",
            "\tif (!init_condition_met(init, cond))"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\nouveau\\nvkm\\subdev\\bios\\init.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\nouveau\\nvkm\\subdev\\bios\\init.c",
          "line": 1824,
          "match": "race(\"IO_CONDITION",
          "context": [
            "\tstruct nvkm_bios *bios = init->subdev->device->bios;",
            "\tu8 cond = nvbios_rd08(bios, init->offset + 1);",
            "",
            "\ttrace(\"IO_CONDITION\\t0x%02x\\n\", cond);",
            "\tinit->offset += 2;",
            "",
            "\tif (!init_io_condition_met(init, cond))"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\nouveau\\nvkm\\subdev\\bios\\init.c"
          ]
        },
        {
          "file": "linux\\drivers\\hwtracing\\coresight\\coresight-etm-perf.c",
          "line": 600,
          "match": "race condition",
          "context": [
            "",
            "\t/*",
            "\t * The per CPU sink has own interrupt handling, it might have",
            "\t * race condition with updating buffer on AUX trace pause if",
            "\t * it is invoked from NMI.  To avoid the race condition,",
            "\t * disallows updating buffer for the per CPU sink case.",
            "\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hwtracing\\coresight\\coresight-etm-perf.c"
          ]
        },
        {
          "file": "linux\\drivers\\hwtracing\\coresight\\coresight-etm-perf.c",
          "line": 601,
          "match": "race condition",
          "context": [
            "\t/*",
            "\t * The per CPU sink has own interrupt handling, it might have",
            "\t * race condition with updating buffer on AUX trace pause if",
            "\t * it is invoked from NMI.  To avoid the race condition,",
            "\t * disallows updating buffer for the per CPU sink case.",
            "\t */",
            "\tif (coresight_is_percpu_sink(sink))"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hwtracing\\coresight\\coresight-etm-perf.c"
          ]
        },
        {
          "file": "linux\\drivers\\hwtracing\\coresight\\coresight-etm4x-core.c",
          "line": 2239,
          "match": "race condition",
          "context": [
            "\tinit_arg.csa = &access;",
            "",
            "\t/*",
            "\t * Serialize against CPUHP callbacks to avoid race condition",
            "\t * between the smp call and saving the delayed probe.",
            "\t */",
            "\tcpus_read_lock();"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hwtracing\\coresight\\coresight-etm4x-core.c"
          ]
        },
        {
          "file": "linux\\drivers\\hwtracing\\coresight\\coresight-syscfg.c",
          "line": 1234,
          "match": "race condition",
          "context": [
            "\t/*",
            "\t * grab the mutex - even though we are exiting, some configfs files",
            "\t * may still be live till we dump them, so ensure list data is",
            "\t * protected from a race condition.",
            "\t */",
            "\tmutex_lock(&cscfg_mutex);",
            "\twhile (!list_empty(&cscfg_mgr->load_order_list)) {"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hwtracing\\coresight\\coresight-syscfg.c"
          ]
        },
        {
          "file": "linux\\drivers\\i2c\\busses\\i2c-designware-master.c",
          "line": 869,
          "match": "race condition",
          "context": [
            "\t/*",
            "\t * We must disable the adapter before returning and signaling the end",
            "\t * of the current transfer. Otherwise the hardware might continue",
            "\t * generating interrupts which in turn causes a race condition with",
            "\t * the following transfer. Needs some more investigation if the",
            "\t * additional interrupts are a hardware bug or this driver doesn't",
            "\t * handle them correctly yet."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\i2c\\busses\\i2c-designware-master.c"
          ]
        },
        {
          "file": "linux\\drivers\\i2c\\busses\\i2c-meson.c",
          "line": 80,
          "match": "race condition",
          "context": [
            " * @count:\tNumber of bytes to be sent/received in current transfer",
            " * @pos:\tCurrent position in the send/receive buffer",
            " * @error:\tFlag set when an error is received",
            " * @lock:\tTo avoid race conditions between irq handler and xfer code",
            " * @done:\tCompletion used to wait for transfer termination",
            " * @tokens:\tSequence of tokens to be written to the device",
            " * @num_tokens:\tNumber of tokens"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\i2c\\busses\\i2c-meson.c"
          ]
        },
        {
          "file": "linux\\drivers\\i2c\\busses\\i2c-rcar.c",
          "line": 723,
          "match": "race condition",
          "context": [
            "",
            "/*",
            " * This driver has a lock-free design because there are IP cores (at least",
            " * R-Car Gen2) which have an inherent race condition in their hardware design.",
            " * There, we need to switch to RCAR_BUS_PHASE_DATA as soon as possible after",
            " * the interrupt was generated, otherwise an unwanted repeated message gets",
            " * generated. It turned out that taking a spinlock at the beginning of the ISR"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\i2c\\busses\\i2c-rcar.c"
          ]
        },
        {
          "file": "linux\\drivers\\iio\\adc\\mt6360-adc.c",
          "line": 61,
          "match": "race condition",
          "context": [
            "struct mt6360_adc_data {",
            "\tstruct device *dev;",
            "\tstruct regmap *regmap;",
            "\t/* Due to only one set of ADC control, this lock is used to prevent the race condition */",
            "\tstruct mutex adc_lock;",
            "\tktime_t last_off_timestamps[MT6360_CHAN_MAX];",
            "};"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\iio\\adc\\mt6360-adc.c"
          ]
        },
        {
          "file": "linux\\drivers\\iio\\addac\\stx104.c",
          "line": 91,
          "match": "race condition",
          "context": [
            "",
            "/**",
            " * struct stx104_iio - IIO device private data structure",
            " * @lock: synchronization lock to prevent I/O race conditions",
            " * @aio_data_map: Regmap for analog I/O data",
            " * @aio_ctl_map: Regmap for analog I/O control",
            " */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\iio\\addac\\stx104.c"
          ]
        },
        {
          "file": "linux\\drivers\\iio\\cdc\\ad7150.c",
          "line": 297,
          "match": "race condition",
          "context": [
            "\t\t\tgoto error_ret;",
            "",
            "\t\t/*",
            "\t\t * There is a potential race condition here, but not easy",
            "\t\t * to close given we can't disable the interrupt at the",
            "\t\t * chip side of things. Rely on the status bit.",
            "\t\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\iio\\cdc\\ad7150.c"
          ]
        },
        {
          "file": "linux\\drivers\\iio\\light\\st_uvis25_core.c",
          "line": 100,
          "match": "race condition",
          "context": [
            "\tmsleep(1500);",
            "",
            "\t/*",
            "\t * in order to avoid possible race conditions with interrupt",
            "\t * generation, disable the sensor first and then poll output",
            "\t * register. That sequence guarantees the interrupt will be reset",
            "\t * when irq line is unmasked"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\iio\\light\\st_uvis25_core.c"
          ]
        },
        {
          "file": "linux\\drivers\\infiniband\\hw\\hfi1\\firmware.c",
          "line": 635,
          "match": "race condition",
          "context": [
            "/*",
            " * Called by all HFIs when loading their firmware - i.e. device probe time.",
            " * The first one will do the actual firmware load.  Use a mutex to resolve",
            " * any possible race condition.",
            " *",
            " * The call to this routine cannot be moved to driver load because the kernel",
            " * call request_firmware() requires a device which is only available after"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\infiniband\\hw\\hfi1\\firmware.c"
          ]
        },
        {
          "file": "linux\\drivers\\infiniband\\hw\\hfi1\\qp.c",
          "line": 420,
          "match": "race condition",
          "context": [
            "\t\t/*",
            "\t\t * If we are sending a first-leg packet from the second leg,",
            "\t\t * we need to clear the busy flag from priv->s_flags to",
            "\t\t * avoid a race condition when the qp wakes up before",
            "\t\t * the call to hfi1_verbs_send() returns to the second",
            "\t\t * leg. In that case, the second leg will terminate without",
            "\t\t * being re-scheduled, resulting in failure to send TID RDMA"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\infiniband\\hw\\hfi1\\qp.c"
          ]
        },
        {
          "file": "linux\\drivers\\infiniband\\hw\\qib\\qib_sd7220.c",
          "line": 619,
          "match": "race condition",
          "context": [
            "}",
            "",
            "/*",
            " * Lemma to deal with race condition of write..read to epb regs",
            " */",
            "static int epb_trans(struct qib_devdata *dd, u16 reg, u64 i_val, u64 *o_vp)",
            "{"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\infiniband\\hw\\qib\\qib_sd7220.c"
          ]
        },
        {
          "file": "linux\\drivers\\infiniband\\ulp\\ipoib\\ipoib_main.c",
          "line": 1006,
          "match": "race condition",
          "context": [
            "\t\treturn NULL;",
            "\t}",
            "",
            "\t/* To avoid race condition, make sure that the",
            "\t * neigh will be added only once.",
            "\t */",
            "\tif (unlikely(!list_empty(&neigh->list))) {"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\infiniband\\ulp\\ipoib\\ipoib_main.c"
          ]
        },
        {
          "file": "linux\\drivers\\input\\misc\\xen-kbdfront.c",
          "line": 515,
          "match": "race condition",
          "context": [
            "",
            "\tcase XenbusStateConnected:",
            "\t\t/*",
            "\t\t * Work around xenbus race condition: If backend goes",
            "\t\t * through InitWait to Connected fast enough, we can",
            "\t\t * get Connected twice here.",
            "\t\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\input\\misc\\xen-kbdfront.c"
          ]
        },
        {
          "file": "linux\\drivers\\input\\mouse\\synaptics_i2c.c",
          "line": 237,
          "match": "race condition",
          "context": [
            "}",
            "",
            "/*",
            " * Driver's initial design makes no race condition possible on i2c bus,",
            " * so there is no need in any locking.",
            " * Keep it in mind, while playing with the code.",
            " */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\input\\mouse\\synaptics_i2c.c"
          ]
        },
        {
          "file": "linux\\drivers\\input\\rmi4\\rmi_f54.c",
          "line": 193,
          "match": "race condition",
          "context": [
            "\t}",
            "",
            "\t/*",
            "\t * Small delay after disabling interrupts to avoid race condition",
            "\t * in firmare. This value is a bit higher than absolutely necessary.",
            "\t * Should be removed once issue is resolved in firmware.",
            "\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\input\\rmi4\\rmi_f54.c"
          ]
        },
        {
          "file": "linux\\drivers\\iommu\\intel\\iommu.c",
          "line": 2204,
          "match": "race condition",
          "context": [
            "\t\tif (ecap_prs(iommu->ecap)) {",
            "\t\t\t/*",
            "\t\t\t * Call dmar_alloc_hwirq() with dmar_global_lock held,",
            "\t\t\t * could cause possible lock race condition.",
            "\t\t\t */",
            "\t\t\tup_write(&dmar_global_lock);",
            "\t\t\tret = intel_iommu_enable_prq(iommu);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\iommu\\intel\\iommu.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\bcache\\btree.c",
          "line": 1090,
          "match": "race condition",
          "context": [
            "\t * If the btree node is selected and flushing in btree_flush_write(),",
            "\t * delay and retry until the BTREE_NODE_journal_flush bit cleared,",
            "\t * then it is safe to free the btree node here. Otherwise this btree",
            "\t * node will be in race condition.",
            "\t */",
            "\tif (btree_node_journal_flush(b)) {",
            "\t\tmutex_unlock(&b->write_lock);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\bcache\\btree.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\dm-vdo\\funnel-workqueue.c",
          "line": 187,
          "match": "race condition",
          "context": [
            "\t\t *",
            "\t\t * Force synchronization between setting the idle flag and checking the funnel",
            "\t\t * queue; the producer side will do them in the reverse order. (There's still a",
            "\t\t * race condition we've chosen to allow, because we've got a timeout below that",
            "\t\t * unwedges us if we hit it, but this may narrow the window a little.)",
            "\t\t */",
            "\t\tatomic_set(&queue->idle, 1);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\dm-vdo\\funnel-workqueue.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\dm-vdo\\io-submitter.c",
          "line": 462,
          "match": "race condition",
          "context": [
            " * @io_submitter: The I/O submitter data to destroy.",
            " *",
            " * This must be called after vdo_cleanup_io_submitter(). It is used to release resources late in",
            " * the shutdown process to avoid or reduce the chance of race conditions.",
            " */",
            "void vdo_free_io_submitter(struct io_submitter *io_submitter)",
            "{"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\dm-vdo\\io-submitter.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\dvb-core\\dvb_ca_en50221.c",
          "line": 844,
          "match": "race condition",
          "context": [
            "",
            "\t/*",
            "\t * It may need some time for the CAM to settle down, or there might",
            "\t * be a race condition between the CAM, writing HC and our last",
            "\t * check for DA. This happens, if the CAM asserts DA, just after",
            "\t * checking DA before we are setting HC. In this case it might be",
            "\t * a bug in the CAM to keep the FR bit, the lower layer/HW"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\dvb-core\\dvb_ca_en50221.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\i2c\\adv7511-v4l2.c",
          "line": 930,
          "match": "race condition",
          "context": [
            "\tu8 irq_status;",
            "\tu8 cec_irq;",
            "",
            "\t/* disable interrupts to prevent a race condition */",
            "\tadv7511_set_isr(sd, false);",
            "\tirq_status = adv7511_rd(sd, 0x96);",
            "\tcec_irq = adv7511_rd(sd, 0x97);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\i2c\\adv7511-v4l2.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\mc\\mc-request.c",
          "line": 270,
          "match": "race condition",
          "context": [
            "\t * the request can never be released. The fdget() above ensures that",
            "\t * even if userspace closes the request filehandle, the release()",
            "\t * fop won't be called, so the media_request_get() always succeeds",
            "\t * and there is no race condition where the request was released",
            "\t * before media_request_get() is called.",
            "\t */",
            "\tmedia_request_get(req);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\mc\\mc-request.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\rc\\rc-main.c",
          "line": 681,
          "match": "race condition",
          "context": [
            "\tunsigned long flags;",
            "",
            "\t/*",
            "\t * ir->keyup_jiffies is used to prevent a race condition if a",
            "\t * hardware interrupt occurs at this point and the keyup timer",
            "\t * event is moved further into the future as a result.",
            "\t *"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\rc\\rc-main.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\pci\\cx23885\\cx23885-core.c",
          "line": 1611,
          "match": "race condition",
          "context": [
            " *",
            " * It also sets the final jump of the previous buffer to the start of the new",
            " * buffer, thus chaining the new buffer into the DMA chain. This is a single",
            " * atomic u32 write, so there is no race condition.",
            " *",
            " * The end-result of all this that you only get an interrupt when a buffer",
            " * is ready, so the control flow is very easy."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\pci\\cx23885\\cx23885-core.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\pci\\cx23885\\cx23885-vbi.c",
          "line": 177,
          "match": "race condition",
          "context": [
            " *",
            " * It also sets the final jump of the previous buffer to the start of the new",
            " * buffer, thus chaining the new buffer into the DMA chain. This is a single",
            " * atomic u32 write, so there is no race condition.",
            " *",
            " * The end-result of all this that you only get an interrupt when a buffer",
            " * is ready, so the control flow is very easy."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\pci\\cx23885\\cx23885-vbi.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\pci\\cx23885\\cx23885-video.c",
          "line": 451,
          "match": "race condition",
          "context": [
            " *",
            " * It also sets the final jump of the previous buffer to the start of the new",
            " * buffer, thus chaining the new buffer into the DMA chain. This is a single",
            " * atomic u32 write, so there is no race condition.",
            " *",
            " * The end-result of all this that you only get an interrupt when a buffer",
            " * is ready, so the control flow is very easy."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\pci\\cx23885\\cx23885-video.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\pci\\ivtv\\ivtv-firmware.c",
          "line": 52,
          "match": "race condition",
          "context": [
            "\t\tconst u32 *src = (const u32 *)fw->data;",
            "",
            "\t\tif (fw->size != size) {",
            "\t\t\t/* Due to race conditions in firmware loading (esp. with udev <0.95)",
            "\t\t\t   the wrong file was sometimes loaded. So we check filesizes to",
            "\t\t\t   see if at least the right-sized file was loaded. If not, then we",
            "\t\t\t   retry. */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\pci\\ivtv\\ivtv-firmware.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\pci\\tw68\\tw68-video.c",
          "line": 399,
          "match": "race condition",
          "context": [
            " *",
            " * It also sets the final jump of the previous buffer to the start of the new",
            " * buffer, thus chaining the new buffer into the DMA chain. This is a single",
            " * atomic u32 write, so there is no race condition.",
            " *",
            " * The end-result of all this that you only get an interrupt when a buffer",
            " * is ready, so the control flow is very easy."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\pci\\tw68\\tw68-video.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\platform\\broadcom\\bcm2835-unicam.c",
          "line": 826,
          "match": "race condition",
          "context": [
            "\t}",
            "",
            "\t/*",
            "\t * Cannot swap buffer at frame end, there may be a race condition",
            "\t * where the HW does not actually swap it if the new frame has",
            "\t * already started.",
            "\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\platform\\broadcom\\bcm2835-unicam.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\platform\\cadence\\cdns-csi2tx.c",
          "line": 97,
          "match": "race condition",
          "context": [
            "\tunsigned int\t\t\tcount;",
            "",
            "\t/*",
            "\t * Used to prevent race conditions between multiple,",
            "\t * concurrent calls to start and stop.",
            "\t */",
            "\tstruct mutex\t\t\tlock;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\platform\\cadence\\cdns-csi2tx.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\platform\\cadence\\cdns-csi2rx.c",
          "line": 79,
          "match": "race condition",
          "context": [
            "\tunsigned int\t\t\tcount;",
            "",
            "\t/*",
            "\t * Used to prevent race conditions between multiple,",
            "\t * concurrent calls to start and stop.",
            "\t */",
            "\tstruct mutex\t\t\tlock;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\platform\\cadence\\cdns-csi2rx.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\platform\\nxp\\imx8-isi\\imx8-isi-video.c",
          "line": 543,
          "match": "race condition",
          "context": [
            "\t *",
            "\t * As none of the shadow registers are accessible, races can occur",
            "\t * between address programming and buffer switching. It is possible to",
            "\t * detect the race condition by checking if a frame end interrupt",
            "\t * occurred after programming the addresses, but impossible to",
            "\t * determine if the race has been won or lost.",
            "\t *"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\platform\\nxp\\imx8-isi\\imx8-isi-video.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\platform\\nxp\\imx8-isi\\imx8-isi-video.c",
          "line": 623,
          "match": "race condition",
          "context": [
            "\t * using B1 just before we programmed B3. Unlike in the previous race",
            "\t * condition, B3 has been programmed and will be written to the next",
            "\t * time the ISI switches to BUF2. We can however handle this exactly as",
            "\t * the first race condition, as we'll program B3 (still at the head of",
            "\t * the pending list) when handling IRQ3.",
            "\t */",
            "\tstatus = mxc_isi_channel_irq_status(pipe, false);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\platform\\nxp\\imx8-isi\\imx8-isi-video.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\platform\\ti\\omap3isp\\isp.c",
          "line": 1200,
          "match": "race condition",
          "context": [
            "",
            "\t/*",
            "\t * atomic_set() doesn't include memory barrier on ARM platform for SMP",
            "\t * scenario. We'll call it here to avoid race conditions.",
            "\t */",
            "\tatomic_set(stopping, 1);",
            "\tsmp_mb();"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\platform\\ti\\omap3isp\\isp.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\platform\\ti\\omap3isp\\ispresizer.c",
          "line": 1330,
          "match": "race condition",
          "context": [
            "",
            "\t/* Update the source format, resizing ratios and crop rectangle. If",
            "\t * streaming is on the IRQ handler will reprogram the resizer after the",
            "\t * current frame. We thus we need to protect against race conditions.",
            "\t */",
            "\tspin_lock_irqsave(&res->lock, flags);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\platform\\ti\\omap3isp\\ispresizer.c"
          ]
        },
        {
          "file": "linux\\drivers\\misc\\bcm-vk\\bcm_vk_msg.c",
          "line": 1284,
          "match": "race condition",
          "context": [
            "\t/*",
            "\t * if there are outstanding DMA transactions, need to delay long enough",
            "\t * to ensure that the card side would have stopped touching the host buffer",
            "\t * and its SGL list.  A race condition could happen if the host app is killed",
            "\t * abruptly, eg kill -9, while some DMA transfer orders are still inflight.",
            "\t * Nothing could be done except for a delay as host side is running in a",
            "\t * completely async fashion."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\misc\\bcm-vk\\bcm_vk_msg.c"
          ]
        },
        {
          "file": "linux\\drivers\\mmc\\host\\omap_hsmmc.c",
          "line": 2068,
          "match": "race condition",
          "context": [
            "\t\tif (!(OMAP_HSMMC_READ(host->base, PSTATE) & DLEV_DAT(1))) {",
            "\t\t\t/*",
            "\t\t\t * dat1 line low, pending sdio irq",
            "\t\t\t * race condition: possible irq handler running on",
            "\t\t\t * multi-core, abort",
            "\t\t\t */",
            "\t\t\tdev_dbg(dev, \"pending sdio irq, abort suspend\\n\");"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\mmc\\host\\omap_hsmmc.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\arcnet\\arcnet.c",
          "line": 415,
          "match": "race window between the exit condition",
          "context": [
            "\trtnl_lock();",
            "",
            "\t/* Do another check, in case of an ifdown that was triggered in",
            "\t * the small race window between the exit condition above and",
            "\t * acquiring RTNL.",
            "\t */",
            "\tif (!netif_running(dev) || !lp->reset_in_progress)"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\arcnet\\arcnet.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\bonding\\bond_main.c",
          "line": 357,
          "match": "race condition",
          "context": [
            " * The design of synchronization/protection for this operation in the 8021q",
            " * module is good for one or more VLAN devices over a single physical device",
            " * and cannot be extended for a teaming solution like bonding, so there is a",
            " * potential race condition here where a net device from the vlan group might",
            " * be referenced (either by a base driver or the 8021q code) while it is being",
            " * removed from the system. However, it turns out we're not making matters",
            " * worse, and if it works for regular VLAN usage it will work here too."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\bonding\\bond_main.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\bonding\\bond_main.c",
          "line": 6570,
          "match": "race condition",
          "context": [
            "}",
            "",
            "/* According to commit 69b0216ac255 (\"bonding: fix bonding_masters",
            " * race condition in bond unloading\") we need to remove sysfs files",
            " * before we remove our devices (done later in bond_net_exit_rtnl())",
            " */",
            "static void __net_exit bond_net_pre_exit(struct net *net)"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\bonding\\bond_main.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ieee802154\\at86rf230.c",
          "line": 412,
          "match": "race condition",
          "context": [
            "\t\t * STATE_BUSY_RX_AACK and a SHR was detected.",
            "\t\t */",
            "\t\tif  (trx_state == STATE_BUSY_RX_AACK) {",
            "\t\t\t/* Undocumented race condition. If we send a state",
            "\t\t\t * change to STATE_RX_AACK_ON the transceiver could",
            "\t\t\t * change his state automatically to STATE_BUSY_RX_AACK",
            "\t\t\t * if a SHR was detected. This is not an error, but we"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ieee802154\\at86rf230.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\plip\\plip.c",
          "line": 956,
          "match": "race condition",
          "context": [
            "\t\tbreak;",
            "",
            "\tcase PLIP_CN_RECEIVE:",
            "\t\t/* May occur because there is race condition",
            "\t\t   around test and set of dev->interrupt.",
            "\t\t   Ignore this interrupt. */",
            "\t\tbreak;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\plip\\plip.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\slip\\slip.c",
          "line": 1246,
          "match": "race condition",
          "context": [
            "\t\tbreak;",
            "",
            "\tcase SIOCSLEASE:",
            "\t\t/* Resolve race condition, when ioctl'ing hanged up",
            "\t\t   and opened by another process device.",
            "\t\t */",
            "\t\tif (sl->tty != current->signal->tty &&"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\slip\\slip.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\can\\ctucanfd\\ctucanfd_base.c",
          "line": 965,
          "match": "race condition",
          "context": [
            "\tif (!framecnt && res != 0) {",
            "\t\tif (napi_complete_done(napi, work_done)) {",
            "\t\t\t/* Clear and enable RBNEI. It is level-triggered, so",
            "\t\t\t * there is no race condition.",
            "\t\t\t */",
            "\t\t\tctucan_write32(priv, CTUCANFD_INT_STAT, REG_INT_STAT_RBNEI);",
            "\t\t\tctucan_write32(priv, CTUCANFD_INT_MASK_CLR, REG_INT_STAT_RBNEI);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\can\\ctucanfd\\ctucanfd_base.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\can\\ctucanfd\\ctucanfd_base.c",
          "line": 1070,
          "match": "race condition",
          "context": [
            "\t\tspin_unlock_irqrestore(&priv->tx_lock, flags);",
            "",
            "\t\t/* If no buffers were processed this time, we cannot clear - that would introduce",
            "\t\t * a race condition.",
            "\t\t */",
            "\t\tif (some_buffers_processed) {",
            "\t\t\t/* Clear the interrupt again. We do not want to receive again interrupt for"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\can\\ctucanfd\\ctucanfd_base.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\can\\esd\\esdacc.c",
          "line": 334,
          "match": "race period where it counts 128 \"idle condition",
          "context": [
            "\t\t}",
            "\t\tacc_resetmode_leave(priv->core);",
            "\t\t/* To leave the bus-off state the esdACC controller begins",
            "\t\t * here a grace period where it counts 128 \"idle conditions\" (each",
            "\t\t * of 11 consecutive recessive bits) on the bus as required",
            "\t\t * by the CAN spec.",
            "\t\t *"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\can\\esd\\esdacc.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\can\\rockchip\\rockchip_canfd-core.c",
          "line": 661,
          "match": "race condition",
          "context": [
            "\tif (!reg_int)",
            "\t\treturn IRQ_NONE;",
            "",
            "\t/* First ACK then handle, to avoid lost-IRQ race condition on",
            "\t * fast re-occurring interrupts.",
            "\t */",
            "\trkcanfd_write(priv, RKCANFD_REG_INT, reg_int);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\can\\rockchip\\rockchip_canfd-core.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\can\\spi\\mcp251x.c",
          "line": 1086,
          "match": "race condition",
          "context": [
            "\t\t\tif (!(intf & CANINTF_RX1IF)) {",
            "\t\t\t\tu8 intf1, eflag1;",
            "",
            "\t\t\t\t/* intf needs to be read again to avoid a race condition */",
            "\t\t\t\tmcp251x_read_2regs(spi, CANINTF, &intf1, &eflag1);",
            "",
            "\t\t\t\t/* combine flags from both operations for error handling */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\can\\spi\\mcp251x.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\can\\usb\\gs_usb.c",
          "line": 317,
          "match": "race condition",
          "context": [
            "\tu32 feature;",
            "\tunsigned int hf_size_tx;",
            "",
            "\t/* This lock prevents a race condition between xmit and receive. */",
            "\tspinlock_t tx_ctx_lock;",
            "\tstruct gs_tx_context tx_context[GS_MAX_TX_URBS];",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\can\\usb\\gs_usb.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\can\\spi\\mcp251xfd\\mcp251xfd-core.c",
          "line": 1218,
          "match": "race condition",
          "context": [
            "\t * Sometimes there is an ECC error in the TX-RAM, which leads",
            "\t * to a TX MAB underflow.",
            "\t *",
            "\t * However, probably due to a race condition, there is no",
            "\t * associated MODIF pending.",
            "\t *",
            "\t * Further, there are situations, where the SERRIF is caused"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\can\\spi\\mcp251xfd\\mcp251xfd-core.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\can\\spi\\mcp251xfd\\mcp251xfd-core.c",
          "line": 1511,
          "match": "race condition",
          "context": [
            "\t\t * - First ACK then handle, to avoid lost-IRQ race",
            "\t\t *   condition on fast re-occurring interrupts.",
            "\t\t * - Write \"0\" to clear active IRQs, \"1\" to all other,",
            "\t\t *   to avoid r/m/w race condition on the",
            "\t\t *   MCP251XFD_REG_INT register.",
            "\t\t */",
            "\t\tintf_pending_clearable = intf_pending &"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\can\\spi\\mcp251xfd\\mcp251xfd-core.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\can\\usb\\etas_es58x\\es58x_core.c",
          "line": 646,
          "match": "race condition",
          "context": [
            " * through the drivers/net/can/dev.c:can_restart() function. The",
            " * device is technically capable to recover by itself under certain",
            " * circumstances, however, allowing self recovery would create",
            " * complex race conditions with drivers/net/can/dev.c:can_restart()",
            " * and thus was not implemented. To activate automatic restart, please",
            " * set the restart-ms parameter (e.g. ip link set can0 type can",
            " * restart-ms 100)."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\can\\usb\\etas_es58x\\es58x_core.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\dsa\\sja1105\\sja1105_tas.c",
          "line": 754,
          "match": "race condition",
          "context": [
            "\t\t/* Plan to start the earliest schedule first. The others",
            "\t\t * will be started in hardware, by way of their respective",
            "\t\t * entry points delta.",
            "\t\t * Try our best to avoid fringe cases (race condition between",
            "\t\t * ptpschtm and ptpstrtsch) by pushing the oper_base_time at",
            "\t\t * least one second in the future from now. This is not ideal,",
            "\t\t * but this only needs to buy us time until the"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\dsa\\sja1105\\sja1105_tas.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\3com\\3c509.c",
          "line": 38,
          "match": "race condition",
          "context": [
            "\t\tv1.10 4/21/97 Fixed module code so that multiple cards may be detected,",
            "\t\t\t\tother cleanups.  -djb",
            "\t\tAndrea Arcangeli:\tUpgraded to Donald Becker's version 1.12.",
            "\t\tRick Payne:\tFixed SMP race condition",
            "\t\tv1.13 9/8/97 Made 'max_interrupt_work' an insmod-settable variable -djb",
            "\t\tv1.14 10/15/97 Avoided waiting..discard message for fast machines -djb",
            "\t\tv1.15 1/31/98 Faster recovery for Tx errors. -djb"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\3com\\3c509.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\3com\\3c515.c",
          "line": 1471,
          "match": "race condition",
          "context": [
            "/*  Update statistics.",
            "\tUnlike with the EL3 we need not worry about interrupts changing",
            "\tthe window setting from underneath us, but we must still guard",
            "\tagainst a race condition with a StatsUpdate interrupt updating the",
            "\ttable.  This is done by checking that the ASM (!) code generated uses",
            "\tatomic updates with '+='.",
            "\t*/"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\3com\\3c515.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\3com\\3c59x.c",
          "line": 2841,
          "match": "race condition",
          "context": [
            "/*  Update statistics.",
            "\tUnlike with the EL3 we need not worry about interrupts changing",
            "\tthe window setting from underneath us, but we must still guard",
            "\tagainst a race condition with a StatsUpdate interrupt updating the",
            "\ttable.  This is done by checking that the ASM (!) code generated uses",
            "\tatomic updates with '+='.",
            "\t*/"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\3com\\3c59x.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\alteon\\acenic.c",
          "line": 30,
          "match": "race condition",
          "context": [
            " *                              driver under Linux/Sparc64",
            " *   Matt Domsch <Matt_Domsch@dell.com>: Detect Alteon 1000baseT cards",
            " *                                       ETHTOOL_GDRVINFO support",
            " *   Chip Salzenberg <chip@valinux.com>: Fix race condition between tx",
            " *                                       handler and close() cleanup.",
            " *   Ken Aaker <kdaaker@rchland.vnet.ibm.com>: Correct check for whether",
            " *                                       memory mapped IO is enabled to"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\alteon\\acenic.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\alteon\\acenic.c",
          "line": 2066,
          "match": "race condition",
          "context": [
            "\t/* So... tx_ret_csm is advanced _after_ check for device wakeup.",
            "\t *",
            "\t * We could try to make it before. In this case we would get",
            "\t * the following race condition: hard_start_xmit on other cpu",
            "\t * enters after we advanced tx_ret_csm and fills space,",
            "\t * which we have just freed, so that we make illegal device wakeup.",
            "\t * There is no good way to workaround this (at entry"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\alteon\\acenic.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\alteon\\acenic.c",
          "line": 2077,
          "match": "race condition",
          "context": [
            "\t * if we really have some space in ring (though the core doing",
            "\t * hard_start_xmit can see full ring for some period and has to",
            "\t * synchronize.) Superb.",
            "\t * BUT! We get another subtle race condition. hard_start_xmit",
            "\t * may think that ring is full between wakeup and advancing",
            "\t * tx_ret_csm and will stop device instantly! It is not so bad.",
            "\t * We are guaranteed that there is something in ring, so that"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\alteon\\acenic.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\alteon\\acenic.c",
          "line": 2509,
          "match": "race condition",
          "context": [
            "",
            "overflow:",
            "\t/*",
            "\t * This race condition is unavoidable with lock-free drivers.",
            "\t * We wake up the queue _before_ tx_prd is advanced, so that we can",
            "\t * enter hard_start_xmit too early, while tx ring still looks closed.",
            "\t * This happens ~1-4 times per 100000 packets, so that we can allow"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\alteon\\acenic.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\amd\\nmclan_cs.c",
          "line": 85,
          "match": "race condition",
          "context": [
            " * Revision 0.14  1995/05/23  03:19:30  rpao",
            " * Added, in nmclan_config(), \"tuple.Attributes = 0;\".",
            " * Modified MACE ID check to ignore chip revision level.",
            " * Avoid tx_free_frames race condition between _start_xmit and _interrupt.",
            " *",
            " * Revision 0.13  1995/05/18  05:56:34  rpao",
            " * Statistics changes."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\amd\\nmclan_cs.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\broadcom\\cnic.c",
          "line": 502,
          "match": "race condition",
          "context": [
            "\trcu_assign_pointer(cnic_ulp_tbl[ulp_type], ulp_ops);",
            "\tmutex_unlock(&cnic_lock);",
            "",
            "\t/* Prevent race conditions with netdev_event */",
            "\trtnl_lock();",
            "\tlist_for_each_entry(dev, &cnic_dev_list, list) {",
            "\t\tstruct cnic_local *cp = dev->cnic_priv;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\broadcom\\cnic.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\broadcom\\tg3.c",
          "line": 7293,
          "match": "race condition",
          "context": [
            "\t\t\ttw32_mailbox(tnapi->int_mbox, tnapi->last_tag << 24);",
            "",
            "\t\t\t/* This test here is synchronized by napi_schedule()",
            "\t\t\t * and napi_complete() to close the race condition.",
            "\t\t\t */",
            "\t\t\tif (unlikely(tnapi == &tp->napi[1] && tp->rx_refill)) {",
            "\t\t\t\ttw32(HOSTCC_MODE, tp->coalesce_mode |"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\broadcom\\tg3.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\cadence\\macb_main.c",
          "line": 2120,
          "match": "race condition",
          "context": [
            "\ttx_skb->skb = skb;",
            "",
            "\t/* Update TX ring: update buffer descriptors in reverse order",
            "\t * to avoid race condition",
            "\t */",
            "",
            "\t/* Set 'TX_USED' bit in buffer descriptor at tx_head position"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\cadence\\macb_main.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\calxeda\\xgmac.c",
          "line": 1130,
          "match": "race condition",
          "context": [
            "\telse",
            "\t\tdesc_flags |= TXDESC_LAST_SEG | irq_flag;",
            "",
            "\t/* Set owner on first desc last to avoid race condition */",
            "\twmb();",
            "\tdesc_set_tx_owner(first, desc_flags | TXDESC_FIRST_SEG);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\calxeda\\xgmac.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\sun\\cassini.c",
          "line": 166,
          "match": "race condition",
          "context": [
            "#if 1",
            "/*",
            " * Eliminate these and use separate atomic counters for each, to",
            " * avoid a race condition.",
            " */",
            "#else",
            "#define CAS_RESET_MTU                   1"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\sun\\cassini.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\sun\\sunvnet_common.c",
          "line": 706,
          "match": "race condition",
          "context": [
            "\t\treturn 0;",
            "\t}",
            "",
            "\t/* sync for race conditions with vnet_start_xmit() and tell xmit it",
            "\t * is time to send a trigger.",
            "\t */",
            "\ttrace_vnet_rx_stopped_ack(port->vio._local_sid,"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\sun\\sunvnet_common.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\brocade\\bna\\bnad.c",
          "line": 2988,
          "match": "race condition",
          "context": [
            "",
            "\t\tsmp_mb();",
            "\t\t/*",
            "\t\t * Check again to deal with race condition between",
            "\t\t * netif_stop_queue here, and netif_wake_queue in",
            "\t\t * interrupt handler which is not inside netif tx lock.",
            "\t\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\brocade\\bna\\bnad.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\cisco\\enic\\vnic_rq.c",
          "line": 149,
          "match": "race condition",
          "context": [
            "\tstruct vnic_dev *vdev = rq->vdev;",
            "\tint i;",
            "",
            "\t/* Due to a race condition with clearing RQ \"mini-cache\" in hw, we need",
            "\t * to disable the RQ twice to guarantee that stale descriptors are not",
            "\t * used when this RQ is re-enabled.",
            "\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\cisco\\enic\\vnic_rq.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\hisilicon\\hns3\\hns3vf\\hclgevf_mbx.c",
          "line": 20,
          "match": "race condition",
          "context": [
            "static void hclgevf_reset_mbx_resp_status(struct hclgevf_dev *hdev)",
            "{",
            "\t/* this function should be called with mbx_resp.mbx_mutex held",
            "\t * to protect the received_response from race condition",
            "\t */",
            "\thdev->mbx_resp.received_resp  = false;",
            "\thdev->mbx_resp.origin_mbx_msg = 0;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\hisilicon\\hns3\\hns3vf\\hclgevf_mbx.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\intel\\e1000\\e1000_main.c",
          "line": 504,
          "match": "race condition",
          "context": [
            "\tmsleep(10);",
            "",
            "\t/* Set the carrier off after transmits have been disabled in the",
            "\t * hardware, to avoid race conditions with e1000_watchdog() (which",
            "\t * may be running concurrently to us, checking for the carrier",
            "\t * bit to decide whether it should enable transmits again). Such",
            "\t * a race condition would result into transmission being disabled"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\intel\\e1000\\e1000_main.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\intel\\e1000\\e1000_main.c",
          "line": 507,
          "match": "race condition",
          "context": [
            "\t * hardware, to avoid race conditions with e1000_watchdog() (which",
            "\t * may be running concurrently to us, checking for the carrier",
            "\t * bit to decide whether it should enable transmits again). Such",
            "\t * a race condition would result into transmission being disabled",
            "\t * in the hardware until the next IFF_DOWN+IFF_UP cycle.",
            "\t */",
            "\tnetif_carrier_off(netdev);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\intel\\e1000\\e1000_main.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\intel\\i40e\\i40e_adminq.c",
          "line": 995,
          "match": "race condition",
          "context": [
            " *",
            " *  Acquires the lock and calls the main send command execution",
            " *  routine. Returns the last Admin Queue status in aq_status",
            " *  to avoid race conditions in access to hw->aq.asq_last_status.",
            " **/",
            "int",
            "i40e_asq_send_command_atomic_v2(struct i40e_hw *hw,"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\intel\\i40e\\i40e_adminq.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\intel\\i40e\\i40e_common.c",
          "line": 2297,
          "match": "race condition",
          "context": [
            " *",
            " * Add MAC/VLAN addresses to the HW filtering.",
            " * The _v2 version returns the last Admin Queue status in aq_status",
            " * to avoid race conditions in access to hw->aq.asq_last_status.",
            " * It also calls _v2 versions of asq_send_command functions to",
            " * get the aq_status on the stack.",
            " **/"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\intel\\i40e\\i40e_common.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\intel\\i40e\\i40e_common.c",
          "line": 2373,
          "match": "race condition",
          "context": [
            " *",
            " * Remove MAC/VLAN addresses from the HW filtering.",
            " * The _v2 version returns the last Admin Queue status in aq_status",
            " * to avoid race conditions in access to hw->aq.asq_last_status.",
            " * It also calls _v2 versions of asq_send_command functions to",
            " * get the aq_status on the stack.",
            " **/"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\intel\\i40e\\i40e_common.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\intel\\i40e\\i40e_nvm.c",
          "line": 1539,
          "match": "race condition",
          "context": [
            "\t\thw->nvmupd_state = I40E_NVMUPD_STATE_INIT;",
            "\t}",
            "",
            "\t/* Acquire lock to prevent race condition where adminq_task",
            "\t * can execute after i40e_nvmupd_nvm_read/write but before state",
            "\t * variables (nvm_wait_opcode, nvm_release_on_done) are updated.",
            "\t *"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\intel\\i40e\\i40e_nvm.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\intel\\ice\\ice_dcb_lib.c",
          "line": 412,
          "match": "race condition",
          "context": [
            "\tice_send_event_to_aux(pf, event);",
            "\tkfree(event);",
            "",
            "\t/* avoid race conditions by holding the lock while disabling and",
            "\t * re-enabling the VSI",
            "\t */",
            "\tif (!locked)"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\intel\\ice\\ice_dcb_lib.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\intel\\ice\\ice_ethtool.c",
          "line": 1908,
          "match": "race condition",
          "context": [
            "\t\t * correlations for statistics.",
            "\t\t *",
            "\t\t * Even if it appears to be safe, changes to the size or",
            "\t\t * order of strings will suffer from race conditions and are",
            "\t\t * not safe.",
            "\t\t */",
            "\t\treturn ICE_ALL_STATS_LEN(netdev);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\intel\\ice\\ice_ethtool.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\intel\\ice\\ice_idc.c",
          "line": 16,
          "match": "race condition",
          "context": [
            " * @cdev: pointer to iidc_rdma_core_dev_info struct",
            " *",
            " * This function has to be called with a device_lock on the",
            " * cdev->adev.dev to avoid race conditions.",
            " *",
            " * Return: pointer to the matched auxiliary driver struct",
            " */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\intel\\ice\\ice_idc.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\intel\\igb\\e1000_mbx.c",
          "line": 378,
          "match": "race condition",
          "context": [
            "\ts32 ret_val;",
            "\tu16 i;",
            "",
            "\t/* lock the mailbox to prevent pf/vf race condition */",
            "\tret_val = igb_obtain_mbx_lock_pf(hw, vf_number);",
            "\tif (ret_val)",
            "\t\tgoto out_no_write;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\intel\\igb\\e1000_mbx.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\intel\\igb\\e1000_mbx.c",
          "line": 420,
          "match": "race condition",
          "context": [
            "\ts32 ret_val;",
            "\tu16 i;",
            "",
            "\t/* lock the mailbox to prevent pf/vf race condition */",
            "\tret_val = igb_obtain_mbx_lock_pf(hw, vf_number);",
            "\tif (ret_val)",
            "\t\tgoto out_no_read;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\intel\\igb\\e1000_mbx.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\intel\\igbvf\\mbx.c",
          "line": 247,
          "match": "race condition",
          "context": [
            "",
            "\tlockdep_assert_held(&hw->mbx_lock);",
            "",
            "\t/* lock the mailbox to prevent pf/vf race condition */",
            "\terr = e1000_obtain_mbx_lock_vf(hw);",
            "\tif (err)",
            "\t\tgoto out_no_write;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\intel\\igbvf\\mbx.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\intel\\igbvf\\mbx.c",
          "line": 285,
          "match": "race condition",
          "context": [
            "",
            "\tlockdep_assert_held(&hw->mbx_lock);",
            "",
            "\t/* lock the mailbox to prevent pf/vf race condition */",
            "\terr = e1000_obtain_mbx_lock_vf(hw);",
            "\tif (err)",
            "\t\tgoto out_no_read;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\intel\\igbvf\\mbx.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\intel\\ixgbe\\ixgbe_mbx.c",
          "line": 339,
          "match": "race condition",
          "context": [
            "\tint ret_val;",
            "\tu16 i;",
            "",
            "\t/* lock the mailbox to prevent pf/vf race condition */",
            "\tret_val = ixgbe_obtain_mbx_lock_pf(hw, vf_number);",
            "\tif (ret_val)",
            "\t\treturn ret_val;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\intel\\ixgbe\\ixgbe_mbx.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\intel\\ixgbe\\ixgbe_mbx.c",
          "line": 378,
          "match": "race condition",
          "context": [
            "\tint ret_val;",
            "\tu16 i;",
            "",
            "\t/* lock the mailbox to prevent pf/vf race condition */",
            "\tret_val = ixgbe_obtain_mbx_lock_pf(hw, vf_number);",
            "\tif (ret_val)",
            "\t\treturn ret_val;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\intel\\ixgbe\\ixgbe_mbx.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\intel\\ixgbe\\ixgbe_main.c",
          "line": 6341,
          "match": "race condition",
          "context": [
            "",
            "\tif (ixgbe_removed(hw->hw_addr))",
            "\t\treturn;",
            "\t/* lock SFP init bit to prevent race conditions with the watchdog */",
            "\twhile (test_and_set_bit(__IXGBE_IN_SFP_INIT, &adapter->state))",
            "\t\tusleep_range(1000, 2000);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\intel\\ixgbe\\ixgbe_main.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\intel\\ixgbevf\\mbx.c",
          "line": 268,
          "match": "race condition",
          "context": [
            "\ts32 ret_val;",
            "\tu16 i;",
            "",
            "\t/* lock the mailbox to prevent PF/VF race condition */",
            "\tret_val = ixgbevf_obtain_mbx_lock_vf(hw);",
            "\tif (ret_val)",
            "\t\tgoto out_no_write;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\intel\\ixgbevf\\mbx.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\intel\\ixgbevf\\mbx.c",
          "line": 311,
          "match": "race condition",
          "context": [
            "\ts32 ret_val;",
            "\tu16 i;",
            "",
            "\t/* lock the mailbox to prevent PF/VF race condition */",
            "\tret_val = ixgbevf_obtain_mbx_lock_vf(hw);",
            "\tif (ret_val)",
            "\t\tgoto out_no_write;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\intel\\ixgbevf\\mbx.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\intel\\ixgbevf\\mbx.c",
          "line": 385,
          "match": "race condition",
          "context": [
            "\ts32 ret_val = 0;",
            "\tu16 i;",
            "",
            "\t/* lock the mailbox to prevent PF/VF race condition */",
            "\tret_val = ixgbevf_obtain_mbx_lock_vf(hw);",
            "\tif (ret_val)",
            "\t\tgoto out_no_read;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\intel\\ixgbevf\\mbx.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\mellanox\\mlx5\\core\\en_txrx.c",
          "line": 105,
          "match": "race condition",
          "context": [
            "\t\txsk_clear_tx_need_wakeup(xsksq->xsk_pool);",
            "",
            "\t/* If WQ is empty, RX won't trigger NAPI, so set need_wakeup. Do it",
            "\t * before refilling to avoid race condition with userspace.",
            "\t */",
            "\tif (need_wakeup && !mlx5e_rqwq_get_cur_sz(xskrq))",
            "\t\txsk_set_rx_need_wakeup(xskrq->xsk_pool);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\mellanox\\mlx5\\core\\en_txrx.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\qlogic\\netxen\\netxen_nic_init.c",
          "line": 1795,
          "match": "race condition",
          "context": [
            "\t * the card has already interrupted the host then the host can miss the",
            "\t * interrupt.",
            "\t *",
            "\t * There is still a possible race condition and the host could miss an",
            "\t * interrupt. The card has to take care of this.",
            "\t */",
            "\thw_consumer = le32_to_cpu(*(tx_ring->hw_consumer));"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\qlogic\\netxen\\netxen_nic_init.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\qlogic\\qlcnic\\qlcnic_io.c",
          "line": 948,
          "match": "race condition",
          "context": [
            "\t * the card has already interrupted the host then the host can miss the",
            "\t * interrupt.",
            "\t *",
            "\t * There is still a possible race condition and the host could miss an",
            "\t * interrupt. The card has to take care of this.",
            "\t */",
            "\thw_consumer = le32_to_cpu(*(tx_ring->hw_consumer));"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\qlogic\\qlcnic\\qlcnic_io.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\qualcomm\\emac\\emac-mac.c",
          "line": 973,
          "match": "race condition",
          "context": [
            "\tphy_stop(adpt->phydev);",
            "",
            "\t/* Interrupts must be disabled before the PHY is disconnected, to",
            "\t * avoid a race condition where adjust_link is null when we get",
            "\t * an interrupt.",
            "\t */",
            "\twritel(DIS_INT, adpt->base + EMAC_INT_STATUS);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\qualcomm\\emac\\emac-mac.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\stmicro\\stmmac\\dwmac4_descs.c",
          "line": 353,
          "match": "race condition",
          "context": [
            "\tif (is_fs && tx_own)",
            "\t\t/* When the own bit, for the first frame, has to be set, all",
            "\t\t * descriptors for the same frame has to be set before, to",
            "\t\t * avoid race condition.",
            "\t\t */",
            "\t\tdma_wmb();",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\stmicro\\stmmac\\dwmac4_descs.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\stmicro\\stmmac\\dwmac4_descs.c",
          "line": 396,
          "match": "race condition",
          "context": [
            "\tif (is_fs && tx_own)",
            "\t\t/* When the own bit, for the first frame, has to be set, all",
            "\t\t * descriptors for the same frame has to be set before, to",
            "\t\t * avoid race condition.",
            "\t\t */",
            "\t\tdma_wmb();",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\stmicro\\stmmac\\dwmac4_descs.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\stmicro\\stmmac\\dwxgmac2_descs.c",
          "line": 192,
          "match": "race condition",
          "context": [
            "\tif (is_fs && tx_own)",
            "\t\t/* When the own bit, for the first frame, has to be set, all",
            "\t\t * descriptors for the same frame has to be set before, to",
            "\t\t * avoid race condition.",
            "\t\t */",
            "\t\tdma_wmb();",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\stmicro\\stmmac\\dwxgmac2_descs.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\stmicro\\stmmac\\dwxgmac2_descs.c",
          "line": 232,
          "match": "race condition",
          "context": [
            "\tif (is_fs && tx_own)",
            "\t\t/* When the own bit, for the first frame, has to be set, all",
            "\t\t * descriptors for the same frame has to be set before, to",
            "\t\t * avoid race condition.",
            "\t\t */",
            "\t\tdma_wmb();",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\stmicro\\stmmac\\dwxgmac2_descs.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\stmicro\\stmmac\\enh_desc.c",
          "line": 342,
          "match": "race condition",
          "context": [
            "\tif (is_fs && tx_own)",
            "\t\t/* When the own bit, for the first frame, has to be set, all",
            "\t\t * descriptors for the same frame has to be set before, to",
            "\t\t * avoid race condition.",
            "\t\t */",
            "\t\tdma_wmb();",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\stmicro\\stmmac\\enh_desc.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\wangxun\\libwx\\wx_mbx.c",
          "line": 101,
          "match": "race condition",
          "context": [
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\t/* lock the mailbox to prevent pf/vf race condition */",
            "\tret = wx_obtain_mbx_lock_pf(wx, vf);",
            "\tif (ret)",
            "\t\treturn ret;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\wangxun\\libwx\\wx_mbx.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\wangxun\\libwx\\wx_mbx.c",
          "line": 141,
          "match": "race condition",
          "context": [
            "\tif (size > mbx->size)",
            "\t\tsize = mbx->size;",
            "",
            "\t/* lock the mailbox to prevent pf/vf race condition */",
            "\tret = wx_obtain_mbx_lock_pf(wx, vf);",
            "\tif (ret)",
            "\t\treturn ret;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\wangxun\\libwx\\wx_mbx.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\ath\\ath5k\\dma.c",
          "line": 747,
          "match": "race condition",
          "context": [
            "\told_mask = ah->ah_imr;",
            "",
            "\t/*",
            "\t * Disable card interrupts to prevent any race conditions",
            "\t * (they will be re-enabled afterwards if AR5K_INT GLOBAL",
            "\t * is set again on the new mask).",
            "\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\ath\\ath5k\\dma.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\ath\\ath6kl\\htc_pipe.c",
          "line": 954,
          "match": "race condition",
          "context": [
            "\tint status = 0;",
            "",
            "\t/*",
            "\t * ar->htc_target can be NULL due to a race condition that can occur",
            "\t * during driver initialization(we do 'ath6kl_hif_power_on' before",
            "\t * initializing 'ar->htc_target' via 'ath6kl_htc_create').",
            "\t * 'ath6kl_hif_power_on' assigns 'ath6kl_recv_complete' as"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\ath\\ath6kl\\htc_pipe.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\ath\\ath6kl\\main.c",
          "line": 932,
          "match": "race condition",
          "context": [
            "",
            "\t/*",
            "\t * If there are no associated STAs, ignore the DTIM expiry event.",
            "\t * There can be potential race conditions where the last associated",
            "\t * STA may disconnect & before the host could clear the 'Indicate",
            "\t * DTIM' request to the firmware, the firmware would have just",
            "\t * indicated a DTIM expiry event. The race is between 'clear DTIM"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\ath\\ath6kl\\main.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\ath\\ath9k\\xmit.c",
          "line": 2649,
          "match": "race condition",
          "context": [
            "\t\tbf = list_first_entry(&txq->axq_q, struct ath_buf, list);",
            "",
            "\t\t/*",
            "\t\t * There is a race condition that a BH gets scheduled",
            "\t\t * after sw writes TxE and before hw re-load the last",
            "\t\t * descriptor to get the newly chained one.",
            "\t\t * Software must keep the last DONE descriptor as a"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\ath\\ath9k\\xmit.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\ath\\wil6210\\txrx.c",
          "line": 1985,
          "match": "race condition",
          "context": [
            "\t}",
            "",
            "\t/* Make sure to advance the head only after descriptor update is done.",
            "\t * This will prevent a race condition where the completion thread",
            "\t * will see the DU bit set from previous run and will handle the",
            "\t * skb before it was completed.",
            "\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\ath\\wil6210\\txrx.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\ath\\wil6210\\txrx.c",
          "line": 2138,
          "match": "race condition",
          "context": [
            "\t}",
            "",
            "\t/* Make sure to advance the head only after descriptor update is done.",
            "\t * This will prevent a race condition where the completion thread",
            "\t * will see the DU bit set from previous run and will handle the",
            "\t * skb before it was completed.",
            "\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\ath\\wil6210\\txrx.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\broadcom\\b43\\main.c",
          "line": 1431,
          "match": "race condition",
          "context": [
            "\tif (dev->phy.type != B43_PHYTYPE_G)",
            "\t\treturn;",
            "",
            "\t/* Possible race condition: It might be possible that the user",
            "\t * changed to a different channel in the meantime since we",
            "\t * started the calculation. We ignore that fact, since it's",
            "\t * not really that much of a problem. The background noise is"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\broadcom\\b43\\main.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\broadcom\\brcm80211\\brcmfmac\\flowring.c",
          "line": 272,
          "match": "race condition",
          "context": [
            "\t    (skb_queue_len(&ring->skblist) > BRCMF_FLOWRING_HIGH)) {",
            "\t\tbrcmf_flowring_block(flow, flowid, true);",
            "\t\tbrcmf_dbg(MSGBUF, \"Flowcontrol: BLOCK for ring %d\\n\", flowid);",
            "\t\t/* To prevent (work around) possible race condition, check",
            "\t\t * queue len again. It is also possible to use locking to",
            "\t\t * protect, but that is undesirable for every enqueue and",
            "\t\t * dequeue. This simple check will solve a possible race"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\broadcom\\brcm80211\\brcmfmac\\flowring.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\intel\\ipw2x00\\ipw2100.c",
          "line": 6517,
          "match": "race condition",
          "context": [
            " * @returns 0 if ok, < 0 errno node con error.",
            " *",
            " * Note: we cannot init the /proc stuff until the PCI driver is there,",
            " * or we risk an unlikely race condition on someone accessing",
            " * uninitialized data in the PCI dev struct through /proc.",
            " */",
            "static int __init ipw2100_init(void)"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\intel\\ipw2x00\\ipw2100.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\intel\\iwlegacy\\4965-mac.c",
          "line": 5357,
          "match": "race condition",
          "context": [
            "",
            "\til_clear_ucode_stations(il);",
            "",
            "\t/* FIXME: race conditions ? */",
            "\tspin_lock_irq(&il->sta_lock);",
            "\t/*",
            "\t * Remove all key information that is not stored as part"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\intel\\iwlegacy\\4965-mac.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\intel\\iwlwifi\\mld\\mac80211.c",
          "line": 1367,
          "match": "race condition",
          "context": [
            "{",
            "\tstruct iwl_mld *mld = IWL_MAC80211_GET_MLD(hw);",
            "",
            "\t/* Due to a race condition, it's possible that mac80211 asks",
            "\t * us to stop a hw_scan when it's already stopped. This can",
            "\t * happen, for instance, if we stopped the scan ourselves,",
            "\t * called ieee80211_scan_completed() and the userspace called"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\intel\\iwlwifi\\mld\\mac80211.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\intel\\iwlwifi\\mld\\mac80211.c",
          "line": 1398,
          "match": "race condition",
          "context": [
            "{",
            "\tstruct iwl_mld *mld = IWL_MAC80211_GET_MLD(hw);",
            "",
            "\t/* Due to a race condition, it's possible that mac80211 asks",
            "\t * us to stop a sched_scan when it's already stopped. This",
            "\t * can happen, for instance, if we stopped the scan ourselves,",
            "\t * called ieee80211_sched_scan_stopped() and the userspace called"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\intel\\iwlwifi\\mld\\mac80211.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\intel\\iwlwifi\\mvm\\mac80211.c",
          "line": 3337,
          "match": "race condition",
          "context": [
            "",
            "\tguard(mvm)(mvm);",
            "",
            "\t/* Due to a race condition, it's possible that mac80211 asks",
            "\t * us to stop a hw_scan when it's already stopped.  This can",
            "\t * happen, for instance, if we stopped the scan ourselves,",
            "\t * called ieee80211_scan_completed() and the userspace called"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\intel\\iwlwifi\\mvm\\mac80211.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\intel\\iwlwifi\\mvm\\mac80211.c",
          "line": 4349,
          "match": "race condition",
          "context": [
            "",
            "\tmutex_lock(&mvm->mutex);",
            "",
            "\t/* Due to a race condition, it's possible that mac80211 asks",
            "\t * us to stop a sched_scan when it's already stopped.  This",
            "\t * can happen, for instance, if we stopped the scan ourselves,",
            "\t * called ieee80211_sched_scan_stopped() and the userspace called"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\intel\\iwlwifi\\mvm\\mac80211.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\intel\\iwlwifi\\mvm\\sta.c",
          "line": 1618,
          "match": "race condition",
          "context": [
            "",
            "/*",
            " * In DQA mode, after a HW restart the queues should be allocated as before, in",
            " * order to avoid race conditions when there are shared queues. This function",
            " * does the re-mapping and queue allocation.",
            " *",
            " * Note that re-enabling aggregations isn't done in this function."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\intel\\iwlwifi\\mvm\\sta.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\intel\\iwlwifi\\mvm\\tx.c",
          "line": 1210,
          "match": "race condition",
          "context": [
            "\t\t * Note that the no lock is taken here in order to not serialize",
            "\t\t * the TX flow. This isn't dangerous because scheduling",
            "\t\t * mvm->add_stream_wk can't ruin the state, and if we DON'T",
            "\t\t * schedule it due to some race condition then next TX we get",
            "\t\t * here we will.",
            "\t\t */",
            "\t\tif (unlikely(mvm->queue_info[txq_id].status =="
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\intel\\iwlwifi\\mvm\\tx.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\ralink\\rt2x00\\rt2400pci.c",
          "line": 1135,
          "match": "race condition",
          "context": [
            "\trt2x00_desc_write(txd, 4, word);",
            "",
            "\t/*",
            "\t * Writing TXD word 0 must the last to prevent a race condition with",
            "\t * the device, whereby the device may take hold of the TXD before we",
            "\t * finished updating it.",
            "\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\ralink\\rt2x00\\rt2400pci.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\ralink\\rt2x00\\rt2500pci.c",
          "line": 1284,
          "match": "race condition",
          "context": [
            "\trt2x00_desc_write(txd, 10, word);",
            "",
            "\t/*",
            "\t * Writing TXD word 0 must the last to prevent a race condition with",
            "\t * the device, whereby the device may take hold of the TXD before we",
            "\t * finished updating it.",
            "\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\ralink\\rt2x00\\rt2500pci.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\ralink\\rt2x00\\rt2x00mac.c",
          "line": 102,
          "match": "race condition",
          "context": [
            "\t * Mac80211 might be calling this function while we are trying",
            "\t * to remove the device or perhaps suspending it.",
            "\t * Note that we can only stop the TX queues inside the TX path",
            "\t * due to possible race conditions in mac80211.",
            "\t */",
            "\tif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))",
            "\t\tgoto exit_free_skb;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\ralink\\rt2x00\\rt2x00mac.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\ralink\\rt2x00\\rt61pci.c",
          "line": 1832,
          "match": "race condition",
          "context": [
            "\t}",
            "",
            "\t/*",
            "\t * Writing TXD word 0 must the last to prevent a race condition with",
            "\t * the device, whereby the device may take hold of the TXD before we",
            "\t * finished updating it.",
            "\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\ralink\\rt2x00\\rt61pci.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\realtek\\rtlwifi\\btcoexist\\halbtcoutsrc.c",
          "line": 181,
          "match": "race condition",
          "context": [
            "\tif (!halbtc_is_hw_mailbox_exist(btcoexist))",
            "\t\treturn false;",
            "",
            "\tif (wait_ms)\t/* before h2c to avoid race condition */",
            "\t\treinit_completion(&btcoexist->bt_mp_comp);",
            "",
            "\trtlpriv = btcoexist->adapter;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\realtek\\rtlwifi\\btcoexist\\halbtcoutsrc.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\realtek\\rtlwifi\\rtl8192ee\\fw.c",
          "line": 190,
          "match": "race condition",
          "context": [
            "",
            "\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD, \"come in\\n\");",
            "",
            "\t/* 1. Prevent race condition in setting H2C cmd.",
            "\t * (copy from MgntActSet_RF_State().)",
            "\t */",
            "\twhile (true) {"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\realtek\\rtlwifi\\rtl8192ee\\fw.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\st\\cw1200\\wsm.c",
          "line": 1321,
          "match": "race condition",
          "context": [
            "\t\tu16 wsm_cmd;",
            "",
            "\t\t/* Do not trust FW too much. Protection against repeated",
            "\t\t * response and race condition removal (see above).",
            "\t\t */",
            "\t\tspin_lock(&priv->wsm_cmd.lock);",
            "\t\twsm_arg = priv->wsm_cmd.arg;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\st\\cw1200\\wsm.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\ti\\wlcore\\main.c",
          "line": 604,
          "match": "race condition",
          "context": [
            "",
            "\t/*",
            "\t * In case edge triggered interrupt must be used, we cannot iterate",
            "\t * more than once without introducing race conditions with the hardirq.",
            "\t */",
            "\tif (wl->irq_flags & (IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING))",
            "\t\tloopcount = 1;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\ti\\wlcore\\main.c"
          ]
        },
        {
          "file": "linux\\drivers\\nfc\\pn533\\uart.c",
          "line": 35,
          "match": "race condition",
          "context": [
            "\t/*",
            "\t * send_wakeup variable is used to control if we need to send a wakeup",
            "\t * request to the pn532 chip prior to our actual command. There is a",
            "\t * little propability of a race condition. We decided to not mutex the",
            "\t * variable as the worst that could happen is, that we send a wakeup",
            "\t * to the chip that is already awake. This does not hurt. It is a",
            "\t * no-op to the chip."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\nfc\\pn533\\uart.c"
          ]
        },
        {
          "file": "linux\\drivers\\ntb\\test\\ntb_perf.c",
          "line": 269,
          "match": "race-condition",
          "context": [
            "\t/*",
            "\t * Perform predefined number of attempts before give up.",
            "\t * We are sending the data to the port specific scratchpad, so",
            "\t * to prevent a multi-port access race-condition. Additionally",
            "\t * there is no need in local locking since only thread-safe",
            "\t * service work is using this method.",
            "\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\ntb\\test\\ntb_perf.c"
          ]
        },
        {
          "file": "linux\\drivers\\ntb\\test\\ntb_perf.c",
          "line": 359,
          "match": "race-condition",
          "context": [
            "",
            "\t/*",
            "\t * Perform predefined number of attempts before give up. Message",
            "\t * registers are free of race-condition problem when accessed",
            "\t * from different ports, so we don't need splitting registers",
            "\t * by global device index. We also won't have local locking,",
            "\t * since the method is used from service work only."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\ntb\\test\\ntb_perf.c"
          ]
        },
        {
          "file": "linux\\drivers\\nvme\\target\\rdma.c",
          "line": 1006,
          "match": "race condition",
          "context": [
            "",
            "\tspin_lock_irqsave(&queue->state_lock, flags);",
            "\t/*",
            "\t * recheck queue state is not live to prevent a race condition",
            "\t * with RDMA_CM_EVENT_ESTABLISHED handler.",
            "\t */",
            "\tif (queue->state == NVMET_RDMA_Q_LIVE)"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\nvme\\target\\rdma.c"
          ]
        },
        {
          "file": "linux\\drivers\\pinctrl\\samsung\\pinctrl-samsung.c",
          "line": 553,
          "match": "race condition",
          "context": [
            "",
            "/*",
            " * The samsung_gpio_set_vlaue() should be called with \"bank->slock\" held",
            " * to avoid race condition.",
            " */",
            "static void samsung_gpio_set_value(struct gpio_chip *gc,",
            "\t\t\t\t\t  unsigned offset, int value)"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\pinctrl\\samsung\\pinctrl-samsung.c"
          ]
        },
        {
          "file": "linux\\drivers\\pinctrl\\samsung\\pinctrl-samsung.c",
          "line": 625,
          "match": "race condition",
          "context": [
            "",
            "/*",
            " * The samsung_gpio_set_direction() should be called with \"bank->slock\" held",
            " * to avoid race condition.",
            " * The calls to gpio_direction_output() and gpio_direction_input()",
            " * leads to this function call.",
            " */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\pinctrl\\samsung\\pinctrl-samsung.c"
          ]
        },
        {
          "file": "linux\\drivers\\power\\supply\\axp20x_usb_power.c",
          "line": 462,
          "match": "race condition",
          "context": [
            "\t}",
            "",
            "\t/*",
            "\t * BC1.2 detection can cause a race condition if we try to set a current",
            "\t * limit while it's in progress. When it finishes it will overwrite the",
            "\t * current limit we just set.",
            "\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\power\\supply\\axp20x_usb_power.c"
          ]
        },
        {
          "file": "linux\\drivers\\s390\\char\\tape_core.c",
          "line": 770,
          "match": "race condition",
          "context": [
            "\t\trequest = list_entry(l, struct tape_request, list);",
            "",
            "\t\t/*",
            "\t\t * Avoid race condition if bottom-half was triggered more than",
            "\t\t * once.",
            "\t\t */",
            "\t\tif (request->status == TAPE_REQUEST_IN_IO)"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\s390\\char\\tape_core.c"
          ]
        },
        {
          "file": "linux\\drivers\\s390\\net\\ctcm_mpc.c",
          "line": 593,
          "match": "race condition",
          "context": [
            "\t\t\t/* on the io_queue will now be sen t\t*/",
            "\t\t\ttasklet_schedule(&rch->ch_tasklet);",
            "\t\t}",
            "\t\t/* possible race condition\t\t\t*/",
            "\t\tif (mpcg_state == MPCG_STATE_READY) {",
            "\t\t\tgrp->flow_off_called = 1;",
            "\t\t\tbreak;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\s390\\net\\ctcm_mpc.c"
          ]
        },
        {
          "file": "linux\\drivers\\s390\\scsi\\zfcp_dbf.c",
          "line": 238,
          "match": "race event for bit error condition",
          "context": [
            "}",
            "",
            "/**",
            " * zfcp_dbf_hba_bit_err - trace event for bit error conditions",
            " * @tag: tag indicating which kind of bit error unsolicited status was received",
            " * @req: request which caused the bit_error condition",
            " */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\s390\\scsi\\zfcp_dbf.c"
          ]
        },
        {
          "file": "linux\\drivers\\s390\\scsi\\zfcp_scsi.c",
          "line": 179,
          "match": "race condition",
          "context": [
            "\tint retry = 3;",
            "\tchar *dbf_tag;",
            "",
            "\t/* avoid race condition between late normal completion and abort */",
            "\twrite_lock_irqsave(&adapter->abort_lock, flags);",
            "",
            "\told_req = zfcp_reqlist_find(adapter->req_list, old_reqid);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\s390\\scsi\\zfcp_scsi.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\arm\\acornscsi.c",
          "line": 21,
          "match": "race condition",
          "context": [
            " *\t\t\tUpdated proc/scsi reporting.",
            " *  05-Oct-1997\tRMK\tImplemented writing to SCSI devices.",
            " *  06-Oct-1997\tRMK\tCorrected small (non-serious) bug with the connect/",
            " *\t\t\treconnect race condition causing a warning message.",
            " *  12-Oct-1997\tRMK\tAdded catch for re-entering interrupt routine.",
            " *  15-Oct-1997\tRMK\tImproved handling of commands.",
            " *  27-Jun-1998\tRMK\tChanged asm/delay.h to linux/delay.h."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\arm\\acornscsi.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\bnx2fc\\bnx2fc_io.c",
          "line": 1194,
          "match": "race condition",
          "context": [
            "\t/*",
            "\t * Only eh_abort processing will remove the IO from",
            "\t * active_cmd_q before processing the request. this is",
            "\t * done to avoid race conditions between IOs aborted",
            "\t * as part of task management completion and eh_abort",
            "\t * processing",
            "\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\bnx2fc\\bnx2fc_io.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\bnx2fc\\bnx2fc_io.c",
          "line": 1271,
          "match": "race condition",
          "context": [
            "\t\tgoto done;",
            "\t} else {",
            "\t\t/*",
            "\t\t * We come here even when there was a race condition",
            "\t\t * between timeout and abts completion, and abts",
            "\t\t * completion happens just in time.",
            "\t\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\bnx2fc\\bnx2fc_io.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\lpfc\\lpfc_init.c",
          "line": 1739,
          "match": "race condition",
          "context": [
            "\t}",
            "",
            "\t/*",
            "\t * This is to ptrotect against a race condition in which",
            "\t * first write to the host attention register clear the",
            "\t * host status register.",
            "\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\lpfc\\lpfc_init.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\lpfc\\lpfc_sli.c",
          "line": 9276,
          "match": "race condition",
          "context": [
            "",
            "\tif (pmbox != NULL)",
            "\t\tmb = &pmbox->u.mb;",
            "\t/* Check the pmbox pointer first.  There is a race condition",
            "\t * between the mbox timeout handler getting executed in the",
            "\t * worklist and the mailbox actually completing. When this",
            "\t * race condition occurs, the mbox_active will be NULL."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\lpfc\\lpfc_sli.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\lpfc\\lpfc_sli.c",
          "line": 9279,
          "match": "race condition",
          "context": [
            "\t/* Check the pmbox pointer first.  There is a race condition",
            "\t * between the mbox timeout handler getting executed in the",
            "\t * worklist and the mailbox actually completing. When this",
            "\t * race condition occurs, the mbox_active will be NULL.",
            "\t */",
            "\tspin_lock_irq(&phba->hbalock);",
            "\tif (pmbox == NULL) {"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\lpfc\\lpfc_sli.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\mpt3sas\\mpt3sas_base.c",
          "line": 1587,
          "match": "race condition",
          "context": [
            " * @ioc: per adapter object",
            " *",
            " * Pause polling on the mq poll (io uring) queues when driver is flushing",
            " * out the IOs. Otherwise we may see the race condition of completing the same",
            " * IO from two paths.",
            " *",
            " * Returns nothing."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\mpt3sas\\mpt3sas_base.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\mvsas\\mv_sas.c",
          "line": 1542,
          "match": "race condition",
          "context": [
            "\tspin_lock(&task->task_state_lock);",
            "\ttask->task_state_flags &= ~SAS_TASK_STATE_PENDING;",
            "\ttask->task_state_flags |= SAS_TASK_STATE_DONE;",
            "\t/* race condition*/",
            "\taborted = task->task_state_flags & SAS_TASK_STATE_ABORTED;",
            "\tspin_unlock(&task->task_state_lock);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\mvsas\\mv_sas.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\pm8001\\pm8001_hwi.c",
          "line": 2947,
          "match": "race condition",
          "context": [
            "\t\tpm8001_ha->memoryMap.region[NVMD].virt_ptr,",
            "\t\tfw_control_context->len);",
            "\tkfree(ccb->fw_control_context);",
            "\t/* To avoid race condition, complete should be",
            "\t * called after the message is copied to",
            "\t * fw_control_context->usrAddr",
            "\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\pm8001\\pm8001_hwi.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\qedf\\qedf_main.c",
          "line": 2032,
          "match": "race condition",
          "context": [
            "",
            "/*",
            " * During removal we need to wait for all the vports associated with a port",
            " * to be destroyed so we avoid a race condition where libfc is still trying",
            " * to reap vports while the driver remove function has already reaped the",
            " * driver contexts associated with the physical port.",
            " */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\qedf\\qedf_main.c"
          ]
        },
        {
          "file": "linux\\drivers\\soc\\ixp4xx\\ixp4xx-npe.c",
          "line": 183,
          "match": "race condition",
          "context": [
            "\t__raw_writel(cmd, &npe->regs->exec_status_cmd);",
            "\t/* Iintroduce extra read cycles after issuing read command to NPE",
            "\t   so that we read the register after the NPE has updated it.",
            "\t   This is to overcome race condition between XScale and NPE */",
            "\t__raw_readl(&npe->regs->exec_data);",
            "\t__raw_readl(&npe->regs->exec_data);",
            "\treturn __raw_readl(&npe->regs->exec_data);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\soc\\ixp4xx\\ixp4xx-npe.c"
          ]
        },
        {
          "file": "linux\\drivers\\staging\\media\\atomisp\\pci\\sh_css_sp.c",
          "line": 1637,
          "match": "race-condition",
          "context": [
            "\t * Note 2: Not all SP binaries supports host2sp_commands.",
            "\t * In case a binary does support it, the host2sp_command",
            "\t * will have status cmd_ready after return of the function",
            "\t * sh_css_hrt_sp_start_isp. There is no race-condition here",
            "\t * because only after the process_frame command has been",
            "\t * received, the SP starts configuring the input network.",
            "\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\staging\\media\\atomisp\\pci\\sh_css_sp.c"
          ]
        },
        {
          "file": "linux\\drivers\\staging\\rtl8723bs\\hal\\rtl8723b_cmd.c",
          "line": 71,
          "match": "race condition",
          "context": [
            "\tif (padapter->bSurpriseRemoved)",
            "\t\tgoto exit;",
            "",
            "\t/* pay attention to if  race condition happened in  H2C cmd setting. */",
            "\tdo {",
            "\t\th2c_box_num = pHalData->LastHMEBoxNum;",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\staging\\rtl8723bs\\hal\\rtl8723b_cmd.c"
          ]
        },
        {
          "file": "linux\\drivers\\tty\\hvc\\hvcs.c",
          "line": 78,
          "match": "races around single statements following condition",
          "context": [
            "",
            "/*",
            " * 1.3.0 -> 1.3.1 In hvcs_open memset(..,0x00,..) instead of memset(..,0x3F,00).",
            " * Removed braces around single statements following conditionals.  Removed '=",
            " * 0' after static int declarations since these default to zero.  Removed",
            " * list_for_each_safe() and replaced with list_for_each_entry() in",
            " * hvcs_get_by_index().  The 'safe' version is un-needed now that the driver is"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\tty\\hvc\\hvcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\tty\\serial\\mpc52xx_uart.c",
          "line": 8,
          "match": "race condition",
          "context": [
            " * FIXME According to the usermanual the status bits in the status register",
            " * are only updated when the peripherals access the FIFO and not when the",
            " * CPU access them. So since we use this bits to know when we stop writing",
            " * and reading, they may not be updated in-time and a race condition may",
            " * exists. But I haven't be able to prove this and I don't care. But if",
            " * any problem arises, it might worth checking. The TX/RX FIFO Stats",
            " * registers should be used in addition."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\tty\\serial\\mpc52xx_uart.c"
          ]
        },
        {
          "file": "linux\\drivers\\tty\\serial\\serial_core.c",
          "line": 1076,
          "match": "race condition",
          "context": [
            "\t/*",
            "\t * If we're about to load something into the transmit",
            "\t * register, we'll pretend the transmitter isn't empty to",
            "\t * avoid a race condition (depending on when the transmit",
            "\t * interrupt happens).",
            "\t */",
            "\tif (uport->x_char ||"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\tty\\serial\\serial_core.c"
          ]
        },
        {
          "file": "linux\\drivers\\tty\\serial\\8250\\8250_port.c",
          "line": 1593,
          "match": "race condition",
          "context": [
            "\t * em485->active_timer != &em485->stop_tx_timer, it might happen that",
            "\t * the timer is still armed and triggers only after the current bunch of",
            "\t * chars is send and em485->active_timer == &em485->stop_tx_timer again.",
            "\t * So cancel the timer. There is still a theoretical race condition if",
            "\t * the timer is already running and only comes around to check for",
            "\t * em485->active_timer when &em485->stop_tx_timer is armed again.",
            "\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\tty\\serial\\8250\\8250_port.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\atm\\usbatm.c",
          "line": 46,
          "match": "race condition",
          "context": [
            " *\t\t- fixed memory leak and vcc->tx_inuse starvation bug",
            " *\t\t  when not enough memory left in vcc.",
            " *",
            " *  1.2:\t- Fixed race condition in usbatm_usb_send_data()",
            " *  1.1:\t- Turned off packet debugging",
            " *",
            " */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\atm\\usbatm.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\dwc2\\core.c",
          "line": 269,
          "match": "race condition",
          "context": [
            "",
            "\t/*",
            "\t * Wait For Restore_done Interrupt. This mechanism of polling the",
            "\t * interrupt is introduced to avoid any possible race conditions",
            "\t */",
            "\tif (dwc2_hsotg_wait_bit_set(hsotg, GINTSTS, GINTSTS_RESTOREDONE,",
            "\t\t\t\t    20000)) {"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\dwc2\\core.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\dwc2\\hcd_ddma.c",
          "line": 396,
          "match": "race condition",
          "context": [
            "",
            "/*",
            " * Determine starting frame for Isochronous transfer.",
            " * Few frames skipped to prevent race condition with HC.",
            " */",
            "static u16 dwc2_calc_starting_frame(struct dwc2_hsotg *hsotg,",
            "\t\t\t\t    struct dwc2_qh *qh, u16 *skip_frames)"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\dwc2\\hcd_ddma.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\image\\mdc800.c",
          "line": 32,
          "match": "race condition",
          "context": [
            " * version 0.7.5",
            " * Fixed potential SMP races with Spinlocks.",
            " * Thanks to Oliver Neukum <oliver@neukum.name> who ",
            " * noticed the race conditions.",
            " * (30/10/2000)",
            " *",
            " * Fixed: Setting urb->dev before submitting urb."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\image\\mdc800.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\phy\\phy-tegra-usb.c",
          "line": 998,
          "match": "race condition",
          "context": [
            "\t * disable interrupt for both PHY and CI or for CI only.  The",
            "\t * interrupt needs to be disabled while hardware is reprogrammed",
            "\t * because interrupt touches the programmed registers, and thus,",
            "\t * there could be a race condition.",
            "\t */",
            "\tif (phy->irq > 0)",
            "\t\tdisable_irq(phy->irq);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\phy\\phy-tegra-usb.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\serial\\digi_acceleport.c",
          "line": 566,
          "match": "race condition",
          "context": [
            " *  Digi transmit idle waits, up to timeout ticks, for the transmitter",
            " *  to go idle.  It returns 0 if successful or a negative error.",
            " *",
            " *  There are race conditions here if more than one process is calling",
            " *  digi_transmit_idle on the same port at the same time.  However, this",
            " *  is only called from close, and only one process can be in close on a",
            " *  port at a time, so its ok."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\serial\\digi_acceleport.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\usbip\\vhci_hcd.c",
          "line": 1012,
          "match": "race condition",
          "context": [
            "/*",
            " * The important thing is that only one context begins cleanup.",
            " * This is why error handling and cleanup become simple.",
            " * We do not want to consider race condition as possible.",
            " */",
            "static void vhci_shutdown_connection(struct usbip_device *ud)",
            "{"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\usbip\\vhci_hcd.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\gadget\\function\\f_eem.c",
          "line": 260,
          "match": "race condition",
          "context": [
            "\t * in drivers/usb/gadget/configfs.c:configfs_composite_bind()",
            "\t * configurations are bound in sequence with list_for_each_entry,",
            "\t * in each configuration its functions are bound in sequence",
            "\t * with list_for_each_entry, so we assume no race condition",
            "\t * with regard to eem_opts->bound access",
            "\t */",
            "\tif (!eem_opts->bound) {"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\gadget\\function\\f_eem.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\gadget\\function\\f_fs.c",
          "line": 1132,
          "match": "race condition",
          "context": [
            "\t\t\t\tgoto error_lock;",
            "\t\t\t}",
            "\t\t\t/*",
            "\t\t\t * To avoid race condition with ffs_epfile_io_complete,",
            "\t\t\t * dequeue the request first then check",
            "\t\t\t * status. usb_ep_dequeue API should guarantee no race",
            "\t\t\t * condition with req->complete callback."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\gadget\\function\\f_fs.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\gadget\\function\\f_fs.c",
          "line": 3521,
          "match": "race condition",
          "context": [
            "\t * in drivers/usb/gadget/configfs.c:configfs_composite_bind()",
            "\t * configurations are bound in sequence with list_for_each_entry,",
            "\t * in each configuration its functions are bound in sequence",
            "\t * with list_for_each_entry, so we assume no race condition",
            "\t * with regard to ffs_opts->bound access",
            "\t */",
            "\tif (!ffs_opts->refcnt) {"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\gadget\\function\\f_fs.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\gadget\\function\\f_phonet.c",
          "line": 497,
          "match": "race condition",
          "context": [
            "\t * in drivers/usb/gadget/configfs.c:configfs_composite_bind()",
            "\t * configurations are bound in sequence with list_for_each_entry,",
            "\t * in each configuration its functions are bound in sequence",
            "\t * with list_for_each_entry, so we assume no race condition",
            "\t * with regard to phonet_opts->bound access",
            "\t */",
            "\tif (!phonet_opts->bound) {"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\gadget\\function\\f_phonet.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\gadget\\function\\f_rndis.c",
          "line": 688,
          "match": "race condition",
          "context": [
            "\t * in drivers/usb/gadget/configfs.c:configfs_composite_bind()",
            "\t * configurations are bound in sequence with list_for_each_entry,",
            "\t * in each configuration its functions are bound in sequence",
            "\t * with list_for_each_entry, so we assume no race condition",
            "\t * with regard to rndis_opts->bound access",
            "\t */",
            "\tif (!rndis_opts->bound) {"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\gadget\\function\\f_rndis.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\gadget\\function\\f_subset.c",
          "line": 308,
          "match": "race condition",
          "context": [
            "\t * in drivers/usb/gadget/configfs.c:configfs_composite_bind()",
            "\t * configurations are bound in sequence with list_for_each_entry,",
            "\t * in each configuration its functions are bound in sequence",
            "\t * with list_for_each_entry, so we assume no race condition",
            "\t * with regard to gether_opts->bound access",
            "\t */",
            "\tif (!gether_opts->bound) {"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\gadget\\function\\f_subset.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\gadget\\function\\u_serial.c",
          "line": 87,
          "match": "race condition",
          "context": [
            "#define WRITE_BUF_SIZE\t\t8192\t\t/* TX only */",
            "#define GS_CONSOLE_BUF_SIZE\t8192",
            "",
            "/* Prevents race conditions while accessing gser->ioport */",
            "static DEFINE_SPINLOCK(serial_port_lock);",
            "",
            "/* console info */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\gadget\\function\\u_serial.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\gadget\\udc\\renesas_usbf.c",
          "line": 1674,
          "match": "race condition",
          "context": [
            "",
            "\tdo {",
            "\t\t/* Were going to read the FIFO for this current request.",
            "\t\t * NAK any other incoming data to avoid a race condition if no",
            "\t\t * more request are available.",
            "\t\t */",
            "\t\tif (!ep->is_in && ep->id != 0) {"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\gadget\\udc\\renesas_usbf.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\gadget\\udc\\snps_udc_core.c",
          "line": 78,
          "match": "race condition",
          "context": [
            "",
            "/* set_rde -- Is used to control enabling of RX DMA. Problem is",
            " * that UDC has only one bit (RDE) to enable/disable RX DMA for",
            " * all OUT endpoints. So we have to handle race conditions like",
            " * when OUT data reaches the fifo but no request was queued yet.",
            " * This cannot be solved by letting the RX DMA disabled until a",
            " * request gets queued because there may be other OUT packets"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\gadget\\udc\\snps_udc_core.c"
          ]
        },
        {
          "file": "linux\\drivers\\video\\fbdev\\vga16fb.c",
          "line": 105,
          "match": "race condition",
          "context": [
            "   the scenes in the VGA's 32-bit latch register, and reading and writing",
            "   video memory just invokes latch behavior.",
            "",
            "   To avoid race conditions (is this necessary?), reading and writing",
            "   the memory byte should be done with a single instruction.  One",
            "   suitable instruction is the x86 bitwise OR.  The following",
            "   read-modify-write routine should optimize to one such bitwise"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\video\\fbdev\\vga16fb.c"
          ]
        },
        {
          "file": "linux\\drivers\\video\\fbdev\\xen-fbfront.c",
          "line": 634,
          "match": "race condition",
          "context": [
            "",
            "\tcase XenbusStateConnected:",
            "\t\t/*",
            "\t\t * Work around xenbus race condition: If backend goes",
            "\t\t * through InitWait to Connected fast enough, we can",
            "\t\t * get Connected twice here.",
            "\t\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\video\\fbdev\\xen-fbfront.c"
          ]
        },
        {
          "file": "linux\\drivers\\video\\fbdev\\nvidia\\nv_accel.c",
          "line": 58,
          "match": "race condition",
          "context": [
            "#include \"nv_dma.h\"",
            "#include \"nv_local.h\"",
            "",
            "/* There is a HW race condition with videoram command buffers.",
            "   You can't jump to the location of your put offset.  We write put",
            "   at the jump offset + SKIPS dwords with noop padding in between",
            "   to solve this problem */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\video\\fbdev\\nvidia\\nv_accel.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\print-tree.c",
          "line": 220,
          "match": "race condition",
          "context": [
            "",
            "/*",
            " * Helper to output refs and locking status of extent buffer.  Useful to debug",
            " * race condition related problems.",
            " */",
            "static void print_eb_refs_lock(const struct extent_buffer *eb)",
            "{"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\print-tree.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\super.c",
          "line": 1197,
          "match": "race condition",
          "context": [
            "\t\t}",
            "\t\tif (subvol_objectid && root_objectid != subvol_objectid) {",
            "\t\t\t/*",
            "\t\t\t * This will also catch a race condition where a",
            "\t\t\t * subvolume which was passed by ID is renamed and",
            "\t\t\t * another subvolume is renamed over the old location.",
            "\t\t\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\super.c"
          ]
        },
        {
          "file": "linux\\fs\\erofs\\zdata.c",
          "line": 896,
          "match": "race condition",
          "context": [
            "",
            "\t/*",
            "\t * It's impossible to fail after the pcluster is freezed, but in order",
            "\t * to avoid some race conditions, add a DBG_BUGON to observe this.",
            "\t */",
            "\tDBG_BUGON(__xa_erase(&sbi->managed_pslots, pcl->pos) != pcl);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\erofs\\zdata.c"
          ]
        },
        {
          "file": "linux\\fs\\ext2\\ialloc.c",
          "line": 92,
          "match": "race condition",
          "context": [
            "/*",
            " * NOTE! When we get the inode, we're the only people",
            " * that have access to it, and as such there are no",
            " * race conditions we have to worry about. The inode",
            " * is not on the hash-lists, and it cannot be reached",
            " * through the filesystem because the directory entry",
            " * has been deleted earlier."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ext2\\ialloc.c"
          ]
        },
        {
          "file": "linux\\fs\\ext4\\extents_status.c",
          "line": 802,
          "match": "race condition",
          "context": [
            "\t\t\t\t\t       struct extent_status *es)",
            "{",
            "\t/*",
            "\t * We don't need to worry about the race condition because",
            "\t * caller takes i_data_sem locking.",
            "\t */",
            "\tBUG_ON(!rwsem_is_locked(&EXT4_I(inode)->i_data_sem));"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ext4\\extents_status.c"
          ]
        },
        {
          "file": "linux\\fs\\ext4\\ialloc.c",
          "line": 222,
          "match": "race condition",
          "context": [
            "/*",
            " * NOTE! When we get the inode, we're the only people",
            " * that have access to it, and as such there are no",
            " * race conditions we have to worry about. The inode",
            " * is not on the hash-lists, and it cannot be reached",
            " * through the filesystem because the directory entry",
            " * has been deleted earlier."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ext4\\ialloc.c"
          ]
        },
        {
          "file": "linux\\fs\\f2fs\\compress.c",
          "line": 1308,
          "match": "race condition",
          "context": [
            "\t\t/*",
            "\t\t * We need to wait for node_write to avoid block allocation during",
            "\t\t * checkpoint. This can only happen to quota writes which can cause",
            "\t\t * the below discard race condition.",
            "\t\t */",
            "\t\tf2fs_down_read(&sbi->node_write);",
            "\t} else if (!f2fs_trylock_op(sbi)) {"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\f2fs\\compress.c"
          ]
        },
        {
          "file": "linux\\fs\\f2fs\\data.c",
          "line": 2845,
          "match": "race condition",
          "context": [
            "\t\t/*",
            "\t\t * We need to wait for node_write to avoid block allocation during",
            "\t\t * checkpoint. This can only happen to quota writes which can cause",
            "\t\t * the below discard race condition.",
            "\t\t */",
            "\t\tif (quota_inode)",
            "\t\t\tf2fs_down_read(&sbi->node_write);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\f2fs\\data.c"
          ]
        },
        {
          "file": "linux\\fs\\f2fs\\dir.c",
          "line": 794,
          "match": "race condition",
          "context": [
            "\t\treturn err;",
            "",
            "\t/*",
            "\t * An immature stackable filesystem shows a race condition between lookup",
            "\t * and create. If we have same task when doing lookup and create, it's",
            "\t * definitely fine as expected by VFS normally. Otherwise, let's just",
            "\t * verify on-disk dentry one more time, which guarantees filesystem"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\f2fs\\dir.c"
          ]
        },
        {
          "file": "linux\\fs\\f2fs\\gc.c",
          "line": 1554,
          "match": "race condition",
          "context": [
            "\t\t/*",
            "\t\t * stop BG_GC if there is not enough free sections.",
            "\t\t * Or, stop GC if the segment becomes fully valid caused by",
            "\t\t * race condition along with SSR block allocation.",
            "\t\t */",
            "\t\tif ((gc_type == BG_GC && has_not_enough_free_secs(sbi, 0, 0)) ||",
            "\t\t\t(!force_migrate && get_valid_blocks(sbi, segno, true) =="
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\f2fs\\gc.c"
          ]
        },
        {
          "file": "linux\\fs\\lockd\\svclock.c",
          "line": 12,
          "match": "race condition",
          "context": [
            " * of the worst ideas Sun ever had. Except maybe for the idea of doing",
            " * NFS file locking at all.",
            " *",
            " * I'm trying hard to avoid race conditions by protecting most accesses",
            " * to a file's list of blocked locks through a semaphore. The global",
            " * list of blocked locks is not protected in this fashion however.",
            " * Therefore, some functions (such as the RPC callback for the async grant"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\lockd\\svclock.c"
          ]
        },
        {
          "file": "linux\\fs\\nfs\\nfs4proc.c",
          "line": 4516,
          "match": "race condition",
          "context": [
            " * Got race?",
            " * Because OPEN is always done by name in nfsv4, it is",
            " * possible that we opened a different file by the same",
            " * name.  We can recognize this race condition, but we",
            " * can't do anything about it besides returning an error.",
            " *",
            " * This will be fixed with VFS changes (lookup-intent)."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\nfs\\nfs4proc.c"
          ]
        },
        {
          "file": "linux\\fs\\nilfs2\\inode.c",
          "line": 111,
          "match": "race condition",
          "context": [
            "\t\t\t\t * be locked in this case.",
            "\t\t\t\t */",
            "\t\t\t\tnilfs_warn(inode->i_sb,",
            "\t\t\t\t\t   \"%s (ino=%lu): a race condition while inserting a data block at offset=%llu\",",
            "\t\t\t\t\t   __func__, inode->i_ino,",
            "\t\t\t\t\t   (unsigned long long)blkoff);",
            "\t\t\t\terr = -EAGAIN;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\nilfs2\\inode.c"
          ]
        },
        {
          "file": "linux\\fs\\nilfs2\\segment.c",
          "line": 2039,
          "match": "race condition",
          "context": [
            "\t\t\tgoto retry;",
            "\t\t}",
            "",
            "\t\t// Always redirty the buffer to avoid race condition",
            "\t\tmark_buffer_dirty(ii->i_bh);",
            "\t\tnilfs_mdt_mark_dirty(ifile);",
            ""
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\nilfs2\\segment.c"
          ]
        },
        {
          "file": "linux\\fs\\ufs\\ialloc.c",
          "line": 44,
          "match": "race condition",
          "context": [
            "/*",
            " * NOTE! When we get the inode, we're the only people",
            " * that have access to it, and as such there are no",
            " * race conditions we have to worry about. The inode",
            " * is not on the hash-lists, and it cannot be reached",
            " * through the filesystem because the directory entry",
            " * has been deleted earlier."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ufs\\ialloc.c"
          ]
        },
        {
          "file": "linux\\fs\\verity\\enable.c",
          "line": 382,
          "match": "race condition",
          "context": [
            "",
            "\t/*",
            "\t * We no longer drop the inode's pagecache after enabling verity.  This",
            "\t * used to be done to try to avoid a race condition where pages could be",
            "\t * evicted after being used in the Merkle tree construction, then",
            "\t * re-instantiated by a concurrent read.  Such pages are unverified, and",
            "\t * the backing storage could have filled them with different content, so"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\verity\\enable.c"
          ]
        },
        {
          "file": "linux\\fs\\verity\\enable.c",
          "line": 389,
          "match": "race condition",
          "context": [
            "\t * they shouldn't be used to fulfill reads once verity is enabled.",
            "\t *",
            "\t * But, dropping the pagecache has a big performance impact, and it",
            "\t * doesn't fully solve the race condition anyway.  So for those reasons,",
            "\t * and also because this race condition isn't very important relatively",
            "\t * speaking (especially for small-ish files, where the chance of a page",
            "\t * being used, evicted, *and* re-instantiated all while enabling verity"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\verity\\enable.c"
          ]
        },
        {
          "file": "linux\\fs\\verity\\enable.c",
          "line": 390,
          "match": "race condition",
          "context": [
            "\t *",
            "\t * But, dropping the pagecache has a big performance impact, and it",
            "\t * doesn't fully solve the race condition anyway.  So for those reasons,",
            "\t * and also because this race condition isn't very important relatively",
            "\t * speaking (especially for small-ish files, where the chance of a page",
            "\t * being used, evicted, *and* re-instantiated all while enabling verity",
            "\t * is quite small), we no longer drop the inode's pagecache."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\verity\\enable.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_aops.c",
          "line": 727,
          "match": "race condition",
          "context": [
            "\t * because the refcountbt entries for the extents being removed have",
            "\t * not yet been updated.  Hence the swapon call fails unexpectedly.",
            "\t *",
            "\t * The race condition is currently most obvious from the unlink()",
            "\t * operation as extent removal is deferred until after the last",
            "\t * reference to the inode goes away.  We then process the extent",
            "\t * removal asynchronously, hence triggers the \"syscall completed but"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_aops.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_buf_item.c",
          "line": 402,
          "match": "race condition",
          "context": [
            " * refcount drops to zero, the bli could still be AIL resident and the buffer",
            " * submitted for I/O at any point before we return. This can result in IO",
            " * completion freeing the buffer while we are still trying to access it here.",
            " * This race condition can also occur in shutdown situations where we abort and",
            " * unpin buffers from contexts other that journal IO completion.",
            " *",
            " * Hence we have to hold a buffer reference per pin count to ensure that the"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_buf_item.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_buf_item.c",
          "line": 517,
          "match": "race condition",
          "context": [
            "\t\t * If we have just raced with a buffer being pinned and it has",
            "\t\t * been marked stale, we could end up stalling until someone else",
            "\t\t * issues a log force to unpin the stale buffer. Check for the",
            "\t\t * race condition here so xfsaild recognizes the buffer is pinned",
            "\t\t * and queues a log force to move it along.",
            "\t\t */",
            "\t\tif (xfs_buf_ispinned(bp))"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_buf_item.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_inode_item.c",
          "line": 829,
          "match": "race condition",
          "context": [
            " * simply return the given lsn.",
            " *",
            " * If the inode has been marked stale because the cluster is being freed, we",
            " * don't want to (re-)insert this inode into the AIL. There is a race condition",
            " * where the cluster buffer may be unpinned before the inode is inserted into",
            " * the AIL during transaction committed processing. If the buffer is unpinned",
            " * before the inode item has been committed and inserted, then it is possible"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_inode_item.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_log_cil.c",
          "line": 238,
          "match": "race condition",
          "context": [
            " *",
            " * To avoid this, we need to move the memory allocation outside the",
            " * xc_ctx_lock, but because the log vector buffers are disposable, that opens",
            " * up a TOCTOU race condition w.r.t. the CIL committing and removing the log",
            " * vector buffers between the check and the formatting of the item into the",
            " * log vector buffer within the xc_ctx_lock.",
            " *"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_log_cil.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\trampoline.c",
          "line": 72,
          "match": "race condition",
          "context": [
            "\t *   cleanup_direct_functions_after_ipmodify",
            "\t *",
            "\t * In both cases, direct_mutex is already locked. Use",
            "\t * mutex_trylock(&tr->mutex) to avoid deadlock in race condition",
            "\t * (something else is making changes to this same trampoline).",
            "\t */",
            "\tif (!mutex_trylock(&tr->mutex)) {"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\trampoline.c"
          ]
        },
        {
          "file": "linux\\kernel\\cgroup\\cpuset.c",
          "line": 4305,
          "match": "race condition",
          "context": [
            "\t * relax locking here to avoid taking global locks - while accepting",
            "\t * there may be rare scenarios where the result may be innaccurate.",
            "\t *",
            "\t * Reclaim and migration are subject to these same race conditions, and",
            "\t * cannot make strong isolation guarantees, so this is acceptable.",
            "\t */",
            "\tcs = container_of(css, struct cpuset, css);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\cgroup\\cpuset.c"
          ]
        },
        {
          "file": "linux\\kernel\\futex\\core.c",
          "line": 941,
          "match": "race condition",
          "context": [
            "\t\t/*",
            "\t\t * q->lock_ptr can change between reading it and",
            "\t\t * spin_lock(), causing us to take the wrong lock.  This",
            "\t\t * corrects the race condition.",
            "\t\t *",
            "\t\t * Reasoning goes like this: if we have the wrong lock,",
            "\t\t * q->lock_ptr must have changed (maybe several times)"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\futex\\core.c"
          ]
        },
        {
          "file": "linux\\kernel\\futex\\pi.c",
          "line": 864,
          "match": "race condition",
          "context": [
            " * @locked:\tif the attempt to take the rt_mutex succeeded (1) or not (0)",
            " *",
            " * After attempting to lock an rt_mutex, this function is called to cleanup",
            " * the pi_state owner as well as handle race conditions that may allow us to",
            " * acquire the lock. Must be called with the hb lock held.",
            " *",
            " * Return:"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\futex\\pi.c"
          ]
        },
        {
          "file": "linux\\kernel\\futex\\waitwake.c",
          "line": 608,
          "match": "race condition",
          "context": [
            "\t * The basic logical guarantee of a futex is that it blocks ONLY",
            "\t * if cond(var) is known to be true at the time of blocking, for",
            "\t * any cond.  If we locked the hash-bucket after testing *uaddr, that",
            "\t * would open a race condition where we could block indefinitely with",
            "\t * cond(var) false, which would violate the guarantee.",
            "\t *",
            "\t * On the other hand, we insert q and release the hash-bucket only"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\futex\\waitwake.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rwsem.c",
          "line": 597,
          "match": "race condition",
          "context": [
            "",
            "/*",
            " * This function must be called with the sem->wait_lock held to prevent",
            " * race conditions between checking the rwsem wait list and setting the",
            " * sem->count accordingly.",
            " *",
            " * Implies rwsem_del_waiter() on success."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rwsem.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\rcutorture.c",
          "line": 1284,
          "match": "race condition",
          "context": [
            "/*",
            " * RCU torture force-quiescent-state kthread.  Repeatedly induces",
            " * bursts of calls to force_quiescent_state(), increasing the probability",
            " * of occurrence of some important types of race conditions.",
            " */",
            "static int",
            "rcu_torture_fqs(void *arg)"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\rcutorture.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\rcutorture.c",
          "line": 3892,
          "match": "race condition",
          "context": [
            "static void rcu_torture_err_cb(struct rcu_head *rhp)",
            "{",
            "\t/*",
            "\t * This -might- happen due to race conditions, but is unlikely.",
            "\t * The scenario that leads to this happening is that the",
            "\t * first of the pair of duplicate callbacks is queued,",
            "\t * someone else starts a grace period that includes that"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\rcutorture.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\deadline.c",
          "line": 394,
          "match": "race condition",
          "context": [
            " * inactive timer fired (and running_bw has been decreased) the",
            " * task's utilization has to be added to running_bw again.",
            " * A flag in the deadline scheduling entity (dl_non_contending)",
            " * is used to avoid race conditions between the inactive timer handler",
            " * and task wakeups.",
            " *",
            " * The following diagram shows how running_bw is updated. A task is"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\deadline.c"
          ]
        },
        {
          "file": "linux\\kernel\\time\\posix-cpu-timers.c",
          "line": 242,
          "match": "race condition",
          "context": [
            "",
            "/*",
            " * Set cputime to sum_cputime if sum_cputime > cputime. Use cmpxchg",
            " * to avoid race conditions with concurrent updates to cputime.",
            " */",
            "static inline void __update_gt_cputime(atomic64_t *cputime, u64 sum_cputime)",
            "{"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\time\\posix-cpu-timers.c"
          ]
        },
        {
          "file": "linux\\kernel\\time\\timer_migration.c",
          "line": 91,
          "match": "race condition",
          "context": [
            " * The groups are built up at init time or when CPUs come online. They are",
            " * not destroyed when a group becomes empty due to offlining. The group",
            " * just won't participate in the hierarchy management anymore. Destroying",
            " * groups would result in interesting race conditions which would just make",
            " * the whole mechanism slow and complex.",
            " *",
            " *"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\time\\timer_migration.c"
          ]
        },
        {
          "file": "linux\\kernel\\time\\timer_migration.c",
          "line": 167,
          "match": "race condition",
          "context": [
            " *    CPUs     0           1              2           3",
            " *             idle    --> active         active      idle",
            " *",
            " * 3. Here is the race condition: CPU1 managed to propagate its changes (from",
            " *    step 2) through the hierarchy to GRP1:0 before CPU0 (step 1) did. The",
            " *    active members of GRP1:0 remain unchanged after the update since it is",
            " *    still valid from CPU1 current point of view:"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\time\\timer_migration.c"
          ]
        },
        {
          "file": "linux\\kernel\\trace\\trace.c",
          "line": 1301,
          "match": "race when some condition",
          "context": [
            " *",
            " * This causes a swap between the snapshot buffer and the current live",
            " * tracing buffer. You can use this to take snapshots of the live",
            " * trace when some condition is triggered, but continue to trace.",
            " *",
            " * Note, make sure to allocate the snapshot with either",
            " * a tracing_snapshot_alloc(), or by doing it manually"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\trace\\trace.c"
          ]
        },
        {
          "file": "linux\\kernel\\trace\\trace.c",
          "line": 1486,
          "match": "race when some condition",
          "context": [
            " *",
            " * This causes a swap between the snapshot buffer and the current live",
            " * tracing buffer. You can use this to take snapshots of the live",
            " * trace when some condition is triggered, but continue to trace.",
            " */",
            "void tracing_snapshot_alloc(void)",
            "{"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\trace\\trace.c"
          ]
        },
        {
          "file": "linux\\kernel\\trace\\trace_branch.c",
          "line": 88,
          "match": "race_likely_condition",
          "context": [
            "}",
            "",
            "static inline",
            "void trace_likely_condition(struct ftrace_likely_data *f, int val, int expect)",
            "{",
            "\tif (!branch_tracing_enabled)",
            "\t\treturn;"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\trace\\trace_branch.c"
          ]
        },
        {
          "file": "linux\\kernel\\trace\\trace_branch.c",
          "line": 194,
          "match": "race_likely_condition",
          "context": [
            "",
            "#else",
            "static inline",
            "void trace_likely_condition(struct ftrace_likely_data *f, int val, int expect)",
            "{",
            "}",
            "#endif /* CONFIG_BRANCH_TRACER */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\trace\\trace_branch.c"
          ]
        },
        {
          "file": "linux\\kernel\\trace\\trace_branch.c",
          "line": 215,
          "match": "race_likely_condition",
          "context": [
            "\t * conditions that the recursive nightmare that exists is too",
            "\t * much to try to get working. At least for now.",
            "\t */",
            "\ttrace_likely_condition(f, val, expect);",
            "",
            "\t/* FIXME: Make this atomic! */",
            "\tif (val == expect)"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\trace\\trace_branch.c"
          ]
        },
        {
          "file": "linux\\kernel\\trace\\trace_events_trigger.c",
          "line": 35,
          "match": "race entry for the event, NULL for uncondition",
          "context": [
            " * event_triggers_call - Call triggers associated with a trace event",
            " * @file: The trace_event_file associated with the event",
            " * @buffer: The ring buffer that the event is being written to",
            " * @rec: The trace entry for the event, NULL for unconditional invocation",
            " * @event: The event meta data in the ring buffer",
            " *",
            " * For each trigger associated with an event, invoke the trigger"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\trace\\trace_events_trigger.c"
          ]
        },
        {
          "file": "linux\\kernel\\trace\\trace_osnoise.c",
          "line": 783,
          "match": "race condition",
          "context": [
            "\t} while (int_counter != local_read(&osn_var->int_counter));",
            "",
            "\t/*",
            "\t * This is an evidence of race conditions that cause",
            "\t * a value to be \"discounted\" too much.",
            "\t */",
            "\tif (duration < 0)"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\trace\\trace_osnoise.c"
          ]
        },
        {
          "file": "linux\\kernel\\trace\\trace_osnoise.c",
          "line": 1352,
          "match": "racer hit stop condition",
          "context": [
            "\t\t\t\t\"stop tracing hit on cpu %d\\n\", smp_processor_id());",
            "",
            "\t\tif (test_bit(OSN_PANIC_ON_STOP, &osnoise_options))",
            "\t\t\tpanic(\"tracer hit stop condition on CPU %d\\n\", smp_processor_id());",
            "",
            "\t\ttracer_tracing_off(tr);",
            "\t}"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\trace\\trace_osnoise.c"
          ]
        },
        {
          "file": "linux\\net\\atm\\pppoatm.c",
          "line": 143,
          "match": "race condition",
          "context": [
            "",
            "\t/*",
            "\t * We always used to run the wakeup tasklet unconditionally here, for",
            "\t * fear of race conditions where we clear the BLOCKED flag just as we",
            "\t * refuse another packet in pppoatm_send(). This was quite inefficient.",
            "\t *",
            "\t * In fact it's OK. The PPP core will only ever call pppoatm_send()"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\net\\atm\\pppoatm.c"
          ]
        },
        {
          "file": "linux\\net\\batman-adv\\bat_iv_ogm.c",
          "line": 804,
          "match": "race condition",
          "context": [
            "\tif (!*ogm_buff)",
            "\t\treturn;",
            "",
            "\t/* the interface gets activated here to avoid race conditions between",
            "\t * the moment of activating the interface in",
            "\t * hardif_activate_interface() where the originator mac is set and",
            "\t * outdated packets (especially uninitialized mac addresses) in the"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\net\\batman-adv\\bat_iv_ogm.c"
          ]
        },
        {
          "file": "linux\\net\\bluetooth\\l2cap_core.c",
          "line": 6378,
          "match": "race condition",
          "context": [
            "{",
            "\t/* l2cap_reassemble_sdu may free skb, hence invalidate control, so store",
            "\t * the txseq field in advance to use it after l2cap_reassemble_sdu",
            "\t * returns and to avoid the race condition, for example:",
            "\t *",
            "\t * The current thread calls:",
            "\t *   l2cap_reassemble_sdu"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\net\\bluetooth\\l2cap_core.c"
          ]
        },
        {
          "file": "linux\\net\\core\\datagram.c",
          "line": 231,
          "match": "race condition",
          "context": [
            " *\terror was detected.",
            " *",
            " *\t* It does not lock socket since today. This function is",
            " *\t* free of race conditions. This measure should/can improve",
            " *\t* significantly datagram socket latencies at high loads,",
            " *\t* when data copying to user space takes lots of time.",
            " *\t* (BTW I've just killed the last cli() in IP/IPv6/core/netlink/packet"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\net\\core\\datagram.c"
          ]
        },
        {
          "file": "linux\\net\\devlink\\region.c",
          "line": 391,
          "match": "race condition",
          "context": [
            " *\tusers of the snapshot id.",
            " *",
            " *\tNote that the caller of this function counts as a 'user', in order to",
            " *\tavoid race conditions. The caller must release its hold on the",
            " *\tsnapshot by using devlink_region_snapshot_id_put.",
            " */",
            "static int __devlink_region_snapshot_id_get(struct devlink *devlink, u32 *id)"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\net\\devlink\\region.c"
          ]
        },
        {
          "file": "linux\\net\\ipv4\\inet_connection_sock.c",
          "line": 611,
          "match": "race condition",
          "context": [
            "EXPORT_SYMBOL_GPL(inet_csk_get_port);",
            "",
            "/*",
            " * Wait for an incoming connection, avoid race conditions. This must be called",
            " * with the socket locked.",
            " */",
            "static int inet_csk_wait_for_connect(struct sock *sk, long timeo)"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\net\\ipv4\\inet_connection_sock.c"
          ]
        },
        {
          "file": "linux\\net\\ipv4\\inet_connection_sock.c",
          "line": 1391,
          "match": "race condition",
          "context": [
            "\t\tBUG_ON(rcu_access_pointer(tcp_sk(child)->fastopen_rsk) != req);",
            "\t\tBUG_ON(sk != req->rsk_listener);",
            "",
            "\t\t/* Paranoid, to prevent race condition if",
            "\t\t * an inbound pkt destined for child is",
            "\t\t * blocked by sock lock in tcp_v4_rcv().",
            "\t\t * Also to satisfy an assertion in"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\net\\ipv4\\inet_connection_sock.c"
          ]
        },
        {
          "file": "linux\\net\\ipv4\\route.c",
          "line": 50,
          "match": "Race condition",
          "context": [
            " *\t\t\t\t\troute.c and rewritten from scratch.",
            " *\t\tAndi Kleen\t:\tLoad-limit warning messages.",
            " *\tVitaly E. Lavrov\t:\tTransparent proxy revived after year coma.",
            " *\tVitaly E. Lavrov\t:\tRace condition in ip_route_input_slow.",
            " *\tTobias Ringstrom\t:\tUninitialized res.type in ip_route_output_slow.",
            " *\tVladimir V. Ivanov\t:\tIP rule info (flowid) is really useful.",
            " *\t\tMarc Boucher\t:\trouting by fwmark"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\net\\ipv4\\route.c"
          ]
        },
        {
          "file": "linux\\net\\ipv4\\route.c",
          "line": 1493,
          "match": "race condition",
          "context": [
            "\t}",
            "\torig = *p;",
            "",
            "\t/* hold dst before doing cmpxchg() to avoid race condition",
            "\t * on this dst",
            "\t */",
            "\tdst_hold(&rt->dst);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\net\\ipv4\\route.c"
          ]
        },
        {
          "file": "linux\\net\\ipv4\\tcp_minisocks.c",
          "line": 933,
          "match": "race condition",
          "context": [
            " * the new socket.",
            " *",
            " * For the vast majority of cases child->sk_state will be TCP_SYN_RECV",
            " * when entering. But other states are possible due to a race condition",
            " * where after __inet_lookup_established() fails but before the listener",
            " * locked is obtained, other packets cause the same connection to",
            " * be created."
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\net\\ipv4\\tcp_minisocks.c"
          ]
        },
        {
          "file": "linux\\net\\kcm\\kcmsock.c",
          "line": 1265,
          "match": "race condition",
          "context": [
            "\twrite_lock_bh(&csk->sk_callback_lock);",
            "",
            "\t/* Check if sk_user_data is already by KCM or someone else.",
            "\t * Must be done under lock to prevent race conditions.",
            "\t */",
            "\tif (csk->sk_user_data) {",
            "\t\twrite_unlock_bh(&csk->sk_callback_lock);"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\net\\kcm\\kcmsock.c"
          ]
        },
        {
          "file": "linux\\net\\kcm\\kcmsock.c",
          "line": 1685,
          "match": "race condition",
          "context": [
            "\tsock_orphan(sk);",
            "\tkfree_skb(kcm->seq_skb);",
            "",
            "\t/* Purge queue under lock to avoid race condition with tx_work trying",
            "\t * to act when queue is nonempty. If tx_work runs after this point",
            "\t * it will just return.",
            "\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\net\\kcm\\kcmsock.c"
          ]
        },
        {
          "file": "linux\\net\\mac80211\\debugfs_sta.c",
          "line": 1246,
          "match": "race condition",
          "context": [
            "\tsnprintf(mac, sizeof(mac), \"%pM\", sta->sta.addr);",
            "",
            "\t/*",
            "\t * This might fail due to a race condition:",
            "\t * When mac80211 unlinks a station, the debugfs entries",
            "\t * remain, but it is already possible to link a new",
            "\t * station with the same address which triggers adding"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\net\\mac80211\\debugfs_sta.c"
          ]
        },
        {
          "file": "linux\\net\\mac80211\\sta_info.c",
          "line": 2015,
          "match": "race condition",
          "context": [
            "\t\tint tid, ac;",
            "",
            "\t\t/*",
            "\t\t * For PS-Poll, this can only happen due to a race condition",
            "\t\t * when we set the TIM bit and the station notices it, but",
            "\t\t * before it can poll for the frame we expire it.",
            "\t\t *"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\net\\mac80211\\sta_info.c"
          ]
        },
        {
          "file": "linux\\net\\netfilter\\nf_conntrack_core.c",
          "line": 1657,
          "match": "race condition",
          "context": [
            "\tunsigned int ct_count;",
            "\tstruct nf_conn *ct;",
            "",
            "\t/* We don't want any race condition at early drop stage */",
            "\tct_count = atomic_inc_return(&cnet->count);",
            "",
            "\tif (nf_conntrack_max && unlikely(ct_count > nf_conntrack_max)) {"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\net\\netfilter\\nf_conntrack_core.c"
          ]
        },
        {
          "file": "linux\\net\\sunrpc\\svcsock.c",
          "line": 1410,
          "match": "race condition",
          "context": [
            "\tsvsk->sk_odata = inet->sk_data_ready;",
            "\tsvsk->sk_owspace = inet->sk_write_space;",
            "\t/*",
            "\t * This barrier is necessary in order to prevent race condition",
            "\t * with svc_data_ready(), svc_tcp_listen_data_ready(), and others",
            "\t * when calling callbacks above.",
            "\t */"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\net\\sunrpc\\svcsock.c"
          ]
        },
        {
          "file": "linux\\net\\tipc\\socket.c",
          "line": 783,
          "match": "race condition",
          "context": [
            " * It appears that the usual socket locking mechanisms are not useful here",
            " * since the pollmask info is potentially out-of-date the moment this routine",
            " * exits.  TCP and other protocols seem to rely on higher level poll routines",
            " * to handle any preventable race conditions, so TIPC will do the same ...",
            " *",
            " * IMPORTANT: The fact that a read or write operation is indicated does NOT",
            " * imply that the operation will succeed, merely that it should be performed"
          ],
          "pattern": "race.*condition",
          "description": "Race conditions between concurrent threads/processes",
          "code_snippet": [
            "File not found: linux\\linux\\net\\tipc\\socket.c"
          ]
        }
      ]
    },
    "deadlock": {
      "count": 1256,
      "description": "Deadlock scenarios and lock ordering issues",
      "issues": [
        {
          "file": "linux\\fs\\bpf_fs_kfuncs.c",
          "line": 227,
          "match": "deadlock",
          "context": [
            "",
            "\t\t/* This xattr is set by BPF LSM, so we do not call",
            "\t\t * security_inode_post_setxattr. Otherwise, we would",
            "\t\t * risk deadlocks by calling back to the same kfunc.",
            "\t\t *",
            "\t\t * This is the same as security_inode_setsecurity().",
            "\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bpf_fs_kfuncs.c"
          ]
        },
        {
          "file": "linux\\fs\\bpf_fs_kfuncs.c",
          "line": 264,
          "match": "deadlock",
          "context": [
            "",
            "\t\t/* This xattr is removed by BPF LSM, so we do not call",
            "\t\t * security_inode_post_removexattr. Otherwise, we would",
            "\t\t * risk deadlocks by calling back to the same kfunc.",
            "\t\t */",
            "\t}",
            "\treturn ret;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bpf_fs_kfuncs.c"
          ]
        },
        {
          "file": "linux\\fs\\eventfd.c",
          "line": 61,
          "match": "Deadlock",
          "context": [
            "\tunsigned long flags;",
            "",
            "\t/*",
            "\t * Deadlock or stack overflow issues can happen if we recurse here",
            "\t * through waitqueue wakeup handlers. If the caller users potentially",
            "\t * nested waitqueues with custom wakeup handlers, then it should",
            "\t * check eventfd_signal_allowed() before calling this function. If"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\eventfd.c"
          ]
        },
        {
          "file": "linux\\fs\\eventpoll.c",
          "line": 64,
          "match": "deadlock",
          "context": [
            " * The epnested_mutex is acquired when inserting an epoll fd onto another",
            " * epoll fd. We do this so that we walk the epoll tree and ensure that this",
            " * insertion does not create a cycle of epoll file descriptors, which",
            " * could lead to deadlock. We need a global mutex to prevent two",
            " * simultaneous inserts (A into B and B into A) from racing and",
            " * constructing a cycle without either insert observing that it is",
            " * going to."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\eventpoll.c"
          ]
        },
        {
          "file": "linux\\fs\\file_table.c",
          "line": 549,
          "match": "deadlock",
          "context": [
            "/*",
            " * synchronous analog of fput(); for kernel threads that might be needed",
            " * in some umount() (and thus can't use flush_delayed_fput() without",
            " * risking deadlocks), need to wait for completion of __fput() and know",
            " * for this specific struct file it won't involve anything that would",
            " * need them.  Use only if you really need it - at the very least,",
            " * don't blindly convert fput() by kernel thread to that."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\file_table.c"
          ]
        },
        {
          "file": "linux\\fs\\locks.c",
          "line": 144,
          "match": "deadlock",
          "context": [
            "",
            "",
            "/*",
            " * The blocked_hash is used to find POSIX lock loops for deadlock detection.",
            " * It is protected by blocked_lock_lock.",
            " *",
            " * We hash locks by lockowner in order to optimize searching for the lock a"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\locks.c"
          ]
        },
        {
          "file": "linux\\fs\\locks.c",
          "line": 992,
          "match": "Deadlock",
          "context": [
            "EXPORT_SYMBOL(posix_test_lock);",
            "",
            "/*",
            " * Deadlock detection:",
            " *",
            " * We attempt to detect deadlocks that are due purely to posix file",
            " * locks."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\locks.c"
          ]
        },
        {
          "file": "linux\\fs\\locks.c",
          "line": 994,
          "match": "deadlock",
          "context": [
            "/*",
            " * Deadlock detection:",
            " *",
            " * We attempt to detect deadlocks that are due purely to posix file",
            " * locks.",
            " *",
            " * We assume that a task can be waiting for at most one lock at a time."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\locks.c"
          ]
        },
        {
          "file": "linux\\fs\\locks.c",
          "line": 1007,
          "match": "deadlock",
          "context": [
            " *",
            " * Since we do this before we ever put a process to sleep on a lock, we",
            " * are ensured that there is never a cycle; that is what guarantees that",
            " * the while() loop in posix_locks_deadlock() eventually completes.",
            " *",
            " * Note: the above assumption may not be true when handling lock",
            " * requests from a broken NFS client. It may also fail in the presence"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\locks.c"
          ]
        },
        {
          "file": "linux\\fs\\locks.c",
          "line": 1016,
          "match": "deadlock",
          "context": [
            " *",
            " * For FL_OFDLCK locks, the owner is the filp, not the files_struct.",
            " * Because the owner is not even nominally tied to a thread of",
            " * execution, the deadlock detection below can't reasonably work well. Just",
            " * skip it for those.",
            " *",
            " * In principle, we could do a more limited deadlock detection on FL_OFDLCK"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\locks.c"
          ]
        },
        {
          "file": "linux\\fs\\locks.c",
          "line": 1019,
          "match": "deadlock",
          "context": [
            " * execution, the deadlock detection below can't reasonably work well. Just",
            " * skip it for those.",
            " *",
            " * In principle, we could do a more limited deadlock detection on FL_OFDLCK",
            " * locks that just checks for the case where two tasks are attempting to",
            " * upgrade from read to write locks on the same inode.",
            " */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\locks.c"
          ]
        },
        {
          "file": "linux\\fs\\locks.c",
          "line": 1042,
          "match": "deadlock",
          "context": [
            "}",
            "",
            "/* Must be called with the blocked_lock_lock held! */",
            "static bool posix_locks_deadlock(struct file_lock *caller_fl,",
            "\t\t\t\t struct file_lock *block_fl)",
            "{",
            "\tstruct file_lock_core *caller = &caller_fl->c;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\locks.c"
          ]
        },
        {
          "file": "linux\\fs\\locks.c",
          "line": 1052,
          "match": "deadlock",
          "context": [
            "\tlockdep_assert_held(&blocked_lock_lock);",
            "",
            "\t/*",
            "\t * This deadlock detector can't reasonably detect deadlocks with",
            "\t * FL_OFDLCK locks, since they aren't owned by a process, per-se.",
            "\t */",
            "\tif (caller->flc_flags & FL_OFDLCK)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\locks.c"
          ]
        },
        {
          "file": "linux\\fs\\locks.c",
          "line": 1052,
          "match": "deadlock",
          "context": [
            "\tlockdep_assert_held(&blocked_lock_lock);",
            "",
            "\t/*",
            "\t * This deadlock detector can't reasonably detect deadlocks with",
            "\t * FL_OFDLCK locks, since they aren't owned by a process, per-se.",
            "\t */",
            "\tif (caller->flc_flags & FL_OFDLCK)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\locks.c"
          ]
        },
        {
          "file": "linux\\fs\\locks.c",
          "line": 1207,
          "match": "Deadlock",
          "context": [
            "\t\t\tif (!(request->c.flc_flags & FL_SLEEP))",
            "\t\t\t\tgoto out;",
            "\t\t\t/*",
            "\t\t\t * Deadlock detection and insertion into the blocked",
            "\t\t\t * locks list must be done while holding the same lock!",
            "\t\t\t */",
            "\t\t\terror = -EDEADLK;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\locks.c"
          ]
        },
        {
          "file": "linux\\fs\\locks.c",
          "line": 1214,
          "match": "deadlock",
          "context": [
            "\t\t\tspin_lock(&blocked_lock_lock);",
            "\t\t\t/*",
            "\t\t\t * Ensure that we don't find any locks blocked on this",
            "\t\t\t * request during deadlock detection.",
            "\t\t\t */",
            "\t\t\t__locks_wake_up_blocks(&request->c);",
            "\t\t\tif (likely(!posix_locks_deadlock(request, fl))) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\locks.c"
          ]
        },
        {
          "file": "linux\\fs\\locks.c",
          "line": 1217,
          "match": "deadlock",
          "context": [
            "\t\t\t * request during deadlock detection.",
            "\t\t\t */",
            "\t\t\t__locks_wake_up_blocks(&request->c);",
            "\t\t\tif (likely(!posix_locks_deadlock(request, fl))) {",
            "\t\t\t\terror = FILE_LOCK_DEFERRED;",
            "\t\t\t\t__locks_insert_block(&fl->c, &request->c,",
            "\t\t\t\t\t\t     posix_locks_conflict);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\locks.c"
          ]
        },
        {
          "file": "linux\\fs\\read_write.c",
          "line": 1623,
          "match": "deadlock",
          "context": [
            "\t * for server-side-copy between any two sb.",
            "\t *",
            "\t * In any case, we call do_splice_direct() and not splice_file_range(),",
            "\t * without file_start_write() held, to avoid possible deadlocks related",
            "\t * to splicing from input file, while file_start_write() is held on",
            "\t * the output file on a different sb.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\read_write.c"
          ]
        },
        {
          "file": "linux\\fs\\splice.c",
          "line": 1736,
          "match": "deadlock",
          "context": [
            "\t\treturn ret;",
            "",
            "\t/*",
            "\t * Potential ABBA deadlock, work around it by ordering lock",
            "\t * grabbing by pipe info address. Otherwise two different processes",
            "\t * could deadlock (one doing tee from A -> B, the other from B -> A).",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\splice.c"
          ]
        },
        {
          "file": "linux\\fs\\splice.c",
          "line": 1738,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Potential ABBA deadlock, work around it by ordering lock",
            "\t * grabbing by pipe info address. Otherwise two different processes",
            "\t * could deadlock (one doing tee from A -> B, the other from B -> A).",
            "\t */",
            "\tpipe_double_lock(ipipe, opipe);",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\splice.c"
          ]
        },
        {
          "file": "linux\\fs\\splice.c",
          "line": 1859,
          "match": "deadlock",
          "context": [
            "\tssize_t ret = 0;",
            "",
            "\t/*",
            "\t * Potential ABBA deadlock, work around it by ordering lock",
            "\t * grabbing by pipe info address. Otherwise two different processes",
            "\t * could deadlock (one doing tee from A -> B, the other from B -> A).",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\splice.c"
          ]
        },
        {
          "file": "linux\\fs\\splice.c",
          "line": 1861,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Potential ABBA deadlock, work around it by ordering lock",
            "\t * grabbing by pipe info address. Otherwise two different processes",
            "\t * could deadlock (one doing tee from A -> B, the other from B -> A).",
            "\t */",
            "\tpipe_double_lock(ipipe, opipe);",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\splice.c"
          ]
        },
        {
          "file": "linux\\fs\\super.c",
          "line": 175,
          "match": "deadlock",
          "context": [
            " * One thing we have to be careful of with a per-sb shrinker is that we don't",
            " * drop the last active reference to the superblock from within the shrinker.",
            " * If that happens we could trigger unregistering the shrinker from within the",
            " * shrinker path and that leads to deadlock on the shrinker_mutex. Hence we",
            " * take a passive reference to the superblock to avoid this from occurring.",
            " */",
            "static unsigned long super_cache_scan(struct shrinker *shrink,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\super.c"
          ]
        },
        {
          "file": "linux\\fs\\super.c",
          "line": 191,
          "match": "Deadlock",
          "context": [
            "\tsb = shrink->private_data;",
            "",
            "\t/*",
            "\t * Deadlock avoidance.  We may hold various FS locks, and we don't want",
            "\t * to recurse into the FS that called us in clear_inode() and friends..",
            "\t */",
            "\tif (!(sc->gfp_mask & __GFP_FS))"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\super.c"
          ]
        },
        {
          "file": "linux\\fs\\super.c",
          "line": 340,
          "match": "deadlock",
          "context": [
            "\t * In case that succeeds, it will acquire the s_umount",
            "\t * lock of the old one. Since these are clearly distrinct",
            "\t * locks, and this object isn't exposed yet, there's no",
            "\t * risk of deadlocks.",
            "\t *",
            "\t * Annotate this by putting this lock in a different",
            "\t * subclass."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\super.c"
          ]
        },
        {
          "file": "linux\\kernel\\acct.c",
          "line": 37,
          "match": "deadlock",
          "context": [
            " *  real mess with do_remount_sb(). 9/11/98, AV.",
            " *",
            " *  Fixed a bunch of races (and pair of leaks). Probably not the best way,",
            " *  but this one obviously doesn't introduce deadlocks. Later. BTW, found",
            " *  one race (and leak) in BSD implementation.",
            " *  OK, that's better. ANOTHER race and leak in BSD variant. There always",
            " *  is one more bug... 10/11/98, AV."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\acct.c"
          ]
        },
        {
          "file": "linux\\kernel\\acct.c",
          "line": 556,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * First check to see if there is enough free_space to continue",
            "\t * the process accounting system. Then get freeze protection. If",
            "\t * the fs is frozen, just skip the write as we could deadlock",
            "\t * the system otherwise.",
            "\t */",
            "\tif (check_free_space(acct) && file_start_write_trylock(file)) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\acct.c"
          ]
        },
        {
          "file": "linux\\kernel\\auditfilter.c",
          "line": 1179,
          "match": "deadlock",
          "context": [
            "\tstruct audit_netlink_list *dest;",
            "",
            "\t/* We can't just spew out the rules here because we might fill",
            "\t * the available socket buffer space and deadlock waiting for",
            "\t * auditctl to read from it... which isn't ever going to",
            "\t * happen if we're actually running in the context of auditctl",
            "\t * trying to _send_ the stuff */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\auditfilter.c"
          ]
        },
        {
          "file": "linux\\kernel\\cpu.c",
          "line": 1488,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Ensure that the control task does not run on the to be offlined",
            "\t * CPU to prevent a deadlock against cfs_b->period_timer.",
            "\t * Also keep at least one housekeeping cpu onlined to avoid generating",
            "\t * an empty sched_domain span.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\cpu.c"
          ]
        },
        {
          "file": "linux\\kernel\\kprobes.c",
          "line": 528,
          "match": "deadlock",
          "context": [
            "\t * The optimization/unoptimization refers 'online_cpus' via",
            "\t * stop_machine() and cpu-hotplug modifies the 'online_cpus'.",
            "\t * And same time, 'text_mutex' will be held in cpu-hotplug and here.",
            "\t * This combination can cause a deadlock (cpu-hotplug tries to lock",
            "\t * 'text_mutex' but stop_machine() can not be done because",
            "\t * the 'online_cpus' has been changed)",
            "\t * To avoid this deadlock, caller must have locked cpu-hotplug"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\kprobes.c"
          ]
        },
        {
          "file": "linux\\kernel\\kprobes.c",
          "line": 531,
          "match": "deadlock",
          "context": [
            "\t * This combination can cause a deadlock (cpu-hotplug tries to lock",
            "\t * 'text_mutex' but stop_machine() can not be done because",
            "\t * the 'online_cpus' has been changed)",
            "\t * To avoid this deadlock, caller must have locked cpu-hotplug",
            "\t * for preventing cpu-hotplug outside of 'text_mutex' locking.",
            "\t */",
            "\tlockdep_assert_cpus_held();"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\kprobes.c"
          ]
        },
        {
          "file": "linux\\kernel\\kthread.c",
          "line": 211,
          "match": "deadlock",
          "context": [
            " *",
            " * kthread_should_stop() for freezable kthreads, which will enter",
            " * refrigerator if necessary.  This function is safe from kthread_stop() /",
            " * freezer deadlock and freezable kthreads should use this function instead",
            " * of calling try_to_freeze() directly.",
            " */",
            "bool kthread_freezable_should_stop(bool *was_frozen)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\kthread.c"
          ]
        },
        {
          "file": "linux\\kernel\\kthread.c",
          "line": 1368,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * timer_delete_sync() must be called to make sure that the timer",
            "\t * callback is not running. The lock must be temporary released",
            "\t * to avoid a deadlock with the callback. In the meantime,",
            "\t * any queuing is blocked by setting the canceling counter.",
            "\t */",
            "\twork->canceling++;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\kthread.c"
          ]
        },
        {
          "file": "linux\\kernel\\panic.c",
          "line": 336,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Disable local interrupts. This will prevent panic_smp_self_stop",
            "\t * from deadlocking the first cpu that invokes the panic, since",
            "\t * there is nothing to prevent an interrupt handler (that runs",
            "\t * after setting panic_cpu) from invoking panic() again.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\panic.c"
          ]
        },
        {
          "file": "linux\\kernel\\relay.c",
          "line": 573,
          "match": "deadlock",
          "context": [
            "\t\tif (waitqueue_active(&buf->read_wait)) {",
            "\t\t\t/*",
            "\t\t\t * Calling wake_up_interruptible() from here",
            "\t\t\t * will deadlock if we happen to be logging",
            "\t\t\t * from the scheduler (trying to re-grab",
            "\t\t\t * rq->lock), so defer it.",
            "\t\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\relay.c"
          ]
        },
        {
          "file": "linux\\kernel\\smp.c",
          "line": 647,
          "match": "deadlock",
          "context": [
            "\tthis_cpu = get_cpu();",
            "",
            "\t/*",
            "\t * Can deadlock when called with interrupts disabled.",
            "\t * We allow cpu's that are not yet online though, as no one else can",
            "\t * send smp call function interrupt to this cpu and as such deadlocks",
            "\t * can't happen."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\smp.c"
          ]
        },
        {
          "file": "linux\\kernel\\smp.c",
          "line": 649,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Can deadlock when called with interrupts disabled.",
            "\t * We allow cpu's that are not yet online though, as no one else can",
            "\t * send smp call function interrupt to this cpu and as such deadlocks",
            "\t * can't happen.",
            "\t */",
            "\tWARN_ON_ONCE(cpu_online(this_cpu) && irqs_disabled()"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\smp.c"
          ]
        },
        {
          "file": "linux\\kernel\\smp.c",
          "line": 656,
          "match": "deadlock",
          "context": [
            "\t\t     && !oops_in_progress);",
            "",
            "\t/*",
            "\t * When @wait we can deadlock when we interrupt between llist_add() and",
            "\t * arch_send_call_function_ipi*(); when !@wait we can deadlock due to",
            "\t * csd_lock() on because the interrupt context uses the same csd",
            "\t * storage."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\smp.c"
          ]
        },
        {
          "file": "linux\\kernel\\smp.c",
          "line": 657,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * When @wait we can deadlock when we interrupt between llist_add() and",
            "\t * arch_send_call_function_ipi*(); when !@wait we can deadlock due to",
            "\t * csd_lock() on because the interrupt context uses the same csd",
            "\t * storage.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\smp.c"
          ]
        },
        {
          "file": "linux\\kernel\\smp.c",
          "line": 800,
          "match": "deadlock",
          "context": [
            "\tlockdep_assert_preemption_disabled();",
            "",
            "\t/*",
            "\t * Can deadlock when called with interrupts disabled.",
            "\t * We allow cpu's that are not yet online though, as no one else can",
            "\t * send smp call function interrupt to this cpu and as such deadlocks",
            "\t * can't happen."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\smp.c"
          ]
        },
        {
          "file": "linux\\kernel\\smp.c",
          "line": 802,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Can deadlock when called with interrupts disabled.",
            "\t * We allow cpu's that are not yet online though, as no one else can",
            "\t * send smp call function interrupt to this cpu and as such deadlocks",
            "\t * can't happen.",
            "\t */",
            "\tif (cpu_online(this_cpu) && !oops_in_progress &&"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\smp.c"
          ]
        },
        {
          "file": "linux\\kernel\\smp.c",
          "line": 810,
          "match": "deadlock",
          "context": [
            "\t\tlockdep_assert_irqs_enabled();",
            "",
            "\t/*",
            "\t * When @wait we can deadlock when we interrupt between llist_add() and",
            "\t * arch_send_call_function_ipi*(); when !@wait we can deadlock due to",
            "\t * csd_lock() on because the interrupt context uses the same csd",
            "\t * storage."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\smp.c"
          ]
        },
        {
          "file": "linux\\kernel\\smp.c",
          "line": 811,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * When @wait we can deadlock when we interrupt between llist_add() and",
            "\t * arch_send_call_function_ipi*(); when !@wait we can deadlock due to",
            "\t * csd_lock() on because the interrupt context uses the same csd",
            "\t * storage.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\smp.c"
          ]
        },
        {
          "file": "linux\\kernel\\softirq.c",
          "line": 507,
          "match": "deadlock",
          "context": [
            "/*",
            " * When we run softirqs from irq_exit() and thus on the hardirq stack we need",
            " * to keep the lockdep irq context tracking as tight as possible in order to",
            " * not miss-qualify lock contexts and miss possible deadlocks.",
            " */",
            "",
            "static inline bool lockdep_softirq_start(void)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\softirq.c"
          ]
        },
        {
          "file": "linux\\kernel\\signal.c",
          "line": 5016,
          "match": "deadlock",
          "context": [
            " * kdb_send_sig - Allows kdb to send signals without exposing",
            " * signal internals.  This function checks if the required locks are",
            " * available before calling the main signal code, to avoid kdb",
            " * deadlocks.",
            " */",
            "void kdb_send_sig(struct task_struct *t, int sig)",
            "{"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\signal.c"
          ]
        },
        {
          "file": "linux\\kernel\\signal.c",
          "line": 5033,
          "match": "deadlock",
          "context": [
            "\tif (!task_is_running(t) && new_t) {",
            "\t\tspin_unlock(&t->sighand->siglock);",
            "\t\tkdb_printf(\"Process is not RUNNING, sending a signal from \"",
            "\t\t\t   \"kdb risks deadlock\\n\"",
            "\t\t\t   \"on the run queue locks. \"",
            "\t\t\t   \"The signal has _not_ been sent.\\n\"",
            "\t\t\t   \"Reissue the kill command if you want to risk \""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\signal.c"
          ]
        },
        {
          "file": "linux\\kernel\\signal.c",
          "line": 5037,
          "match": "deadlock",
          "context": [
            "\t\t\t   \"on the run queue locks. \"",
            "\t\t\t   \"The signal has _not_ been sent.\\n\"",
            "\t\t\t   \"Reissue the kill command if you want to risk \"",
            "\t\t\t   \"the deadlock.\\n\");",
            "\t\treturn;",
            "\t}",
            "\tret = send_signal_locked(sig, SEND_SIG_PRIV, t, PIDTYPE_PID);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\signal.c"
          ]
        },
        {
          "file": "linux\\kernel\\stop_machine.c",
          "line": 289,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Ensure that if we race with __stop_cpus() the stoppers won't get",
            "\t * queued up in reverse order leading to system deadlock.",
            "\t *",
            "\t * We can't miss stop_cpus_in_progress if queue_stop_cpus_work() has",
            "\t * queued a work on cpu1 but not on cpu2, we hold both locks."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\stop_machine.c"
          ]
        },
        {
          "file": "linux\\kernel\\stop_machine.c",
          "line": 403,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Disable preemption while queueing to avoid getting",
            "\t * preempted by a stopper which might wait for other stoppers",
            "\t * to enter @fn which can lead to deadlock.",
            "\t */",
            "\tpreempt_disable();",
            "\tstop_cpus_in_progress = true;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\stop_machine.c"
          ]
        },
        {
          "file": "linux\\kernel\\torture.c",
          "line": 657,
          "match": "deadlock",
          "context": [
            "\t/* OK, shut down the system. */",
            "",
            "\tVERBOSE_TOROUT_STRING(\"torture_shutdown task shutting down system\");",
            "\tshutdown_task = NULL;\t/* Avoid self-kill deadlock. */",
            "\tif (torture_shutdown_hook)",
            "\t\ttorture_shutdown_hook();",
            "\telse"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\torture.c"
          ]
        },
        {
          "file": "linux\\kernel\\watch_queue.c",
          "line": 624,
          "match": "deadlock",
          "context": [
            "\t\tspin_unlock_bh(&wqueue->lock);",
            "",
            "\t\t/* We can't do the next bit under the queue lock as we need to",
            "\t\t * get the list lock - which would cause a deadlock if someone",
            "\t\t * was removing from the opposite direction at the same time or",
            "\t\t * posting a notification.",
            "\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\watch_queue.c"
          ]
        },
        {
          "file": "linux\\kernel\\workqueue.c",
          "line": 502,
          "match": "deadlock",
          "context": [
            "/*",
            " * I: kthread_worker to release pwq's. pwq release needs to be bounced to a",
            " * process context while holding a pool lock. Bounce to a dedicated kthread",
            " * worker to avoid A-A deadlocks.",
            " */",
            "static struct kthread_worker *pwq_release_worker __ro_after_init;",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\workqueue.c"
          ]
        },
        {
          "file": "linux\\kernel\\workqueue.c",
          "line": 1099,
          "match": "deadlock",
          "context": [
            " * false positives.  Note that this isn't complete as one may construct a",
            " * work function which can introduce dependency onto itself through a",
            " * recycled work item.  Well, if somebody wants to shoot oneself in the",
            " * foot that badly, there's only so much we can do, and if such deadlock",
            " * actually occurs, it should be easy to locate the culprit work function.",
            " *",
            " * CONTEXT:"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\workqueue.c"
          ]
        },
        {
          "file": "linux\\kernel\\workqueue.c",
          "line": 1644,
          "match": "deadlock",
          "context": [
            "\t\treturn;",
            "\t/*",
            "\t * @pwq can't be released under pool->lock, bounce to a dedicated",
            "\t * kthread_worker to avoid A-A deadlocks.",
            "\t */",
            "\tkthread_queue_work(pwq_release_worker, &pwq->release_work);",
            "}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\workqueue.c"
          ]
        },
        {
          "file": "linux\\kernel\\workqueue.c",
          "line": 3021,
          "match": "deadlock",
          "context": [
            "\t\t/*",
            "\t\t * We've been trying to create a new worker but",
            "\t\t * haven't been successful.  We might be hitting an",
            "\t\t * allocation deadlock.  Send distress signals to",
            "\t\t * rescuers.",
            "\t\t */",
            "\t\tlist_for_each_entry(work, &pool->worklist, entry)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\workqueue.c"
          ]
        },
        {
          "file": "linux\\kernel\\workqueue.c",
          "line": 3042,
          "match": "deadlock",
          "context": [
            " * have at least one idle worker on return from this function.  If",
            " * creating a new worker takes longer than MAYDAY_INTERVAL, mayday is",
            " * sent to all rescuers with works scheduled on @pool to resolve",
            " * possible allocation deadlock.",
            " *",
            " * On return, need_to_create_worker() is guaranteed to be %false and",
            " * may_start_working() %true."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\workqueue.c"
          ]
        },
        {
          "file": "linux\\kernel\\workqueue.c",
          "line": 3227,
          "match": "deadlock",
          "context": [
            "\t *\t\tC(C)",
            "\t *",
            "\t * Which would create W1->C->W1 dependencies, even though there is no",
            "\t * actual deadlock possible. There are two solutions, using a",
            "\t * read-recursive acquire on the work(queue) 'locks', but this will then",
            "\t * hit the lockdep limitation on recursive locks, or simply discard",
            "\t * these locks."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\workqueue.c"
          ]
        },
        {
          "file": "linux\\kernel\\workqueue.c",
          "line": 3232,
          "match": "deadlock",
          "context": [
            "\t * hit the lockdep limitation on recursive locks, or simply discard",
            "\t * these locks.",
            "\t *",
            "\t * AFAICT there is no possible deadlock scenario between the",
            "\t * flush_work() and complete() primitives (except for single-threaded",
            "\t * workqueues), so hiding them isn't a problem.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\workqueue.c"
          ]
        },
        {
          "file": "linux\\kernel\\workqueue.c",
          "line": 3265,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * The following prevents a kworker from hogging CPU on !PREEMPTION",
            "\t * kernels, where a requeueing work item waiting for something to",
            "\t * happen could deadlock with stop_machine as such work item could",
            "\t * indefinitely requeue itself while all other CPUs are trapped in",
            "\t * stop_machine. At the same time, report a quiescent RCU state so",
            "\t * the same condition doesn't freeze RCU."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\workqueue.c"
          ]
        },
        {
          "file": "linux\\kernel\\workqueue.c",
          "line": 3430,
          "match": "deadlock",
          "context": [
            " *",
            " * Regular work processing on a pool may block trying to create a new",
            " * worker which uses GFP_KERNEL allocation which has slight chance of",
            " * developing into deadlock if some works currently on the same queue",
            " * need to be processed to satisfy the GFP_KERNEL allocation.  This is",
            " * the problem rescuer solves.",
            " *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\workqueue.c"
          ]
        },
        {
          "file": "linux\\kernel\\workqueue.c",
          "line": 3701,
          "match": "deadlock",
          "context": [
            " * already running, or will not be at all), check if @target_wq doesn't have",
            " * %WQ_MEM_RECLAIM and verify that %current is not reclaiming memory or running",
            " * on a workqueue which doesn't have %WQ_MEM_RECLAIM as that can break forward-",
            " * progress guarantee leading to a deadlock.",
            " */",
            "static void check_flush_dependency(struct workqueue_struct *target_wq,",
            "\t\t\t\t   struct work_struct *target_work,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\workqueue.c"
          ]
        },
        {
          "file": "linux\\kernel\\workqueue.c",
          "line": 3775,
          "match": "deadlock",
          "context": [
            "\t * debugobject calls are safe here even with pool->lock locked",
            "\t * as we know for sure that this will not trigger any of the",
            "\t * checks and call back into the fixup functions where we",
            "\t * might deadlock.",
            "\t *",
            "\t * BH and threaded workqueues need separate lockdep keys to avoid",
            "\t * spuriously triggering \"inconsistent {SOFTIRQ-ON-W} -> {IN-SOFTIRQ-W}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\workqueue.c"
          ]
        },
        {
          "file": "linux\\kernel\\workqueue.c",
          "line": 4181,
          "match": "deadlock",
          "context": [
            "\ttouch_work_lockdep_map(work, wq);",
            "",
            "\t/*",
            "\t * Force a lock recursion deadlock when using flush_work() inside a",
            "\t * single-threaded or rescuer equipped workqueue.",
            "\t *",
            "\t * For single threaded workqueues the deadlock happens when the work"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\workqueue.c"
          ]
        },
        {
          "file": "linux\\kernel\\workqueue.c",
          "line": 4184,
          "match": "deadlock",
          "context": [
            "\t * Force a lock recursion deadlock when using flush_work() inside a",
            "\t * single-threaded or rescuer equipped workqueue.",
            "\t *",
            "\t * For single threaded workqueues the deadlock happens when the work",
            "\t * is after the work issuing the flush_work(). For rescuer equipped",
            "\t * workqueues the deadlock happens when the rescuer stalls, blocking",
            "\t * forward progress."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\workqueue.c"
          ]
        },
        {
          "file": "linux\\kernel\\workqueue.c",
          "line": 4186,
          "match": "deadlock",
          "context": [
            "\t *",
            "\t * For single threaded workqueues the deadlock happens when the work",
            "\t * is after the work issuing the flush_work(). For rescuer equipped",
            "\t * workqueues the deadlock happens when the rescuer stalls, blocking",
            "\t * forward progress.",
            "\t */",
            "\tif (!from_cancel && (wq->saved_max_active == 1 || wq->rescuer))"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\workqueue.c"
          ]
        },
        {
          "file": "linux\\kernel\\workqueue.c",
          "line": 6342,
          "match": "deadlock",
          "context": [
            "\t\traw_spin_lock_irqsave(&pwq->pool->lock, irq_flags);",
            "\t\tif (!pwq_is_empty(pwq)) {",
            "\t\t\t/*",
            "\t\t\t * Defer printing to avoid deadlocks in console",
            "\t\t\t * drivers that queue work while holding locks",
            "\t\t\t * also taken in their write paths.",
            "\t\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\workqueue.c"
          ]
        },
        {
          "file": "linux\\kernel\\workqueue.c",
          "line": 6381,
          "match": "deadlock",
          "context": [
            "\t\thung = jiffies_to_msecs(jiffies - pool->watchdog_ts) / 1000;",
            "",
            "\t/*",
            "\t * Defer printing to avoid deadlocks in console drivers that",
            "\t * queue work while holding locks also taken in their write",
            "\t * paths.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\workqueue.c"
          ]
        },
        {
          "file": "linux\\kernel\\workqueue.c",
          "line": 7511,
          "match": "deadlock",
          "context": [
            "\thash_for_each(pool->busy_hash, bkt, worker, hentry) {",
            "\t\tif (task_is_running(worker->task)) {",
            "\t\t\t/*",
            "\t\t\t * Defer printing to avoid deadlocks in console",
            "\t\t\t * drivers that queue work while holding locks",
            "\t\t\t * also taken in their write paths.",
            "\t\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\workqueue.c"
          ]
        },
        {
          "file": "linux\\net\\socket.c",
          "line": 1488,
          "match": "deadlock",
          "context": [
            "\t/* Compatibility.",
            "",
            "\t   This uglymoron is moved from INET layer to here to avoid",
            "\t   deadlock in module load.",
            "\t */",
            "\tif (family == PF_INET && type == SOCK_PACKET) {",
            "\t\tpr_info_once(\"%s uses obsolete (PF_INET,SOCK_PACKET)\\n\","
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\socket.c"
          ]
        },
        {
          "file": "linux\\arch\\arm\\kernel\\traps.c",
          "line": 314,
          "match": "deadlock",
          "context": [
            "",
            "\toops_enter();",
            "",
            "\t/* racy, but better than risking deadlock. */",
            "\traw_local_irq_save(flags);",
            "\tcpu = smp_processor_id();",
            "\tif (!arch_spin_trylock(&die_lock)) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\arch\\arm\\kernel\\traps.c"
          ]
        },
        {
          "file": "linux\\arch\\arm64\\kernel\\sdei.c",
          "line": 238,
          "match": "deadlock",
          "context": [
            "\tif (elr != read_sysreg(elr_el1)) {",
            "\t\t/*",
            "\t\t * We took a synchronous exception from the SDEI handler.",
            "\t\t * This could deadlock, and if you interrupt KVM it will",
            "\t\t * hyp-panic instead.",
            "\t\t */",
            "\t\tpr_warn(\"unsafe: exception during handler\\n\");"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\arch\\arm64\\kernel\\sdei.c"
          ]
        },
        {
          "file": "linux\\arch\\arm64\\kernel\\topology.c",
          "line": 445,
          "match": "deadlock",
          "context": [
            "{",
            "\t/*",
            "\t * Abort call on counterless CPU or when interrupts are",
            "\t * disabled - can lead to deadlock in smp sync call.",
            "\t */",
            "\tif (!cpu_has_amu_feat(cpu))",
            "\t\treturn -EOPNOTSUPP;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\arch\\arm64\\kernel\\topology.c"
          ]
        },
        {
          "file": "linux\\arch\\mips\\kernel\\mips-cm.c",
          "line": 341,
          "match": "deadlock",
          "context": [
            "\t\t * may modify the redirect register. We do so here in a",
            "\t\t * slightly obscure way by using a spin lock, since this has",
            "\t\t * the neat property of also catching any nested uses of",
            "\t\t * mips_cm_lock_other() leading to a deadlock or a nice warning",
            "\t\t * with lockdep enabled.",
            "\t\t */",
            "\t\tspin_lock_irqsave(this_cpu_ptr(&cm_core_lock),"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\arch\\mips\\kernel\\mips-cm.c"
          ]
        },
        {
          "file": "linux\\arch\\parisc\\kernel\\firmware.c",
          "line": 1282,
          "match": "deadlock",
          "context": [
            " * down the system. Under hardware control pressing the power button",
            " * powers off the system immediately.",
            " *",
            " * The _panic version relies on spin_trylock to prevent deadlock",
            " * on panic path.",
            " */",
            "int pdc_soft_power_button(int sw_control)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\arch\\parisc\\kernel\\firmware.c"
          ]
        },
        {
          "file": "linux\\arch\\powerpc\\kernel\\traps.c",
          "line": 188,
          "match": "deadlock",
          "context": [
            "",
            "\toops_enter();",
            "",
            "\t/* racy, but better than risking deadlock. */",
            "\traw_local_irq_save(flags);",
            "\tcpu = smp_processor_id();",
            "\tif (!arch_spin_trylock(&die_lock)) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\arch\\powerpc\\kernel\\traps.c"
          ]
        },
        {
          "file": "linux\\arch\\sparc\\kernel\\process_32.c",
          "line": 235,
          "match": "deadlock",
          "context": [
            "",
            "\t/* do_fork() grabs the parent semaphore, we must release it",
            "\t * temporarily so we can build the child clone stack frame",
            "\t * without deadlocking.",
            "\t */",
            "\tif (__copy_user(sp, src, size))",
            "\t\tsp = NULL;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\arch\\sparc\\kernel\\process_32.c"
          ]
        },
        {
          "file": "linux\\arch\\sparc\\kernel\\process_32.c",
          "line": 293,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * A new process must start with interrupts disabled, see schedule_tail()",
            "\t * and finish_task_switch(). (If we do not do it and if a timer interrupt",
            "\t * hits before we unlock and attempts to take the rq->lock, we deadlock.)",
            "\t *",
            "\t * Thus, kpsr |= PSR_PIL.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\arch\\sparc\\kernel\\process_32.c"
          ]
        },
        {
          "file": "linux\\arch\\sparc\\kernel\\smp_64.c",
          "line": 593,
          "match": "deadlock",
          "context": [
            "\t\t\tint i, this_busy_nack = 0;",
            "",
            "\t\t\t/* Delay some random time with interrupts enabled",
            "\t\t\t * to prevent deadlock.",
            "\t\t\t */",
            "\t\t\tudelay(2 * nack_busy_id);",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\arch\\sparc\\kernel\\smp_64.c"
          ]
        },
        {
          "file": "linux\\arch\\um\\kernel\\trap.c",
          "line": 70,
          "match": "deadlock",
          "context": [
            " *",
            " * For example, if we have a kernel bug that causes a page",
            " * fault, we don't want to just use mmap_read_lock() to get",
            " * the mm lock, because that would deadlock if the bug were",
            " * to happen while we're holding the mm lock for writing.",
            " *",
            " * So this checks the exception tables on kernel faults in"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\arch\\um\\kernel\\trap.c"
          ]
        },
        {
          "file": "linux\\arch\\x86\\kernel\\crash.c",
          "line": 122,
          "match": "deadlock",
          "context": [
            "\tcpu_emergency_stop_pt();",
            "",
            "#ifdef CONFIG_X86_IO_APIC",
            "\t/* Prevent crash_kexec() from deadlocking on ioapic_lock. */",
            "\tioapic_zap_locks();",
            "\tclear_IO_APIC();",
            "#endif"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\arch\\x86\\kernel\\crash.c"
          ]
        },
        {
          "file": "linux\\arch\\x86\\kernel\\dumpstack.c",
          "line": 337,
          "match": "deadlock",
          "context": [
            "",
            "\toops_enter();",
            "",
            "\t/* racy, but better than risking deadlock. */",
            "\traw_local_irq_save(flags);",
            "\tcpu = smp_processor_id();",
            "\tif (!arch_spin_trylock(&die_lock)) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\arch\\x86\\kernel\\dumpstack.c"
          ]
        },
        {
          "file": "linux\\arch\\x86\\kernel\\apic\\apic.c",
          "line": 1035,
          "match": "deadlock",
          "context": [
            "\t}",
            "",
            "\t/*",
            "\t * the NMI deadlock-detector uses this.",
            "\t */",
            "\tinc_irq_stat(apic_timer_irqs);",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\arch\\x86\\kernel\\apic\\apic.c"
          ]
        },
        {
          "file": "linux\\arch\\x86\\kernel\\cpu\\mce\\core.c",
          "line": 125,
          "match": "deadlock",
          "context": [
            "\tm->cpuid\t= cpuid_eax(1);",
            "\tm->cpuvendor\t= boot_cpu_data.x86_vendor;",
            "\tm->mcgcap\t= native_rdmsrq(MSR_IA32_MCG_CAP);",
            "\t/* need the internal __ version to avoid deadlocks */",
            "\tm->time\t\t= __ktime_get_real_seconds();",
            "}",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\arch\\x86\\kernel\\cpu\\mce\\core.c"
          ]
        },
        {
          "file": "linux\\arch\\x86\\kernel\\cpu\\mce\\core.c",
          "line": 1098,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * For UC somewhere we let the CPU who detects it handle it.",
            "\t * Also must let continue the others, otherwise the handling",
            "\t * CPU could deadlock on a lock.",
            "\t */",
            "",
            "\t/*"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\arch\\x86\\kernel\\cpu\\mce\\core.c"
          ]
        },
        {
          "file": "linux\\arch\\x86\\kernel\\cpu\\mce\\core.c",
          "line": 1789,
          "match": "deadlock",
          "context": [
            "\t\t__this_cpu_write(mce_next_interval, check_interval * HZ);",
            "}",
            "",
            "/* Must not be called in IRQ context where timer_delete_sync() can deadlock */",
            "static void mce_timer_delete_all(void)",
            "{",
            "\tint cpu;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\arch\\x86\\kernel\\cpu\\mce\\core.c"
          ]
        },
        {
          "file": "linux\\arch\\x86\\kernel\\cpu\\mce\\dev-mcelog.c",
          "line": 28,
          "match": "deadlock",
          "context": [
            "",
            "/*",
            " * Lockless MCE logging infrastructure.",
            " * This avoids deadlocks on printk locks without having to break locks. Also",
            " * separate MCEs from kernel messages to avoid bogus bug reports.",
            " */",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\arch\\x86\\kernel\\cpu\\mce\\dev-mcelog.c"
          ]
        },
        {
          "file": "linux\\drivers\\ata\\ahci_mvebu.c",
          "line": 64,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Enable the regret bit to allow the SATA unit to regret a",
            "\t * request that didn't receive an acknowlegde and avoid a",
            "\t * deadlock",
            "\t */",
            "\twritel(0x4, hpriv->mmio + AHCI_VENDOR_SPECIFIC_0_ADDR);",
            "\twritel(0x80, hpriv->mmio + AHCI_VENDOR_SPECIFIC_0_DATA);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\ata\\ahci_mvebu.c"
          ]
        },
        {
          "file": "linux\\drivers\\ata\\ata_piix.c",
          "line": 64,
          "match": "deadlock",
          "context": [
            " *\t450NX:\terrata #19\t- DMA hangs on old 450NX",
            " *\t450NX:  errata #20\t- DMA hangs on old 450NX",
            " *\t450NX:  errata #25\t- Corruption with DMA on old 450NX",
            " *\tICH3    errata #15      - IDE deadlock under high load",
            " *\t\t\t\t  (BIOS must set dev 31 fn 0 bit 23)",
            " *\tICH3\terrata #18\t- Don't use native mode",
            " */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\ata\\ata_piix.c"
          ]
        },
        {
          "file": "linux\\drivers\\atm\\eni.c",
          "line": 48,
          "match": "deadlock",
          "context": [
            "/*",
            " * KNOWN BUGS:",
            " *",
            " * - may run into JK-JK bug and deadlock",
            " * - should allocate UBR channel first",
            " * - buffer space allocation algorithm is stupid",
            " *   (RX: should be maxSDU+maxdelay*rate"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\atm\\eni.c"
          ]
        },
        {
          "file": "linux\\drivers\\base\\dd.c",
          "line": 1316,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * If anyone calls device_release_driver() recursively from",
            "\t * within their ->remove callback for the same device, they",
            "\t * will deadlock right here.",
            "\t */",
            "\tdevice_release_driver_internal(dev, NULL, NULL);",
            "}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\base\\dd.c"
          ]
        },
        {
          "file": "linux\\drivers\\block\\nbd.c",
          "line": 6,
          "match": "deadlock",
          "context": [
            " * Network block device - make block devices work over TCP",
            " *",
            " * Note that you can not swap over this thing, yet. Seems to work but",
            " * deadlocks sometimes - you can not swap over TCP in general.",
            " * ",
            " * Copyright 1997-2000, 2008 Pavel Machek <pavel@ucw.cz>",
            " * Parts copyright 2001 Steven Whitehouse <steve@chygwyn.com>"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\block\\nbd.c"
          ]
        },
        {
          "file": "linux\\drivers\\block\\nbd.c",
          "line": 292,
          "match": "deadlock",
          "context": [
            "\tif (!refcount_dec_and_test(&nbd->refs))",
            "\t\treturn;",
            "",
            "\t/* Call del_gendisk() asynchrounously to prevent deadlock */",
            "\tif (test_bit(NBD_DESTROY_ON_DISCONNECT, &nbd->flags))",
            "\t\tqueue_work(nbd_del_wq, &nbd->remove_work);",
            "\telse"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\block\\nbd.c"
          ]
        },
        {
          "file": "linux\\drivers\\block\\nbd.c",
          "line": 2480,
          "match": "deadlock",
          "context": [
            "\t * reason we don't take a ref here is because we can't",
            "\t * take a ref in the index == -1 case as we would need",
            "\t * to put under the nbd_index_mutex, which could",
            "\t * deadlock if we are configured to remove ourselves",
            "\t * once we're disconnected.",
            "\t */",
            "\tif (refcount_read(&nbd->config_refs))"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\block\\nbd.c"
          ]
        },
        {
          "file": "linux\\drivers\\block\\rbd.c",
          "line": 4561,
          "match": "deadlock",
          "context": [
            "}",
            "",
            "/*",
            " * header_rwsem must not be held to avoid a deadlock with",
            " * rbd_dev_refresh() when flushing notifies.",
            " */",
            "static void rbd_unregister_watch(struct rbd_device *rbd_dev)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\block\\rbd.c"
          ]
        },
        {
          "file": "linux\\drivers\\block\\ublk_drv.c",
          "line": 1575,
          "match": "deadlock",
          "context": [
            "\t *",
            "\t * More importantly, we have to provide forward progress guarantee",
            "\t * without holding ub->mutex, otherwise control task grabbing",
            "\t * ub->mutex triggers deadlock",
            "\t *",
            "\t * All requests may be inflight, so ->canceling may not be set, set",
            "\t * it now."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\block\\ublk_drv.c"
          ]
        },
        {
          "file": "linux\\drivers\\block\\ublk_drv.c",
          "line": 1786,
          "match": "deadlock",
          "context": [
            " *   uring_cmd are done",
            " *",
            " * Do _not_ try to acquire ub->mutex before all inflight requests are",
            " * aborted, otherwise deadlock may be caused.",
            " */",
            "static void ublk_uring_cmd_cancel_fn(struct io_uring_cmd *cmd,",
            "\t\tunsigned int issue_flags)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\block\\ublk_drv.c"
          ]
        },
        {
          "file": "linux\\drivers\\clk\\clk.c",
          "line": 134,
          "match": "deadlock",
          "context": [
            " * clk_pm_runtime_get_all() - Runtime \"get\" all clk provider devices",
            " *",
            " * Call clk_pm_runtime_get() on all runtime PM enabled clks in the clk tree so",
            " * that disabling unused clks avoids a deadlock where a device is runtime PM",
            " * resuming/suspending and the runtime PM callback is trying to grab the",
            " * prepare_lock for something like clk_prepare_enable() while",
            " * clk_disable_unused_subtree() holds the prepare_lock and is trying to runtime"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\clk\\clk.c"
          ]
        },
        {
          "file": "linux\\drivers\\clk\\clk.c",
          "line": 159,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Runtime PM \"get\" all the devices that are needed for the clks",
            "\t * currently registered. Do this without holding the prepare_lock, to",
            "\t * avoid the deadlock.",
            "\t */",
            "\thlist_for_each_entry(core, &clk_rpm_list, rpm_node) {",
            "\t\tret = clk_pm_runtime_get(core);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\clk\\clk.c"
          ]
        },
        {
          "file": "linux\\drivers\\comedi\\comedi_fops.c",
          "line": 2644,
          "match": "deadlock",
          "context": [
            "\t\tstruct comedi_subdevice *new_s;",
            "",
            "\t\t/*",
            "\t\t * To avoid deadlock, cannot acquire dev->mutex",
            "\t\t * while dev->attach_lock is held.",
            "\t\t */",
            "\t\tup_read(&dev->attach_lock);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\comedi\\comedi_fops.c"
          ]
        },
        {
          "file": "linux\\drivers\\comedi\\comedi_fops.c",
          "line": 2771,
          "match": "deadlock",
          "context": [
            "\t\tstruct comedi_subdevice *new_s;",
            "",
            "\t\t/*",
            "\t\t * To avoid deadlock, cannot acquire dev->mutex",
            "\t\t * while dev->attach_lock is held.",
            "\t\t */",
            "\t\tup_read(&dev->attach_lock);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\comedi\\comedi_fops.c"
          ]
        },
        {
          "file": "linux\\drivers\\cpufreq\\cpufreq.c",
          "line": 375,
          "match": "deadlock",
          "context": [
            "{",
            "",
            "\t/*",
            "\t * Catch double invocations of _begin() which lead to self-deadlock.",
            "\t * ASYNC_NOTIFICATION drivers are left out because the cpufreq core",
            "\t * doesn't invoke _begin() on their behalf, and hence the chances of",
            "\t * double invocations are very low. Moreover, there are scenarios"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\cpufreq\\cpufreq.c"
          ]
        },
        {
          "file": "linux\\drivers\\cpufreq\\cpufreq.c",
          "line": 375,
          "match": "double invocations of _begin() which lead to self-deadlock",
          "context": [
            "{",
            "",
            "\t/*",
            "\t * Catch double invocations of _begin() which lead to self-deadlock.",
            "\t * ASYNC_NOTIFICATION drivers are left out because the cpufreq core",
            "\t * doesn't invoke _begin() on their behalf, and hence the chances of",
            "\t * double invocations are very low. Moreover, there are scenarios"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\cpufreq\\cpufreq.c"
          ]
        },
        {
          "file": "linux\\drivers\\cpufreq\\pxa2xx-cpufreq.c",
          "line": 215,
          "match": "deadlock",
          "context": [
            "\t * only power savings will suffer from this.",
            "\t *",
            "\t * Note: if the voltage change fails, and a return value is returned, a",
            "\t * bug is triggered (seems a deadlock). Should anybody find out where,",
            "\t * the \"return 0\" should become a \"return ret\".",
            "\t */",
            "\tif (vcc_core && new_freq_cpu < policy->cur)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\cpufreq\\pxa2xx-cpufreq.c"
          ]
        },
        {
          "file": "linux\\drivers\\cpuidle\\coupled.c",
          "line": 119,
          "match": "deadlock",
          "context": [
            "/*",
            " * The cpuidle_coupled_poke_pending mask is used to avoid calling",
            " * __smp_call_function_single with the per cpu call_single_data_t struct already",
            " * in use.  This prevents a deadlock where two cpus are waiting for each others",
            " * call_single_data_t struct to be available",
            " */",
            "static cpumask_t cpuidle_coupled_poke_pending;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\cpuidle\\coupled.c"
          ]
        },
        {
          "file": "linux\\drivers\\dma\\amba-pl08x.c",
          "line": 940,
          "match": "deadlock",
          "context": [
            "\t\tbool success;",
            "",
            "\t\t/*",
            "\t\t * Eww.  We know this isn't going to deadlock",
            "\t\t * but lockdep probably doesn't.",
            "\t\t */",
            "\t\tspin_lock(&next->vc.lock);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\dma\\amba-pl08x.c"
          ]
        },
        {
          "file": "linux\\drivers\\dma-buf\\dma-buf.c",
          "line": 865,
          "match": "deadlock",
          "context": [
            "/**",
            " * DOC: locking convention",
            " *",
            " * In order to avoid deadlock situations between dma-buf exports and importers,",
            " * all dma-buf API users must follow the common dma-buf locking convention.",
            " *",
            " * Convention for importers"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\dma-buf\\dma-buf.c"
          ]
        },
        {
          "file": "linux\\drivers\\dma-buf\\dma-fence.c",
          "line": 89,
          "match": "deadlock",
          "context": [
            " *   Drivers should not try to second guess timeout handling of fences from",
            " *   other drivers.",
            " *",
            " * * To ensure there's no deadlocks of dma_fence_wait() against other locks",
            " *   drivers should annotate all code required to reach dma_fence_signal(),",
            " *   which completes the fences, with dma_fence_begin_signalling() and",
            " *   dma_fence_end_signalling()."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\dma-buf\\dma-fence.c"
          ]
        },
        {
          "file": "linux\\drivers\\dma-buf\\dma-fence.c",
          "line": 226,
          "match": "deadlock",
          "context": [
            " *   allocation sites through &mmu_notifier and &shrinker.",
            " *",
            " * Furthermore lockdep does not handle cross-release dependencies, which means",
            " * any deadlocks between dma_fence_wait() and dma_fence_signal() can't be caught",
            " * at runtime with some quick testing. The simplest example is one thread",
            " * waiting on a &dma_fence while holding a lock::",
            " *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\dma-buf\\dma-fence.c"
          ]
        },
        {
          "file": "linux\\drivers\\dma-buf\\dma-fence.c",
          "line": 257,
          "match": "deadlock",
          "context": [
            " *",
            " * * All code necessary to complete a &dma_fence must be annotated, from the",
            " *   point where a fence is accessible to other threads, to the point where",
            " *   dma_fence_signal() is called. Un-annotated code can contain deadlock issues,",
            " *   and due to the very strict rules and many corner cases it is infeasible to",
            " *   catch these just with review or normal stress testing.",
            " *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\dma-buf\\dma-fence.c"
          ]
        },
        {
          "file": "linux\\drivers\\dma-buf\\dma-fence.c",
          "line": 280,
          "match": "deadlock",
          "context": [
            " * * Validation against the cross driver contract is implemented by priming",
            " *   lockdep with the relevant hierarchy at boot-up. This means even just",
            " *   testing with a single device is enough to validate a driver, at least as",
            " *   far as deadlocks with dma_fence_wait() against dma_fence_signal() are",
            " *   concerned.",
            " */",
            "#ifdef CONFIG_LOCKDEP"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\dma-buf\\dma-fence.c"
          ]
        },
        {
          "file": "linux\\drivers\\dma-buf\\dma-fence.c",
          "line": 709,
          "match": "deadlock",
          "context": [
            " *",
            " * *WARNING*:",
            " * Cancelling a callback should only be done if you really know what you're",
            " * doing, since deadlocks and race conditions could occur all too easily. For",
            " * this reason, it should only ever be done on hardware lockup recovery,",
            " * with a reference held to the fence.",
            " *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\dma-buf\\dma-fence.c"
          ]
        },
        {
          "file": "linux\\drivers\\dma-buf\\sw_sync.c",
          "line": 305,
          "match": "deadlock",
          "context": [
            "/*",
            " * *WARNING*",
            " *",
            " * improper use of this can result in deadlocking kernel drivers from userspace.",
            " */",
            "",
            "/* opening sw_sync create a new sync obj */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\dma-buf\\sw_sync.c"
          ]
        },
        {
          "file": "linux\\drivers\\firewire\\sbp2.c",
          "line": 1221,
          "match": "deadlock",
          "context": [
            "\t\tcontainer_of((void *)tgt, struct Scsi_Host, hostdata[0]);",
            "\tstruct scsi_device *sdev;",
            "",
            "\t/* prevent deadlocks */",
            "\tsbp2_unblock(tgt);",
            "",
            "\tlist_for_each_entry_safe(lu, next, &tgt->lu_list, link) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\firewire\\sbp2.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpio\\gpio-aggregator.c",
          "line": 215,
          "match": "deadlock",
          "context": [
            "\t\t * Normally, we acquire aggr->lock within the configfs",
            "\t\t * callback. However, in the legacy sysfs interface case,",
            "\t\t * calling configfs_(un)register_group while holding",
            "\t\t * aggr->lock could cause a deadlock. Fortunately, this is",
            "\t\t * unnecessary because the new_device/delete_device path",
            "\t\t * and the module unload path are mutually exclusive,",
            "\t\t * thanks to an explicit try_module_get. That's why this"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpio\\gpio-aggregator.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpio\\gpio-aggregator.c",
          "line": 1376,
          "match": "deadlock",
          "context": [
            "{",
            "\t/*",
            "\t * Configfs callbacks acquire gpio_aggregator_lock when accessing",
            "\t * gpio_aggregator_idr, so to prevent lock inversion deadlock, we",
            "\t * cannot protect idr_for_each invocation here with",
            "\t * gpio_aggregator_lock, as gpio_aggregator_idr_remove() accesses",
            "\t * configfs groups. Fortunately, the new_device/delete_device path"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpio\\gpio-aggregator.c"
          ]
        },
        {
          "file": "linux\\drivers\\hid\\hid-wiimote-modules.c",
          "line": 147,
          "match": "deadlock",
          "context": [
            "\telse",
            "\t\tvalue = 0;",
            "",
            "\t/* Locking state.lock here might deadlock with input_event() calls.",
            "\t * schedule_work acts as barrier. Merging multiple changes is fine. */",
            "\twdata->state.cache_rumble = value;",
            "\tschedule_work(&wdata->rumble_worker);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hid\\hid-wiimote-modules.c"
          ]
        },
        {
          "file": "linux\\drivers\\hid\\hid-wiimote-modules.c",
          "line": 1805,
          "match": "deadlock",
          "context": [
            "\telse",
            "\t\tvalue = 0;",
            "",
            "\t/* Locking state.lock here might deadlock with input_event() calls.",
            "\t * schedule_work acts as barrier. Merging multiple changes is fine. */",
            "\twdata->state.cache_rumble = value;",
            "\tschedule_work(&wdata->rumble_worker);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hid\\hid-wiimote-modules.c"
          ]
        },
        {
          "file": "linux\\drivers\\hv\\channel_mgmt.c",
          "line": 682,
          "match": "deadlock",
          "context": [
            "\t * OPEN_CHANNEL message (the host may rescind a channel at any time,",
            "\t * e.g. in the case of hot removing a NIC), and vmbus_onoffer_rescind()",
            "\t * may not wake up the vmbus_open() as it's blocked due to a non-zero",
            "\t * vmbus_connection.offer_in_progress, and finally we have a deadlock.",
            "\t *",
            "\t * The above is also true for primary channels, if the related device",
            "\t * drivers use sync probing mode by default."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hv\\channel_mgmt.c"
          ]
        },
        {
          "file": "linux\\drivers\\hv\\channel_mgmt.c",
          "line": 689,
          "match": "deadlock",
          "context": [
            "\t *",
            "\t * And, usually the handling of primary channels and sub-channels can",
            "\t * depend on each other, so we should offload them to different",
            "\t * workqueues to avoid possible deadlock, e.g. in sync-probing mode,",
            "\t * NIC1's netvsc_subchan_work() can race with NIC2's netvsc_probe() ->",
            "\t * rtnl_lock(), and causes deadlock: the former gets the rtnl_lock",
            "\t * and waits for all the sub-channels to appear, but the latter"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hv\\channel_mgmt.c"
          ]
        },
        {
          "file": "linux\\drivers\\hv\\channel_mgmt.c",
          "line": 691,
          "match": "deadlock",
          "context": [
            "\t * depend on each other, so we should offload them to different",
            "\t * workqueues to avoid possible deadlock, e.g. in sync-probing mode,",
            "\t * NIC1's netvsc_subchan_work() can race with NIC2's netvsc_probe() ->",
            "\t * rtnl_lock(), and causes deadlock: the former gets the rtnl_lock",
            "\t * and waits for all the sub-channels to appear, but the latter",
            "\t * can't get the rtnl_lock and this blocks the handling of",
            "\t * sub-channels."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hv\\channel_mgmt.c"
          ]
        },
        {
          "file": "linux\\drivers\\hv\\hv_balloon.c",
          "line": 1391,
          "match": "deadlock",
          "context": [
            "\t\t/*",
            "\t\t * disable free page reporting if multiple hypercall",
            "\t\t * failure flag set. It is not done in the page_reporting",
            "\t\t * callback context as that causes a deadlock between",
            "\t\t * page_reporting_process() and page_reporting_unregister()",
            "\t\t */",
            "\t\tif (hv_hypercall_multi_failure >= HV_MAX_FAILURES) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hv\\hv_balloon.c"
          ]
        },
        {
          "file": "linux\\drivers\\hwmon\\fschmd.c",
          "line": 803,
          "match": "deadlock",
          "context": [
            "\t * We get called from drivers/char/misc.c with misc_mtx hold, and we",
            "\t * call misc_register() from fschmd_probe() with watchdog_data_mutex",
            "\t * hold, as misc_register() takes the misc_mtx lock, this is a possible",
            "\t * deadlock, so we use mutex_trylock here.",
            "\t */",
            "\tif (!mutex_trylock(&watchdog_data_mutex))",
            "\t\treturn -ERESTARTSYS;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hwmon\\fschmd.c"
          ]
        },
        {
          "file": "linux\\drivers\\hwmon\\it87.c",
          "line": 777,
          "match": "deadlock",
          "context": [
            "/*",
            " * Must be called with data->update_lock held, except during initialization.",
            " * Must be called with SMBus accesses disabled.",
            " * We ignore the IT87 BUSY flag at this moment - it could lead to deadlocks,",
            " * would slow down the IT87 access and should not be necessary.",
            " */",
            "static int it87_read_value(struct it87_data *data, u8 reg)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hwmon\\it87.c"
          ]
        },
        {
          "file": "linux\\drivers\\hwmon\\it87.c",
          "line": 789,
          "match": "deadlock",
          "context": [
            "/*",
            " * Must be called with data->update_lock held, except during initialization.",
            " * Must be called with SMBus accesses disabled.",
            " * We ignore the IT87 BUSY flag at this moment - it could lead to deadlocks,",
            " * would slow down the IT87 access and should not be necessary.",
            " */",
            "static void it87_write_value(struct it87_data *data, u8 reg, u8 value)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hwmon\\it87.c"
          ]
        },
        {
          "file": "linux\\drivers\\hwmon\\lm78.c",
          "line": 673,
          "match": "deadlock",
          "context": [
            " * The SMBus locks itself, but ISA access must be locked explicitly!",
            " * We don't want to lock the whole ISA bus, so we lock each client",
            " * separately.",
            " * We ignore the LM78 BUSY flag at this moment - it could lead to deadlocks,",
            " * would slow down the LM78 access and should not be necessary.",
            " */",
            "static int lm78_read_value(struct lm78_data *data, u8 reg)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hwmon\\lm78.c"
          ]
        },
        {
          "file": "linux\\drivers\\hwmon\\w83781d.c",
          "line": 1723,
          "match": "deadlock",
          "context": [
            "/*",
            " * The SMBus locks itself, usually, but nothing may access the Winbond between",
            " * bank switches. ISA access must always be locked explicitly!",
            " * We ignore the W83781D BUSY flag at this moment - it could lead to deadlocks,",
            " * would slow down the W83781D access and should not be necessary.",
            " * There are some ugly typecasts here, but the good news is - they should",
            " * nowhere else be necessary!"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hwmon\\w83781d.c"
          ]
        },
        {
          "file": "linux\\drivers\\hwmon\\w83793.c",
          "line": 1296,
          "match": "deadlock",
          "context": [
            "\t * We get called from drivers/char/misc.c with misc_mtx hold, and we",
            "\t * call misc_register() from  w83793_probe() with watchdog_data_mutex",
            "\t * hold, as misc_register() takes the misc_mtx lock, this is a possible",
            "\t * deadlock, so we use mutex_trylock here.",
            "\t */",
            "\tif (!mutex_trylock(&watchdog_data_mutex))",
            "\t\treturn -ERESTARTSYS;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hwmon\\w83793.c"
          ]
        },
        {
          "file": "linux\\drivers\\iio\\industrialio-buffer.c",
          "line": 1969,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * The fence will be unref'd in iio_buffer_cleanup.",
            "\t * It can't be done here, as the unref functions might try to lock the",
            "\t * resv object, which can deadlock.",
            "\t */",
            "\tINIT_WORK(&iio_fence->work, iio_buffer_cleanup);",
            "\tschedule_work(&iio_fence->work);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\iio\\industrialio-buffer.c"
          ]
        },
        {
          "file": "linux\\drivers\\iommu\\iommu.c",
          "line": 1918,
          "match": "deadlock",
          "context": [
            "\t\t * FIXME: Mis-locked because the ops->probe_finalize() call-back",
            "\t\t * of some IOMMU drivers calls arm_iommu_attach_device() which",
            "\t\t * in-turn might call back into IOMMU core code, where it tries",
            "\t\t * to take group->mutex, resulting in a deadlock.",
            "\t\t */",
            "\t\tfor_each_group_device(group, gdev)",
            "\t\t\tiommu_group_do_probe_finalize(gdev->dev);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\iommu\\iommu.c"
          ]
        },
        {
          "file": "linux\\drivers\\iommu\\ipmmu-vmsa.c",
          "line": 262,
          "match": "deadlock",
          "context": [
            "\t\t\t\t     !(val & IMCTR_FLUSH), 1, TLB_LOOP_TIMEOUT,",
            "\t\t\t\t     false, domain, IMCTR))",
            "\t\tdev_err_ratelimited(domain->mmu->dev,",
            "\t\t\t\"TLB sync timed out -- MMU may be deadlocked\\n\");",
            "}",
            "",
            "static void ipmmu_tlb_invalidate(struct ipmmu_vmsa_domain *domain)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\iommu\\ipmmu-vmsa.c"
          ]
        },
        {
          "file": "linux\\drivers\\irqchip\\irq-ti-sci-inta.c",
          "line": 418,
          "match": "deadlock",
          "context": [
            " *",
            " * Note: This is the core api where the actual allocation happens for input",
            " *\t hwirq. This allocation involves creating a parent irq for vint.",
            " *\t If this is done in irq_domain_ops.alloc() then a deadlock is reached",
            " *\t for allocation. So this allocation is being done in request_resources()",
            " *",
            " * Return: 0 if all went well else corresponding error."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\irqchip\\irq-ti-sci-inta.c"
          ]
        },
        {
          "file": "linux\\drivers\\macintosh\\smu.c",
          "line": 652,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Ok, we are matched, now expose all i2c busses. We have to defer",
            "\t * that unfortunately or it would deadlock inside the device model",
            "\t */",
            "\tschedule_work(&smu_expose_childs_work);",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\macintosh\\smu.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\dm-bufio.c",
          "line": 1822,
          "match": "deadlock",
          "context": [
            "\t * read if dm_bufio_get function is used. Both dm_bufio_get and",
            "\t * dm_bufio_prefetch can be used in the driver request routine.",
            "\t * If the user called both dm_bufio_prefetch and dm_bufio_get on",
            "\t * the same buffer, it would deadlock if we waited.",
            "\t */",
            "\tif (nf == NF_GET && unlikely(test_bit_acquire(B_READING, &b->state))) {",
            "\t\tcache_put_and_wake(c, b);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\dm-bufio.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\dm-bufio.c",
          "line": 1882,
          "match": "deadlock",
          "context": [
            "\t\t * read if dm_bufio_get function is used. Both dm_bufio_get and",
            "\t\t * dm_bufio_prefetch can be used in the driver request routine.",
            "\t\t * If the user called both dm_bufio_prefetch and dm_bufio_get on",
            "\t\t * the same buffer, it would deadlock if we waited.",
            "\t\t */",
            "\t\tif (nf == NF_GET && unlikely(test_bit_acquire(B_READING, &b->state))) {",
            "\t\t\tcache_put_and_wake(c, b);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\dm-bufio.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\dm-cache-metadata.c",
          "line": 1787,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Replacement block manager (new_bm) is created and old_bm destroyed outside of",
            "\t * cmd root_lock to avoid ABBA deadlock that would result (due to life-cycle of",
            "\t * shrinker associated with the block manager's bufio client vs cmd root_lock).",
            "\t * - must take shrinker_mutex without holding cmd->root_lock",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\dm-cache-metadata.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\dm-crypt.c",
          "line": 1673,
          "match": "deadlock",
          "context": [
            " * core should split the bio as needed).",
            " *",
            " * This function may be called concurrently. If we allocate from the mempool",
            " * concurrently, there is a possibility of deadlock. For example, if we have",
            " * mempool of 256 pages, two processes, each wanting 256, pages allocate from",
            " * the mempool concurrently, it may deadlock in a situation where both processes",
            " * have allocated 128 pages and the mempool is exhausted."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\dm-crypt.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\dm-crypt.c",
          "line": 1675,
          "match": "deadlock",
          "context": [
            " * This function may be called concurrently. If we allocate from the mempool",
            " * concurrently, there is a possibility of deadlock. For example, if we have",
            " * mempool of 256 pages, two processes, each wanting 256, pages allocate from",
            " * the mempool concurrently, it may deadlock in a situation where both processes",
            " * have allocated 128 pages and the mempool is exhausted.",
            " *",
            " * In order to avoid this scenario we allocate the pages under a mutex."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\dm-crypt.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\dm-kcopyd.c",
          "line": 344,
          "match": "deadlock",
          "context": [
            " *---------------------------------------------------------------",
            " * kcopyd_jobs need to be allocated by the *clients* of kcopyd,",
            " * for this reason we use a mempool to prevent the client from",
            " * ever having to do io (which could cause a deadlock).",
            " *---------------------------------------------------------------",
            " */",
            "struct kcopyd_job {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\dm-kcopyd.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\dm-raid.c",
          "line": 3834,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * For raid456, if reshape is interrupted, IO across reshape position",
            "\t * will never make progress, while caller will wait for IO to be done.",
            "\t * Inform raid456 to handle those IO to prevent deadlock.",
            "\t */",
            "\tif (mddev->pers && mddev->pers->prepare_suspend)",
            "\t\tmddev->pers->prepare_suspend(mddev);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\dm-raid.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\dm-raid.c",
          "line": 3854,
          "match": "deadlock",
          "context": [
            "\tif (!test_and_set_bit(RT_FLAG_RS_SUSPENDED, &rs->runtime_flags)) {",
            "\t\t/*",
            "\t\t * sync_thread must be stopped during suspend, and writes have",
            "\t\t * to be stopped before suspending to avoid deadlocks.",
            "\t\t */",
            "\t\tmd_stop_writes(&rs->md);",
            "\t\tmddev_suspend(&rs->md, false);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\dm-raid.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\dm.c",
          "line": 2690,
          "match": "deadlock",
          "context": [
            "\t\tset_bit(DMF_POST_SUSPENDING, &md->flags);",
            "\t\tdm_table_postsuspend_targets(map);",
            "\t}",
            "\t/* dm_put_live_table must be before fsleep, otherwise deadlock is possible */",
            "\tdm_put_live_table(md, srcu_idx);",
            "\tmutex_unlock(&md->suspend_lock);",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\dm.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\dm.c",
          "line": 3022,
          "match": "deadlock",
          "context": [
            "",
            "\tmap = rcu_dereference_protected(md->map, lockdep_is_held(&md->suspend_lock));",
            "\tif (!map) {",
            "\t\t/* avoid deadlock with fs/namespace.c:do_mount() */",
            "\t\tsuspend_flags &= ~DM_SUSPEND_LOCKFS_FLAG;",
            "\t}",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\dm.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\md.c",
          "line": 470,
          "match": "deadlock",
          "context": [
            "\tint err = 0;",
            "",
            "\t/*",
            "\t * hold reconfig_mutex to wait for normal io will deadlock, because",
            "\t * other context can't update super_block, and normal io can rely on",
            "\t * updating super_block.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\md.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\md.c",
          "line": 505,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * For raid456, io might be waiting for reshape to make progress,",
            "\t * allow new reshape to start while waiting for io to be done to",
            "\t * prevent deadlock.",
            "\t */",
            "\tWRITE_ONCE(mddev->suspended, mddev->suspended + 1);",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\md.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\md.c",
          "line": 833,
          "match": "deadlock",
          "context": [
            "\t\t/* These cannot be removed under reconfig_mutex as",
            "\t\t * an access to the files will try to take reconfig_mutex",
            "\t\t * while holding the file unremovable, which leads to",
            "\t\t * a deadlock.",
            "\t\t * So hold set sysfs_active while the remove in happeing,",
            "\t\t * and anything else which might set ->to_remove or my",
            "\t\t * otherwise change the sysfs namespace will fail with"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\md.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\md.c",
          "line": 8082,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * md_thread is a 'system-thread', it's priority should be very",
            "\t * high. We avoid resource deadlocks individually in each",
            "\t * raid personality. (RAID5 does preallocation) We also use RR and",
            "\t * the very same RT priority as kswapd, thus we will never get",
            "\t * into a priority inversion deadlock."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\md.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\md.c",
          "line": 8085,
          "match": "deadlock",
          "context": [
            "\t * high. We avoid resource deadlocks individually in each",
            "\t * raid personality. (RAID5 does preallocation) We also use RR and",
            "\t * the very same RT priority as kswapd, thus we will never get",
            "\t * into a priority inversion deadlock.",
            "\t *",
            "\t * we definitely have to have equal or higher priority than",
            "\t * bdflush, otherwise bdflush will deadlock if there are too"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\md.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\md.c",
          "line": 8088,
          "match": "deadlock",
          "context": [
            "\t * into a priority inversion deadlock.",
            "\t *",
            "\t * we definitely have to have equal or higher priority than",
            "\t * bdflush, otherwise bdflush will deadlock if there are too",
            "\t * many dirty RAID5 blocks.",
            "\t */",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\md.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\md.c",
          "line": 9061,
          "match": "deadlock",
          "context": [
            "\t * Before starting a resync we must have set curr_resync to",
            "\t * 2, and then checked that every \"conflicting\" array has curr_resync",
            "\t * less than ours.  When we find one that is the same or higher",
            "\t * we wait on resync_wait.  To avoid deadlock, we reduce curr_resync",
            "\t * to 1 if we choose to yield (based arbitrarily on address of mddev structure).",
            "\t * This will mean we have to start checking from the beginning again.",
            "\t *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\md.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\md.c",
          "line": 9913,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Recording new badblocks for faulty rdev will force unnecessary",
            "\t * super block updating. This is fragile for external management because",
            "\t * userspace daemon may trying to remove this device and deadlock may",
            "\t * occur. This will be probably solved in the mdadm, but it is safer to",
            "\t * avoid it.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\md.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\raid1-10.c",
          "line": 167,
          "match": "deadlock",
          "context": [
            " * current->bio_list will be set under submit_bio() context, in this case bitmap",
            " * io will be added to the list and wait for current io submission to finish,",
            " * while current io submission must wait for bitmap io to be done. In order to",
            " * avoid such deadlock, submit bitmap io asynchronously.",
            " */",
            "static inline void raid1_prepare_flush_writes(struct mddev *mddev)",
            "{"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\raid1-10.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\raid1.c",
          "line": 1327,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * If r1_bio is set, we are blocking the raid1d thread",
            "\t * so there is a tiny risk of deadlock.  So ask for",
            "\t * emergency memory if needed.",
            "\t */",
            "\tgfp_t gfp = r1_bio ? (GFP_NOIO | __GFP_HIGH) : GFP_NOIO;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\raid1.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\raid5-cache.c",
          "line": 371,
          "match": "deadlock",
          "context": [
            "/*",
            " * Total log space (in sectors) needed to flush all data in cache",
            " *",
            " * To avoid deadlock due to log space, it is necessary to reserve log",
            " * space to flush critical stripes (stripes that occupying log space near",
            " * last_checkpoint). This function helps check how much log space is",
            " * required to flush all cached stripes."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\raid5-cache.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\raid5-cache.c",
          "line": 1330,
          "match": "deadlock",
          "context": [
            "\t * reconfig_mutex hold. The first step of raid5_quiesce() is waiting",
            "\t * for all IO finish, hence waiting for reclaim thread, while reclaim",
            "\t * thread is calling this function and waiting for reconfig mutex. So",
            "\t * there is a deadlock. We workaround this issue with a trylock.",
            "\t * FIXME: we could miss discard if we can't take reconfig mutex",
            "\t */",
            "\tset_mask_bits(&mddev->sb_flags, 0,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\raid5-cache.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\raid5.c",
          "line": 821,
          "match": "deadlock",
          "context": [
            "\t\t\t * Must release the reference to batch_last before",
            "\t\t\t * waiting, on quiesce, otherwise the batch_last will",
            "\t\t\t * hold a reference to a stripe and raid5_quiesce()",
            "\t\t\t * will deadlock waiting for active_stripes to go to",
            "\t\t\t * zero.",
            "\t\t\t */",
            "\t\t\tif (ctx && ctx->batch_last) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\raid5.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\raid5.c",
          "line": 858,
          "match": "deadlock",
          "context": [
            "\t\tset_bit(R5_INACTIVE_BLOCKED, &conf->cache_state);",
            "\t\tr5l_wake_reclaim(conf->log, 0);",
            "",
            "\t\t/* release batch_last before wait to avoid risk of deadlock */",
            "\t\tif (ctx && ctx->batch_last) {",
            "\t\t\traid5_release_stripe(ctx->batch_last);",
            "\t\t\tctx->batch_last = NULL;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\raid5.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\raid5.c",
          "line": 5812,
          "match": "deadlock",
          "context": [
            "\t\t\tset_bit(R5_Overlap, &dev->flags);",
            "\t\t\tspin_unlock_irq(&sh->stripe_lock);",
            "\t\t\traid5_release_stripe(sh);",
            "\t\t\t/* release batch_last before wait to avoid risk of deadlock */",
            "\t\t\tif (ctx->batch_last) {",
            "\t\t\t\traid5_release_stripe(ctx->batch_last);",
            "\t\t\t\tctx->batch_last = NULL;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\raid5.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\raid5.c",
          "line": 6162,
          "match": "deadlock",
          "context": [
            "\t\t\t * scheduling and waiting for work to be done,",
            "\t\t\t * otherwise the batch_last stripe head could prevent",
            "\t\t\t * raid5_activate_delayed() from making progress",
            "\t\t\t * and thus deadlocking.",
            "\t\t\t */",
            "\t\t\tif (ctx.batch_last) {",
            "\t\t\t\traid5_release_stripe(ctx.batch_last);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\raid5.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\raid5.c",
          "line": 8155,
          "match": "deadlock",
          "context": [
            "\tif (test_bit(Journal, &rdev->flags) && conf->log) {",
            "\t\t/*",
            "\t\t * we can't wait pending write here, as this is called in",
            "\t\t * raid5d, wait will deadlock.",
            "\t\t * neilb: there is no locking about new writes here,",
            "\t\t * so this cannot be safe.",
            "\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\raid5.c"
          ]
        },
        {
          "file": "linux\\drivers\\mfd\\tps65010.c",
          "line": 334,
          "match": "deadlock",
          "context": [
            "\t\t\tpr_info(\"%s: power off button\\n\", DRIVER_NAME);",
            "#if 0",
            "\t\t\t/* REVISIT:  this might need its own workqueue",
            "\t\t\t * plus tweaks including deadlock avoidance ...",
            "\t\t\t * also needs to get error handling and probably",
            "\t\t\t * an #ifdef CONFIG_HIBERNATION",
            "\t\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\mfd\\tps65010.c"
          ]
        },
        {
          "file": "linux\\drivers\\misc\\pch_phub.c",
          "line": 74,
          "match": "DEADLOCK",
          "context": [
            "#define PCH_PHUB_BRI_QUEUE_MAXSIZE_REG\t\t0x000C",
            "#define PCH_PHUB_COMP_RESP_TIMEOUT_REG\t\t0x0010",
            "#define PCH_PHUB_BUS_SLAVE_CONTROL_REG\t\t0x0014",
            "#define PCH_PHUB_DEADLOCK_AVOID_TYPE_REG\t0x0018",
            "#define PCH_PHUB_INTPIN_REG_WPERMIT_REG0\t0x0020",
            "#define PCH_PHUB_INTPIN_REG_WPERMIT_REG1\t0x0024",
            "#define PCH_PHUB_INTPIN_REG_WPERMIT_REG2\t0x0028"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\misc\\pch_phub.c"
          ]
        },
        {
          "file": "linux\\drivers\\misc\\pch_phub.c",
          "line": 93,
          "match": "deadlock",
          "context": [
            " * @bri_q_maxsize_reg:\t\t\tBRI_QUEUE_MAXSIZE register val",
            " * @comp_resp_timeout_reg:\t\tCOMP_RESP_TIMEOUT register val",
            " * @bus_slave_control_reg:\t\tBUS_SLAVE_CONTROL_REG register val",
            " * @deadlock_avoid_type_reg:\t\tDEADLOCK_AVOID_TYPE register val",
            " * @intpin_reg_wpermit_reg0:\t\tINTPIN_REG_WPERMIT register 0 val",
            " * @intpin_reg_wpermit_reg1:\t\tINTPIN_REG_WPERMIT register 1 val",
            " * @intpin_reg_wpermit_reg2:\t\tINTPIN_REG_WPERMIT register 2 val"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\misc\\pch_phub.c"
          ]
        },
        {
          "file": "linux\\drivers\\misc\\pch_phub.c",
          "line": 93,
          "match": "DEADLOCK",
          "context": [
            " * @bri_q_maxsize_reg:\t\t\tBRI_QUEUE_MAXSIZE register val",
            " * @comp_resp_timeout_reg:\t\tCOMP_RESP_TIMEOUT register val",
            " * @bus_slave_control_reg:\t\tBUS_SLAVE_CONTROL_REG register val",
            " * @deadlock_avoid_type_reg:\t\tDEADLOCK_AVOID_TYPE register val",
            " * @intpin_reg_wpermit_reg0:\t\tINTPIN_REG_WPERMIT register 0 val",
            " * @intpin_reg_wpermit_reg1:\t\tINTPIN_REG_WPERMIT register 1 val",
            " * @intpin_reg_wpermit_reg2:\t\tINTPIN_REG_WPERMIT register 2 val"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\misc\\pch_phub.c"
          ]
        },
        {
          "file": "linux\\drivers\\misc\\pch_phub.c",
          "line": 115,
          "match": "deadlock",
          "context": [
            "\tu32 bri_q_maxsize_reg;",
            "\tu32 comp_resp_timeout_reg;",
            "\tu32 bus_slave_control_reg;",
            "\tu32 deadlock_avoid_type_reg;",
            "\tu32 intpin_reg_wpermit_reg0;",
            "\tu32 intpin_reg_wpermit_reg1;",
            "\tu32 intpin_reg_wpermit_reg2;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\misc\\pch_phub.c"
          ]
        },
        {
          "file": "linux\\drivers\\misc\\pch_phub.c",
          "line": 167,
          "match": "deadlock",
          "context": [
            "\t\t\t\tioread32(p + PCH_PHUB_COMP_RESP_TIMEOUT_REG);",
            "\tchip->bus_slave_control_reg =",
            "\t\t\t\tioread32(p + PCH_PHUB_BUS_SLAVE_CONTROL_REG);",
            "\tchip->deadlock_avoid_type_reg =",
            "\t\t\t\tioread32(p + PCH_PHUB_DEADLOCK_AVOID_TYPE_REG);",
            "\tchip->intpin_reg_wpermit_reg0 =",
            "\t\t\t\tioread32(p + PCH_PHUB_INTPIN_REG_WPERMIT_REG0);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\misc\\pch_phub.c"
          ]
        },
        {
          "file": "linux\\drivers\\misc\\pch_phub.c",
          "line": 168,
          "match": "DEADLOCK",
          "context": [
            "\tchip->bus_slave_control_reg =",
            "\t\t\t\tioread32(p + PCH_PHUB_BUS_SLAVE_CONTROL_REG);",
            "\tchip->deadlock_avoid_type_reg =",
            "\t\t\t\tioread32(p + PCH_PHUB_DEADLOCK_AVOID_TYPE_REG);",
            "\tchip->intpin_reg_wpermit_reg0 =",
            "\t\t\t\tioread32(p + PCH_PHUB_INTPIN_REG_WPERMIT_REG0);",
            "\tchip->intpin_reg_wpermit_reg1 ="
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\misc\\pch_phub.c"
          ]
        },
        {
          "file": "linux\\drivers\\misc\\pch_phub.c",
          "line": 184,
          "match": "deadlock",
          "context": [
            "\t\t\"chip->bri_q_maxsize_reg=%x, \"",
            "\t\t\"chip->comp_resp_timeout_reg=%x, \"",
            "\t\t\"chip->bus_slave_control_reg=%x, \"",
            "\t\t\"chip->deadlock_avoid_type_reg=%x, \"",
            "\t\t\"chip->intpin_reg_wpermit_reg0=%x, \"",
            "\t\t\"chip->intpin_reg_wpermit_reg1=%x, \"",
            "\t\t\"chip->intpin_reg_wpermit_reg2=%x, \""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\misc\\pch_phub.c"
          ]
        },
        {
          "file": "linux\\drivers\\misc\\pch_phub.c",
          "line": 195,
          "match": "deadlock",
          "context": [
            "\t\tchip->bri_q_maxsize_reg,",
            "\t\tchip->comp_resp_timeout_reg,",
            "\t\tchip->bus_slave_control_reg,",
            "\t\tchip->deadlock_avoid_type_reg,",
            "\t\tchip->intpin_reg_wpermit_reg0,",
            "\t\tchip->intpin_reg_wpermit_reg1,",
            "\t\tchip->intpin_reg_wpermit_reg2,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\misc\\pch_phub.c"
          ]
        },
        {
          "file": "linux\\drivers\\misc\\pch_phub.c",
          "line": 228,
          "match": "deadlock",
          "context": [
            "\t\t\t\t\tp + PCH_PHUB_COMP_RESP_TIMEOUT_REG);",
            "\tiowrite32(chip->bus_slave_control_reg,",
            "\t\t\t\t\tp + PCH_PHUB_BUS_SLAVE_CONTROL_REG);",
            "\tiowrite32(chip->deadlock_avoid_type_reg,",
            "\t\t\t\t\tp + PCH_PHUB_DEADLOCK_AVOID_TYPE_REG);",
            "\tiowrite32(chip->intpin_reg_wpermit_reg0,",
            "\t\t\t\t\tp + PCH_PHUB_INTPIN_REG_WPERMIT_REG0);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\misc\\pch_phub.c"
          ]
        },
        {
          "file": "linux\\drivers\\misc\\pch_phub.c",
          "line": 229,
          "match": "DEADLOCK",
          "context": [
            "\tiowrite32(chip->bus_slave_control_reg,",
            "\t\t\t\t\tp + PCH_PHUB_BUS_SLAVE_CONTROL_REG);",
            "\tiowrite32(chip->deadlock_avoid_type_reg,",
            "\t\t\t\t\tp + PCH_PHUB_DEADLOCK_AVOID_TYPE_REG);",
            "\tiowrite32(chip->intpin_reg_wpermit_reg0,",
            "\t\t\t\t\tp + PCH_PHUB_INTPIN_REG_WPERMIT_REG0);",
            "\tiowrite32(chip->intpin_reg_wpermit_reg1,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\misc\\pch_phub.c"
          ]
        },
        {
          "file": "linux\\drivers\\misc\\pch_phub.c",
          "line": 245,
          "match": "deadlock",
          "context": [
            "\t\t\"chip->bri_q_maxsize_reg=%x, \"",
            "\t\t\"chip->comp_resp_timeout_reg=%x, \"",
            "\t\t\"chip->bus_slave_control_reg=%x, \"",
            "\t\t\"chip->deadlock_avoid_type_reg=%x, \"",
            "\t\t\"chip->intpin_reg_wpermit_reg0=%x, \"",
            "\t\t\"chip->intpin_reg_wpermit_reg1=%x, \"",
            "\t\t\"chip->intpin_reg_wpermit_reg2=%x, \""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\misc\\pch_phub.c"
          ]
        },
        {
          "file": "linux\\drivers\\misc\\pch_phub.c",
          "line": 256,
          "match": "deadlock",
          "context": [
            "\t\tchip->bri_q_maxsize_reg,",
            "\t\tchip->comp_resp_timeout_reg,",
            "\t\tchip->bus_slave_control_reg,",
            "\t\tchip->deadlock_avoid_type_reg,",
            "\t\tchip->intpin_reg_wpermit_reg0,",
            "\t\tchip->intpin_reg_wpermit_reg1,",
            "\t\tchip->intpin_reg_wpermit_reg2,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\misc\\pch_phub.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\virtio_net.c",
          "line": 3362,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Make sure refill_work does not run concurrently to",
            "\t * avoid napi_disable race which leads to deadlock.",
            "\t */",
            "\tdisable_delayed_refill(vi);",
            "\tcancel_delayed_work_sync(&vi->refill);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\virtio_net.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\virtio_net.c",
          "line": 3374,
          "match": "deadlock",
          "context": [
            "{",
            "\t/*",
            "\t * Make sure refill_work does not run concurrently to",
            "\t * avoid napi_disable race which leads to deadlock.",
            "\t */",
            "\tdisable_delayed_refill(vi);",
            "\tcancel_delayed_work_sync(&vi->refill);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\virtio_net.c"
          ]
        },
        {
          "file": "linux\\drivers\\parisc\\power.c",
          "line": 160,
          "match": "deadlock",
          "context": [
            " * the soft-power switch and allows the user to switch off",
            " * the system. We rely in pdc_soft_power_button_panic()",
            " * since this version spin_trylocks (instead of regular",
            " * spinlock), preventing deadlocks on panic path.",
            " */",
            "static int parisc_panic_event(struct notifier_block *this,",
            "\t\tunsigned long event, void *ptr)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\parisc\\power.c"
          ]
        },
        {
          "file": "linux\\drivers\\parport\\share.c",
          "line": 980,
          "match": "deadlock",
          "context": [
            "",
            "\t\tif (port->cad != oldcad) {",
            "\t\t\t/*",
            "\t\t\t * I think we'll actually deadlock rather than",
            "\t\t\t * get here, but just in case..",
            "\t\t\t */",
            "\t\t\tpr_warn(\"%s: %s released port when preempted!\\n\","
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\parport\\share.c"
          ]
        },
        {
          "file": "linux\\drivers\\parport\\share.c",
          "line": 1098,
          "match": "deadlock",
          "context": [
            "",
            "\t\t/*",
            "\t\t * If dev->waiting is clear now, an interrupt",
            "\t\t * gave us the port and we would deadlock if we slept.",
            "\t\t */",
            "\t\tif (dev->waiting) {",
            "\t\t\twait_event_interruptible(dev->wait_q,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\parport\\share.c"
          ]
        },
        {
          "file": "linux\\drivers\\pci\\quirks.c",
          "line": 1964,
          "match": "deadlock",
          "context": [
            " *",
            " * Normally stalling must not be enabled for PCI devices, since it would",
            " * break the PCI requirement for free-flowing writes and may lead to",
            " * deadlock.  We expect PCI devices to support ATS and PRI if they want to",
            " * be fault-tolerant, so there's no ACPI binding to describe anything else,",
            " * even when a \"PCI\" device turns out to be a regular old SoC device",
            " * dressed up as a RCiEP and normal rules don't apply."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\pci\\quirks.c"
          ]
        },
        {
          "file": "linux\\drivers\\pci\\vgaarb.c",
          "line": 82,
          "match": "deadlock",
          "context": [
            "{",
            "\t/*",
            "\t * In theory, we could hand out locks on IO and MEM separately to",
            "\t * userspace, but this can cause deadlocks.",
            "\t */",
            "\tif (strncmp(buf, \"none\", 4) == 0) {",
            "\t\t*io_state = VGA_RSRC_NONE;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\pci\\vgaarb.c"
          ]
        },
        {
          "file": "linux\\drivers\\pcmcia\\cs.c",
          "line": 719,
          "match": "deadlock",
          "context": [
            " * @events:\tevents to pass to pccardd",
            " *",
            " * userspace-issued insert, eject, suspend and resume commands must be",
            " * handled by pccardd to avoid any sysfs-related deadlocks. Valid events",
            " * are PCMCIA_UEVENT_EJECT (for eject), PCMCIA_UEVENT__INSERT (for insert),",
            " * PCMCIA_UEVENT_RESUME (for resume), PCMCIA_UEVENT_SUSPEND (for suspend)",
            " * and PCMCIA_UEVENT_REQUERY (for re-querying the PCMCIA card)."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\pcmcia\\cs.c"
          ]
        },
        {
          "file": "linux\\drivers\\perf\\arm_pmu_acpi.c",
          "line": 371,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Initialise and register the set of PMUs which we know about right",
            "\t * now. Ideally we'd do this in arm_pmu_acpi_cpu_starting() so that we",
            "\t * could handle late hotplug, but this may lead to deadlock since we",
            "\t * might try to register a hotplug notifier instance from within a",
            "\t * hotplug notifier.",
            "\t *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\perf\\arm_pmu_acpi.c"
          ]
        },
        {
          "file": "linux\\drivers\\regulator\\core.c",
          "line": 235,
          "match": "DEADLOCK",
          "context": [
            "\tret = regulator_lock_nested(rdev1, ww_ctx);",
            "\tWARN_ON(ret);",
            "\tret = regulator_lock_nested(rdev2, ww_ctx);",
            "\tif (ret != -EDEADLOCK) {",
            "\t\tWARN_ON(ret);",
            "\t\tgoto exit;",
            "\t}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\regulator\\core.c"
          ]
        },
        {
          "file": "linux\\drivers\\regulator\\core.c",
          "line": 251,
          "match": "DEADLOCK",
          "context": [
            "\t\tswap(held, contended);",
            "\t\tret = regulator_lock_nested(contended, ww_ctx);",
            "",
            "\t\tif (ret != -EDEADLOCK) {",
            "\t\t\tWARN_ON(ret);",
            "\t\t\tbreak;",
            "\t\t}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\regulator\\core.c"
          ]
        },
        {
          "file": "linux\\drivers\\regulator\\irq_helpers.c",
          "line": 33,
          "match": "deadlock",
          "context": [
            "};",
            "",
            "/*",
            " * Should only be called from threaded handler to prevent potential deadlock",
            " */",
            "static void rdev_flag_err(struct regulator_dev *rdev, int err)",
            "{"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\regulator\\irq_helpers.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\53c700.c",
          "line": 1567,
          "match": "deadlock",
          "context": [
            "\t\t\t\tfree_slot(slot, hostdata);",
            "\t\t\t\tSCp->host_scribble = NULL;",
            "\t\t\t\tNCR_700_set_depth(SCp->device, 0);",
            "\t\t\t\t/* NOTE: deadlock potential here: we",
            "\t\t\t\t * rely on mid-layer guarantees that",
            "\t\t\t\t * scsi_done won't try to issue the",
            "\t\t\t\t * command again otherwise we'll"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\53c700.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\53c700.c",
          "line": 1571,
          "match": "deadlock",
          "context": [
            "\t\t\t\t * rely on mid-layer guarantees that",
            "\t\t\t\t * scsi_done won't try to issue the",
            "\t\t\t\t * command again otherwise we'll",
            "\t\t\t\t * deadlock on the",
            "\t\t\t\t * hostdata->state_lock */",
            "\t\t\t\tSCp->result = DID_RESET << 16;",
            "\t\t\t\tscsi_done(SCp);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\53c700.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\aha1740.c",
          "line": 463,
          "match": "deadlock",
          "context": [
            "           can do then anyhow). */",
            "",
            "#define LOOPCNT_WARN 10\t\t/* excessive mbxout wait -> syslog-msg */",
            "#define LOOPCNT_MAX 1000000\t/* mbxout deadlock -> panic() after ~ 2 sec. */",
            "\t\tint loopcnt;",
            "\t\tunsigned int base = SCpnt->device->host->io_port;",
            "\t\tDEB(printk(\"aha1740[%d] critical section\\n\",ecbno));"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\aha1740.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\BusLogic.c",
          "line": 241,
          "match": "deadlock",
          "context": [
            "/*",
            "  blogic_create_addlccbs allocates Additional CCBs for Host Adapter.  If",
            "  allocation fails and there are no remaining CCBs available, the Driver Queue",
            "  Depth is decreased to a known safe value to avoid potential deadlocks when",
            "  multiple host adapters share the same IRQ Channel.",
            "*/",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\BusLogic.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\initio.c",
          "line": 52,
          "match": "deadlock",
          "context": [
            " *\t\t  spinlocks to serialize access to the pSRB_head and",
            " *\t\t  pSRB_tail members of the HCS structure.",
            " * 09/01/99 bv\t- v1.03d",
            " *\t\t- Fixed a deadlock problem in SMP.",
            " * 21/01/99 bv\t- v1.03e",
            " *\t\t- Add support for the Domex 3192U PCI SCSI",
            " *\t\t  This is a slightly modified patch by"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\initio.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\scsi_scan.c",
          "line": 1680,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Bail out if the device or its queue are not running. Otherwise,",
            "\t * the rescan may block waiting for commands to be executed, with us",
            "\t * holding the device lock. This can result in a potential deadlock",
            "\t * in the power management core code when system resume is on-going.",
            "\t */",
            "\tif (sdev->sdev_state != SDEV_RUNNING ||"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\scsi_scan.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\scsi_scan.c",
          "line": 1714,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Bail out if the device or its queue are not running. Otherwise,",
            "\t * the rescan may block waiting for commands to be executed, with us",
            "\t * holding the device lock. This can result in a potential deadlock",
            "\t * in the power management core code when system resume is on-going.",
            "\t */",
            "\tif (sdev->sdev_state != SDEV_RUNNING ||"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\scsi_scan.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\scsi_transport_spi.c",
          "line": 995,
          "match": "deadlock",
          "context": [
            " *\tPerforms the domain validation on the given device in the",
            " *\tcurrent execution thread.  Since DV operations may sleep,",
            " *\tthe current thread must have user context.  Also no SCSI",
            " *\trelated locks that would deadlock I/O issued by the DV may",
            " *\tbe held.",
            " */",
            "void"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\scsi_transport_spi.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\sd.c",
          "line": 678,
          "match": "deadlock",
          "context": [
            "};",
            "",
            "/*",
            " * Don't request a new module, as that could deadlock in multipath",
            " * environment.",
            " */",
            "static void sd_default_probe(dev_t devt)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\sd.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\sd.c",
          "line": 3809,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Query concurrent positioning ranges after",
            "\t * queue_limits_commit_update() unlocked q->limits_lock to avoid",
            "\t * deadlock with q->sysfs_dir_lock and q->sysfs_lock.",
            "\t */",
            "\tif (sdkp->media_present && scsi_device_supports_vpd(sdp))",
            "\t\tsd_read_cpr(sdkp);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\sd.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\sg.c",
          "line": 2059,
          "match": "deadlock",
          "context": [
            "\treq_schp->page_order = 0;",
            "\treq_schp->sglist_len = 0;",
            "\tsrp->res_used = 0;",
            "\t/* Called without mutex lock to avoid deadlock */",
            "\tsfp->res_in_use = 0;",
            "}",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\sg.c"
          ]
        },
        {
          "file": "linux\\drivers\\soundwire\\bus.c",
          "line": 81,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Give each bus_lock and msg_lock a unique key so that lockdep won't",
            "\t * trigger a deadlock warning when the locks of several buses are",
            "\t * grabbed during configuration of a multi-bus stream.",
            "\t */",
            "\tlockdep_register_key(&bus->msg_lock_key);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\soundwire\\bus.c"
          ]
        },
        {
          "file": "linux\\drivers\\soundwire\\stream.c",
          "line": 1255,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Add in order of bus id so that when taking the bus_lock",
            "\t * of multiple buses they will always be taken in the same",
            "\t * order to prevent a mutex deadlock.",
            "\t */",
            "\tinsert_after = &stream->master_list;",
            "\tlist_for_each_entry_reverse(walk_m_rt, &stream->master_list, stream_node) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\soundwire\\stream.c"
          ]
        },
        {
          "file": "linux\\drivers\\thunderbolt\\tb.c",
          "line": 2476,
          "match": "deadlock",
          "context": [
            "\t\t\t/*",
            "\t\t\t * Service drivers are unbound during",
            "\t\t\t * tb_xdomain_remove() so setting XDomain as",
            "\t\t\t * unplugged here prevents deadlock if they call",
            "\t\t\t * tb_xdomain_disable_paths(). We will tear down",
            "\t\t\t * all the tunnels below.",
            "\t\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\thunderbolt\\tb.c"
          ]
        },
        {
          "file": "linux\\drivers\\thunderbolt\\tb.c",
          "line": 3265,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Schedule cleanup of any unplugged devices. Run this in a",
            "\t * separate thread to avoid possible deadlock if the device",
            "\t * removal runtime resumes the unplugged device.",
            "\t */",
            "\tqueue_delayed_work(tb->wq, &tcm->remove_work, msecs_to_jiffies(50));"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\thunderbolt\\tb.c"
          ]
        },
        {
          "file": "linux\\drivers\\tty\\tty_io.c",
          "line": 3014,
          "match": "deadlock",
          "context": [
            " * via AF_UNIX socket, close it and later fetch from socket. FIXME.",
            " *",
            " * Nasty bug: do_SAK is being called in interrupt context.  This can",
            " * deadlock.  We punt it up to process context.  AKPM - 16Mar2001",
            " */",
            "void __do_SAK(struct tty_struct *tty)",
            "{"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\tty\\tty_io.c"
          ]
        },
        {
          "file": "linux\\drivers\\tty\\tty_ldisc.c",
          "line": 233,
          "match": "deadlock",
          "context": [
            " * descriptor, otherwise valid ldisc reference",
            " *",
            " * Note 1: Must not be called from an IRQ/timer context. The caller must also",
            " * be careful not to hold other locks that will deadlock against a discipline",
            " * change, such as an existing ldisc reference (which we check for).",
            " *",
            " * Note 2: a file_operations routine (read/poll/write) should use this function"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\tty\\tty_ldisc.c"
          ]
        },
        {
          "file": "linux\\drivers\\vhost\\vhost.c",
          "line": 599,
          "match": "deadlock",
          "context": [
            "\t} else {",
            "\t\t/* vDPA device does not use worker thead, so there's",
            "\t\t * no need to hold the address space for mm. This help",
            "\t\t * to avoid deadlock in the case of mmap() which may",
            "\t\t * held the refcnt of the file and depends on release",
            "\t\t * method to remove vma.",
            "\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\vhost\\vhost.c"
          ]
        },
        {
          "file": "linux\\drivers\\virtio\\virtio_mem.c",
          "line": 631,
          "match": "deadlock",
          "context": [
            "/*",
            " * Try adding memory to Linux. Will usually only fail if out of memory.",
            " *",
            " * Must not be called with the vm->hotplug_mutex held (possible deadlock with",
            " * onlining code).",
            " *",
            " * Will not modify the state of memory blocks in virtio-mem."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\virtio\\virtio_mem.c"
          ]
        },
        {
          "file": "linux\\drivers\\virtio\\virtio_mem.c",
          "line": 695,
          "match": "deadlock",
          "context": [
            " * Try removing memory from Linux. Will only fail if memory blocks aren't",
            " * offline.",
            " *",
            " * Must not be called with the vm->hotplug_mutex held (possible deadlock with",
            " * onlining code).",
            " *",
            " * Will not modify the state of memory blocks in virtio-mem."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\virtio\\virtio_mem.c"
          ]
        },
        {
          "file": "linux\\drivers\\virtio\\virtio_mem.c",
          "line": 735,
          "match": "deadlock",
          "context": [
            "/*",
            " * Try offlining and removing memory from Linux.",
            " *",
            " * Must not be called with the vm->hotplug_mutex held (possible deadlock with",
            " * onlining code).",
            " *",
            " * Will not modify the state of memory blocks in virtio-mem."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\virtio\\virtio_mem.c"
          ]
        },
        {
          "file": "linux\\drivers\\watchdog\\mei_wdt.c",
          "line": 448,
          "match": "deadlock",
          "context": [
            "",
            "\t/* Run the unregistration in a worker as this can be",
            "\t * run only after ping completion, otherwise the flow will",
            "\t * deadlock on watchdog core mutex.",
            "\t */",
            "\tif (wdt->state == MEI_WDT_RUNNING) {",
            "\t\tif (res.wdstate & MEI_WDT_WDSTATE_NOT_REQUIRED) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\watchdog\\mei_wdt.c"
          ]
        },
        {
          "file": "linux\\drivers\\watchdog\\sc520_wdt.c",
          "line": 18,
          "match": "deadlock",
          "context": [
            " *\tAdditional fixes Alan Cox",
            " *\t-\tFixed formatting",
            " *\t-\tRemoved debug printks",
            " *\t-\tFixed SMP built kernel deadlock",
            " *\t-\tSwitched to private locks not lock_kernel",
            " *\t-\tUsed ioremap/writew/readw",
            " *\t-\tAdded NOWAYOUT support"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\watchdog\\sc520_wdt.c"
          ]
        },
        {
          "file": "linux\\drivers\\xen\\balloon.c",
          "line": 320,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * add_memory_resource() will call online_pages() which in its turn",
            "\t * will call xen_online_page() callback causing deadlock if we don't",
            "\t * release balloon_mutex here. Unlocking here is safe because the",
            "\t * callers drop the mutex before trying again.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\xen\\balloon.c"
          ]
        },
        {
          "file": "linux\\drivers\\accel\\qaic\\qaic_drv.c",
          "line": 290,
          "match": "deadlock",
          "context": [
            "\t * Need to sync carefully with users calling close(). The",
            "\t * list of users can be modified elsewhere when the lock isn't",
            "\t * held here, but the sync'ing the srcu with the mutex held",
            "\t * could deadlock. Grab the mutex so that the list will be",
            "\t * unmodified. The user we get will exist as long as the",
            "\t * lock is held. Signal that the qcdev is going away, and",
            "\t * grab a reference to the user so they don't go away for"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\accel\\qaic\\qaic_drv.c"
          ]
        },
        {
          "file": "linux\\drivers\\accel\\qaic\\qaic_drv.c",
          "line": 295,
          "match": "deadlock",
          "context": [
            "\t * lock is held. Signal that the qcdev is going away, and",
            "\t * grab a reference to the user so they don't go away for",
            "\t * synchronize_srcu(). Then release the mutex to avoid",
            "\t * deadlock and make sure the user has observed the signal.",
            "\t * With the lock released, we cannot maintain any state of the",
            "\t * user list.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\accel\\qaic\\qaic_drv.c"
          ]
        },
        {
          "file": "linux\\drivers\\accel\\habanalabs\\common\\command_submission.c",
          "line": 979,
          "match": "deadlock",
          "context": [
            "\t\t * a point in which only part of the staged submission was",
            "\t\t * submitted and we don't have enough room in the 'cs_pending'",
            "\t\t * array for the rest of the submission.",
            "\t\t * This causes a deadlock because this CS will never be",
            "\t\t * completed as it depends on future CS's for completion.",
            "\t\t */",
            "\t\tif (other->cs_sequence == user_sequence)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\accel\\habanalabs\\common\\command_submission.c"
          ]
        },
        {
          "file": "linux\\drivers\\accel\\habanalabs\\common\\command_submission.c",
          "line": 984,
          "match": "deadlock",
          "context": [
            "\t\t */",
            "\t\tif (other->cs_sequence == user_sequence)",
            "\t\t\tdev_crit_ratelimited(hdev->dev,",
            "\t\t\t\t\"Staged CS %llu deadlock due to lack of resources\",",
            "\t\t\t\tuser_sequence);",
            "",
            "\t\tdev_dbg_ratelimited(hdev->dev,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\accel\\habanalabs\\common\\command_submission.c"
          ]
        },
        {
          "file": "linux\\drivers\\accel\\habanalabs\\common\\command_submission.c",
          "line": 1716,
          "match": "deadlock",
          "context": [
            "\t\t\t\t * while we want to do context-switch (-EBUSY),",
            "\t\t\t\t * we need to soft-reset because QMAN is",
            "\t\t\t\t * probably stuck. However, we can't call to",
            "\t\t\t\t * reset here directly because of deadlock, so",
            "\t\t\t\t * need to do it at the very end of this",
            "\t\t\t\t * function",
            "\t\t\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\accel\\habanalabs\\common\\command_submission.c"
          ]
        },
        {
          "file": "linux\\drivers\\acpi\\acpica\\dsmethod.c",
          "line": 333,
          "match": "deadlock",
          "context": [
            "\t\t/*",
            "\t\t * The current_sync_level (per-thread) must be less than or equal to",
            "\t\t * the sync level of the method. This mechanism provides some",
            "\t\t * deadlock prevention.",
            "\t\t *",
            "\t\t * If the method was auto-serialized, we just ignore the sync level",
            "\t\t * mechanism, because auto-serialization of methods can interfere"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\acpi\\acpica\\dsmethod.c"
          ]
        },
        {
          "file": "linux\\drivers\\acpi\\acpica\\exmutex.c",
          "line": 214,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Current sync level must be less than or equal to the sync level",
            "\t * of the mutex. This mechanism provides some deadlock prevention.",
            "\t */",
            "\tif (walk_state->thread->current_sync_level > obj_desc->mutex.sync_level) {",
            "\t\tACPI_ERROR((AE_INFO,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\acpi\\acpica\\exmutex.c"
          ]
        },
        {
          "file": "linux\\drivers\\acpi\\acpica\\utcache.c",
          "line": 264,
          "match": "deadlock",
          "context": [
            "\t\t}",
            "#endif",
            "",
            "\t\t/* Avoid deadlock with ACPI_ALLOCATE_ZEROED */",
            "",
            "\t\tstatus = acpi_ut_release_mutex(ACPI_MTX_CACHES);",
            "\t\tif (ACPI_FAILURE(status)) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\acpi\\acpica\\utcache.c"
          ]
        },
        {
          "file": "linux\\drivers\\acpi\\acpica\\utmutex.c",
          "line": 206,
          "match": "Deadlock",
          "context": [
            "\t\t/*",
            "\t\t * Mutex debug code, for internal debugging only.",
            "\t\t *",
            "\t\t * Deadlock prevention. Check if this thread owns any mutexes of value",
            "\t\t * greater than or equal to this one. If so, the thread has violated",
            "\t\t * the mutex ordering rule. This indicates a coding error somewhere in",
            "\t\t * the ACPI subsystem code."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\acpi\\acpica\\utmutex.c"
          ]
        },
        {
          "file": "linux\\drivers\\acpi\\acpica\\utmutex.c",
          "line": 229,
          "match": "DEADLOCK",
          "context": [
            "\t\t\t\t\t    acpi_ut_get_mutex_name(i),",
            "\t\t\t\t\t    acpi_ut_get_mutex_name(mutex_id)));",
            "",
            "\t\t\t\treturn (AE_ACQUIRE_DEADLOCK);",
            "\t\t\t}",
            "\t\t}",
            "\t}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\acpi\\acpica\\utmutex.c"
          ]
        },
        {
          "file": "linux\\drivers\\acpi\\acpica\\utmutex.c",
          "line": 301,
          "match": "Deadlock",
          "context": [
            "\t\t/*",
            "\t\t * Mutex debug code, for internal debugging only.",
            "\t\t *",
            "\t\t * Deadlock prevention. Check if this thread owns any mutexes of value",
            "\t\t * greater than this one. If so, the thread has violated the mutex",
            "\t\t * ordering rule. This indicates a coding error somewhere in",
            "\t\t * the ACPI subsystem code."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\acpi\\acpica\\utmutex.c"
          ]
        },
        {
          "file": "linux\\drivers\\acpi\\acpica\\utmutex.c",
          "line": 318,
          "match": "DEADLOCK",
          "context": [
            "\t\t\t\t\t    acpi_ut_get_mutex_name(i),",
            "\t\t\t\t\t    acpi_ut_get_mutex_name(mutex_id)));",
            "",
            "\t\t\t\treturn (AE_RELEASE_DEADLOCK);",
            "\t\t\t}",
            "\t\t}",
            "\t}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\acpi\\acpica\\utmutex.c"
          ]
        },
        {
          "file": "linux\\drivers\\base\\firmware_loader\\main.c",
          "line": 1657,
          "match": "deadlock",
          "context": [
            "{",
            "\t/*",
            "\t * Kill all pending fallback requests to avoid both stalling shutdown,",
            "\t * and avoid a deadlock with the usermode_lock.",
            "\t */",
            "\tkill_pending_fw_fallback_reqs(true);",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\base\\firmware_loader\\main.c"
          ]
        },
        {
          "file": "linux\\drivers\\base\\power\\runtime.c",
          "line": 201,
          "match": "deadlock",
          "context": [
            " * the flag for devices in the path whose siblings don't set the flag.",
            " *",
            " * The function should only be called by block device, or network",
            " * device driver for solving the deadlock problem during runtime",
            " * resume/suspend:",
            " *",
            " *     If memory allocation with GFP_KERNEL is called inside runtime"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\base\\power\\runtime.c"
          ]
        },
        {
          "file": "linux\\drivers\\base\\power\\runtime.c",
          "line": 206,
          "match": "deadlock",
          "context": [
            " *",
            " *     If memory allocation with GFP_KERNEL is called inside runtime",
            " *     resume/suspend callback of any one of its ancestors(or the",
            " *     block device itself), the deadlock may be triggered inside the",
            " *     memory allocation since it might not complete until the block",
            " *     device becomes active and the involed page I/O finishes. The",
            " *     situation is pointed out first by Alan Stern. Network device"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\base\\power\\runtime.c"
          ]
        },
        {
          "file": "linux\\drivers\\base\\power\\runtime.c",
          "line": 436,
          "match": "Deadlock",
          "context": [
            "\t\tunsigned int noio_flag;",
            "",
            "\t\t/*",
            "\t\t * Deadlock might be caused if memory allocation with",
            "\t\t * GFP_KERNEL happens inside runtime_suspend and",
            "\t\t * runtime_resume callbacks of one block device's",
            "\t\t * ancestor or the block device itself. Network"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\base\\power\\runtime.c"
          ]
        },
        {
          "file": "linux\\drivers\\block\\drbd\\drbd_bitmap.c",
          "line": 69,
          "match": "deadlock",
          "context": [
            " *",
            " *\tWe plan to reduce the amount of in-core bitmap pages by paging them in",
            " *\tand out against their on-disk location as necessary, but need to make",
            " *\tsure we don't cause too much meta data IO, and must not deadlock in",
            " *\ttight memory situations. This needs some more work.",
            " */",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\block\\drbd\\drbd_bitmap.c"
          ]
        },
        {
          "file": "linux\\drivers\\block\\drbd\\drbd_nl.c",
          "line": 887,
          "match": "deadlock",
          "context": [
            "\treturn buf;",
            "}",
            "",
            "/* there is still a theoretical deadlock when called from receiver",
            " * on an D_INCONSISTENT R_PRIMARY:",
            " *  remote READ does inc_ap_bio, receiver would need to receive answer",
            " *  packet from remote to dec_ap_bio again."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\block\\drbd\\drbd_nl.c"
          ]
        },
        {
          "file": "linux\\drivers\\block\\drbd\\drbd_nl.c",
          "line": 892,
          "match": "deadlock",
          "context": [
            " *  remote READ does inc_ap_bio, receiver would need to receive answer",
            " *  packet from remote to dec_ap_bio again.",
            " *  receiver receive_sizes(), comes here,",
            " *  waits for ap_bio_cnt == 0. -> deadlock.",
            " * but this cannot happen, actually, because:",
            " *  R_PRIMARY D_INCONSISTENT, and peer's disk is unreachable",
            " *  (not connected, or bad/no disk on peer):"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\block\\drbd\\drbd_nl.c"
          ]
        },
        {
          "file": "linux\\drivers\\block\\drbd\\drbd_receiver.c",
          "line": 256,
          "match": "deadlock",
          "context": [
            " * allocation (schedule_timeout) to give the system some room to breathe.",
            " *",
            " * We do not use max-buffers as hard limit, because it could lead to",
            " * congestion and further to a distributed deadlock during online-verify or",
            " * (checksum based) resync, if the max-buffers, socket buffer sizes and",
            " * resync-rate settings are mis-configured.",
            " *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\block\\drbd\\drbd_receiver.c"
          ]
        },
        {
          "file": "linux\\drivers\\block\\drbd\\drbd_receiver.c",
          "line": 313,
          "match": "deadlock",
          "context": [
            "\treturn page;",
            "}",
            "",
            "/* Must not be used from irq, as that may deadlock: see drbd_alloc_pages.",
            " * Is also used from inside an other spin_lock_irq(&resource->req_lock);",
            " * Either links the page chain back to the global pool,",
            " * or returns all pages to the system. */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\block\\drbd\\drbd_receiver.c"
          ]
        },
        {
          "file": "linux\\drivers\\block\\drbd\\drbd_receiver.c",
          "line": 1782,
          "match": "deadlock",
          "context": [
            "\t\t\treturn 0;",
            "",
            "\t\t/* receiver context, in the writeout path of the other node.",
            "\t\t * avoid potential distributed deadlock */",
            "\t\tepoch = kmalloc(sizeof(struct drbd_epoch), GFP_NOIO);",
            "\t\tif (epoch)",
            "\t\t\tbreak;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\block\\drbd\\drbd_receiver.c"
          ]
        },
        {
          "file": "linux\\drivers\\block\\drbd\\drbd_receiver.c",
          "line": 4885,
          "match": "deadlock",
          "context": [
            "\t\terr = drbd_send_bitmap(device, peer_device);",
            "\t\tif (err)",
            "\t\t\tgoto out;",
            "\t\t/* Omit CS_ORDERED with this state transition to avoid deadlocks. */",
            "\t\trv = _drbd_request_state(device, NS(conn, C_WF_SYNC_UUID), CS_VERBOSE);",
            "\t\tD_ASSERT(device, rv == SS_SUCCESS);",
            "\t} else if (device->state.conn != C_WF_BITMAP_S) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\block\\drbd\\drbd_receiver.c"
          ]
        },
        {
          "file": "linux\\drivers\\block\\drbd\\drbd_state.c",
          "line": 668,
          "match": "deadlock",
          "context": [
            " * We wrap it all into wait_event(), to retry in case the drbd_req_state()",
            " * returns SS_IN_TRANSIENT_STATE.",
            " *",
            " * To avoid potential deadlock with e.g. the receiver thread trying to grab",
            " * drbd_md_get_buffer() while trying to get out of the \"transient state\", we",
            " * need to grab and release the meta data buffer inside of that wait_event loop.",
            " */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\block\\drbd\\drbd_state.c"
          ]
        },
        {
          "file": "linux\\drivers\\block\\drbd\\drbd_worker.c",
          "line": 361,
          "match": "deadlock",
          "context": [
            "\t\tdrbd_csum_ee(peer_device->connection->csums_tfm, peer_req, digest);",
            "\t\t/* Free peer_req and pages before send.",
            "\t\t * In case we block on congestion, we could otherwise run into",
            "\t\t * some distributed deadlock, if the other side blocks on",
            "\t\t * congestion as well, because our receiver blocks in",
            "\t\t * drbd_alloc_pages due to pp_in_use > max_buffers. */",
            "\t\tdrbd_free_peer_req(device, peer_req);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\block\\drbd\\drbd_worker.c"
          ]
        },
        {
          "file": "linux\\drivers\\block\\drbd\\drbd_worker.c",
          "line": 572,
          "match": "deadlock",
          "context": [
            "",
            "\t/* Don't have more than \"max-buffers\"/2 in-flight.",
            "\t * Otherwise we may cause the remote site to stall on drbd_alloc_pages(),",
            "\t * potentially causing a distributed deadlock on congestion during",
            "\t * online-verify or (checksum-based) resync, if max-buffers,",
            "\t * socket buffer sizes and resync rate settings are mis-configured. */",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\block\\drbd\\drbd_worker.c"
          ]
        },
        {
          "file": "linux\\drivers\\block\\drbd\\drbd_worker.c",
          "line": 1260,
          "match": "deadlock",
          "context": [
            "",
            "\t/* Free e and pages before send.",
            "\t * In case we block on congestion, we could otherwise run into",
            "\t * some distributed deadlock, if the other side blocks on",
            "\t * congestion as well, because our receiver blocks in",
            "\t * drbd_alloc_pages due to pp_in_use > max_buffers. */",
            "\tdrbd_free_peer_req(device, peer_req);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\block\\drbd\\drbd_worker.c"
          ]
        },
        {
          "file": "linux\\drivers\\block\\drbd\\drbd_worker.c",
          "line": 1332,
          "match": "deadlock",
          "context": [
            "",
            "\t/* Free peer_req and pages before send.",
            "\t * In case we block on congestion, we could otherwise run into",
            "\t * some distributed deadlock, if the other side blocks on",
            "\t * congestion as well, because our receiver blocks in",
            "\t * drbd_alloc_pages due to pp_in_use > max_buffers. */",
            "\tdrbd_free_peer_req(device, peer_req);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\block\\drbd\\drbd_worker.c"
          ]
        },
        {
          "file": "linux\\drivers\\block\\rnbd\\rnbd-clt.c",
          "line": 663,
          "match": "deadlock",
          "context": [
            "\t * if something goes wrong (failing of outstanding requests",
            "\t * happens exactly from the context where we are blocking now).",
            "\t *",
            "\t * So to avoid deadlocks each usr message sent from here must",
            "\t * be asynchronous.",
            "\t */",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\block\\rnbd\\rnbd-clt.c"
          ]
        },
        {
          "file": "linux\\drivers\\block\\rnbd\\rnbd-clt.c",
          "line": 845,
          "match": "deadlock",
          "context": [
            "\tmutex_unlock(&sess_lock);",
            "\t/* loop in caller, see __find_and_get_sess().",
            "\t * You can't leave mutex locked and call schedule(), you will catch a",
            "\t * deadlock with a caller of free_sess(), which has just put the last",
            "\t * reference and is about to take the sess_lock in order to delete",
            "\t * the session from the list.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\block\\rnbd\\rnbd-clt.c"
          ]
        },
        {
          "file": "linux\\drivers\\block\\rnbd\\rnbd-clt.c",
          "line": 1659,
          "match": "deadlock",
          "context": [
            "\trnbd_clt_remove_dev_symlink(dev);",
            "\tif (dev->kobj.state_initialized) {",
            "\t\tif (sysfs_self)",
            "\t\t\t/* To avoid deadlock firstly remove itself */",
            "\t\t\tsysfs_remove_file_self(&dev->kobj, sysfs_self);",
            "\t\tkobject_del(&dev->kobj);",
            "\t\tkobject_put(&dev->kobj);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\block\\rnbd\\rnbd-clt.c"
          ]
        },
        {
          "file": "linux\\drivers\\block\\rnbd\\rnbd-srv.c",
          "line": 331,
          "match": "deadlock",
          "context": [
            "\t\treturn;",
            "",
            "\tsess_dev->keep_id = true;",
            "\t/* first remove sysfs itself to avoid deadlock */",
            "\tsysfs_remove_file_self(&sess_dev->kobj, &attr->attr);",
            "\trnbd_srv_destroy_dev_session_sysfs(sess_dev);",
            "\tmutex_unlock(&sess->lock);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\block\\rnbd\\rnbd-srv.c"
          ]
        },
        {
          "file": "linux\\drivers\\block\\zram\\zram_drv.c",
          "line": 1075,
          "match": "deadlock",
          "context": [
            "",
            "/*",
            " * Block layer want one ->submit_bio to be active at a time, so if we use",
            " * chained IO with parent IO in same context, it's a deadlock. To avoid that,",
            " * use a worker thread context.",
            " */",
            "static int read_from_bdev_sync(struct zram *zram, struct page *page,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\block\\zram\\zram_drv.c"
          ]
        },
        {
          "file": "linux\\drivers\\char\\ipmi\\ipmi_msghandler.c",
          "line": 954,
          "match": "deadlock",
          "context": [
            "\t} else if (oops_in_progress) {",
            "\t\t/*",
            "\t\t * If we are running in the panic context, calling the",
            "\t\t * receive handler doesn't much meaning and has a deadlock",
            "\t\t * risk.  At this moment, simply skip it in that case.",
            "\t\t */",
            "\t\tipmi_free_recv_msg(msg);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\char\\ipmi\\ipmi_msghandler.c"
          ]
        },
        {
          "file": "linux\\drivers\\char\\ipmi\\ipmi_msghandler.c",
          "line": 4808,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Start the next message if available.",
            "\t *",
            "\t * Do this here, not in the actual receiver, because we may deadlock",
            "\t * because the lower layer is allowed to hold locks while calling",
            "\t * message delivery.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\char\\ipmi\\ipmi_msghandler.c"
          ]
        },
        {
          "file": "linux\\drivers\\char\\ipmi\\ipmi_watchdog.c",
          "line": 565,
          "match": "deadlock",
          "context": [
            "\t\t * to restore the timer's info.  Note that we still hold",
            "\t\t * the heartbeat lock, to keep a heartbeat from happening",
            "\t\t * in this process, so must say no heartbeat to avoid a",
            "\t\t * deadlock on this mutex",
            "\t\t */",
            "\t\trv = _ipmi_set_timeout(IPMI_SET_TIMEOUT_NO_HB);",
            "\t\tif (rv) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\char\\ipmi\\ipmi_watchdog.c"
          ]
        },
        {
          "file": "linux\\drivers\\clk\\mediatek\\clk-mtk.c",
          "line": 503,
          "match": "deadlock",
          "context": [
            "\t\tdevm_pm_runtime_enable(&pdev->dev);",
            "\t\t/*",
            "\t\t * Do a pm_runtime_resume_and_get() to workaround a possible",
            "\t\t * deadlock between clk_register() and the genpd framework.",
            "\t\t */",
            "\t\tr = pm_runtime_resume_and_get(&pdev->dev);",
            "\t\tif (r)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\clk\\mediatek\\clk-mtk.c"
          ]
        },
        {
          "file": "linux\\drivers\\firmware\\arm_scmi\\raw_mode.c",
          "line": 1399,
          "match": "deadlock",
          "context": [
            "\t * msg_q.",
            "\t *",
            "\t * Note that nowhere else these locks are taken together, so no risk of",
            "\t * deadlocks du eto inversion.",
            "\t */",
            "\tspin_lock_irqsave(&q->msg_q_lock, flags);",
            "\trb = scmi_raw_buffer_get(q);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\firmware\\arm_scmi\\raw_mode.c"
          ]
        },
        {
          "file": "linux\\drivers\\firmware\\arm_scmi\\scmi_power_control.c",
          "line": 192,
          "match": "deadlock",
          "context": [
            "",
            "\tdev_dbg(sc->dev, \"Graceful request timed out...forcing !\\n\");",
            "\tmutex_lock(&sc->state_mtx);",
            "\t/* avoid deadlock by unregistering reboot notifier first */",
            "\tunregister_reboot_notifier(&sc->reboot_nb);",
            "\tif (sc->state == SCMI_SYSPOWER_IN_PROGRESS)",
            "\t\tscmi_request_forceful_transition(sc);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\firmware\\arm_scmi\\scmi_power_control.c"
          ]
        },
        {
          "file": "linux\\drivers\\firmware\\efi\\unaccepted_memory.c",
          "line": 137,
          "match": "deadlock",
          "context": [
            "",
            "\t\t/*",
            "\t\t * Keep interrupts disabled until the accept operation is",
            "\t\t * complete in order to prevent deadlocks.",
            "\t\t *",
            "\t\t * Enabling interrupts before calling arch_accept_memory()",
            "\t\t * creates an opportunity for an interrupt handler to request"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\firmware\\efi\\unaccepted_memory.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\drm_atomic.c",
          "line": 275,
          "match": "deadlock",
          "context": [
            " * drm_atomic_state_clear - clear state object",
            " * @state: atomic state",
            " *",
            " * When the w/w mutex algorithm detects a deadlock we need to back off and drop",
            " * all locks. So someone else could sneak in and change the current modeset",
            " * configuration. Which means that all the state assembled in @state is no",
            " * longer an atomic update to the current state, but to some arbitrary earlier"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\drm_atomic.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\drm_atomic.c",
          "line": 340,
          "match": "deadlock",
          "context": [
            " *",
            " * Returns:",
            " * Either the allocated state or the error code encoded into the pointer. When",
            " * the error is EDEADLK then the w/w mutex code has detected a deadlock and the",
            " * entire atomic sequence must be restarted. All other errors are fatal.",
            " */",
            "struct drm_crtc_state *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\drm_atomic.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\drm_atomic.c",
          "line": 520,
          "match": "deadlock",
          "context": [
            " *",
            " * Returns:",
            " * Either the allocated state or the error code encoded into the pointer. When",
            " * the error is EDEADLK then the w/w mutex code has detected a deadlock and the",
            " * entire atomic sequence must be restarted. All other errors are fatal.",
            " */",
            "struct drm_plane_state *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\drm_atomic.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\drm_atomic.c",
          "line": 1014,
          "match": "deadlock",
          "context": [
            " *",
            " * Returns:",
            " * The connector connected to @encoder, or an error pointer otherwise.",
            " * When the error is EDEADLK, a deadlock has been detected and the",
            " * sequence must be restarted.",
            " */",
            "struct drm_connector *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\drm_atomic.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\drm_atomic.c",
          "line": 1120,
          "match": "deadlock",
          "context": [
            " *",
            " * Returns:",
            " * Either the allocated state or the error code encoded into the pointer. When",
            " * the error is EDEADLK then the w/w mutex code has detected a deadlock and the",
            " * entire atomic sequence must be restarted. All other errors are fatal.",
            " */",
            "struct drm_connector_state *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\drm_atomic.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\drm_atomic.c",
          "line": 1229,
          "match": "deadlock",
          "context": [
            " *",
            " * Returns:",
            " * Either the allocated state or the error code encoded into the pointer. When",
            " * the error is EDEADLK then the w/w mutex code has detected a deadlock and the",
            " * entire atomic sequence must be restarted.",
            " */",
            "struct drm_bridge_state *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\drm_atomic.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\drm_atomic.c",
          "line": 1303,
          "match": "deadlock",
          "context": [
            " *",
            " * Returns:",
            " * 0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK",
            " * then the w/w mutex code has detected a deadlock and the entire atomic",
            " * sequence must be restarted. All other errors are fatal.",
            " */",
            "int"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\drm_atomic.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\drm_atomic.c",
          "line": 1348,
          "match": "deadlock",
          "context": [
            " *",
            " * Returns:",
            " * 0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK",
            " * then the w/w mutex code has detected a deadlock and the entire atomic",
            " * sequence must be restarted. All other errors are fatal.",
            " */",
            "int"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\drm_atomic.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\drm_atomic.c",
          "line": 1412,
          "match": "deadlock",
          "context": [
            " *",
            " * Returns:",
            " * 0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK",
            " * then the w/w mutex code has detected a deadlock and the entire atomic",
            " * sequence must be restarted. All other errors are fatal.",
            " */",
            "int"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\drm_atomic.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\drm_atomic.c",
          "line": 1445,
          "match": "deadlock",
          "context": [
            " * @state: atomic configuration to check",
            " *",
            " * Note that this function can return -EDEADLK if the driver needed to acquire",
            " * more locks but encountered a deadlock. The caller must then do the usual w/w",
            " * backoff dance and restart. All other errors are fatal.",
            " *",
            " * Returns:"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\drm_atomic.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\drm_atomic.c",
          "line": 1553,
          "match": "deadlock",
          "context": [
            " * @state: atomic configuration to check",
            " *",
            " * Note that this function can return -EDEADLK if the driver needed to acquire",
            " * more locks but encountered a deadlock. The caller must then do the usual w/w",
            " * backoff dance and restart. All other errors are fatal.",
            " *",
            " * This function will take its own reference on @state."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\drm_atomic.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\drm_atomic.c",
          "line": 1586,
          "match": "deadlock",
          "context": [
            " * @state: atomic configuration to check",
            " *",
            " * Note that this function can return -EDEADLK if the driver needed to acquire",
            " * more locks but encountered a deadlock. The caller must then do the usual w/w",
            " * backoff dance and restart. All other errors are fatal.",
            " *",
            " * This function will take its own reference on @state."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\drm_atomic.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\drm_atomic_uapi.c",
          "line": 184,
          "match": "deadlock",
          "context": [
            " *",
            " * Returns:",
            " * 0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK",
            " * then the w/w mutex code has detected a deadlock and the entire atomic",
            " * sequence must be restarted. All other errors are fatal.",
            " */",
            "int"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\drm_atomic_uapi.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\drm_atomic_uapi.c",
          "line": 270,
          "match": "deadlock",
          "context": [
            " *",
            " * Returns:",
            " * 0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK",
            " * then the w/w mutex code has detected a deadlock and the entire atomic",
            " * sequence must be restarted. All other errors are fatal.",
            " */",
            "int"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\drm_atomic_uapi.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\drm_bridge.c",
          "line": 156,
          "match": "deadlock",
          "context": [
            " *   and attach it.",
            " *",
            " * At this point, we're now certain that both the upstream driver and",
            " * the bridge driver are functional and we can't have a deadlock-like",
            " * situation when probing.",
            " */",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\drm_bridge.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\drm_exec.c",
          "line": 318,
          "match": "DEADLOCK",
          "context": [
            " * Prepares all GEM objects in an array, aborts on first error.",
            " * Reserves @num_fences on each GEM object after locking it.",
            " *",
            " * Returns: -EDEADLOCK on contention, -EALREADY when object is already locked,",
            " * -ENOMEM when memory allocation failed and zero for success.",
            " */",
            "int drm_exec_prepare_array(struct drm_exec *exec,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\drm_exec.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\drm_fb_helper.c",
          "line": 1846,
          "match": "deadlock",
          "context": [
            "\tinfo = fb_helper->info;",
            "\tinfo->var.pixclock = 0;",
            "",
            "\t/* Need to drop locks to avoid recursive deadlock in",
            "\t * register_framebuffer. This is ok because the only thing left to do is",
            "\t * register the fbdev emulation instance in kernel_fb_helper_list. */",
            "\tmutex_unlock(&fb_helper->lock);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\drm_fb_helper.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\drm_framebuffer.c",
          "line": 802,
          "match": "deadlock",
          "context": [
            "\t * avoid upsetting lockdep since the universal cursor code adds a",
            "\t * framebuffer while holding mutex locks.",
            "\t *",
            "\t * Note that a real deadlock between fpriv->fbs_lock and the modeset",
            "\t * locks is impossible here since no one else but this function can get",
            "\t * at it any more.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\drm_framebuffer.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\drm_modeset_lock.c",
          "line": 35,
          "match": "deadlock",
          "context": [
            " *",
            " * As KMS moves toward more fine grained locking, and atomic ioctl where",
            " * userspace can indirectly control locking order, it becomes necessary",
            " * to use &ww_mutex and acquire-contexts to avoid deadlocks.  But because",
            " * the locking is more distributed around the driver code, we want a bit",
            " * of extra utility/tracking out of our acquire-ctx.  This is provided",
            " * by &struct drm_modeset_lock and &struct drm_modeset_acquire_ctx."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\drm_modeset_lock.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\drm_modeset_lock.c",
          "line": 335,
          "match": "deadlock",
          "context": [
            "}",
            "",
            "/**",
            " * drm_modeset_backoff - deadlock avoidance backoff",
            " * @ctx: the acquire context",
            " *",
            " * If deadlock is detected (ie. drm_modeset_lock() returns -EDEADLK),"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\drm_modeset_lock.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\drm_modeset_lock.c",
          "line": 338,
          "match": "deadlock",
          "context": [
            " * drm_modeset_backoff - deadlock avoidance backoff",
            " * @ctx: the acquire context",
            " *",
            " * If deadlock is detected (ie. drm_modeset_lock() returns -EDEADLK),",
            " * you must call this function to drop all currently held locks and",
            " * block until the contended lock becomes available.",
            " *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\drm_modeset_lock.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\drm_modeset_lock.c",
          "line": 382,
          "match": "deadlock",
          "context": [
            " * If @ctx is not NULL, then its ww acquire context is used and the",
            " * lock will be tracked by the context and can be released by calling",
            " * drm_modeset_drop_locks().  If -EDEADLK is returned, this means a",
            " * deadlock scenario has been detected and it is an error to attempt",
            " * to take any more locks without first calling drm_modeset_backoff().",
            " *",
            " * If the @ctx is not NULL and initialized with"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\drm_modeset_lock.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\drm_mode_config.c",
          "line": 565,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Single-threaded teardown context, so it's not required to grab the",
            "\t * fb_lock to protect against concurrent fb_list access. Contrary, it",
            "\t * would actually deadlock with the drm_framebuffer_cleanup function.",
            "\t *",
            "\t * Also, if there are any framebuffers left, that's a driver leak now,",
            "\t * so politely WARN about this."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\drm_mode_config.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\drm_probe_helper.c",
          "line": 859,
          "match": "deadlock",
          "context": [
            " * Determine if %current task is an output poll worker.  This can be used",
            " * to select distinct code paths for output polling versus other contexts.",
            " *",
            " * One use case is to avoid a deadlock between the output poll worker and",
            " * the autosuspend worker wherein the latter waits for polling to finish",
            " * upon calling drm_kms_helper_poll_disable(), while the former waits for",
            " * runtime suspend to finish upon calling pm_runtime_get_sync() in a"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\drm_probe_helper.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\drm_syncobj.c",
          "line": 451,
          "match": "deadlock",
          "context": [
            "\t\treturn -ENOENT;",
            "",
            "\t/* Waiting for userspace with locks help is illegal cause that can",
            "\t * trivial deadlock with page faults for example. Make lockdep complain",
            "\t * about it early on.",
            "\t */",
            "\tif (flags & DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\drm_syncobj.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\ast\\ast_post.c",
          "line": 2037,
          "match": "deadlock",
          "context": [
            "\t\t * If \"Fast restet\" is enabled for ARM-ICE debugger,",
            "\t\t * then WDT needs to enable, that",
            "\t\t * WDT04 is WDT#1 Reload reg.",
            "\t\t * WDT08 is WDT#1 counter restart reg to avoid system deadlock",
            "\t\t * WDT0C is WDT#1 control reg",
            "\t\t *\t[6:5]:= 01:Full chip",
            "\t\t *\t[4]:= 1:1MHz clock source"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\ast\\ast_post.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\display\\drm_dp_mst_topology.c",
          "line": 3790,
          "match": "deadlock",
          "context": [
            " * drm_atomic_helper_resume()) this function should be called beforehand with",
            " * @sync set to true. In contexts like runtime resume where the driver is not",
            " * expected to be calling drm_atomic_helper_resume(), this function should be",
            " * called with @sync set to false in order to avoid deadlocking.",
            " *",
            " * Returns: -1 if the MST topology was removed while we were suspended, 0",
            " * otherwise."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\display\\drm_dp_mst_topology.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\i915_perf.c",
          "line": 3438,
          "match": "deadlock",
          "context": [
            "",
            "\t/* To ensure it's handled consistently we simply treat all reads of a",
            "\t * disabled stream as an error. In particular it might otherwise lead",
            "\t * to a deadlock for blocking file descriptors...",
            "\t */",
            "\tif (!stream->enabled || !(stream->sample_flags & SAMPLE_OA_REPORT))",
            "\t\treturn -EIO;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\i915_perf.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\intel_runtime_pm.c",
          "line": 183,
          "match": "deadlock",
          "context": [
            " * @rpm: the intel_runtime_pm structure",
            " *",
            " * This is the unlocked version of intel_display_power_is_enabled() and should",
            " * only be used from error capture and recovery code where deadlocks are",
            " * possible.",
            " * This function grabs a device-level runtime pm reference (mostly used for",
            " * asynchronous PM management from display code) and ensures that it is powered"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\intel_runtime_pm.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\msm\\msm_gem_submit.c",
          "line": 332,
          "match": "deadlock",
          "context": [
            "\t * the LRU lock for each individual bo, while (b) avoiding holding the",
            "\t * LRU lock while calling msm_gem_pin_vma_locked() (which could trigger",
            "\t * get_pages() which could trigger reclaim.. and if we held the LRU lock",
            "\t * could trigger deadlock with the shrinker).",
            "\t */",
            "\tmutex_lock(&priv->lru.lock);",
            "\tfor (i = 0; i < submit->nr_bos; i++) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\msm\\msm_gem_submit.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\msm\\msm_gem_vma.c",
          "line": 78,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * NOTE: iommu/io-pgtable can allocate pages, so we cannot hold",
            "\t * a lock across map/unmap which is also used in the job_run()",
            "\t * path, as this can cause deadlock in job_run() vs shrinker/",
            "\t * reclaim.",
            "\t *",
            "\t * Revisit this if we can come up with a scheme to pre-alloc pages"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\msm\\msm_gem_vma.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\nouveau\\nouveau_backlight.c",
          "line": 130,
          "match": "deadlock",
          "context": [
            "retry:",
            "\tret = drm_modeset_lock(&dev->mode_config.connection_mutex, &ctx);",
            "\tif (ret == -EDEADLK)",
            "\t\tgoto deadlock;",
            "\telse if (ret < 0)",
            "\t\tgoto out;",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\nouveau\\nouveau_backlight.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\nouveau\\nouveau_backlight.c",
          "line": 140,
          "match": "deadlock",
          "context": [
            "",
            "\tret = drm_modeset_lock(&crtc->mutex, &ctx);",
            "\tif (ret == -EDEADLK)",
            "\t\tgoto deadlock;",
            "\telse if (ret < 0)",
            "\t\tgoto out;",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\nouveau\\nouveau_backlight.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\nouveau\\nouveau_backlight.c",
          "line": 152,
          "match": "deadlock",
          "context": [
            "\tdrm_modeset_drop_locks(&ctx);",
            "\tdrm_modeset_acquire_fini(&ctx);",
            "\treturn ret;",
            "deadlock:",
            "\tdrm_modeset_backoff(&ctx);",
            "\tgoto retry;",
            "}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\nouveau\\nouveau_backlight.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\nouveau\\nouveau_backlight.c",
          "line": 173,
          "match": "deadlock",
          "context": [
            "retry:",
            "\tret = drm_modeset_lock(&dev->mode_config.connection_mutex, &ctx);",
            "\tif (ret == -EDEADLK)",
            "\t\tgoto deadlock;",
            "\telse if (ret < 0)",
            "\t\tgoto out;",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\nouveau\\nouveau_backlight.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\nouveau\\nouveau_backlight.c",
          "line": 183,
          "match": "deadlock",
          "context": [
            "",
            "\tret = drm_modeset_lock(&crtc->mutex, &ctx);",
            "\tif (ret == -EDEADLK)",
            "\t\tgoto deadlock;",
            "\telse if (ret < 0)",
            "\t\tgoto out;",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\nouveau\\nouveau_backlight.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\nouveau\\nouveau_backlight.c",
          "line": 194,
          "match": "deadlock",
          "context": [
            "\tdrm_modeset_drop_locks(&ctx);",
            "\tdrm_modeset_acquire_fini(&ctx);",
            "\treturn ret;",
            "deadlock:",
            "\tdrm_modeset_backoff(&ctx);",
            "\tgoto retry;",
            "}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\nouveau\\nouveau_backlight.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\nouveau\\nouveau_connector.c",
          "line": 575,
          "match": "deadlock",
          "context": [
            "\tenum drm_connector_status conn_status = connector_status_disconnected;",
            "",
            "\t/* Outputs are only polled while runtime active, so resuming the",
            "\t * device here is unnecessary (and would deadlock upon runtime suspend",
            "\t * because it waits for polling to finish). We do however, want to",
            "\t * prevent the autosuspend timer from elapsing during this operation",
            "\t * if possible."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\nouveau\\nouveau_connector.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\omapdrm\\omap_dmm_tiler.c",
          "line": 472,
          "match": "deadlock",
          "context": [
            "\t * Asynchronous fill does not work reliably, as the driver does not",
            "\t * handle errors in the async code paths. The fill operation may",
            "\t * silently fail, leading to leaking DMM engines, which may eventually",
            "\t * lead to deadlock if we run out of DMM engines.",
            "\t *",
            "\t * For now, always set 'wait' so that we only use sync fills. Async",
            "\t * fills should be fixed, or alternatively we could decide to only"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\omapdrm\\omap_dmm_tiler.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\panthor\\panthor_sched.c",
          "line": 682,
          "match": "deadlock",
          "context": [
            "\t/**",
            "\t * @release_work: Work used to release group resources.",
            "\t *",
            "\t * We need to postpone the group release to avoid a deadlock when",
            "\t * the last ref is released in the tick work.",
            "\t */",
            "\tstruct work_struct release_work;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\panthor\\panthor_sched.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\panthor\\panthor_sched.c",
          "line": 3882,
          "match": "deadlock",
          "context": [
            "\t */",
            "\tnum_groups = min_t(u32, MAX_CSGS, glb_iface->control->group_num);",
            "",
            "\t/* The FW-side scheduler might deadlock if two groups with the same",
            "\t * priority try to access a set of resources that overlaps, with part",
            "\t * of the resources being allocated to one group and the other part to",
            "\t * the other group, both groups waiting for the remaining resources to"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\panthor\\panthor_sched.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\radeon\\r300.c",
          "line": 325,
          "match": "DEADLOCK",
          "context": [
            "\t\t\t   (6 << R300_MS_Y5_SHIFT) |",
            "\t\t\t   (6 << R300_MSBD1_SHIFT)));",
            "\tradeon_ring_write(ring, PACKET0(R300_GA_ENHANCE, 0));",
            "\tradeon_ring_write(ring, R300_GA_DEADLOCK_CNTL | R300_GA_FASTSYNC_CNTL);",
            "\tradeon_ring_write(ring, PACKET0(R300_GA_POLY_MODE, 0));",
            "\tradeon_ring_write(ring,",
            "\t\t\t  R300_FRONT_PTYPE_TRIANGE | R300_BACK_PTYPE_TRIANGE);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\radeon\\r300.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\radeon\\r420.c",
          "line": 96,
          "match": "deadlock",
          "context": [
            "\tunsigned gb_pipe_select;",
            "\tunsigned num_pipes;",
            "",
            "\t/* GA_ENHANCE workaround TCL deadlock issue */",
            "\tWREG32(R300_GA_ENHANCE, R300_GA_DEADLOCK_CNTL | R300_GA_FASTSYNC_CNTL |",
            "\t       (1 << 2) | (1 << 3));",
            "\t/* add idle wait as per freedesktop.org bug 24041 */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\radeon\\r420.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\radeon\\r420.c",
          "line": 97,
          "match": "DEADLOCK",
          "context": [
            "\tunsigned num_pipes;",
            "",
            "\t/* GA_ENHANCE workaround TCL deadlock issue */",
            "\tWREG32(R300_GA_ENHANCE, R300_GA_DEADLOCK_CNTL | R300_GA_FASTSYNC_CNTL |",
            "\t       (1 << 2) | (1 << 3));",
            "\t/* add idle wait as per freedesktop.org bug 24041 */",
            "\tif (r100_gui_wait_for_idle(rdev)) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\radeon\\r420.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\radeon\\radeon_sync.c",
          "line": 136,
          "match": "deadlock",
          "context": [
            "\t\tif (!radeon_fence_need_sync(fence, ring))",
            "\t\t\tcontinue;",
            "",
            "\t\t/* prevent GPU deadlocks */",
            "\t\tif (!rdev->ring[i].ready) {",
            "\t\t\tdev_err(rdev->dev, \"Syncing to a disabled ring!\");",
            "\t\t\treturn -EINVAL;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\radeon\\radeon_sync.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\radeon\\rv515.c",
          "line": 109,
          "match": "DEADLOCK",
          "context": [
            "\t\t\t   (6 << MS_Y5_SHIFT) |",
            "\t\t\t   (6 << MSBD1_SHIFT)));",
            "\tradeon_ring_write(ring, PACKET0(GA_ENHANCE, 0));",
            "\tradeon_ring_write(ring, GA_DEADLOCK_CNTL | GA_FASTSYNC_CNTL);",
            "\tradeon_ring_write(ring, PACKET0(GA_POLY_MODE, 0));",
            "\tradeon_ring_write(ring, FRONT_PTYPE_TRIANGE | BACK_PTYPE_TRIANGE);",
            "\tradeon_ring_write(ring, PACKET0(GA_ROUND_MODE, 0));"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\radeon\\rv515.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\scheduler\\sched_main.c",
          "line": 717,
          "match": "deadlock",
          "context": [
            " *",
            " * This turned out to be not working very well. First of all there are many",
            " * problem with the dma_fence implementation and requirements. Either the",
            " * implementation is risking deadlocks with core memory management or violating",
            " * documented implementation details of the dma_fence object.",
            " *",
            " * Drivers can still save and restore their state for recovery operations, but"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\scheduler\\sched_main.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\ttm\\ttm_backup.c",
          "line": 81,
          "match": "deadlock",
          "context": [
            " *",
            " * Context: If called from reclaim context, the caller needs to",
            " * assert that the shrinker gfp has __GFP_FS set, to avoid",
            " * deadlocking on lock_page(). If @writeback is set to true and",
            " * called from reclaim context, the caller also needs to assert",
            " * that the shrinker gfp has __GFP_IO set, since without it,",
            " * we're not allowed to start backup IO."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\ttm\\ttm_backup.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\ttm\\ttm_execbuf_util.c",
          "line": 70,
          "match": "deadlock",
          "context": [
            " *",
            " * If a buffer is reserved for another validation, the validator with",
            " * the highest validation sequence backs off and waits for that buffer",
            " * to become unreserved. This prevents deadlocks when validating multiple",
            " * buffers in different orders.",
            " */",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\ttm\\ttm_execbuf_util.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\vmwgfx\\vmwgfx_binding.c",
          "line": 46,
          "match": "deadlock",
          "context": [
            " *",
            " * Note that a resource can be pointed to by bindings from multiple contexts,",
            " * Therefore we can't easily protect this data by a per context mutex",
            " * (unless we use deadlock-safe WW mutexes). So we use a global binding_mutex",
            " * to protect all binding manager data.",
            " *",
            " * Finally, any association between a context and a global resource"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\vmwgfx\\vmwgfx_binding.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\vmwgfx\\vmwgfx_cmdbuf.c",
          "line": 1267,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * For now, set the default size to VMW_CMDBUF_INLINE_SIZE to",
            "\t * prevent deadlocks from happening when vmw_cmdbuf_space_pool()",
            "\t * needs to wait for space and we block on further command",
            "\t * submissions to be able to free up space.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\vmwgfx\\vmwgfx_cmdbuf.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\vmwgfx\\vmwgfx_execbuf.c",
          "line": 574,
          "match": "deadlock",
          "context": [
            " * @sw_context: Pointer to the software context.",
            " *",
            " * Note that since vmware's command submission currently is protected by the",
            " * cmdbuf mutex, no fancy deadlock avoidance is required for resources, since",
            " * only a single thread at once will attempt this.",
            " */",
            "static int vmw_resources_reserve(struct vmw_sw_context *sw_context)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\vmwgfx\\vmwgfx_execbuf.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\vmwgfx\\vmwgfx_execbuf.c",
          "line": 4292,
          "match": "deadlock",
          "context": [
            "\tmutex_unlock(&dev_priv->cmdbuf_mutex);",
            "",
            "\t/*",
            "\t * Unreference resources outside of the cmdbuf_mutex to avoid deadlocks",
            "\t * in resource destruction paths.",
            "\t */",
            "\tvmw_validation_unref_lists(&val_ctx);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\vmwgfx\\vmwgfx_execbuf.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\vmwgfx\\vmwgfx_execbuf.c",
          "line": 4317,
          "match": "deadlock",
          "context": [
            "\tmutex_unlock(&dev_priv->cmdbuf_mutex);",
            "",
            "\t/*",
            "\t * Unreference resources outside of the cmdbuf_mutex to avoid deadlocks",
            "\t * in resource destruction paths.",
            "\t */",
            "\tvmw_validation_unref_lists(&val_ctx);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\vmwgfx\\vmwgfx_execbuf.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\vmwgfx\\vmwgfx_kms.c",
          "line": 1192,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Docs says we should take the lock before calling this function",
            "\t * but since it destroys encoders and our destructor calls",
            "\t * drm_encoder_cleanup which takes the lock we deadlock.",
            "\t */",
            "\tdrm_mode_config_cleanup(&dev_priv->drm);",
            "\tif (dev_priv->active_display_unit == vmw_du_legacy)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\vmwgfx\\vmwgfx_kms.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\vmwgfx\\vmwgfx_validation.c",
          "line": 618,
          "match": "deadlock",
          "context": [
            " * @ctx: The validation context.",
            " *",
            " * The hash table used for duplicate finding is an expensive resource and",
            " * may be protected by mutexes that may cause deadlocks during resource",
            " * unreferencing if held. After resource- and buffer object registering,",
            " * there is no longer any use for this hash table, so allow freeing it",
            " * either to shorten any mutex locking time, or before resources- and"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\vmwgfx\\vmwgfx_validation.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\xe\\xe_exec_queue.c",
          "line": 231,
          "match": "deadlock",
          "context": [
            " * Normalize bind exec queue creation. Bind exec queue is tied to migration VM",
            " * for access to physical memory required for page table programming. On a",
            " * faulting devices the reserved copy engine instance must be used to avoid",
            " * deadlocking (user binds cannot get stuck behind faults as kernel binds which",
            " * resolve faults depend on user binds). On non-faulting devices any copy engine",
            " * can be used.",
            " *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\xe\\xe_exec_queue.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\xe\\xe_guc_ct.c",
          "line": 55,
          "match": "DEADLOCK",
          "context": [
            "\tCT_DEAD_G2H_READ,\t\t\t/* 0x0020 */",
            "\tCT_DEAD_G2H_RECV,\t\t\t/* 0x0040 */",
            "\tCT_DEAD_G2H_RELEASE,\t\t\t/* 0x0080 */",
            "\tCT_DEAD_DEADLOCK,\t\t\t/* 0x0100 */",
            "\tCT_DEAD_PROCESS_FAILED,\t\t\t/* 0x0200 */",
            "\tCT_DEAD_FAST_G2H,\t\t\t/* 0x0400 */",
            "\tCT_DEAD_PARSE_G2H_RESPONSE,\t\t/* 0x0800 */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\xe\\xe_guc_ct.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\xe\\xe_guc_ct.c",
          "line": 913,
          "match": "DEADLOCK",
          "context": [
            "",
            "broken:",
            "\txe_gt_err(gt, \"No forward process on H2G, reset required\\n\");",
            "\tCT_DEAD(ct, &ct->ctbs.h2g, DEADLOCK);",
            "",
            "\treturn -EDEADLK;",
            "}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\xe\\xe_guc_ct.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\xe\\xe_guc_ct.c",
          "line": 1603,
          "match": "deadlock",
          "context": [
            "\t * here. If we ever need something stronger than get_if_ongoing() then",
            "\t * we need to be careful with blocking the pm callbacks from getting CT",
            "\t * responses, if the worker here is blocked on those callbacks",
            "\t * completing, creating a deadlock.",
            "\t */",
            "\tongoing = xe_pm_runtime_get_if_active(ct_to_xe(ct));",
            "\tif (!ongoing && xe_pm_read_callback_task(ct_to_xe(ct)) == NULL)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\xe\\xe_guc_ct.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\xe\\xe_migrate.c",
          "line": 364,
          "match": "deadlock",
          "context": [
            "}",
            "",
            "/*",
            " * Including the reserved copy engine is required to avoid deadlocks due to",
            " * migrate jobs servicing the faults gets stuck behind the job that faulted.",
            " */",
            "static u32 xe_migrate_usm_logical_mask(struct xe_gt *gt)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\xe\\xe_migrate.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\xe\\xe_pm.c",
          "line": 451,
          "match": "deadlock",
          "context": [
            "\t *                               |      lock(A)",
            "\t * xe_pm_runtime_get()           |",
            "\t *",
            "\t * This will clearly deadlock since rpm core needs to wait for",
            "\t * xe_pm_runtime_suspend() to complete, but here we are holding lock(A)",
            "\t * on CPU0 which prevents CPU1 making forward progress.  With the",
            "\t * annotation here and in xe_pm_runtime_get() lockdep will see"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\xe\\xe_pm.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\xe\\xe_pm.c",
          "line": 560,
          "match": "deadlock",
          "context": [
            "}",
            "",
            "/*",
            " * For places where resume is synchronous it can be quite easy to deadlock",
            " * if we are not careful. Also in practice it might be quite timing",
            " * sensitive to ever see the 0 -> 1 transition with the callers locks",
            " * held, so deadlocks might exist but are hard for lockdep to ever see."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\xe\\xe_pm.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\xe\\xe_pm.c",
          "line": 563,
          "match": "deadlock",
          "context": [
            " * For places where resume is synchronous it can be quite easy to deadlock",
            " * if we are not careful. Also in practice it might be quite timing",
            " * sensitive to ever see the 0 -> 1 transition with the callers locks",
            " * held, so deadlocks might exist but are hard for lockdep to ever see.",
            " * With this in mind, help lockdep learn about the potentially scary",
            " * stuff that can happen inside the runtime_resume callback by acquiring",
            " * a dummy lock (it doesn't protect anything and gets compiled out on"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\xe\\xe_pm.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\xe\\xe_vm.c",
          "line": 1644,
          "match": "deadlock",
          "context": [
            "\t * manipulated under the PXP mutex. However, the PXP mutex can be taken",
            "\t * under a user-VM lock when the PXP session is started at exec_queue",
            "\t * creation time. Those are different VMs and therefore there is no risk",
            "\t * of deadlock, but we need to tell lockdep that this is the case or it",
            "\t * will print a warning.",
            "\t */",
            "\tif (flags & XE_VM_FLAG_GSC) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\xe\\xe_vm.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\amdgpu_amdkfd_gpuvm.c",
          "line": 1106,
          "match": "deadlock",
          "context": [
            "}",
            "",
            "/* Reserving a BO and its page table BOs must happen atomically to",
            " * avoid deadlocks. Some operations update multiple VMs at once. Track",
            " * all the reservation info in a context structure. Optionally a sync",
            " * object can track VM updates.",
            " */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\amdgpu_amdkfd_gpuvm.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\amdgpu_device.c",
          "line": 5180,
          "match": "deadlock",
          "context": [
            "\t\t * Most of the connector probing functions try to acquire runtime pm",
            "\t\t * refs to ensure that the GPU is powered on when connector polling is",
            "\t\t * performed. Since we're calling this from a runtime PM callback,",
            "\t\t * trying to acquire rpm refs will cause us to deadlock.",
            "\t\t *",
            "\t\t * Since we're guaranteed to be holding the rpm lock, it's safe to",
            "\t\t * temporarily disable the rpm helpers so this doesn't deadlock us."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\amdgpu_device.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\amdgpu_device.c",
          "line": 5183,
          "match": "deadlock",
          "context": [
            "\t\t * trying to acquire rpm refs will cause us to deadlock.",
            "\t\t *",
            "\t\t * Since we're guaranteed to be holding the rpm lock, it's safe to",
            "\t\t * temporarily disable the rpm helpers so this doesn't deadlock us.",
            "\t\t */",
            "#ifdef CONFIG_PM",
            "\t\tdev->dev->power.disable_depth++;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\amdgpu_device.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\amdgpu_device.c",
          "line": 7229,
          "match": "deadlock",
          "context": [
            "",
            "\t\t/*",
            "\t\t * Wait for any gang to be assembled before switching to a",
            "\t\t * different owner or otherwise we could deadlock the",
            "\t\t * submissions.",
            "\t\t */",
            "\t\tif (!job->gang_submit) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\amdgpu_device.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\amdgpu_ttm.c",
          "line": 1435,
          "match": "deadlock",
          "context": [
            "\t * driver (pages, VRAM, GART space). They point to resources",
            "\t * owned by someone else (e.g. pageable memory in user mode",
            "\t * or a DMABuf). They are used in a preemptible context so we",
            "\t * can guarantee no deadlocks and good QoS in case of MMU",
            "\t * notifiers or DMABuf move notifiers from the resource owner.",
            "\t */",
            "\tif (bo->resource->mem_type == AMDGPU_PL_PREEMPT)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\amdgpu_ttm.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\gfx_v11_0.c",
          "line": 5880,
          "match": "deadlock",
          "context": [
            "\tu32 control = INDIRECT_BUFFER_VALID | ib->length_dw | (vmid << 24);",
            "",
            "\t/* Currently, there is a high possibility to get wave ID mismatch",
            "\t * between ME and GDS, leading to a hw deadlock, because ME generates",
            "\t * different wave IDs than the GDS expects. This situation happens",
            "\t * randomly when at least 5 compute pipes use GDS ordered append.",
            "\t * The wave IDs generated by ME are also wrong after suspend/resume."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\gfx_v11_0.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\gfx_v10_0.c",
          "line": 8685,
          "match": "deadlock",
          "context": [
            "\tu32 control = INDIRECT_BUFFER_VALID | ib->length_dw | (vmid << 24);",
            "",
            "\t/* Currently, there is a high possibility to get wave ID mismatch",
            "\t * between ME and GDS, leading to a hw deadlock, because ME generates",
            "\t * different wave IDs than the GDS expects. This situation happens",
            "\t * randomly when at least 5 compute pipes use GDS ordered append.",
            "\t * The wave IDs generated by ME are also wrong after suspend/resume."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\gfx_v10_0.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\gfx_v8_0.c",
          "line": 6079,
          "match": "deadlock",
          "context": [
            "\tu32 control = INDIRECT_BUFFER_VALID | ib->length_dw | (vmid << 24);",
            "",
            "\t/* Currently, there is a high possibility to get wave ID mismatch",
            "\t * between ME and GDS, leading to a hw deadlock, because ME generates",
            "\t * different wave IDs than the GDS expects. This situation happens",
            "\t * randomly when at least 5 compute pipes use GDS ordered append.",
            "\t * The wave IDs generated by ME are also wrong after suspend/resume."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\gfx_v8_0.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\gfx_v7_0.c",
          "line": 2244,
          "match": "deadlock",
          "context": [
            "\tu32 control = INDIRECT_BUFFER_VALID | ib->length_dw | (vmid << 24);",
            "",
            "\t/* Currently, there is a high possibility to get wave ID mismatch",
            "\t * between ME and GDS, leading to a hw deadlock, because ME generates",
            "\t * different wave IDs than the GDS expects. This situation happens",
            "\t * randomly when at least 5 compute pipes use GDS ordered append.",
            "\t * The wave IDs generated by ME are also wrong after suspend/resume."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\gfx_v7_0.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\gfx_v9_0.c",
          "line": 5515,
          "match": "deadlock",
          "context": [
            "\tu32 control = INDIRECT_BUFFER_VALID | ib->length_dw | (vmid << 24);",
            "",
            "\t/* Currently, there is a high possibility to get wave ID mismatch",
            "\t * between ME and GDS, leading to a hw deadlock, because ME generates",
            "\t * different wave IDs than the GDS expects. This situation happens",
            "\t * randomly when at least 5 compute pipes use GDS ordered append.",
            "\t * The wave IDs generated by ME are also wrong after suspend/resume."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\gfx_v9_0.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\gfx_v9_4_3.c",
          "line": 2852,
          "match": "deadlock",
          "context": [
            "\tu32 control = INDIRECT_BUFFER_VALID | ib->length_dw | (vmid << 24);",
            "",
            "\t/* Currently, there is a high possibility to get wave ID mismatch",
            "\t * between ME and GDS, leading to a hw deadlock, because ME generates",
            "\t * different wave IDs than the GDS expects. This situation happens",
            "\t * randomly when at least 5 compute pipes use GDS ordered append.",
            "\t * The wave IDs generated by ME are also wrong after suspend/resume."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\gfx_v9_4_3.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdkfd\\kfd_process.c",
          "line": 1487,
          "match": "deadlock",
          "context": [
            "\t\t/* GFXv10 and later GPUs do not support shader preemption",
            "\t\t * during page faults. This can lead to poor QoS for queue",
            "\t\t * management and memory-manager-related preemptions or",
            "\t\t * even deadlocks.",
            "\t\t */",
            "\t\tif (KFD_GC_VERSION(dev) >= IP_VERSION(10, 1, 1))",
            "\t\t\treturn false;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdkfd\\kfd_process.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdkfd\\kfd_svm.c",
          "line": 1597,
          "match": "deadlock",
          "context": [
            " *",
            " * To prevent concurrent destruction or change of range attributes, the",
            " * svm_read_lock must be held. The caller must not hold the svm_write_lock",
            " * because that would block concurrent evictions and lead to deadlocks. To",
            " * serialize concurrent migrations or validations of the same range, the",
            " * prange->migrate_mutex must be held.",
            " *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdkfd\\kfd_svm.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\amdgpu_dm\\amdgpu_dm.c",
          "line": 12239,
          "match": "deadlock",
          "context": [
            "",
            "fail:",
            "\tif (ret == -EDEADLK)",
            "\t\tdrm_dbg_atomic(dev, \"Atomic check stopped to avoid deadlock.\\n\");",
            "\telse if (ret == -EINTR || ret == -EAGAIN || ret == -ERESTARTSYS)",
            "\t\tdrm_dbg_atomic(dev, \"Atomic check stopped due to signal.\\n\");",
            "\telse"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\amdgpu_dm\\amdgpu_dm.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_hotplug.c",
          "line": 696,
          "match": "deadlock",
          "context": [
            "\t * Our hotplug handler can grab modeset locks (by calling down into the",
            "\t * fb helpers). Hence it must not be run on our own dev-priv->wq work",
            "\t * queue for otherwise the flush_work in the pageflip code will",
            "\t * deadlock.",
            "\t */",
            "\tif (queue_dig)",
            "\t\tqueue_work(display->hotplug.dp_wq, &display->hotplug.dig_port_work);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\display\\intel_hotplug.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_pps.c",
          "line": 451,
          "match": "deadlock",
          "context": [
            "\t\treturn;",
            "",
            "\t/*",
            "\t * We can't grab pps_mutex here due to deadlock with power_domain",
            "\t * mutex when power_domain functions are called while holding pps_mutex.",
            "\t * That also means that in order to use vlv_pps_pipe the code needs to",
            "\t * hold both a power domain reference and pps_mutex, and the power domain"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\display\\intel_pps.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\gem\\i915_gem_execbuffer.c",
          "line": 185,
          "match": "deadlock",
          "context": [
            " * the object. Simple! ... The relocation entries are stored in user memory",
            " * and so to access them we have to copy them into a local buffer. That copy",
            " * has to avoid taking any pagefaults as they may lead back to a GEM object",
            " * requiring the struct_mutex (i.e. recursive deadlock). So once again we split",
            " * the relocation into multiple passes. First we try to do everything within an",
            " * atomic context (avoid the pagefaults) which requires that we never wait. If",
            " * we detect that we may wait, or if we need to fault, then we have to fallback"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\gem\\i915_gem_execbuffer.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\gem\\i915_gem_execbuffer.c",
          "line": 766,
          "match": "deadlock",
          "context": [
            "\t * progress (perhaps we are fighting the shrinker?). When evicting the",
            "\t * VM this time around, anything that we can't lock we now track using",
            "\t * the busy_bo, using the full lock (after dropping the vm->mutex to",
            "\t * prevent deadlocks), instead of trylock. We then continue to evict the",
            "\t * VM, this time with the stubborn object locked, which we can now",
            "\t * hopefully unbind (if still bound in the VM). Repeat until the VM is",
            "\t * evicted. Finally we should be able bind everything."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\gem\\i915_gem_execbuffer.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\gem\\i915_gem_object.c",
          "line": 746,
          "match": "deadlock",
          "context": [
            " * available.",
            " *",
            " * Return: 0 on success. Negative error code on failure. In particular may",
            " * return -ENXIO on lack of region space, -EDEADLK for deadlock avoidance",
            " * if @ww is set, -EINTR or -ERESTARTSYS if signal pending, and",
            " * -EBUSY if the object is pinned.",
            " */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\gem\\i915_gem_object.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\gem\\i915_gem_object.c",
          "line": 780,
          "match": "deadlock",
          "context": [
            " * available.",
            " *",
            " * Return: 0 on success. Negative error code on failure. In particular may",
            " * return -ENXIO on lack of region space, -EDEADLK for deadlock avoidance",
            " * if @ww is set, -EINTR or -ERESTARTSYS if signal pending, and",
            " * -EBUSY if the object is pinned.",
            " */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\gem\\i915_gem_object.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\gem\\i915_gem_pages.c",
          "line": 290,
          "match": "deadlock",
          "context": [
            "\t\t * As these are finite, map_new_virtual() must wait for some",
            "\t\t * other kmap() to finish when it runs out. If we map a large",
            "\t\t * number of objects, there is no method for it to tell us",
            "\t\t * to release the mappings, and we deadlock.",
            "\t\t *",
            "\t\t * However, if we make an explicit vmap of the page, that",
            "\t\t * uses a larger vmalloc arena, and also has the ability"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\gem\\i915_gem_pages.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\gem\\i915_gem_shrinker.c",
          "line": 92,
          "match": "deadlock",
          "context": [
            " * free system memory - the pages might still be in-used to due to other reasons",
            " * (like cpu mmaps) or the mm core has reused them before we could grab them.",
            " * Therefore code that needs to explicitly shrink buffer objects caches (e.g. to",
            " * avoid deadlocks in memory reclaim) must fall back to i915_gem_shrink_all().",
            " *",
            " * Also note that any kind of pinning (both per-vma address space pins and",
            " * backing storage pins at the buffer object level) result in the shrinker code"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\gem\\i915_gem_shrinker.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\gem\\i915_gem_userptr.c",
          "line": 193,
          "match": "deadlock",
          "context": [
            "\t\t\t * migrate_folio, that is alreadying holding the lock",
            "\t\t\t * on the folio. Such a try_to_unmap() will result",
            "\t\t\t * in us calling put_pages() and so recursively try",
            "\t\t\t * to lock the page. We avoid that deadlock with",
            "\t\t\t * a trylock_page() and in exchange we risk missing",
            "\t\t\t * some page dirtying.",
            "\t\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\gem\\i915_gem_userptr.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\gem\\selftests\\i915_gem_migrate.c",
          "line": 407,
          "match": "deadlock",
          "context": [
            "\t\t * Use MI_NOOP, making the spinner non-preemptible. If there",
            "\t\t * is a code path where we fail async operation due to the",
            "\t\t * running spinner, we will block and fail to end the",
            "\t\t * spinner resulting in a deadlock. But with a non-",
            "\t\t * preemptible spinner, hangcheck will terminate the spinner",
            "\t\t * for us, and we will later detect that and fail the test.",
            "\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\gem\\selftests\\i915_gem_migrate.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\gem\\selftests\\i915_gem_migrate.c",
          "line": 444,
          "match": "deadlock",
          "context": [
            "/*",
            " * Setting ASYNC_FAIL_ALLOC to 2 will simulate memory allocation failure while",
            " * arming the migration error check and block async migration. This",
            " * will cause us to deadlock and hangcheck will terminate the spinner",
            " * causing the test to fail.",
            " */",
            "#define ASYNC_FAIL_ALLOC 1"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\gem\\selftests\\i915_gem_migrate.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_ct.c",
          "line": 21,
          "match": "DEADLOCK",
          "context": [
            "\tCT_DEAD_ALIVE = 0,",
            "\tCT_DEAD_SETUP,",
            "\tCT_DEAD_WRITE,",
            "\tCT_DEAD_DEADLOCK,",
            "\tCT_DEAD_H2G_HAS_ROOM,",
            "\tCT_DEAD_READ,",
            "\tCT_DEAD_PROCESS_FAILED,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_ct.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_ct.c",
          "line": 569,
          "match": "deadlock",
          "context": [
            "}",
            "",
            "#define GUC_CTB_TIMEOUT_MS\t1500",
            "static inline bool ct_deadlocked(struct intel_guc_ct *ct)",
            "{",
            "\tlong timeout = GUC_CTB_TIMEOUT_MS;",
            "\tbool ret = ktime_ms_delta(ktime_get(), ct->stall_time) > timeout;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_ct.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_ct.c",
          "line": 590,
          "match": "DEADLOCK",
          "context": [
            "\t\tCT_ERROR(ct, \"Head: %u\\n (Dwords)\", ct->ctbs.recv.desc->head);",
            "\t\tCT_ERROR(ct, \"Tail: %u\\n (Dwords)\", ct->ctbs.recv.desc->tail);",
            "",
            "\t\tCT_DEAD(ct, DEADLOCK);",
            "\t\tct->ctbs.send.broken = true;",
            "\t}",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_ct.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_ct.c",
          "line": 664,
          "match": "deadlock",
          "context": [
            "\t\tif (!g2h)",
            "\t\t\ttasklet_hi_schedule(&ct->receive_tasklet);",
            "",
            "\t\tif (unlikely(ct_deadlocked(ct)))",
            "\t\t\treturn -EPIPE;",
            "\t\telse",
            "\t\t\treturn -EBUSY;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_ct.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_ct.c",
          "line": 749,
          "match": "deadlock",
          "context": [
            "\t\t\tct->stall_time = ktime_get();",
            "\t\tspin_unlock_irqrestore(&ctb->lock, flags);",
            "",
            "\t\tif (unlikely(ct_deadlocked(ct)))",
            "\t\t\treturn -EPIPE;",
            "",
            "\t\tif (msleep_interruptible(sleep_period_ms))"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_ct.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_ct.c",
          "line": 1221,
          "match": "deadlock",
          "context": [
            "\tGEM_BUG_ON(FIELD_GET(GUC_HXG_MSG_0_TYPE, hxg[0]) != GUC_HXG_TYPE_EVENT);",
            "",
            "\t/*",
            "\t * Adjusting the space must be done in IRQ or deadlock can occur as the",
            "\t * CTB processing in the below workqueue can send CTBs which creates a",
            "\t * circular dependency if the space was returned there.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_ct.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_submission.c",
          "line": 1398,
          "match": "deadlock",
          "context": [
            "\t * hold the reset mutex. The busyness worker also attempts to acquire the",
            "\t * reset mutex. Synchronously flushing a worker thread requires acquiring",
            "\t * the worker mutex. Lockdep sees this as a conflict. It thinks that the",
            "\t * flush can deadlock because it holds the worker mutex while waiting for",
            "\t * the reset mutex, but another thread is holding the reset mutex and might",
            "\t * attempt to use other worker functions.",
            "\t *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_submission.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_submission.c",
          "line": 1537,
          "match": "deadlock",
          "context": [
            "\t * gt_park path cancels the worker synchronously and this complicates",
            "\t * the flow if the worker is also running at the same time. The cancel",
            "\t * waits for the worker and when the worker releases the wakeref, that",
            "\t * would call gt_park and would lead to a deadlock.",
            "\t *",
            "\t * The resolution is to take the global pm wakeref if runtime pm is",
            "\t * already active. If not, we don't need to update the busyness stats as"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_submission.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_submission.c",
          "line": 1565,
          "match": "deadlock",
          "context": [
            "\t * Synchronize with gt reset to make sure the worker does not",
            "\t * corrupt the engine/guc stats. NB: can't actually block waiting",
            "\t * for a reset to complete as the reset requires flushing out",
            "\t * this worker thread if started. So waiting would deadlock.",
            "\t */",
            "\tret = intel_gt_reset_trylock(gt, &srcu);",
            "\tif (ret)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\gt\\uc\\intel_guc_submission.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\msm\\adreno\\a6xx_preempt.c",
          "line": 182,
          "match": "deadlock",
          "context": [
            "\ttrace_msm_gpu_preemption_irq(a6xx_gpu->cur_ring->id);",
            "",
            "\t/*",
            "\t * Retrigger preemption to avoid a deadlock that might occur when preemption",
            "\t * is skipped due to it being already in flight when requested.",
            "\t */",
            "\ta6xx_preempt_trigger(gpu);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\msm\\adreno\\a6xx_preempt.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\nouveau\\dispnv50\\crc.c",
          "line": 591,
          "match": "deadlock",
          "context": [
            "\tif (IS_ERR(crtc_state)) {",
            "\t\tret = PTR_ERR(crtc_state);",
            "\t\tif (ret == -EDEADLK)",
            "\t\t\tgoto deadlock;",
            "\t\telse if (ret)",
            "\t\t\tgoto out_drop_locks;",
            "\t}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\nouveau\\dispnv50\\crc.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\nouveau\\dispnv50\\crc.c",
          "line": 601,
          "match": "deadlock",
          "context": [
            "",
            "\tret = drm_atomic_commit(state);",
            "\tif (ret == -EDEADLK)",
            "\t\tgoto deadlock;",
            "\telse if (ret)",
            "\t\tgoto out_drop_locks;",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\nouveau\\dispnv50\\crc.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\nouveau\\dispnv50\\crc.c",
          "line": 625,
          "match": "deadlock",
          "context": [
            "\tdrm_modeset_acquire_fini(&ctx);",
            "\treturn ret;",
            "",
            "deadlock:",
            "\tdrm_atomic_state_clear(state);",
            "\tdrm_modeset_backoff(&ctx);",
            "\tgoto retry;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\nouveau\\dispnv50\\crc.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\nouveau\\dispnv50\\disp.c",
          "line": 1470,
          "match": "deadlock",
          "context": [
            "",
            "\t/* Don't change the MST state of this connector until we've finished",
            "\t * resuming, since we can't safely grab hpd_irq_lock in our resume",
            "\t * path to protect mstm->is_mst without potentially deadlocking",
            "\t */",
            "\tmutex_lock(&outp->dp.hpd_irq_lock);",
            "\tmstm->suspended = true;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\nouveau\\dispnv50\\disp.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\nouveau\\nvkm\\subdev\\therm\\fan.c",
          "line": 81,
          "match": "deadlock",
          "context": [
            "\t}",
            "",
            "\t/* fan speed updated, drop the fan lock before grabbing the",
            "\t * alarm-scheduling lock and risking a deadlock",
            "\t */",
            "\tspin_unlock_irqrestore(&fan->lock, flags);",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\nouveau\\nvkm\\subdev\\therm\\fan.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\ttm\\tests\\ttm_bo_test.c",
          "line": 134,
          "match": "deadlock",
          "context": [
            "",
            "/*",
            " * A test case heavily inspired by ww_test_edeadlk_normal(). It injects",
            " * a deadlock by manipulating the sequence number of the context that holds",
            " * dma_resv lock of bo2 so the other context is \"wounded\" and has to back off",
            " * (indicated by -EDEADLK). The subtest checks if ttm_bo_reserve() properly",
            " * propagates that error."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\ttm\\tests\\ttm_bo_test.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\ttm\\tests\\ttm_bo_test.c",
          "line": 139,
          "match": "deadlock",
          "context": [
            " * (indicated by -EDEADLK). The subtest checks if ttm_bo_reserve() properly",
            " * propagates that error.",
            " */",
            "static void ttm_bo_reserve_deadlock(struct kunit *test)",
            "{",
            "\tstruct ttm_buffer_object *bo1, *bo2;",
            "\tstruct ww_acquire_ctx ctx1, ctx2;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\ttm\\tests\\ttm_bo_test.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\ttm\\tests\\ttm_bo_test.c",
          "line": 153,
          "match": "deadlock",
          "context": [
            "\tww_acquire_init(&ctx1, &reservation_ww_class);",
            "\tww_mutex_base_lock(&bo2->base.resv->lock.base);",
            "",
            "\t/* The deadlock will be caught by WW mutex, don't warn about it */",
            "\tlock_release(&bo2->base.resv->lock.base.dep_map, 1);",
            "",
            "\tbo2->base.resv->lock.ctx = &ctx2;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\ttm\\tests\\ttm_bo_test.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\ttm\\tests\\ttm_bo_test.c",
          "line": 615,
          "match": "deadlock",
          "context": [
            "#if IS_BUILTIN(CONFIG_DRM_TTM_KUNIT_TEST)",
            "\tKUNIT_CASE(ttm_bo_reserve_interrupted),",
            "#endif",
            "\tKUNIT_CASE(ttm_bo_reserve_deadlock),",
            "\tKUNIT_CASE(ttm_bo_unreserve_basic),",
            "\tKUNIT_CASE(ttm_bo_unreserve_pinned),",
            "\tKUNIT_CASE(ttm_bo_unreserve_bulk),"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\ttm\\tests\\ttm_bo_test.c"
          ]
        },
        {
          "file": "linux\\drivers\\hid\\bpf\\hid_bpf_dispatch.c",
          "line": 418,
          "match": "DEADLOCK",
          "context": [
            "\tctx_kern = container_of(ctx, struct hid_bpf_ctx_kern, ctx);",
            "",
            "\tif (ctx_kern->from_bpf)",
            "\t\treturn -EDEADLOCK;",
            "",
            "\t/* check arguments */",
            "\tret = __hid_bpf_hw_check_params(ctx, buf, &size, rtype);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hid\\bpf\\hid_bpf_dispatch.c"
          ]
        },
        {
          "file": "linux\\drivers\\hid\\bpf\\hid_bpf_dispatch.c",
          "line": 476,
          "match": "DEADLOCK",
          "context": [
            "",
            "\tctx_kern = container_of(ctx, struct hid_bpf_ctx_kern, ctx);",
            "\tif (ctx_kern->from_bpf)",
            "\t\treturn -EDEADLOCK;",
            "",
            "\t/* check arguments */",
            "\tret = __hid_bpf_hw_check_params(ctx, buf, &size, HID_OUTPUT_REPORT);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hid\\bpf\\hid_bpf_dispatch.c"
          ]
        },
        {
          "file": "linux\\drivers\\hid\\bpf\\hid_bpf_dispatch.c",
          "line": 502,
          "match": "DEADLOCK",
          "context": [
            "",
            "\tctx_kern = container_of(ctx, struct hid_bpf_ctx_kern, ctx);",
            "\tif (ctx_kern->from_bpf)",
            "\t\treturn -EDEADLOCK;",
            "",
            "\t/* check arguments */",
            "\tret = __hid_bpf_hw_check_params(ctx, buf, &size, type);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hid\\bpf\\hid_bpf_dispatch.c"
          ]
        },
        {
          "file": "linux\\drivers\\hid\\usbhid\\hid-core.c",
          "line": 565,
          "match": "deadlock",
          "context": [
            "\t\t\t */",
            "\t\t\tusb_block_urb(usbhid->urbout);",
            "",
            "\t\t\t/* Drop lock to avoid deadlock if the callback runs */",
            "\t\t\tspin_unlock(&usbhid->lock);",
            "",
            "\t\t\tusb_unlink_urb(usbhid->urbout);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hid\\usbhid\\hid-core.c"
          ]
        },
        {
          "file": "linux\\drivers\\hid\\usbhid\\hid-core.c",
          "line": 616,
          "match": "deadlock",
          "context": [
            "\t\t */",
            "\t\tusb_block_urb(usbhid->urbctrl);",
            "",
            "\t\t/* Drop lock to avoid deadlock if the callback runs */",
            "\t\tspin_unlock(&usbhid->lock);",
            "",
            "\t\tusb_unlink_urb(usbhid->urbctrl);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hid\\usbhid\\hid-core.c"
          ]
        },
        {
          "file": "linux\\drivers\\i2c\\busses\\i2c-omap.c",
          "line": 305,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Don't write to this register if the IE state is 0 as it can",
            "\t * cause deadlock.",
            "\t */",
            "\tif (omap->iestate)",
            "\t\tomap_i2c_write_reg(omap, OMAP_I2C_IE_REG, omap->iestate);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\i2c\\busses\\i2c-omap.c"
          ]
        },
        {
          "file": "linux\\drivers\\iio\\adc\\ad4695.c",
          "line": 872,
          "match": "deadlock",
          "context": [
            "\t * NB: technically, this is part the SPI offload trigger enable, but it",
            "\t * doesn't work to call it from the offload trigger enable callback",
            "\t * because it requires accessing the SPI bus. Calling it from the",
            "\t * trigger enable callback could cause a deadlock.",
            "\t */",
            "\tret = regmap_set_bits(st->regmap, AD4695_REG_GP_MODE,",
            "\t\t\t      AD4695_REG_GP_MODE_BUSY_GP_EN);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\iio\\adc\\ad4695.c"
          ]
        },
        {
          "file": "linux\\drivers\\infiniband\\core\\cm.c",
          "line": 3919,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * The CM worker thread may try to destroy the cm_id before it",
            "\t * can execute this work item.  To prevent potential deadlock,",
            "\t * we need to find the cm_id once we're in the context of the",
            "\t * worker thread, rather than holding a reference on it.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\infiniband\\core\\cm.c"
          ]
        },
        {
          "file": "linux\\drivers\\infiniband\\core\\iwcm.c",
          "line": 894,
          "match": "deadlock",
          "context": [
            "\tspin_lock_irqsave(&cm_id_priv->lock, flags);",
            "\t/*",
            "\t * Clear the connect wait bit so a callback function calling",
            "\t * iw_cm_disconnect will not wait and deadlock this thread",
            "\t */",
            "\tclear_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags);",
            "\tBUG_ON(cm_id_priv->state != IW_CM_STATE_CONN_SENT);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\infiniband\\core\\iwcm.c"
          ]
        },
        {
          "file": "linux\\drivers\\infiniband\\hw\\hfi1\\sdma.c",
          "line": 483,
          "match": "deadlock",
          "context": [
            "\t\t\tcontinue;",
            "\t\t/*",
            "\t\t * We must lock interrupts when acquiring sde->lock,",
            "\t\t * to avoid a deadlock if interrupt triggers and spins on",
            "\t\t * the same lock on same CPU",
            "\t\t */",
            "\t\tspin_lock_irqsave(&curr_sde->tail_lock, flags);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\infiniband\\hw\\hfi1\\sdma.c"
          ]
        },
        {
          "file": "linux\\drivers\\infiniband\\hw\\hfi1\\tid_rdma.c",
          "line": 603,
          "match": "deadlock",
          "context": [
            " * tid_rdma_schedule_tid_wakeup - schedule wakeup for a qp",
            " * @qp: the qp",
            " *",
            " * trigger a schedule or a waiting qp in a deadlock",
            " * safe manner.  The qp reference is held prior",
            " * to this call via first_qp().",
            " *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\infiniband\\hw\\hfi1\\tid_rdma.c"
          ]
        },
        {
          "file": "linux\\drivers\\infiniband\\hw\\qib\\qib_user_sdma.c",
          "line": 1073,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * We need this spin lock here because interrupt handler",
            "\t * might modify this list in qib_user_sdma_send_desc(), also",
            "\t * we can not get interrupted, otherwise it is a deadlock.",
            "\t */",
            "\tspin_lock_irqsave(&pq->sent_lock, flags);",
            "\tlist_for_each_entry_safe(pkt, pkt_prev, &pq->sent, list) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\infiniband\\hw\\qib\\qib_user_sdma.c"
          ]
        },
        {
          "file": "linux\\drivers\\infiniband\\hw\\usnic\\usnic_ib_verbs.c",
          "line": 349,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * usdev_lock is acquired after (and not before) ib_get_eth_speed call",
            "\t * because acquiring rtnl_lock in ib_get_eth_speed, while holding",
            "\t * usdev_lock could lead to a deadlock.",
            "\t */",
            "\tmutex_lock(&us_ibdev->usdev_lock);",
            "\t/* props being zeroed by the caller, avoid zeroing it here */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\infiniband\\hw\\usnic\\usnic_ib_verbs.c"
          ]
        },
        {
          "file": "linux\\drivers\\infiniband\\sw\\rxe\\rxe_pool.c",
          "line": 209,
          "match": "deadlock",
          "context": [
            "\t\t\t\t\tmsecs_to_jiffies(50000));",
            "",
            "\t\t\t/* Shouldn't happen. There are still references to",
            "\t\t\t * the object but, rather than deadlock, free the",
            "\t\t\t * object or pass back to rdma-core.",
            "\t\t\t */",
            "\t\t\tif (WARN_ON(!ret))"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\infiniband\\sw\\rxe\\rxe_pool.c"
          ]
        },
        {
          "file": "linux\\drivers\\infiniband\\ulp\\ipoib\\ipoib_main.c",
          "line": 2721,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * We create a global workqueue here that is used for all flush",
            "\t * operations.  However, if you attempt to flush a workqueue",
            "\t * from a task on that same workqueue, it deadlocks the system.",
            "\t * We want to be able to flush the tasks associated with a",
            "\t * specific net device, so we also create a workqueue for each",
            "\t * netdevice.  We queue up the tasks for that device only on"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\infiniband\\ulp\\ipoib\\ipoib_main.c"
          ]
        },
        {
          "file": "linux\\drivers\\infiniband\\ulp\\ipoib\\ipoib_main.c",
          "line": 2726,
          "match": "deadlock",
          "context": [
            "\t * specific net device, so we also create a workqueue for each",
            "\t * netdevice.  We queue up the tasks for that device only on",
            "\t * its private workqueue, and we only queue up flush events",
            "\t * on our global flush workqueue.  This avoids the deadlocks.",
            "\t */",
            "\tipoib_workqueue = alloc_ordered_workqueue(\"ipoib_flush\", 0);",
            "\tif (!ipoib_workqueue) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\infiniband\\ulp\\ipoib\\ipoib_main.c"
          ]
        },
        {
          "file": "linux\\drivers\\infiniband\\ulp\\ipoib\\ipoib_multicast.c",
          "line": 383,
          "match": "deadlock",
          "context": [
            "",
            "\t\t/*",
            "\t\t * Defer carrier on work to priv->wq to avoid a",
            "\t\t * deadlock on rtnl_lock here.  Requeue our multicast",
            "\t\t * work too, which will end up happening right after",
            "\t\t * our carrier on task work and will allow us to",
            "\t\t * send out all of the non-broadcast joins"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\infiniband\\ulp\\ipoib\\ipoib_multicast.c"
          ]
        },
        {
          "file": "linux\\drivers\\infiniband\\ulp\\ipoib\\ipoib_vlan.c",
          "line": 223,
          "match": "deadlock",
          "context": [
            "/*",
            " * sysfs callbacks of a netdevice cannot obtain the rtnl lock as",
            " * unregister_netdev ultimately deletes the sysfs files while holding the rtnl",
            " * lock. This deadlocks the system.",
            " *",
            " * A callback can use rtnl_trylock to avoid the deadlock but it cannot call",
            " * unregister_netdev as that internally takes and releases the rtnl_lock.  So"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\infiniband\\ulp\\ipoib\\ipoib_vlan.c"
          ]
        },
        {
          "file": "linux\\drivers\\infiniband\\ulp\\ipoib\\ipoib_vlan.c",
          "line": 225,
          "match": "deadlock",
          "context": [
            " * unregister_netdev ultimately deletes the sysfs files while holding the rtnl",
            " * lock. This deadlocks the system.",
            " *",
            " * A callback can use rtnl_trylock to avoid the deadlock but it cannot call",
            " * unregister_netdev as that internally takes and releases the rtnl_lock.  So",
            " * instead we find the netdev to unregister and then do the actual unregister",
            " * from the global work queue where we can obtain the rtnl_lock safely."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\infiniband\\ulp\\ipoib\\ipoib_vlan.c"
          ]
        },
        {
          "file": "linux\\drivers\\infiniband\\ulp\\rtrs\\rtrs-srv-sysfs.c",
          "line": 55,
          "match": "deadlock",
          "context": [
            "\t\t\tsizeof(str));",
            "",
            "\trtrs_info(s, \"disconnect for path %s requested\\n\", str);",
            "\t/* first remove sysfs itself to avoid deadlock */",
            "\tsysfs_remove_file_self(&srv_path->kobj, &attr->attr);",
            "\tclose_path(srv_path);",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\infiniband\\ulp\\rtrs\\rtrs-srv-sysfs.c"
          ]
        },
        {
          "file": "linux\\drivers\\input\\keyboard\\applespi.c",
          "line": 1539,
          "match": "deadlock",
          "context": [
            "\t\t/*",
            "\t\t * We don't actually know if this was a pure read, or a response",
            "\t\t * to a write. But this is a rare error condition that should",
            "\t\t * never occur, so clearing both flags to avoid deadlock.",
            "\t\t */",
            "\t\tapplespi_msg_complete(applespi, true, true);",
            "\t} else {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\input\\keyboard\\applespi.c"
          ]
        },
        {
          "file": "linux\\drivers\\input\\mouse\\psmouse-smbus.c",
          "line": 145,
          "match": "deadlock",
          "context": [
            "",
            "/*",
            " * This schedules removal of SMBus companion device. We have to do",
            " * it in a separate tread to avoid deadlocking on psmouse_mutex in",
            " * case the device has a trackstick (which is also driven by psmouse).",
            " *",
            " * Note that this may be racing with i2c adapter removal, but we"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\input\\mouse\\psmouse-smbus.c"
          ]
        },
        {
          "file": "linux\\drivers\\iommu\\intel\\iommu.c",
          "line": 4508,
          "match": "deadlock",
          "context": [
            "",
            "/* On Tylersburg chipsets, some BIOSes have been known to enable the",
            "   ISOCH DMAR unit for the Azalia sound device, but not give it any",
            "   TLB entries, which causes it to deadlock. Check for that.  We do",
            "   this in a function called from init_dmars(), instead of in a PCI",
            "   quirk, because we don't want to print the obnoxious \"BIOS broken\"",
            "   message if VT-d is actually disabled."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\iommu\\intel\\iommu.c"
          ]
        },
        {
          "file": "linux\\drivers\\iommu\\intel\\dmar.c",
          "line": 1456,
          "match": "deadlock",
          "context": [
            "\t\t * We will leave the interrupts disabled, to prevent interrupt",
            "\t\t * context to queue another cmd while a cmd is already submitted",
            "\t\t * and waiting for completion on this cpu. This is to avoid",
            "\t\t * a deadlock where the interrupt context can wait indefinitely",
            "\t\t * for free slots in the queue.",
            "\t\t */",
            "\t\trc = qi_check_fault(iommu, index, wait_index);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\iommu\\intel\\dmar.c"
          ]
        },
        {
          "file": "linux\\drivers\\iommu\\iommufd\\io_pagetable.c",
          "line": 747,
          "match": "DEADLOCK",
          "context": [
            "\t\t\t/* Something is not responding to unmap requests. */",
            "\t\t\ttries++;",
            "\t\t\tif (WARN_ON(tries > 100))",
            "\t\t\t\treturn -EDEADLOCK;",
            "\t\t\tgoto again;",
            "\t\t}",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\iommu\\iommufd\\io_pagetable.c"
          ]
        },
        {
          "file": "linux\\drivers\\iommu\\iommufd\\selftest.c",
          "line": 1529,
          "match": "DEADLOCK",
          "context": [
            "\t * the range is unpinned. This simple implementation puts a global lock",
            "\t * around the pin, which may not suit drivers that want this to be a",
            "\t * performance path. drivers that get this wrong will trigger WARN_ON",
            "\t * races and cause EDEADLOCK failures to userspace.",
            "\t */",
            "\tmutex_lock(&staccess->lock);",
            "\trc = iommufd_access_pin_pages(staccess->access, iova, length, pages,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\iommu\\iommufd\\selftest.c"
          ]
        },
        {
          "file": "linux\\drivers\\iommu\\arm\\arm-smmu\\arm-smmu-qcom-debug.c",
          "line": 74,
          "match": "deadlock",
          "context": [
            "\t\t\t\t      DEFAULT_RATELIMIT_BURST);",
            "",
            "\tif (__ratelimit(&rs)) {",
            "\t\tdev_err(smmu->dev, \"TLB sync timed out -- SMMU may be deadlocked\\n\");",
            "",
            "\t\tcfg = qsmmu->data->cfg;",
            "\t\tif (!cfg)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\iommu\\arm\\arm-smmu\\arm-smmu-qcom-debug.c"
          ]
        },
        {
          "file": "linux\\drivers\\iommu\\arm\\arm-smmu\\arm-smmu-nvidia.c",
          "line": 129,
          "match": "deadlock",
          "context": [
            "\t}",
            "",
            "\tdev_err_ratelimited(smmu->dev,",
            "\t\t\t    \"TLB sync timed out -- SMMU may be deadlocked\\n\");",
            "}",
            "",
            "static int nvidia_smmu_reset(struct arm_smmu_device *smmu)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\iommu\\arm\\arm-smmu\\arm-smmu-nvidia.c"
          ]
        },
        {
          "file": "linux\\drivers\\iommu\\arm\\arm-smmu\\arm-smmu.c",
          "line": 233,
          "match": "deadlock",
          "context": [
            "\t\tudelay(delay);",
            "\t}",
            "\tdev_err_ratelimited(smmu->dev,",
            "\t\t\t    \"TLB sync timed out -- SMMU may be deadlocked\\n\");",
            "}",
            "",
            "static void arm_smmu_tlb_sync_global(struct arm_smmu_device *smmu)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\iommu\\arm\\arm-smmu\\arm-smmu.c"
          ]
        },
        {
          "file": "linux\\drivers\\leds\\trigger\\ledtrig-netdev.c",
          "line": 274,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Take RTNL lock before trigger_data lock to prevent potential",
            "\t * deadlock with netdev notifier registration.",
            "\t */",
            "\trtnl_lock();",
            "\tmutex_lock(&trigger_data->lock);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\leds\\trigger\\ledtrig-netdev.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\bcache\\alloc.c",
          "line": 363,
          "match": "deadlock",
          "context": [
            "\t\tallocator_wait(ca, !atomic_read(&ca->set->prio_blocked));",
            "\t\tif (CACHE_SYNC(&ca->sb)) {",
            "\t\t\t/*",
            "\t\t\t * This could deadlock if an allocation with a btree",
            "\t\t\t * node locked ever blocked - having the btree node",
            "\t\t\t * locked would block garbage collection, but here we're",
            "\t\t\t * waiting on garbage collection before we invalidate"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\bcache\\alloc.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\bcache\\btree.c",
          "line": 907,
          "match": "deadlock",
          "context": [
            "",
            "/*",
            " * We can only have one thread cannibalizing other cached btree nodes at a time,",
            " * or we'll deadlock. We use an open coded mutex to ensure that, which a",
            " * cannibalize_bucket() will take. This means every time we unlock the root of",
            " * the btree, we need to release this lock if we have it held.",
            " */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\bcache\\btree.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\bcache\\journal.c",
          "line": 884,
          "match": "deadlock",
          "context": [
            "\t\t\t/*",
            "\t\t\t * XXX: If we were inserting so many keys that they",
            "\t\t\t * won't fit in an _empty_ journal write, we'll",
            "\t\t\t * deadlock. For now, handle this in",
            "\t\t\t * bch_keylist_realloc() - but something to think about.",
            "\t\t\t */",
            "\t\t\tBUG_ON(!w->data->keys);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\bcache\\journal.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\bcache\\super.c",
          "line": 1251,
          "match": "Deadlock",
          "context": [
            "\t}",
            "",
            "\t/*",
            "\t * Deadlocks since we're called via sysfs...",
            "\t * sysfs_remove_file(&dc->kobj, &sysfs_attach);",
            "\t */",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\bcache\\super.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\bcache\\super.c",
          "line": 2777,
          "match": "deadlock",
          "context": [
            "\t\t/*",
            "\t\t * The reason bch_register_lock is not held to call",
            "\t\t * bch_cache_set_stop() and bcache_device_stop() is to",
            "\t\t * avoid potential deadlock during reboot, because cache",
            "\t\t * set or bcache device stopping process will acquire",
            "\t\t * bch_register_lock too.",
            "\t\t *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\bcache\\super.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\dm-vdo\\dm-vdo-target.c",
          "line": 915,
          "match": "deadlock",
          "context": [
            "\t\treturn DM_MAPIO_SUBMITTED;",
            "\t}",
            "",
            "\t/* This could deadlock, */",
            "\tcurrent_work_queue = vdo_get_current_work_queue();",
            "\tBUG_ON((current_work_queue != NULL) &&",
            "\t       (vdo == vdo_get_work_queue_owner(current_work_queue)->vdo));"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\dm-vdo\\dm-vdo-target.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\dm-vdo\\slab-depot.c",
          "line": 3514,
          "match": "deadlock",
          "context": [
            "\tif (operation == VDO_ADMIN_STATE_LOADING_FOR_REBUILD) {",
            "\t\t/*",
            "\t\t * Must requeue because the kcopyd client cannot be freed in the same stack frame",
            "\t\t * as the kcopyd callback, lest it deadlock.",
            "\t\t */",
            "\t\tvdo_prepare_completion_for_requeue(&allocator->completion,",
            "\t\t\t\t\t\t   finish_loading_allocator,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\dm-vdo\\slab-depot.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\radio\\radio-si476x.c",
          "line": 1055,
          "match": "deadlock",
          "context": [
            "\t\t\tgoto power_down;",
            "",
            "\t\tsi476x_core_unlock(radio->core);",
            "\t\t/*Must be done after si476x_core_unlock to prevent a deadlock*/",
            "\t\tv4l2_ctrl_handler_setup(&radio->ctrl_handler);",
            "\t}",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\radio\\radio-si476x.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\rc\\imon.c",
          "line": 591,
          "match": "deadlock",
          "context": [
            "/*",
            " * Sends a packet to the device -- this function must be called with",
            " * ictx->lock held, or its unlock/lock sequence while waiting for tx",
            " * to complete can/will lead to a deadlock.",
            " */",
            "static int send_packet(struct imon_context *ictx)",
            "{"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\rc\\imon.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\tuners\\tda8290.c",
          "line": 279,
          "match": "deadlock",
          "context": [
            "\t\t}",
            "\t}",
            "",
            "\t/* l/ l' deadlock? */",
            "\tif(priv->tda8290_easy_mode & 0x60) {",
            "\t\ttuner_i2c_xfer_send_recv(&priv->i2c_props,",
            "\t\t\t\t\t &addr_adc_sat, 1,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\tuners\\tda8290.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\tuners\\tda8290.c",
          "line": 288,
          "match": "deadlock",
          "context": [
            "\t\t\t\t\t &addr_pll_stat, 1,",
            "\t\t\t\t\t &pll_stat, 1);",
            "\t\tif ((adc_sat > 20) || !(pll_stat & 0x80)) {",
            "\t\t\ttuner_dbg(\"trying to resolve SECAM L deadlock\\n\");",
            "\t\t\ttuner_i2c_xfer_send(&priv->i2c_props, agc_rst_on, 2);",
            "\t\t\tmsleep(40);",
            "\t\t\ttuner_i2c_xfer_send(&priv->i2c_props, agc_rst_off, 2);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\tuners\\tda8290.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\pci\\intel\\ipu-bridge.c",
          "line": 523,
          "match": "deadlock",
          "context": [
            "",
            "/*",
            " * The actual instantiation must be done from a workqueue to avoid",
            " * a deadlock on taking list_lock from v4l2-async twice.",
            " */",
            "struct ipu_bridge_instantiate_vcm_work_data {",
            "\tstruct work_struct work;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\pci\\intel\\ipu-bridge.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\pci\\saa7164\\saa7164-fw.c",
          "line": 386,
          "match": "deadlock",
          "context": [
            "\t\t\t\"%s() The firmware hung, probably bad firmware\\n\",",
            "\t\t\t__func__);",
            "",
            "\t\t/* Tell the second stage loader we have a deadlock */",
            "\t\tsaa7164_writel(SAA_DEVICE_DEADLOCK_DETECTED_OFFSET,",
            "\t\t\tSAA_DEVICE_DEADLOCK_DETECTED);",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\pci\\saa7164\\saa7164-fw.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\pci\\saa7164\\saa7164-fw.c",
          "line": 387,
          "match": "DEADLOCK",
          "context": [
            "\t\t\t__func__);",
            "",
            "\t\t/* Tell the second stage loader we have a deadlock */",
            "\t\tsaa7164_writel(SAA_DEVICE_DEADLOCK_DETECTED_OFFSET,",
            "\t\t\tSAA_DEVICE_DEADLOCK_DETECTED);",
            "",
            "\t\tsaa7164_getfirmwarestatus(dev);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\pci\\saa7164\\saa7164-fw.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\pci\\saa7164\\saa7164-fw.c",
          "line": 388,
          "match": "DEADLOCK",
          "context": [
            "",
            "\t\t/* Tell the second stage loader we have a deadlock */",
            "\t\tsaa7164_writel(SAA_DEVICE_DEADLOCK_DETECTED_OFFSET,",
            "\t\t\tSAA_DEVICE_DEADLOCK_DETECTED);",
            "",
            "\t\tsaa7164_getfirmwarestatus(dev);",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\pci\\saa7164\\saa7164-fw.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\platform\\marvell\\cafe-driver.c",
          "line": 533,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Set up I2C/SMBUS communications.  We have to drop the mutex here",
            "\t * because the sensor could attach in this call chain, leading to",
            "\t * unsightly deadlocks.",
            "\t */",
            "\tret = cafe_smbus_setup(cam);",
            "\tif (ret)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\platform\\marvell\\cafe-driver.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\platform\\chips-media\\coda\\coda-bit.c",
          "line": 2608,
          "match": "deadlock",
          "context": [
            "\tstruct vb2_v4l2_buffer *dst_buf;",
            "",
            "\t/*",
            "\t * For now this only handles the case where we would deadlock with",
            "\t * userspace, i.e. userspace issued DEC_CMD_STOP and waits for EOS,",
            "\t * but after a failed decode run we would hold the context and wait for",
            "\t * userspace to queue more buffers."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\platform\\chips-media\\coda\\coda-bit.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\platform\\mediatek\\vcodec\\encoder\\mtk_vcodec_enc.c",
          "line": 1131,
          "match": "deadlock",
          "context": [
            "/*",
            " * v4l2_m2m_streamoff() holds dev_mutex and waits mtk_venc_worker()",
            " * to call v4l2_m2m_job_finish().",
            " * If mtk_venc_worker() tries to acquire dev_mutex, it will deadlock.",
            " * So this function must not try to acquire dev->dev_mutex.",
            " * This means v4l2 ioctls and mtk_venc_worker() can run at the same time.",
            " * mtk_venc_worker() should be carefully implemented to avoid bugs."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\platform\\mediatek\\vcodec\\encoder\\mtk_vcodec_enc.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\rc\\img-ir\\img-ir-hw.c",
          "line": 556,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Release the lock to stop the end timer, since the end timer handler",
            "\t * acquires the lock and we don't want to deadlock waiting for it.",
            "\t */",
            "\tspin_unlock_irq(&priv->lock);",
            "\ttimer_delete_sync(&hw->end_timer);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\rc\\img-ir\\img-ir-hw.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\test-drivers\\vivid\\vivid-kthread-cap.c",
          "line": 441,
          "match": "deadlock",
          "context": [
            "\t\t * lock is already taken and there is no need to take the mutex.",
            "\t\t *",
            "\t\t * The problem with taking the mutex is that you can get",
            "\t\t * deadlocked if instance A locks instance B and vice versa.",
            "\t\t * It is not really worth trying to be very smart about this,",
            "\t\t * so just try to take the lock, and if you can't, then just",
            "\t\t * set out_dev to NULL and you will end up with a single frame"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\test-drivers\\vivid\\vivid-kthread-cap.c"
          ]
        },
        {
          "file": "linux\\drivers\\message\\fusion\\mptbase.c",
          "line": 379,
          "match": "deadlock",
          "context": [
            "\t\t/*",
            "\t\t * Call mptscsih_flush_pending_cmds callback so that we",
            "\t\t * flush all pending commands back to OS.",
            "\t\t * This call is required to aovid deadlock at block layer.",
            "\t\t * Dead IOC will fail to do diag reset,and this call is safe",
            "\t\t * since dead ioc will never return any command back from HW.",
            "\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\message\\fusion\\mptbase.c"
          ]
        },
        {
          "file": "linux\\drivers\\misc\\sgi-xp\\xpc_main.c",
          "line": 806,
          "match": "deadlock",
          "context": [
            "\t\t\t/*",
            "\t\t\t * NOTE: if (ignore_disconnecting &&",
            "\t\t\t * !(ch->flags & XPC_C_DISCONNECTINGCALLOUT)) is true,",
            "\t\t\t * then we'll deadlock if all other kthreads assigned",
            "\t\t\t * to this channel are blocked in the channel's",
            "\t\t\t * registerer, because the only thing that will unblock",
            "\t\t\t * them is the xpDisconnecting callout that this"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\misc\\sgi-xp\\xpc_main.c"
          ]
        },
        {
          "file": "linux\\drivers\\mmc\\core\\core.c",
          "line": 2347,
          "match": "deadlock",
          "context": [
            "\thost->pm_flags = 0;",
            "",
            "\tif (host->bus_ops) {",
            "\t\t/* Calling bus_ops->remove() with a claimed host can deadlock */",
            "\t\thost->bus_ops->remove(host);",
            "\t\tmmc_claim_host(host);",
            "\t\tmmc_detach_bus(host);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\mmc\\core\\core.c"
          ]
        },
        {
          "file": "linux\\drivers\\mmc\\host\\sdhci-uhs2.c",
          "line": 209,
          "match": "DEADLOCK",
          "context": [
            "\t}",
            "",
            "\tif (count >= 0xF) {",
            "\t\tDBG(\"%s: Too large timeout 0x%x requested for DEADLOCK!\\n\",",
            "\t\t    mmc_hostname(host->mmc), count);",
            "\t\tcount = 0xE;",
            "\t}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\mmc\\host\\sdhci-uhs2.c"
          ]
        },
        {
          "file": "linux\\drivers\\mmc\\host\\sdhci-uhs2.c",
          "line": 223,
          "match": "DEADLOCK",
          "context": [
            "\tu8 cmd_res, dead_lock;",
            "",
            "\tsdhci_calc_timeout_uhs2(host, &cmd_res, &dead_lock);",
            "\tcmd_res |= FIELD_PREP(SDHCI_UHS2_TIMER_CTRL_DEADLOCK_MASK, dead_lock);",
            "\tsdhci_writeb(host, cmd_res, SDHCI_UHS2_TIMER_CTRL);",
            "}",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\mmc\\host\\sdhci-uhs2.c"
          ]
        },
        {
          "file": "linux\\drivers\\mmc\\host\\sdhci-uhs2.c",
          "line": 266,
          "match": "DEADLOCK",
          "context": [
            "\tsdhci_calc_timeout_uhs2(host, &cmd_res, &dead_lock);",
            "",
            "\t/* change to use calculate value */",
            "\tcmd_res |= FIELD_PREP(SDHCI_UHS2_TIMER_CTRL_DEADLOCK_MASK, dead_lock);",
            "",
            "\tsdhci_uhs2_clear_set_irqs(host,",
            "\t\t\t\t  SDHCI_UHS2_INT_CMD_TIMEOUT |"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\mmc\\host\\sdhci-uhs2.c"
          ]
        },
        {
          "file": "linux\\drivers\\mmc\\host\\sdhci-uhs2.c",
          "line": 270,
          "match": "DEADLOCK",
          "context": [
            "",
            "\tsdhci_uhs2_clear_set_irqs(host,",
            "\t\t\t\t  SDHCI_UHS2_INT_CMD_TIMEOUT |",
            "\t\t\t\t  SDHCI_UHS2_INT_DEADLOCK_TIMEOUT,",
            "\t\t\t\t  0);",
            "\tsdhci_writeb(host, cmd_res, SDHCI_UHS2_TIMER_CTRL);",
            "\tsdhci_uhs2_clear_set_irqs(host, 0,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\mmc\\host\\sdhci-uhs2.c"
          ]
        },
        {
          "file": "linux\\drivers\\mmc\\host\\sdhci-uhs2.c",
          "line": 275,
          "match": "DEADLOCK",
          "context": [
            "\tsdhci_writeb(host, cmd_res, SDHCI_UHS2_TIMER_CTRL);",
            "\tsdhci_uhs2_clear_set_irqs(host, 0,",
            "\t\t\t\t  SDHCI_UHS2_INT_CMD_TIMEOUT |",
            "\t\t\t\t  SDHCI_UHS2_INT_DEADLOCK_TIMEOUT);",
            "",
            "\t/* UHS2 timing. Note, UHS2 timing is disabled when powering off */",
            "\tctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\mmc\\host\\sdhci-uhs2.c"
          ]
        },
        {
          "file": "linux\\drivers\\mmc\\host\\sdhci-uhs2.c",
          "line": 1024,
          "match": "DEADLOCK",
          "context": [
            "\t\t\treturn;",
            "\t\t}",
            "",
            "\t\tif (uhs2mask & SDHCI_UHS2_INT_DEADLOCK_TIMEOUT) {",
            "\t\t\tpr_err(\"%s: Got deadlock timeout interrupt 0x%08x\\n\",",
            "\t\t\t       mmc_hostname(host->mmc),",
            "\t\t\t       (unsigned int)uhs2mask);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\mmc\\host\\sdhci-uhs2.c"
          ]
        },
        {
          "file": "linux\\drivers\\mmc\\host\\sdhci-uhs2.c",
          "line": 1025,
          "match": "deadlock",
          "context": [
            "\t\t}",
            "",
            "\t\tif (uhs2mask & SDHCI_UHS2_INT_DEADLOCK_TIMEOUT) {",
            "\t\t\tpr_err(\"%s: Got deadlock timeout interrupt 0x%08x\\n\",",
            "\t\t\t       mmc_hostname(host->mmc),",
            "\t\t\t       (unsigned int)uhs2mask);",
            "\t\t\thost->data->error = -ETIMEDOUT;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\mmc\\host\\sdhci-uhs2.c"
          ]
        },
        {
          "file": "linux\\drivers\\mmc\\host\\wbsd.c",
          "line": 749,
          "match": "deadlock",
          "context": [
            "\tstruct mmc_command *cmd;",
            "",
            "\t/*",
            "\t * Disable bh works to avoid a deadlock.",
            "\t */",
            "\tspin_lock_bh(&host->lock);",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\mmc\\host\\wbsd.c"
          ]
        },
        {
          "file": "linux\\drivers\\mtd\\ubi\\eba.c",
          "line": 1350,
          "match": "deadlock",
          "context": [
            "\t * are moving it, so lock it.",
            "\t *",
            "\t * Note, we are using non-waiting locking here, because we cannot sleep",
            "\t * on the LEB, since it may cause deadlocks. Indeed, imagine a task is",
            "\t * unmapping the LEB which is mapped to the PEB we are going to move",
            "\t * (@from). This task locks the LEB and goes sleep in the",
            "\t * 'ubi_wl_put_peb()' function on the @ubi->move_mutex. In turn, we are"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\mtd\\ubi\\eba.c"
          ]
        },
        {
          "file": "linux\\drivers\\mtd\\nand\\raw\\nandsim.c",
          "line": 1549,
          "match": "deadlock",
          "context": [
            "\t\t * We allocate memory with GFP_NOFS because a flash FS may",
            "\t\t * utilize this. If it is holding an FS lock, then gets here,",
            "\t\t * then kernel memory alloc runs writeback which goes to the FS",
            "\t\t * again and deadlocks. This was seen in practice.",
            "\t\t */",
            "\t\tmypage->byte = kmem_cache_alloc(ns->nand_pages_slab, GFP_NOFS);",
            "\t\tif (mypage->byte == NULL) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\mtd\\nand\\raw\\nandsim.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\bonding\\bond_main.c",
          "line": 5601,
          "match": "deadlock",
          "context": [
            "\tstruct bonding *bond = netdev_priv(dev);",
            "\tnetdev_tx_t ret = NETDEV_TX_OK;",
            "",
            "\t/* If we risk deadlock from transmitting this in the",
            "\t * netpoll path, tell netpoll to queue the frame for later tx",
            "\t */",
            "\tif (unlikely(is_netpoll_tx_blocked(dev)))"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\bonding\\bond_main.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\hyperv\\netvsc.c",
          "line": 104,
          "match": "deadlock",
          "context": [
            "\tstruct rndis_device *rdev;",
            "\tint i, ret;",
            "",
            "\t/* Avoid deadlock with device removal already under RTNL */",
            "\tif (!rtnl_trylock()) {",
            "\t\tschedule_work(w);",
            "\t\treturn;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\hyperv\\netvsc.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\phy\\dp83tg720.c",
          "line": 536,
          "match": "deadlock",
          "context": [
            " * reliably detect or report a stable link state. To recover from such",
            " * scenarios, the PHY must be periodically reset when the link is down. However,",
            " * if the link partner also runs Linux with the same driver, synchronized reset",
            " * intervals can lead to a deadlock where the link never establishes due to",
            " * simultaneous resets on both sides.",
            " *",
            " * To avoid this, the function implements randomized polling intervals when the"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\phy\\dp83tg720.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\phy\\phy_device.c",
          "line": 351,
          "match": "deadlock",
          "context": [
            "\t/* We must stop the state machine manually, otherwise it stops out of",
            "\t * control, possibly with the phydev->lock held. Upon resume, netdev",
            "\t * may call phy routines that try to grab the same lock, and that may",
            "\t * lead to a deadlock.",
            "\t */",
            "\tif (phy_uses_state_machine(phydev))",
            "\t\tphy_stop_machine(phydev);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\phy\\phy_device.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ppp\\pppoe.c",
          "line": 924,
          "match": "deadlock",
          "context": [
            "\t * xmit operations conclude prior to an unregistration call.  Thus",
            "\t * sk->sk_state cannot change, so we don't need to do lock_sock().",
            "\t * But, we also can't do a lock_sock since that introduces a potential",
            "\t * deadlock as we'd reverse the lock ordering used when calling",
            "\t * ppp_unregister_channel().",
            "\t */",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ppp\\pppoe.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ppp\\ppp_generic.c",
          "line": 1333,
          "match": "deadlock",
          "context": [
            "",
            "\t/* rtnl_lock is already held here, but ppp_create_interface() locks",
            "\t * ppp_mutex before holding rtnl_lock. Using mutex_trylock() avoids",
            "\t * possible deadlock due to lock order inversion, at the cost of",
            "\t * pushing the problem back to userspace.",
            "\t */",
            "\tif (!mutex_trylock(&ppp_mutex)) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ppp\\ppp_generic.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\usb\\lan78xx.c",
          "line": 3554,
          "match": "deadlock",
          "context": [
            "",
            "\t/* deferred work (task, timer, softirq) must also stop.",
            "\t * can't flush_scheduled_work() until we drop rtnl (later),",
            "\t * else workers could deadlock; so make workers a NOP.",
            "\t */",
            "\tclear_bit(EVENT_TX_HALT, &dev->flags);",
            "\tclear_bit(EVENT_RX_HALT, &dev->flags);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\usb\\lan78xx.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\usb\\usbnet.c",
          "line": 2090,
          "match": "deadlock",
          "context": [
            "",
            "/*",
            " * The function can't be called inside suspend/resume callback,",
            " * otherwise deadlock will be caused.",
            " */",
            "int usbnet_read_cmd(struct usbnet *dev, u8 cmd, u8 reqtype,",
            "\t\t    u16 value, u16 index, void *data, u16 size)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\usb\\usbnet.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\usb\\usbnet.c",
          "line": 2108,
          "match": "deadlock",
          "context": [
            "",
            "/*",
            " * The function can't be called inside suspend/resume callback,",
            " * otherwise deadlock will be caused.",
            " */",
            "int usbnet_write_cmd(struct usbnet *dev, u8 cmd, u8 reqtype,",
            "\t\t     u16 value, u16 index, const void *data, u16 size)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\usb\\usbnet.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\vmxnet3\\vmxnet3_drv.c",
          "line": 3618,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * we must clear VMXNET3_STATE_BIT_RESETTING, otherwise",
            "\t * vmxnet3_close() will deadlock.",
            "\t */",
            "\tBUG_ON(test_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state));",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\vmxnet3\\vmxnet3_drv.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\vmxnet3\\vmxnet3_drv.c",
          "line": 3622,
          "match": "deadlock",
          "context": [
            "\t */",
            "\tBUG_ON(test_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state));",
            "",
            "\t/* we need to enable NAPI, otherwise dev_close will deadlock */",
            "\tfor (i = 0; i < adapter->num_rx_queues; i++)",
            "\t\tnapi_enable(&adapter->rx_queue[i].napi);",
            "\t/*"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\vmxnet3\\vmxnet3_drv.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wwan\\wwan_hwsim.c",
          "line": 373,
          "match": "deadlock",
          "context": [
            "{",
            "\tstruct wwan_hwsim_port *port = file->private_data;",
            "",
            "\t/* We can not delete port here since it will cause a deadlock due to",
            "\t * waiting this callback to finish in the debugfs_remove() call. So,",
            "\t * use workqueue.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wwan\\wwan_hwsim.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wwan\\wwan_hwsim.c",
          "line": 418,
          "match": "deadlock",
          "context": [
            "{",
            "\tstruct wwan_hwsim_dev *dev = file->private_data;",
            "",
            "\t/* We can not delete device here since it will cause a deadlock due to",
            "\t * waiting this callback to finish in the debugfs_remove() call. So,",
            "\t * use workqueue.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wwan\\wwan_hwsim.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\3com\\3c59x.c",
          "line": 2131,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * We can't allow a recursion from our interrupt handler back into the",
            "\t * tx routine, as they take the same spin lock, and that causes",
            "\t * deadlock.  Just return NETDEV_TX_BUSY and let the stack try again in",
            "\t * a bit",
            "\t */",
            "\tif (vp->handling_irq)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\3com\\3c59x.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\8390\\lib8390.c",
          "line": 170,
          "match": "deadlock",
          "context": [
            " *\t\tDisable the IRQ (but not mask locally- someone seems to have",
            " *\t\t\tbroken this with the lock validator stuff)",
            " *\t\t\t[This must be _nosync as the page lock may otherwise",
            " *\t\t\t\tdeadlock us]",
            " *\t\tDrop the page lock and turn IRQs back on",
            " *",
            " *\t\tAt this point an existing IRQ may still be running but we can't"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\8390\\lib8390.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\8390\\lib8390.c",
          "line": 186,
          "match": "deadlock",
          "context": [
            " *",
            " *",
            " *\tWe have to use disable_irq because otherwise you will get delayed",
            " *\tinterrupts on the APIC bus deadlocking the transmit path.",
            " *",
            " *\tQuite hairy but the chip simply wasn't designed for SMP and you can't",
            " *\teven ACK an interrupt without risking corrupting other parallel"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\8390\\lib8390.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\broadcom\\tg3.c",
          "line": 7991,
          "match": "deadlock",
          "context": [
            "\t/* We are running in BH disabled context with netif_tx_lock",
            "\t * and TX reclaim runs via tp->napi.poll inside of a software",
            "\t * interrupt.  Furthermore, IRQ processing runs lockless so we have",
            "\t * no IRQ context deadlocks to worry about either.  Rejoice!",
            "\t */",
            "\tif (unlikely(budget <= (skb_shinfo(skb)->nr_frags + 1))) {",
            "\t\tif (!netif_tx_queue_stopped(txq)) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\broadcom\\tg3.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\faraday\\ftgmac100.c",
          "line": 1589,
          "match": "deadlock",
          "context": [
            "\t/* Note about the reset task: We are called with the rtnl lock",
            "\t * held, so we are synchronized against the core of the reset",
            "\t * task. We must not try to synchronously cancel it otherwise",
            "\t * we can deadlock. But since it will test for netif_running()",
            "\t * which has already been cleared by the net core, we don't",
            "\t * anything special to do.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\faraday\\ftgmac100.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\freescale\\ucc_geth.c",
          "line": 1902,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Tell the kernel the link is down.",
            "\t * Must be done before disabling the controller",
            "\t * or deadlock may happen.",
            "\t */",
            "\tphylink_stop(ugeth->phylink);",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\freescale\\ucc_geth.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\natsemi\\ns83820.c",
          "line": 22,
          "match": "deadlock",
          "context": [
            " *\t20010713\t0.4 - zero copy, no hangs.",
            " *\t\t\t0.5 - 64 bit dma support (davem will hate me for this)",
            " *\t\t\t    - disable jumbo frames to avoid tx hangs",
            " *\t\t\t    - work around tx deadlocks on my 1.02 card via",
            " *\t\t\t      fiddling with TXCFG",
            " *\t20010810\t0.6 - use pci dma api for ringbuffers, work on ia64",
            " *\t20010816\t0.7 - misc cleanups"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\natsemi\\ns83820.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\sfc\\mcdi.c",
          "line": 1189,
          "match": "deadlock",
          "context": [
            "\t * efx_mcdi_ev_cpl()]",
            "\t *",
            "\t * If there is an outstanding asynchronous request, we can't",
            "\t * complete it now (efx_mcdi_complete() would deadlock).  The",
            "\t * reset process will take care of this.",
            "\t *",
            "\t * There's a race here with efx_mcdi_send_request(), because"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\sfc\\mcdi.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\smsc\\smc91x.c",
          "line": 218,
          "match": "deadlock",
          "context": [
            "",
            "/*",
            " * Wait while MMU is busy.  This is usually in the order of a few nanosecs",
            " * if at all, but let's avoid deadlocking the system if the hardware",
            " * decides to go south.",
            " */",
            "#define SMC_WAIT_MMU_BUSY(lp) do {\t\t\t\t\t\\"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\smsc\\smc91x.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\sun\\cassini.c",
          "line": 240,
          "match": "deadlock",
          "context": [
            "\t\tspin_lock_nested(&cp->tx_lock[i], i);",
            "}",
            "",
            "/* WTZ: QA was finding deadlock problems with the previous",
            " * versions after long test runs with multiple cards per machine.",
            " * See if replacing cas_lock_all with safer versions helps. The",
            " * symptoms QA is reporting match those we'd expect if interrupts"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\sun\\cassini.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\sun\\cassini.c",
          "line": 244,
          "match": "deadlock",
          "context": [
            " * versions after long test runs with multiple cards per machine.",
            " * See if replacing cas_lock_all with safer versions helps. The",
            " * symptoms QA is reporting match those we'd expect if interrupts",
            " * aren't being properly restored, and we fixed a previous deadlock",
            " * with similar symptoms by using save/restore versions in other",
            " * places.",
            " */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\sun\\cassini.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\sun\\sungem.c",
          "line": 2186,
          "match": "deadlock",
          "context": [
            "\ttimer_delete_sync(&gp->link_timer);",
            "",
            "\t/* We cannot cancel the reset task while holding the",
            "\t * rtnl lock, we'd get an A->B / B->A deadlock stituation",
            "\t * if we did. This is not an issue however as the reset",
            "\t * task is synchronized vs. us (rtnl_lock) and will do",
            "\t * nothing if the device is down or suspended. We do"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\sun\\sungem.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\sun\\sunhme.c",
          "line": 1489,
          "match": "deadlock",
          "context": [
            "\t\tregtmp |= BIGMAC_TXCFG_FULLDPLX;",
            "",
            "\t/* Don't turn on the \"don't give up\" bit for now.  It could cause hme",
            "\t * to deadlock with the PHY if a Jabber occurs.",
            "\t */",
            "\thme_write32(hp, bregs + BMAC_TXCFG, regtmp /*| BIGMAC_TXCFG_DGIVEUP*/);",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\sun\\sunhme.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\amazon\\ena\\ena_netdev.c",
          "line": 3543,
          "match": "deadlock",
          "context": [
            "/* For the rare case where the device runs out of Rx descriptors and the",
            " * napi handler failed to refill new Rx descriptors (due to a lack of memory",
            " * for example).",
            " * This case will lead to a deadlock:",
            " * The device won't send interrupts since all the new Rx packets will be dropped",
            " * The napi handler won't allocate new Rx descriptors so the device will be",
            " * able to send new packets."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\amazon\\ena\\ena_netdev.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\amd\\pds_core\\core.c",
          "line": 625,
          "match": "deadlock",
          "context": [
            "\tif (fw_status != PDS_RC_BAD_PCI)",
            "\t\treturn;",
            "",
            "\t/* prevent deadlock between pdsc_reset_prepare and pdsc_health_thread */",
            "\tqueue_work(pdsc->wq, &pdsc->pci_reset_work);",
            "}",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\amd\\pds_core\\core.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\chelsio\\cxgb\\tp.c",
          "line": 14,
          "match": "deadlock",
          "context": [
            "\tadapter_t *adapter;",
            "};",
            "",
            "/* Pause deadlock avoidance parameters */",
            "#define DROP_MSEC 16",
            "#define DROP_PKTS_CNT  1",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\chelsio\\cxgb\\tp.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\chelsio\\cxgb\\tp.c",
          "line": 42,
          "match": "deadlock",
          "context": [
            "\t       V_5TUPLE_LOOKUP(p->use_5tuple_mode) |",
            "\t       V_SYN_COOKIE_PARAMETER(29), ap->regs + A_TP_GLOBAL_CONFIG);",
            "\t/*",
            "\t * Enable pause frame deadlock prevention.",
            "\t */",
            "\tif (is_T2(ap) && ap->params.nports > 1) {",
            "\t\tu32 drop_ticks = DROP_MSEC * (tp_clk / 1000);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\chelsio\\cxgb\\tp.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\chelsio\\cxgb3\\cxgb3_main.c",
          "line": 142,
          "match": "deadlock",
          "context": [
            "/*",
            " * We have work elements that we need to cancel when an interface is taken",
            " * down.  Normally the work elements would be executed by keventd but that",
            " * can deadlock because of linkwatch.  If our close method takes the rtnl",
            " * lock and linkwatch is ahead of our work elements in keventd, linkwatch",
            " * will block keventd as it needs the rtnl lock, and we'll deadlock waiting",
            " * for our work to complete.  Get our own work queue to solve this."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\chelsio\\cxgb3\\cxgb3_main.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\chelsio\\cxgb3\\cxgb3_main.c",
          "line": 144,
          "match": "deadlock",
          "context": [
            " * down.  Normally the work elements would be executed by keventd but that",
            " * can deadlock because of linkwatch.  If our close method takes the rtnl",
            " * lock and linkwatch is ahead of our work elements in keventd, linkwatch",
            " * will block keventd as it needs the rtnl lock, and we'll deadlock waiting",
            " * for our work to complete.  Get our own work queue to solve this.",
            " */",
            "struct workqueue_struct *cxgb3_wq;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\chelsio\\cxgb3\\cxgb3_main.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\chelsio\\cxgb4vf\\cxgb4vf_main.c",
          "line": 2525,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Some environments do not properly handle PCIE FLRs -- e.g. in Linux",
            "\t * 2.6.31 and later we can't call pci_reset_function() in order to",
            "\t * issue an FLR because of a self- deadlock on the device semaphore.",
            "\t * Meanwhile, the OS infrastructure doesn't issue FLRs in all the",
            "\t * cases where they're needed -- for instance, some versions of KVM",
            "\t * fail to reset \"Assigned Devices\" when the VM reboots.  Therefore we"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\chelsio\\cxgb4vf\\cxgb4vf_main.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\chelsio\\cxgb4\\t4_hw.c",
          "line": 5959,
          "match": "deadlock",
          "context": [
            "\t\tif (tp->snap_len > ((10 * 1024 / 4) - (2 * 8)))",
            "\t\t\treturn -EINVAL;",
            "\t} else {",
            "\t\t/* If multiple tracers are disabled, to avoid deadlocks",
            "\t\t * maximum packet capture size of 9600 bytes is recommended.",
            "\t\t * Also in this mode, only trace0 can be enabled and running.",
            "\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\chelsio\\cxgb4\\t4_hw.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\freescale\\fs_enet\\fs_enet-main.c",
          "line": 597,
          "match": "deadlock",
          "context": [
            "\t * shortly after, it no longer makes sense to try to recover from the",
            "\t * timeout. netif_running() will return false when called from the",
            "\t * .ndo_close() callback. Calling the following recovery code while",
            "\t * called from .ndo_close() could deadlock on rtnl.",
            "\t */",
            "\tif (!netif_running(dev))",
            "\t\treturn;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\freescale\\fs_enet\\fs_enet-main.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\ibm\\emac\\mal.c",
          "line": 603,
          "match": "deadlock",
          "context": [
            "\tcfg |= MAL_CFG_PLBB | MAL_CFG_OPBBL | MAL_CFG_LEA;",
            "",
            "\t/* Current Axon is not happy with priority being non-0, it can",
            "\t * deadlock, fix it up here",
            "\t */",
            "\tif (of_device_is_compatible(ofdev->dev.of_node, \"ibm,mcmal-axon\"))",
            "\t\tcfg &= ~(MAL2_CFG_RPP_10 | MAL2_CFG_WPP_10);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\ibm\\emac\\mal.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\intel\\iavf\\iavf_main.c",
          "line": 4579,
          "match": "deadlock",
          "context": [
            "\tset_bit(__IAVF_VSI_DOWN, adapter->vsi.state);",
            "\t/* We cannot send IAVF_FLAG_AQ_GET_OFFLOAD_VLAN_V2_CAPS before",
            "\t * IAVF_FLAG_AQ_DISABLE_QUEUES because in such case there is rtnl",
            "\t * deadlock with adminq_task() until iavf_close timeouts. We must send",
            "\t * IAVF_FLAG_AQ_GET_CONFIG before IAVF_FLAG_AQ_DISABLE_QUEUES to make",
            "\t * disable queues possible for vf. Give only necessary flags to",
            "\t * iavf_down and save other to set them right before iavf_close()"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\intel\\iavf\\iavf_main.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\marvell\\octeontx2\\nic\\qos.c",
          "line": 126,
          "match": "deadlock",
          "context": [
            "\t(*num_regs)++;",
            "",
            "\t/* Don't configure CIR when both CIR+PIR not supported",
            "\t * On 96xx, CIR + PIR + RED_ALGO=STALL causes deadlock",
            "\t */",
            "\tif (!test_bit(QOS_CIR_PIR_SUPPORT, &pfvf->hw.cap_flag))",
            "\t\treturn;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\marvell\\octeontx2\\nic\\qos.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\mellanox\\mlx4\\en_main.c",
          "line": 330,
          "match": "deadlock",
          "context": [
            "\tmlx4_en_set_num_rx_rings(mdev);",
            "",
            "\t/* Create our own workqueue for reset/multicast tasks",
            "\t * Note: we cannot use the shared workqueue because of deadlocks caused",
            "\t *       by the rtnl lock */",
            "\tmdev->workqueue = create_singlethread_workqueue(\"mlx4_en\");",
            "\tif (!mdev->workqueue) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\mellanox\\mlx4\\en_main.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\mellanox\\mlxsw\\spectrum_ptp.c",
          "line": 806,
          "match": "deadlock",
          "context": [
            "\t * networking stack. This is usually done from a trap handler, which is",
            "\t * invoked in a softirq context. Here we are going to do it in process",
            "\t * context. If that were to be interrupted by a softirq, it could cause",
            "\t * a deadlock when an attempt is made to take an already-taken lock",
            "\t * somewhere along the sending path. Disable softirqs to prevent this.",
            "\t */",
            "\tlocal_bh_disable();"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\mellanox\\mlxsw\\spectrum_ptp.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\mellanox\\mlxsw\\spectrum_router.c",
          "line": 8539,
          "match": "deadlock",
          "context": [
            "\tstruct mlxsw_sp_router_hwstats_notify_work *hws_work;",
            "",
            "\t/* To collect notification payload, the core ends up sending another",
            "\t * notifier block message, which would deadlock on the attempt to",
            "\t * acquire the router lock again. Just postpone the notification until",
            "\t * later.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\mellanox\\mlxsw\\spectrum_router.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\netronome\\nfp\\flower\\conntrack.c",
          "line": 2220,
          "match": "deadlock",
          "context": [
            "\tswitch (type) {",
            "\tcase TC_SETUP_CLSFLOWER:",
            "\t\twhile (!mutex_trylock(&zt->priv->nfp_fl_lock)) {",
            "\t\t\tif (!zt->nft) /* avoid deadlock */",
            "\t\t\t\treturn err;",
            "\t\t\tmsleep(20);",
            "\t\t}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\netronome\\nfp\\flower\\conntrack.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\netronome\\nfp\\flower\\conntrack.c",
          "line": 2274,
          "match": "deadlock",
          "context": [
            "",
            "\t\tif (!zt->pre_ct_count && zt->nft) {",
            "\t\t\tnft = zt->nft;",
            "\t\t\tzt->nft = NULL; /* avoid deadlock */",
            "\t\t\tnf_flow_table_offload_del_cb(nft,",
            "\t\t\t\t\t\t     nfp_fl_ct_handle_nft_flow,",
            "\t\t\t\t\t\t     zt);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\netronome\\nfp\\flower\\conntrack.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\qlogic\\qede\\qede_main.c",
          "line": 1121,
          "match": "deadlock",
          "context": [
            "\tif (test_and_clear_bit(QEDE_SP_RECOVERY, &edev->sp_flags)) {",
            "\t\tcancel_delayed_work_sync(&edev->periodic_task);",
            "#ifdef CONFIG_QED_SRIOV",
            "\t\t/* SRIOV must be disabled outside the lock to avoid a deadlock.",
            "\t\t * The recovery of the active VFs is currently not supported.",
            "\t\t */",
            "\t\tif (pci_num_vf(edev->pdev))"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\qlogic\\qede\\qede_main.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\qlogic\\qede\\qede_main.c",
          "line": 1150,
          "match": "deadlock",
          "context": [
            "",
            "\tif (test_and_clear_bit(QEDE_SP_AER, &edev->sp_flags)) {",
            "#ifdef CONFIG_QED_SRIOV",
            "\t\t/* SRIOV must be disabled outside the lock to avoid a deadlock.",
            "\t\t * The recovery of the active VFs is currently not supported.",
            "\t\t */",
            "\t\tif (pci_num_vf(edev->pdev))"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\qlogic\\qede\\qede_main.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\sfc\\siena\\mcdi.c",
          "line": 1212,
          "match": "deadlock",
          "context": [
            "\t * efx_mcdi_ev_cpl()]",
            "\t *",
            "\t * If there is an outstanding asynchronous request, we can't",
            "\t * complete it now (efx_mcdi_complete() would deadlock).  The",
            "\t * reset process will take care of this.",
            "\t *",
            "\t * There's a race here with efx_mcdi_send_request(), because"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\sfc\\siena\\mcdi.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\ath\\ath10k\\core.c",
          "line": 2560,
          "match": "deadlock",
          "context": [
            "\t/* TODO: We can have one instance of cancelling coverage_class_work by",
            "\t * moving it to ath10k_halt(), so that both stop() and restart() would",
            "\t * call that but it takes conf_mutex() and if we call cancel_work_sync()",
            "\t * with conf_mutex it will deadlock.",
            "\t */",
            "\tcancel_work_sync(&ar->set_coverage_class_work);",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\ath\\ath10k\\core.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\ath\\ath10k\\core.c",
          "line": 3537,
          "match": "deadlock",
          "context": [
            "\tath10k_core_free_firmware_files(ar);",
            "err:",
            "\t/* TODO: It's probably a good idea to release device from the driver",
            "\t * but calling device_release_driver() here will cause a deadlock.",
            "\t */",
            "\treturn;",
            "}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\ath\\ath10k\\core.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\ath\\ath10k\\debug.c",
          "line": 1752,
          "match": "deadlock",
          "context": [
            "\t\t      ar->normal_mode_fw.fw_file.fw_features))",
            "\t\tath10k_debug_cal_data_fetch(ar);",
            "",
            "\t/* Must not use _sync to avoid deadlock, we do that in",
            "\t * ath10k_debug_destroy(). The check for htt_stats_mask is to avoid",
            "\t * warning from timer_delete().",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\ath\\ath10k\\debug.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\ath\\ath10k\\mac.c",
          "line": 7506,
          "match": "deadlock",
          "context": [
            "\t\t\tath10k_mac_txq_init(sta->txq[i]);",
            "\t}",
            "",
            "\t/* cancel must be done outside the mutex to avoid deadlock */",
            "\tif ((old_state == IEEE80211_STA_NONE &&",
            "\t     new_state == IEEE80211_STA_NOTEXIST)) {",
            "\t\tcancel_work_sync(&arsta->update_wk);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\ath\\ath10k\\mac.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\ath\\ath11k\\mac.c",
          "line": 9668,
          "match": "deadlock",
          "context": [
            "\tstruct ath11k_peer *peer;",
            "\tint ret = 0;",
            "",
            "\t/* cancel must be done outside the mutex to avoid deadlock */",
            "\tif ((old_state == IEEE80211_STA_NONE &&",
            "\t     new_state == IEEE80211_STA_NOTEXIST)) {",
            "\t\tcancel_work_sync(&arsta->update_wk);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\ath\\ath11k\\mac.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\ath\\wil6210\\main.c",
          "line": 454,
          "match": "deadlock",
          "context": [
            "\t}",
            "",
            "\t/* call event handler manually after processing wmi_call,",
            "\t * to avoid deadlock - disconnect event handler acquires",
            "\t * wil->mutex while it is already held here",
            "\t */",
            "\t_wil6210_disconnect_complete(vif, bssid, reason_code);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\ath\\wil6210\\main.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\broadcom\\b43\\main.c",
          "line": 4338,
          "match": "deadlock",
          "context": [
            "\tif (!dev || b43_status(dev) < B43_STAT_STARTED)",
            "\t\treturn dev;",
            "",
            "\t/* Cancel work. Unlock to avoid deadlocks. */",
            "\tmutex_unlock(&wl->mutex);",
            "\tcancel_delayed_work_sync(&dev->periodic_work);",
            "\tcancel_work_sync(&wl->tx_work);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\broadcom\\b43\\main.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\broadcom\\b43\\main.c",
          "line": 4362,
          "match": "deadlock",
          "context": [
            "\t\tb43_read32(dev, B43_MMIO_GEN_IRQ_MASK);\t/* Flush */",
            "\t\tspin_unlock_irq(&wl->hardirq_lock);",
            "\t}",
            "\t/* Synchronize and free the interrupt handlers. Unlock to avoid deadlocks. */",
            "\torig_dev = dev;",
            "\tmutex_unlock(&wl->mutex);",
            "\tif (b43_bus_host_is_sdio(dev->dev))"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\broadcom\\b43\\main.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\broadcom\\b43legacy\\main.c",
          "line": 2404,
          "match": "deadlock",
          "context": [
            "\tstruct b43legacy_wl *wl = (struct b43legacy_wl *)rng->priv;",
            "\tunsigned long flags;",
            "",
            "\t/* Don't take wl->mutex here, as it could deadlock with",
            "\t * hwrng internal locking. It's not needed to take",
            "\t * wl->mutex here, anyway. */",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\broadcom\\b43legacy\\main.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\broadcom\\b43legacy\\main.c",
          "line": 2935,
          "match": "deadlock",
          "context": [
            "\tb43legacy_set_status(dev, B43legacy_STAT_INITIALIZED);",
            "",
            "\tmutex_unlock(&wl->mutex);",
            "\t/* Must unlock as it would otherwise deadlock. No races here.",
            "\t * Cancel the possibly running self-rearming periodic work. */",
            "\tcancel_delayed_work_sync(&dev->periodic_work);",
            "\tcancel_work_sync(&wl->tx_work);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\broadcom\\b43legacy\\main.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\marvell\\libertas\\if_sdio.c",
          "line": 1043,
          "match": "deadlock",
          "context": [
            "\t * The actual reset operation must be run outside of lbs_thread. This",
            "\t * is because mmc_remove_host() will cause the device to be instantly",
            "\t * destroyed, and the libertas driver then needs to end lbs_thread,",
            "\t * leading to a deadlock.",
            "\t *",
            "\t * We run it in a workqueue totally independent from the if_sdio_card",
            "\t * instance for that reason."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\marvell\\libertas\\if_sdio.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\marvell\\mwifiex\\main.c",
          "line": 1474,
          "match": "deadlock",
          "context": [
            "\t\t\t/*",
            "\t\t\t * Close the netdev now, because if we do it later, the",
            "\t\t\t * netdev notifiers will need to acquire the wiphy lock",
            "\t\t\t * again --> deadlock.",
            "\t\t\t */",
            "\t\t\tdev_close(priv->wdev.netdev);",
            "\t\t\twiphy_lock(adapter->wiphy);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\marvell\\mwifiex\\main.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\ti\\wlcore\\main.c",
          "line": 119,
          "match": "deadlock",
          "context": [
            "\t\tret = wl1271_set_rx_streaming(wl, wlvif, true);",
            "\telse {",
            "\t\tret = wl1271_set_rx_streaming(wl, wlvif, false);",
            "\t\t/* don't cancel_work_sync since we might deadlock */",
            "\t\ttimer_delete_sync(&wlvif->rx_streaming_timer);",
            "\t}",
            "out:"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\ti\\wlcore\\main.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\ti\\wlcore\\main.c",
          "line": 796,
          "match": "deadlock",
          "context": [
            "\t\tcounter->cur_vif_running = true;",
            "}",
            "",
            "/* caller must not hold wl->mutex, as it might deadlock */",
            "static void wl12xx_get_vif_count(struct ieee80211_hw *hw,",
            "\t\t\t       struct ieee80211_vif *cur_vif,",
            "\t\t\t       struct vif_counter_data *data)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\ti\\wlcore\\main.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\ti\\wlcore\\main.c",
          "line": 2001,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Use the nosync variant to disable interrupts, so the mutex could be",
            "\t * held while doing so without deadlocking.",
            "\t */",
            "\twlcore_disable_interrupts_nosync(wl);",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\ti\\wlcore\\main.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\ti\\wlcore\\main.c",
          "line": 5782,
          "match": "deadlock",
          "context": [
            "\twl1271_tx_flush(wl);",
            "",
            "\t/*",
            "\t * we can't just flush_work here, because it might deadlock",
            "\t * (as we might get called from the same workqueue)",
            "\t */",
            "\tcancel_delayed_work_sync(&wl->roc_complete_work);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\ti\\wlcore\\main.c"
          ]
        },
        {
          "file": "linux\\drivers\\nvme\\host\\apple.c",
          "line": 870,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * The driver will not be starting up queues again if shutting down so",
            "\t * must flush all entered requests to their failed completion to avoid",
            "\t * deadlocking blk-mq hot-cpu notifier.",
            "\t */",
            "\tif (shutdown) {",
            "\t\tnvme_unquiesce_io_queues(&anv->ctrl);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\nvme\\host\\apple.c"
          ]
        },
        {
          "file": "linux\\drivers\\nvme\\host\\core.c",
          "line": 1211,
          "match": "deadlock",
          "context": [
            "",
            "\t\t/*",
            "\t\t * NVME_CMD_EFFECTS_CSE_MASK causes a freeze all I/O queues,",
            "\t\t * which would deadlock when done on an I/O command.  Note that",
            "\t\t * We already warn about an unusual effect above.",
            "\t\t */",
            "\t\teffects &= ~NVME_CMD_EFFECTS_CSE_MASK;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\nvme\\host\\core.c"
          ]
        },
        {
          "file": "linux\\drivers\\nvme\\host\\core.c",
          "line": 4143,
          "match": "deadlock",
          "context": [
            "\tmutex_lock(&ctrl->namespaces_lock);",
            "\t/*",
            "\t * Ensure that no namespaces are added to the ctrl list after the queues",
            "\t * are frozen, thereby avoiding a deadlock between scan and reset.",
            "\t */",
            "\tif (test_bit(NVME_CTRL_FROZEN, &ctrl->flags)) {",
            "\t\tmutex_unlock(&ctrl->namespaces_lock);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\nvme\\host\\core.c"
          ]
        },
        {
          "file": "linux\\drivers\\nvme\\host\\ioctl.c",
          "line": 726,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Handle ioctls that apply to the controller instead of the namespace",
            "\t * separately and drop the ns SRCU reference early.  This avoids a",
            "\t * deadlock when deleting namespaces using the passthrough interface.",
            "\t */",
            "\tif (is_ctrl_ioctl(cmd))",
            "\t\treturn nvme_ns_head_ctrl_ioctl(ns, cmd, argp, head, srcu_idx,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\nvme\\host\\ioctl.c"
          ]
        },
        {
          "file": "linux\\drivers\\nvme\\host\\multipath.c",
          "line": 762,
          "match": "deadlock",
          "context": [
            "\t * We need to suppress the partition scan from occuring within the",
            "\t * controller's scan_work context. If a path error occurs here, the IO",
            "\t * will wait until a path becomes available or all paths are torn down,",
            "\t * but that action also occurs within scan_work, so it would deadlock.",
            "\t * Defer the partition scan to a different context that does not block",
            "\t * scan_work.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\nvme\\host\\multipath.c"
          ]
        },
        {
          "file": "linux\\drivers\\nvme\\host\\multipath.c",
          "line": 872,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * nvme_mpath_set_live() will trigger I/O to the multipath path device",
            "\t * and in turn to this path device.  However we cannot accept this I/O",
            "\t * if the controller is not live.  This may deadlock if called from",
            "\t * nvme_mpath_init_identify() and the ctrl will never complete",
            "\t * initialization, preventing I/O from completing.  For this case we",
            "\t * will reprocess the ANA log page in nvme_mpath_update() once the"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\nvme\\host\\multipath.c"
          ]
        },
        {
          "file": "linux\\drivers\\nvme\\host\\pci.c",
          "line": 1496,
          "match": "deadlock",
          "context": [
            "\t * unblocks PCIe error handling if the nvme driver is waiting in",
            "\t * error_resume for a device that has been removed. We can't unbind the",
            "\t * driver while the driver's error callback is waiting to complete, so",
            "\t * we're relying on a timeout to break that deadlock if a removal",
            "\t * occurs while reset work is running.",
            "\t */",
            "\tif (pci_dev_is_disconnected(pdev))"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\nvme\\host\\pci.c"
          ]
        },
        {
          "file": "linux\\drivers\\nvme\\host\\pci.c",
          "line": 2897,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * The driver will not be starting up queues again if shutting down so",
            "\t * must flush all entered requests to their failed completion to avoid",
            "\t * deadlocking blk-mq hot-cpu notifier.",
            "\t */",
            "\tif (shutdown) {",
            "\t\tnvme_unquiesce_io_queues(&dev->ctrl);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\nvme\\host\\pci.c"
          ]
        },
        {
          "file": "linux\\drivers\\nvme\\target\\rdma.c",
          "line": 1452,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Schedules the actual release because calling rdma_destroy_id from",
            "\t * inside a CM callback would trigger a deadlock. (great API design..)",
            "\t */",
            "\tINIT_WORK(&queue->release_work, nvmet_rdma_release_queue_work);",
            "\tqueue->dev = ndev;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\nvme\\target\\rdma.c"
          ]
        },
        {
          "file": "linux\\drivers\\pci\\controller\\vmd.c",
          "line": 382,
          "match": "deadlock",
          "context": [
            "}",
            "",
            "/*",
            " * CPU may deadlock if config space is not serialized on some versions of this",
            " * hardware, so all config space access is done under a spinlock.",
            " */",
            "static int vmd_pci_read(struct pci_bus *bus, unsigned int devfn, int reg,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\pci\\controller\\vmd.c"
          ]
        },
        {
          "file": "linux\\drivers\\pci\\hotplug\\pciehp_pci.c",
          "line": 69,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Release reset_lock during driver binding",
            "\t * to avoid AB-BA deadlock with device_lock.",
            "\t */",
            "\tup_read(&ctrl->reset_lock);",
            "\tpci_bus_add_devices(parent);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\pci\\hotplug\\pciehp_pci.c"
          ]
        },
        {
          "file": "linux\\drivers\\pci\\hotplug\\pciehp_pci.c",
          "line": 121,
          "match": "deadlock",
          "context": [
            "",
            "\t\t/*",
            "\t\t * Release reset_lock during driver unbinding",
            "\t\t * to avoid AB-BA deadlock with device_lock.",
            "\t\t */",
            "\t\tup_read(&ctrl->reset_lock);",
            "\t\tpci_stop_and_remove_bus_device(dev);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\pci\\hotplug\\pciehp_pci.c"
          ]
        },
        {
          "file": "linux\\drivers\\platform\\x86\\lenovo-yogabook.c",
          "line": 130,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * We are called from the ACPI core and the driver [un]binding which is",
            "\t * done also needs ACPI functions, use a workqueue to avoid deadlocking.",
            "\t */",
            "\tschedule_work(&data->work);",
            "}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\platform\\x86\\lenovo-yogabook.c"
          ]
        },
        {
          "file": "linux\\drivers\\platform\\x86\\p2sb.c",
          "line": 252,
          "match": "deadlock",
          "context": [
            "",
            "/*",
            " * pci_rescan_remove_lock() can not be locked in sysfs PCI bus rescan path",
            " * because of deadlock. To avoid the deadlock, access P2SB devices with the lock",
            " * at an early step in kernel initialization and cache required resources.",
            " *",
            " * We want to run as early as possible. If the P2SB was assigned a bad BAR,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\platform\\x86\\p2sb.c"
          ]
        },
        {
          "file": "linux\\drivers\\platform\\x86\\p2sb.c",
          "line": 252,
          "match": "deadlock",
          "context": [
            "",
            "/*",
            " * pci_rescan_remove_lock() can not be locked in sysfs PCI bus rescan path",
            " * because of deadlock. To avoid the deadlock, access P2SB devices with the lock",
            " * at an early step in kernel initialization and cache required resources.",
            " *",
            " * We want to run as early as possible. If the P2SB was assigned a bad BAR,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\platform\\x86\\p2sb.c"
          ]
        },
        {
          "file": "linux\\drivers\\platform\\surface\\aggregator\\ssh_packet_layer.c",
          "line": 167,
          "match": "deadlock",
          "context": [
            " *",
            " * >> General Notes <<",
            " *",
            " * - To avoid deadlocks, if both queue and pending locks are required, the",
            " *   pending lock must be acquired before the queue lock.",
            " *",
            " * - The packet priority must be accessed only while holding the queue lock."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\platform\\surface\\aggregator\\ssh_packet_layer.c"
          ]
        },
        {
          "file": "linux\\drivers\\platform\\x86\\dell\\dell-lis3lv02d.c",
          "line": 133,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * bus_for_each_dev() and not i2c_for_each_dev() to avoid",
            "\t * a deadlock when find_i801() calls i2c_get_adapter().",
            "\t */",
            "\tbus_for_each_dev(&i2c_bus_type, NULL, &adap, find_i801);",
            "\tif (!adap)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\platform\\x86\\dell\\dell-lis3lv02d.c"
          ]
        },
        {
          "file": "linux\\drivers\\pmdomain\\imx\\imx8m-blk-ctrl.c",
          "line": 294,
          "match": "deadlock",
          "context": [
            "\t\t * nesting being visible at the genpd level, so we need a",
            "\t\t * separate lock class to make lockdep aware of the fact that",
            "\t\t * this are separate domain locks that can be nested without a",
            "\t\t * self-deadlock.",
            "\t\t */",
            "\t\tlockdep_set_class(&domain->genpd.mlock,",
            "\t\t\t\t  &blk_ctrl_genpd_lock_class);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\pmdomain\\imx\\imx8m-blk-ctrl.c"
          ]
        },
        {
          "file": "linux\\drivers\\pmdomain\\imx\\imx93-blk-ctrl.c",
          "line": 282,
          "match": "deadlock",
          "context": [
            "\t\t * nesting being visible at the genpd level, so we need a",
            "\t\t * separate lock class to make lockdep aware of the fact that",
            "\t\t * this are separate domain locks that can be nested without a",
            "\t\t * self-deadlock.",
            "\t\t */",
            "\t\tlockdep_set_class(&domain->genpd.mlock,",
            "\t\t\t\t  &blk_ctrl_genpd_lock_class);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\pmdomain\\imx\\imx93-blk-ctrl.c"
          ]
        },
        {
          "file": "linux\\drivers\\pmdomain\\imx\\imx8mp-blk-ctrl.c",
          "line": 722,
          "match": "deadlock",
          "context": [
            "\t\t * nesting being visible at the genpd level, so we need a",
            "\t\t * separate lock class to make lockdep aware of the fact that",
            "\t\t * this are separate domain locks that can be nested without a",
            "\t\t * self-deadlock.",
            "\t\t */",
            "\t\tlockdep_set_class(&domain->genpd.mlock,",
            "\t\t\t\t  &blk_ctrl_genpd_lock_class);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\pmdomain\\imx\\imx8mp-blk-ctrl.c"
          ]
        },
        {
          "file": "linux\\drivers\\s390\\char\\tape_34xx.c",
          "line": 134,
          "match": "deadlock",
          "context": [
            " * interrupt handler.",
            " * Note: the work handler is called by the system work queue. The tape",
            " * commands started by the handler need to be asynchrounous, otherwise",
            " * a deadlock can occur e.g. in case of a deferred cc=1 (see __tape_do_irq).",
            " */",
            "static void",
            "tape_34xx_work_handler(struct work_struct *work)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\s390\\char\\tape_34xx.c"
          ]
        },
        {
          "file": "linux\\drivers\\s390\\char\\tape_3590.c",
          "line": 616,
          "match": "deadlock",
          "context": [
            " * interrupt context (like unsolicited interrupts).",
            " * Note: the work handler is called by the system work queue. The tape",
            " * commands started by the handler need to be asynchrounous, otherwise",
            " * a deadlock can occur e.g. in case of a deferred cc=1 (see __tape_do_irq).",
            " */",
            "struct work_handler_data {",
            "\tstruct tape_device *device;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\s390\\char\\tape_3590.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\arcmsr\\arcmsr_hba.c",
          "line": 3062,
          "match": "DEADLOCK",
          "context": [
            "\t\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);",
            "\t\tkfree(ver_addr);",
            "\t\tpcmdmessagefld->cmdmessage.Length = allxfer_len;",
            "\t\tif (acb->fw_flag == FW_DEADLOCK)",
            "\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =",
            "\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;",
            "\t\telse"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\arcmsr\\arcmsr_hba.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\arcmsr\\arcmsr_hba.c",
          "line": 3124,
          "match": "DEADLOCK",
          "context": [
            "\t\t}",
            "\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);",
            "\t\tkfree(ver_addr);",
            "\t\tif (acb->fw_flag == FW_DEADLOCK)",
            "\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =",
            "\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;",
            "\t\telse"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\arcmsr\\arcmsr_hba.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\arcmsr\\arcmsr_hba.c",
          "line": 3142,
          "match": "DEADLOCK",
          "context": [
            "\t\tacb->rqbuf_putIndex = 0;",
            "\t\tmemset(pQbuffer, 0, ARCMSR_MAX_QBUFFER);",
            "\t\tspin_unlock_irqrestore(&acb->rqbuffer_lock, flags);",
            "\t\tif (acb->fw_flag == FW_DEADLOCK)",
            "\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =",
            "\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;",
            "\t\telse"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\arcmsr\\arcmsr_hba.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\arcmsr\\arcmsr_hba.c",
          "line": 3159,
          "match": "DEADLOCK",
          "context": [
            "\t\tacb->wqbuf_putIndex = 0;",
            "\t\tmemset(pQbuffer, 0, ARCMSR_MAX_QBUFFER);",
            "\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);",
            "\t\tif (acb->fw_flag == FW_DEADLOCK)",
            "\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =",
            "\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;",
            "\t\telse"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\arcmsr\\arcmsr_hba.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\arcmsr\\arcmsr_hba.c",
          "line": 3185,
          "match": "DEADLOCK",
          "context": [
            "\t\tpQbuffer = acb->wqbuffer;",
            "\t\tmemset(pQbuffer, 0, sizeof(struct QBUFFER));",
            "\t\tspin_unlock_irqrestore(&acb->wqbuffer_lock, flags);",
            "\t\tif (acb->fw_flag == FW_DEADLOCK)",
            "\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =",
            "\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;",
            "\t\telse"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\arcmsr\\arcmsr_hba.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\arcmsr\\arcmsr_hba.c",
          "line": 3194,
          "match": "DEADLOCK",
          "context": [
            "\t\tbreak;",
            "\t}",
            "\tcase ARCMSR_MESSAGE_RETURN_CODE_3F: {",
            "\t\tif (acb->fw_flag == FW_DEADLOCK)",
            "\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =",
            "\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;",
            "\t\telse"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\arcmsr\\arcmsr_hba.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\arcmsr\\arcmsr_hba.c",
          "line": 3204,
          "match": "DEADLOCK",
          "context": [
            "\t}",
            "\tcase ARCMSR_MESSAGE_SAY_HELLO: {",
            "\t\tint8_t *hello_string = \"Hello! I am ARCMSR\";",
            "\t\tif (acb->fw_flag == FW_DEADLOCK)",
            "\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =",
            "\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;",
            "\t\telse"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\arcmsr\\arcmsr_hba.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\arcmsr\\arcmsr_hba.c",
          "line": 3215,
          "match": "DEADLOCK",
          "context": [
            "\t\tbreak;",
            "\t}",
            "\tcase ARCMSR_MESSAGE_SAY_GOODBYE: {",
            "\t\tif (acb->fw_flag == FW_DEADLOCK)",
            "\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =",
            "\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;",
            "\t\telse"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\arcmsr\\arcmsr_hba.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\arcmsr\\arcmsr_hba.c",
          "line": 3225,
          "match": "DEADLOCK",
          "context": [
            "\t\tbreak;",
            "\t}",
            "\tcase ARCMSR_MESSAGE_FLUSH_ADAPTER_CACHE: {",
            "\t\tif (acb->fw_flag == FW_DEADLOCK)",
            "\t\t\tpcmdmessagefld->cmdmessage.ReturnCode =",
            "\t\t\t\tARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;",
            "\t\telse"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\arcmsr\\arcmsr_hba.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\arcmsr\\arcmsr_hba.c",
          "line": 4698,
          "match": "DEADLOCK",
          "context": [
            "\t\tssleep(ARCMSR_SLEEPTIME);",
            "\t\tif (arcmsr_reset_in_progress(acb)) {",
            "\t\t\tif (retry_count > ARCMSR_RETRYCOUNT) {",
            "\t\t\t\tacb->fw_flag = FW_DEADLOCK;",
            "\t\t\t\tpr_notice(\"arcmsr%d: waiting for hw bus reset\"",
            "\t\t\t\t\t\" return, RETRY TERMINATED!!\\n\",",
            "\t\t\t\t\tacb->host->host_no);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\arcmsr\\arcmsr_hba.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\esas2r\\esas2r_disc.c",
          "line": 169,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * now, interrupt processing may have queued up a discovery event.  go",
            "\t * see if we have one to start.  we couldn't start it in the ISR since",
            "\t * polled discovery would cause a deadlock.",
            "\t */",
            "",
            "\tesas2r_disc_start_waiting(a);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\esas2r\\esas2r_disc.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\esas2r\\esas2r_disc.c",
          "line": 302,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Don't start discovery before or during polled discovery.  if we did,",
            "\t * we would have a deadlock if we are in the ISR already.",
            "\t */",
            "\tif (!test_bit(AF_CHPRST_PENDING, &a->flags) &&",
            "\t    !test_bit(AF_DISC_POLLED, &a->flags))"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\esas2r\\esas2r_disc.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\hisi_sas\\hisi_sas_v3_hw.c",
          "line": 5258,
          "match": "deadlock",
          "context": [
            "\tphys_init_v3_hw(hisi_hba);",
            "",
            "\t/*",
            "\t * If a directly-attached disk is removed during suspend, a deadlock",
            "\t * may occur, as the PHYE_RESUME_TIMEOUT processing will require the",
            "\t * hisi_hba->device to be active, which can only happen when resume",
            "\t * completes. So don't wait for the HA event workqueue to drain upon"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\hisi_sas\\hisi_sas_v3_hw.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\lpfc\\lpfc_sli.c",
          "line": 15768,
          "match": "deadlock",
          "context": [
            "\t * the io path completion will only arm eq's when it",
            "\t * receives a completion.  But since eq's are in disa-",
            "\t * rmed state it doesn't receive a completion.  This",
            "\t * creates a deadlock scenaro.",
            "\t */",
            "\tphba->sli4_hba.sli4_write_eq_db(phba, eq, 0, LPFC_QUEUE_REARM);",
            "}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\lpfc\\lpfc_sli.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\mpi3mr\\mpi3mr_os.c",
          "line": 391,
          "match": "deadlock",
          "context": [
            "\t\t * get called as part of processing the",
            "\t\t * same fwevt work (or) when worker thread is",
            "\t\t * waiting for device add/remove APIs to complete.",
            "\t\t * Otherwise we will see deadlock.",
            "\t\t */",
            "\t\tif (current_work() == &fwevt->work || fwevt->pending_at_sml) {",
            "\t\t\tfwevt->discard = 1;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\mpi3mr\\mpi3mr_os.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\mpt3sas\\mpt3sas_base.c",
          "line": 732,
          "match": "deadlock",
          "context": [
            "\t\t/*",
            "\t\t * Call _scsih_flush_pending_cmds callback so that we flush all",
            "\t\t * pending commands back to OS. This call is required to avoid",
            "\t\t * deadlock at block layer. Dead IOC will fail to do diag reset,",
            "\t\t * and this call is safe since dead ioc will never return any",
            "\t\t * command back from HW.",
            "\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\mpt3sas\\mpt3sas_base.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\mpt3sas\\mpt3sas_scsih.c",
          "line": 3702,
          "match": "deadlock",
          "context": [
            "\t\t/*",
            "\t\t * Don't call cancel_work_sync() for current_event",
            "\t\t * other than MPT3SAS_REMOVE_UNRESPONDING_DEVICES;",
            "\t\t * otherwise we may observe deadlock if current",
            "\t\t * hard reset issued as part of processing the current_event.",
            "\t\t *",
            "\t\t * Orginal logic of cleaning the current_event is added"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\mpt3sas\\mpt3sas_scsih.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\sym53c8xx_2\\sym_hipd.c",
          "line": 2856,
          "match": "deadlock",
          "context": [
            "\t\tistatc = INB(np, nc_istat);",
            "\t\tistat |= istatc;",
            "",
            "\t\t/* Prevent deadlock waiting on a condition that may",
            "\t\t * never clear. */",
            "\t\tif (unlikely(sist == 0xffff && dstat == 0xff)) {",
            "\t\t\tif (pci_channel_offline(pdev))"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\sym53c8xx_2\\sym_hipd.c"
          ]
        },
        {
          "file": "linux\\drivers\\staging\\rtl8723bs\\core\\rtw_cmd.c",
          "line": 1653,
          "match": "deadlock",
          "context": [
            "}",
            "",
            "/* dont call R/W in this function, beucase SDIO interrupt have claim host */",
            "/* or deadlock will happen and cause special-systemserver-died in android */",
            "u8 rtw_c2h_wk_cmd(struct adapter *padapter, u8 *c2h_evt)",
            "{",
            "\tstruct cmd_obj *ph2c;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\staging\\rtl8723bs\\core\\rtw_cmd.c"
          ]
        },
        {
          "file": "linux\\drivers\\thermal\\intel\\x86_pkg_temp_thermal.c",
          "line": 437,
          "match": "deadlock",
          "context": [
            "\tif (zonedev->work_scheduled && was_target) {",
            "\t\t/*",
            "\t\t * To cancel the work we need to drop the lock, otherwise",
            "\t\t * we might deadlock if the work needs to be flushed.",
            "\t\t */",
            "\t\traw_spin_unlock_irq(&pkg_temp_lock);",
            "\t\tcancel_delayed_work_sync(&zonedev->work);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\thermal\\intel\\x86_pkg_temp_thermal.c"
          ]
        },
        {
          "file": "linux\\drivers\\tty\\hvc\\hvcs.c",
          "line": 896,
          "match": "deadlock",
          "context": [
            "",
            "/*",
            " * This function is executed by the driver \"rescan\" sysfs entry.  It shouldn't",
            " * be executed elsewhere, in order to prevent deadlock issues.",
            " */",
            "static int hvcs_rescan_devices_list(void)",
            "{"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\tty\\hvc\\hvcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\tty\\hvc\\hvcs.c",
          "line": 1035,
          "match": "deadlock",
          "context": [
            " * Please remember to dec when you are done with the instance.",
            " *",
            " * NOTICE: Do NOT hold either the hvcs_struct.lock or hvcs_structs_lock when",
            " * calling this function or you will get deadlock.",
            " */",
            "static struct hvcs_struct *hvcs_get_by_index(int index)",
            "{"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\tty\\hvc\\hvcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\tty\\hvc\\hvcs.c",
          "line": 1344,
          "match": "deadlock",
          "context": [
            "\t\thvcsd->chars_in_buffer = 0;",
            "\t\t/*",
            "\t\t * Test after the chars_in_buffer reset otherwise this could",
            "\t\t * deadlock our writes if hvc_put_chars fails.",
            "\t\t */",
            "\t\tif (result < 0)",
            "\t\t\tbreak;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\tty\\hvc\\hvcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\tty\\serial\\fsl_lpuart.c",
          "line": 2077,
          "match": "deadlock",
          "context": [
            "\t * baud rate and restart Rx DMA path.",
            "\t *",
            "\t * Since timer function acqures port->lock, need to stop before",
            "\t * acquring same lock because otherwise timer_delete_sync() can deadlock.",
            "\t */",
            "\tif (old && sport->lpuart_dma_rx_use)",
            "\t\tlpuart_dma_rx_free(port);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\tty\\serial\\fsl_lpuart.c"
          ]
        },
        {
          "file": "linux\\drivers\\tty\\serial\\fsl_lpuart.c",
          "line": 2322,
          "match": "deadlock",
          "context": [
            "\t * baud rate and restart Rx DMA path.",
            "\t *",
            "\t * Since timer function acqures port->lock, need to stop before",
            "\t * acquring same lock because otherwise timer_delete_sync() can deadlock.",
            "\t */",
            "\tif (old && sport->lpuart_dma_rx_use)",
            "\t\tlpuart_dma_rx_free(port);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\tty\\serial\\fsl_lpuart.c"
          ]
        },
        {
          "file": "linux\\drivers\\tty\\serial\\max3100.c",
          "line": 109,
          "match": "deadlock",
          "context": [
            "\tstruct work_struct work;",
            "\t/* set to 1 to make the workhandler exit as soon as possible */",
            "\tint  force_end_work;",
            "\t/* need to know we are suspending to avoid deadlock on workqueue */",
            "\tint suspending;",
            "",
            "\tstruct timer_list\ttimer;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\tty\\serial\\max3100.c"
          ]
        },
        {
          "file": "linux\\drivers\\tty\\serial\\pic32_uart.c",
          "line": 190,
          "match": "deadlock",
          "context": [
            "\t\tsport->enable_tx_irq = true;",
            "\t} else if (!en && sport->enable_tx_irq) {",
            "\t\t/* use disable_irq_nosync() and not disable_irq() to avoid self",
            "\t\t * imposed deadlock by not waiting for irq handler to end,",
            "\t\t * since this callback is called from interrupt context.",
            "\t\t */",
            "\t\tdisable_irq_nosync(sport->irq_tx);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\tty\\serial\\pic32_uart.c"
          ]
        },
        {
          "file": "linux\\drivers\\tty\\serial\\8250\\8250_dw.c",
          "line": 179,
          "match": "deadlock",
          "context": [
            "\t\t\twriteb(value, addr);",
            "\t}",
            "\t/*",
            "\t * FIXME: this deadlocks if port->lock is already held",
            "\t * dev_err(p->dev, \"Couldn't set LCR to %d\\n\", value);",
            "\t */",
            "}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\tty\\serial\\8250\\8250_dw.c"
          ]
        },
        {
          "file": "linux\\drivers\\tty\\serial\\8250\\8250_dw.c",
          "line": 353,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * We have no choice but to defer the uartclk update due to two",
            "\t * deadlocks. First one is caused by a recursive mutex lock which",
            "\t * happens when clk_set_rate() is called from dw8250_set_termios().",
            "\t * Second deadlock is more tricky and is caused by an inverted order of",
            "\t * the clk and tty-port mutexes lock. It happens if clock rate change"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\tty\\serial\\8250\\8250_dw.c"
          ]
        },
        {
          "file": "linux\\drivers\\tty\\serial\\8250\\8250_dw.c",
          "line": 355,
          "match": "deadlock",
          "context": [
            "\t * We have no choice but to defer the uartclk update due to two",
            "\t * deadlocks. First one is caused by a recursive mutex lock which",
            "\t * happens when clk_set_rate() is called from dw8250_set_termios().",
            "\t * Second deadlock is more tricky and is caused by an inverted order of",
            "\t * the clk and tty-port mutexes lock. It happens if clock rate change",
            "\t * is requested asynchronously while set_termios() is executed between",
            "\t * tty-port mutex lock and clk_set_rate() function invocation and"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\tty\\serial\\8250\\8250_dw.c"
          ]
        },
        {
          "file": "linux\\drivers\\tty\\serial\\8250\\8250_port.c",
          "line": 2710,
          "match": "deadlock",
          "context": [
            "}",
            "",
            "/*",
            " * Note in order to avoid the tty port mutex deadlock don't use the next method",
            " * within the uart port callbacks. Primarily it's supposed to be utilized to",
            " * handle a sudden reference clock rate change.",
            " */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\tty\\serial\\8250\\8250_port.c"
          ]
        },
        {
          "file": "linux\\drivers\\ufs\\core\\ufshcd.c",
          "line": 7910,
          "match": "deadlock",
          "context": [
            "\t * If runtime PM sent SSU and got a timeout, scsi_error_handler is",
            "\t * stuck in this function waiting for flush_work(&hba->eh_work). And",
            "\t * ufshcd_err_handler(eh_work) is stuck waiting for runtime PM. Do",
            "\t * ufshcd_link_recovery instead of eh_work to prevent deadlock.",
            "\t */",
            "\tif (hba->pm_op_in_progress) {",
            "\t\tif (ufshcd_link_recovery(hba))"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\ufs\\core\\ufshcd.c"
          ]
        },
        {
          "file": "linux\\drivers\\ufs\\core\\ufshcd.c",
          "line": 9060,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * If we get here we know that no TMFs are outstanding and also that",
            "\t * the only pending command is a START STOP UNIT command. Handle the",
            "\t * timeout of that command directly to prevent a deadlock between",
            "\t * ufshcd_set_dev_pwr_mode() and ufshcd_err_handler().",
            "\t */",
            "\tufshcd_link_recovery(hba);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\ufs\\core\\ufshcd.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\core\\devio.c",
          "line": 1559,
          "match": "deadlock",
          "context": [
            "",
            "\t/* Don't touch the device if any interfaces are claimed.",
            "\t * It could interfere with other drivers' operations, and if",
            "\t * an interface is claimed by usbfs it could easily deadlock.",
            "\t */",
            "\tif (actconfig) {",
            "\t\tint i;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\core\\devio.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\core\\hub.c",
          "line": 6342,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Don't allocate memory with GFP_KERNEL in current",
            "\t * context to avoid possible deadlock if usb mass",
            "\t * storage interface or usbnet interface(iSCSI case)",
            "\t * is included in current configuration. The easist",
            "\t * approach is to do it for every device reset,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\core\\hub.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\core\\message.c",
          "line": 1401,
          "match": "deadlock",
          "context": [
            "\t */",
            "\tif (dev->actconfig) {",
            "\t\t/*",
            "\t\t * FIXME: In order to avoid self-deadlock involving the",
            "\t\t * bandwidth_mutex, we have to mark all the interfaces",
            "\t\t * before unregistering any of them.",
            "\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\core\\message.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\core\\port.c",
          "line": 71,
          "match": "deadlock",
          "context": [
            "\t\tgoto out_hub_get;",
            "",
            "\t/*",
            "\t * Prevent deadlock if another process is concurrently",
            "\t * trying to unregister hdev.",
            "\t */",
            "\tkn = sysfs_break_active_protection(&dev->kobj, &attr->attr);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\core\\port.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\core\\port.c",
          "line": 126,
          "match": "deadlock",
          "context": [
            "\t\tgoto out_hub_get;",
            "",
            "\t/*",
            "\t * Prevent deadlock if another process is concurrently",
            "\t * trying to unregister hdev.",
            "\t */",
            "\tkn = sysfs_break_active_protection(&dev->kobj, &attr->attr);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\core\\port.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\core\\sysfs.c",
          "line": 1230,
          "match": "deadlock",
          "context": [
            "\t\tusb_authorize_interface(intf);",
            "\t} else {",
            "\t\t/*",
            "\t\t * Prevent deadlock if another process is concurrently",
            "\t\t * trying to unregister intf.",
            "\t\t */",
            "\t\tkn = sysfs_break_active_protection(&dev->kobj, &attr->attr);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\core\\sysfs.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\core\\usb.c",
          "line": 885,
          "match": "deadlock",
          "context": [
            " * Attempts to acquire the device lock, but fails if the device is",
            " * NOTATTACHED or SUSPENDED, or if iface is specified and the interface",
            " * is neither BINDING nor BOUND.  Rather than sleeping to wait for the",
            " * lock, the routine polls repeatedly.  This is to prevent deadlock with",
            " * disconnect; in some drivers (such as usb-storage) the disconnect()",
            " * or suspend() method will block waiting for a device reset to complete.",
            " *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\core\\usb.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\core\\usb.c",
          "line": 907,
          "match": "deadlock",
          "context": [
            "\twhile (!usb_trylock_device(udev)) {",
            "",
            "\t\t/* If we can't acquire the lock after waiting one second,",
            "\t\t * we're probably deadlocked */",
            "\t\tif (time_after(jiffies, jiffies_expire))",
            "\t\t\treturn -EBUSY;",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\core\\usb.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\image\\microtek.c",
          "line": 87,
          "match": "deadlock",
          "context": [
            " *\t20000516 Removed unnecessary up on instance lock in mts_remove_nolock (john)",
            " *\t20000516 Implemented (badly) scsi_abort (john)",
            " *\t20000516 Version 0.0.12j",
            " *      20000517 Hopefully removed mts_remove_nolock quasideadlock (john)",
            " *      20000517 Added mts_debug_dump to print ll USB info (john)",
            " *\t20000518 Tweaks and documentation updates (john)",
            " *\t20000518 Version 0.0.13j"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\image\\microtek.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\image\\microtek.c",
          "line": 102,
          "match": "deadlock",
          "context": [
            " *\t20000603 Version 0.2.1",
            " *\t20000620 minor cosmetic changes",
            " *\t20000620 Version 0.2.2",
            " *\t20000822 Hopefully fixed deadlock in mts_remove_nolock()",
            " *\t20000822 Fixed minor race in mts_transfer_cleanup()",
            " *\t20000822 Fixed deadlock on submission error in queuecommand",
            " *\t20000822 Version 0.2.3"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\image\\microtek.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\image\\microtek.c",
          "line": 104,
          "match": "deadlock",
          "context": [
            " *\t20000620 Version 0.2.2",
            " *\t20000822 Hopefully fixed deadlock in mts_remove_nolock()",
            " *\t20000822 Fixed minor race in mts_transfer_cleanup()",
            " *\t20000822 Fixed deadlock on submission error in queuecommand",
            " *\t20000822 Version 0.2.3",
            " *\t20000913 Reduced module size if debugging is off",
            " *\t20000913 Version 0.2.4"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\image\\microtek.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\misc\\onboard_usb_dev.c",
          "line": 502,
          "match": "deadlock",
          "context": [
            "\t * onboard_dev_remove() (e.g. through an 'unbind' by userspace),",
            "\t * make sure to re-attach it if needed.",
            "\t *",
            "\t * This needs to be done deferred to avoid self-deadlocks on systems",
            "\t * with nested onboard hubs.",
            "\t */",
            "\tschedule_work(&attach_usb_driver_work);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\misc\\onboard_usb_dev.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\misc\\usb251xb.c",
          "line": 656,
          "match": "deadlock",
          "context": [
            "\t * placed at the same i2c-bus segment. In this case an error should be",
            "\t * returned since we can't safely use the GPIO controller to clear the",
            "\t * reset state (it may affect the hub configuration) and we can't lock",
            "\t * the i2c-bus segment (it will cause a deadlock).",
            "\t */",
            "\terr = usb251x_check_gpio_chip(hub);",
            "\tif (err)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\misc\\usb251xb.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\storage\\uas.c",
          "line": 90,
          "match": "deadlock",
          "context": [
            " *",
            " * In the course of error handling and power management uas_wait_for_pending_cmnds()",
            " * needs to flush pending work items. In these contexts we cannot allocate memory",
            " * by doing block IO as we would deadlock. For the same reason we cannot wait",
            " * for anything allocating memory not heeding these constraints.",
            " *",
            " * So we have to control all work items that can be on the workqueue we flush."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\storage\\uas.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\storage\\uas.c",
          "line": 1154,
          "match": "deadlock",
          "context": [
            "\t\t\t     \"%s: alloc streams error %d after reset\",",
            "\t\t\t     __func__, err);",
            "",
            "\t/* we must unblock the host in every case lest we deadlock */",
            "\tspin_lock_irqsave(shost->host_lock, flags);",
            "\tscsi_report_bus_reset(shost, 0);",
            "\tspin_unlock_irqrestore(shost->host_lock, flags);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\storage\\uas.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\gadget\\function\\f_fs.c",
          "line": 1397,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * The fence will be unref'd in ffs_dmabuf_cleanup.",
            "\t * It can't be done here, as the unref functions might try to lock",
            "\t * the resv object, which would deadlock.",
            "\t */",
            "\tINIT_WORK(&dma_fence->work, ffs_dmabuf_cleanup);",
            "\tqueue_work(priv->ffs->io_completion_wq, &dma_fence->work);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\gadget\\function\\f_fs.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\gadget\\function\\f_fs.c",
          "line": 3500,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Legacy gadget triggers binding in functionfs_ready_callback,",
            "\t * which already uses locking; taking the same lock here would",
            "\t * cause a deadlock.",
            "\t *",
            "\t * Configfs-enabled gadgets however do need ffs_dev_lock.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\gadget\\function\\f_fs.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\gadget\\function\\f_printer.c",
          "line": 415,
          "match": "deadlock",
          "context": [
            "\t\treq->length = USB_BUFSIZE;",
            "\t\treq->complete = rx_complete;",
            "",
            "\t\t/* here, we unlock, and only unlock, to avoid deadlock. */",
            "\t\tspin_unlock(&dev->lock);",
            "\t\terror = usb_ep_queue(dev->out_ep, req, GFP_ATOMIC);",
            "\t\tspin_lock(&dev->lock);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\gadget\\function\\f_printer.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\gadget\\function\\f_printer.c",
          "line": 680,
          "match": "deadlock",
          "context": [
            "",
            "\t\tlist_add(&req->list, &dev->tx_reqs_active);",
            "",
            "\t\t/* here, we unlock, and only unlock, to avoid deadlock. */",
            "\t\tspin_unlock(&dev->lock);",
            "\t\tvalue = usb_ep_queue(dev->in_ep, req, GFP_ATOMIC);",
            "\t\tspin_lock(&dev->lock);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\gadget\\function\\f_printer.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\gadget\\udc\\core.c",
          "line": 274,
          "match": "deadlock",
          "context": [
            " * have queued some data to transfer at that time.",
            " *",
            " * Note that @req's ->complete() callback must never be called from",
            " * within usb_ep_queue() as that can create deadlock situations.",
            " *",
            " * This routine may be called in interrupt context.",
            " *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\gadget\\udc\\core.c"
          ]
        },
        {
          "file": "linux\\drivers\\vdpa\\pds\\vdpa_dev.c",
          "line": 745,
          "match": "deadlock",
          "context": [
            "\t}",
            "",
            "\t/* We use the _vdpa_register_device() call rather than the",
            "\t * vdpa_register_device() to avoid a deadlock because our",
            "\t * dev_add() is called with the vdpa_dev_lock already set",
            "\t * by vdpa_nl_cmd_dev_add_set_doit()",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\vdpa\\pds\\vdpa_dev.c"
          ]
        },
        {
          "file": "linux\\drivers\\vfio\\pci\\vfio_pci_core.c",
          "line": 659,
          "match": "deadlock",
          "context": [
            "\tpci_write_config_word(pdev, PCI_COMMAND, PCI_COMMAND_INTX_DISABLE);",
            "",
            "\t/*",
            "\t * Try to get the locks ourselves to prevent a deadlock. The",
            "\t * success of this is dependent on being able to lock the device,",
            "\t * which is not always possible.",
            "\t * We can not use the \"try\" reset interface here, which will"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\vfio\\pci\\vfio_pci_core.c"
          ]
        },
        {
          "file": "linux\\drivers\\vfio\\pci\\vfio_pci_core.c",
          "line": 2450,
          "match": "deadlock",
          "context": [
            "\t\t/*",
            "\t\t * Take the memory write lock for each device and zap BAR",
            "\t\t * mappings to prevent the user accessing the device while in",
            "\t\t * reset.  Locking multiple devices is prone to deadlock,",
            "\t\t * runaway and unwind if we hit contention.",
            "\t\t */",
            "\t\tif (!down_write_trylock(&vdev->memory_lock)) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\vfio\\pci\\vfio_pci_core.c"
          ]
        },
        {
          "file": "linux\\drivers\\vfio\\pci\\vfio_pci_intrs.c",
          "line": 161,
          "match": "deadlock",
          "context": [
            "",
            "/*",
            " * If this is triggered by an eventfd, we can't call eventfd_signal",
            " * or else we'll deadlock on the eventfd wait queue.  Return >0 when",
            " * a signal is necessary, which can then be handled via a work queue",
            " * or directly depending on the caller.",
            " */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\vfio\\pci\\vfio_pci_intrs.c"
          ]
        },
        {
          "file": "linux\\drivers\\vfio\\pci\\mlx5\\main.c",
          "line": 1284,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * As the higher VFIO layers are holding locks across reset and using",
            "\t * those same locks with the mm_lock we need to prevent ABBA deadlock",
            "\t * with the state_mutex and mm_lock.",
            "\t * In case the state_mutex was taken already we defer the cleanup work",
            "\t * to the unlock flow of the other running context."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\vfio\\pci\\mlx5\\main.c"
          ]
        },
        {
          "file": "linux\\drivers\\vfio\\pci\\virtio\\migrate.c",
          "line": 279,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * As the higher VFIO layers are holding locks across reset and using",
            "\t * those same locks with the mm_lock we need to prevent ABBA deadlock",
            "\t * with the state_mutex and mm_lock.",
            "\t * In case the state_mutex was taken already we defer the cleanup work",
            "\t * to the unlock flow of the other running context."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\vfio\\pci\\virtio\\migrate.c"
          ]
        },
        {
          "file": "linux\\drivers\\video\\fbdev\\smscufx.c",
          "line": 901,
          "match": "deadlock",
          "context": [
            "",
            "/* NOTE: fb_defio.c is holding info->fbdefio.mutex",
            " *   Touching ANY framebuffer memory that triggers a page fault",
            " *   in fb_defio will cause a deadlock, when it also tries to",
            " *   grab the same mutex. */",
            "static void ufx_dpy_deferred_io(struct fb_info *info, struct list_head *pagereflist)",
            "{"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\video\\fbdev\\smscufx.c"
          ]
        },
        {
          "file": "linux\\drivers\\video\\fbdev\\smscufx.c",
          "line": 1793,
          "match": "deadlock",
          "context": [
            "\tdev->urbs.available++;",
            "\tspin_unlock_irqrestore(&dev->urbs.lock, flags);",
            "",
            "\t/* When using fb_defio, we deadlock if up() is called",
            "\t * while another is waiting. So queue to another process */",
            "\tif (fb_defio)",
            "\t\tschedule_delayed_work(&unode->release_urb_work, 0);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\video\\fbdev\\smscufx.c"
          ]
        },
        {
          "file": "linux\\drivers\\video\\fbdev\\udlfb.c",
          "line": 723,
          "match": "deadlock",
          "context": [
            "/*",
            " * NOTE: fb_defio.c is holding info->fbdefio.mutex",
            " *   Touching ANY framebuffer memory that triggers a page fault",
            " *   in fb_defio will cause a deadlock, when it also tries to",
            " *   grab the same mutex.",
            " */",
            "static void dlfb_dpy_deferred_io(struct fb_info *info, struct list_head *pagereflist)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\video\\fbdev\\udlfb.c"
          ]
        },
        {
          "file": "linux\\drivers\\video\\fbdev\\core\\fbcon.c",
          "line": 95,
          "match": "deadlock",
          "context": [
            " *   means concurrent access to the same fbdev from both fbcon and userspace",
            " *   will blow up. To fix this all fbcon calls from fbmem.c need to be moved out",
            " *   of fb_lock/unlock protected sections, since otherwise we'll recurse and",
            " *   deadlock eventually. Aside: Due to these deadlock issues the fbdev code in",
            " *   fbmem.c cannot use locking asserts, and there's lots of callers which get",
            " *   the rules wrong, e.g. fbsysfs.c entirely missed fb_lock/unlock calls too.",
            " */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\video\\fbdev\\core\\fbcon.c"
          ]
        },
        {
          "file": "linux\\drivers\\video\\fbdev\\core\\fbcon.c",
          "line": 95,
          "match": "deadlock",
          "context": [
            " *   means concurrent access to the same fbdev from both fbcon and userspace",
            " *   will blow up. To fix this all fbcon calls from fbmem.c need to be moved out",
            " *   of fb_lock/unlock protected sections, since otherwise we'll recurse and",
            " *   deadlock eventually. Aside: Due to these deadlock issues the fbdev code in",
            " *   fbmem.c cannot use locking asserts, and there's lots of callers which get",
            " *   the rules wrong, e.g. fbsysfs.c entirely missed fb_lock/unlock calls too.",
            " */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\video\\fbdev\\core\\fbcon.c"
          ]
        },
        {
          "file": "linux\\drivers\\virt\\nitro_enclaves\\ne_misc_dev.c",
          "line": 1497,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Acquire the enclave list mutex before the enclave mutex",
            "\t * in order to avoid deadlocks with @ref ne_event_work_handler.",
            "\t */",
            "\tmutex_lock(&ne_pci_dev->enclaves_list_mutex);",
            "\tmutex_lock(&ne_enclave->enclave_info_mutex);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\virt\\nitro_enclaves\\ne_misc_dev.c"
          ]
        },
        {
          "file": "linux\\drivers\\virt\\vboxguest\\vboxguest_utils.c",
          "line": 776,
          "match": "DEADLOCK",
          "context": [
            "\t[-VERR_SEEK_ON_DEVICE]                           = -ESPIPE,",
            "\t[-VERR_WRITE_PROTECT]                            = -EROFS,",
            "\t[-VERR_BROKEN_PIPE]                              = -EPIPE,",
            "\t[-VERR_DEADLOCK]                                 = -EDEADLK,",
            "\t[-VERR_FILENAME_TOO_LONG]                        = -ENAMETOOLONG,",
            "\t[-VERR_FILE_LOCK_FAILED]                         = -ENOLCK,",
            "\t[-VERR_NOT_IMPLEMENTED]                          = -ENOSYS,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\virt\\vboxguest\\vboxguest_utils.c"
          ]
        },
        {
          "file": "linux\\drivers\\xen\\xenbus\\xenbus_dev_frontend.c",
          "line": 345,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * We might be called in xenbus_thread().",
            "\t * Use workqueue to avoid deadlock.",
            "\t */",
            "\tu = container_of(kref, struct xenbus_file_priv, kref);",
            "\tschedule_work(&u->wq);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\xen\\xenbus\\xenbus_dev_frontend.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_cache.c",
          "line": 702,
          "match": "deadlock",
          "context": [
            "",
            "/*",
            " * We can only have one thread cannibalizing other cached btree nodes at a time,",
            " * or we'll deadlock. We use an open coded mutex to ensure that, which a",
            " * cannibalize_bucket() will take. This means every time we unlock the root of",
            " * the btree, we need to release this lock if we have it held.",
            " */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_cache.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_gc.c",
          "line": 1205,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * We have to use trylock here. Otherwise, we would",
            "\t * introduce a deadlock in the RO path - we take the",
            "\t * state lock at the start of going RO.",
            "\t */",
            "\tif (!down_read_trylock(&c->state_lock)) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_gc.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_io.c",
          "line": 1692,
          "match": "deadlock",
          "context": [
            "}",
            "",
            "/*",
            " * XXX This allocates multiple times from the same mempools, and can deadlock",
            " * under sufficient memory pressure (but is only a debug path)",
            " */",
            "static int btree_node_read_all_replicas(struct bch_fs *c, struct btree *b, bool sync)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_io.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_locking.c",
          "line": 155,
          "match": "deadlock",
          "context": [
            "\treturn false;",
            "}",
            "",
            "static void trace_would_deadlock(struct lock_graph *g, struct btree_trans *trans)",
            "{",
            "\tstruct bch_fs *c = trans->c;",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_locking.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_locking.c",
          "line": 159,
          "match": "deadlock",
          "context": [
            "{",
            "\tstruct bch_fs *c = trans->c;",
            "",
            "\tcount_event(c, trans_restart_would_deadlock);",
            "",
            "\tif (trace_trans_restart_would_deadlock_enabled()) {",
            "\t\tstruct printbuf buf = PRINTBUF;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_locking.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_locking.c",
          "line": 161,
          "match": "deadlock",
          "context": [
            "",
            "\tcount_event(c, trans_restart_would_deadlock);",
            "",
            "\tif (trace_trans_restart_would_deadlock_enabled()) {",
            "\t\tstruct printbuf buf = PRINTBUF;",
            "",
            "\t\tbuf.atomic++;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_locking.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_locking.c",
          "line": 167,
          "match": "deadlock",
          "context": [
            "\t\tbuf.atomic++;",
            "\t\tprint_cycle(&buf, g);",
            "",
            "\t\ttrace_trans_restart_would_deadlock(trans, buf.buf);",
            "\t\tprintbuf_exit(&buf);",
            "\t}",
            "}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_locking.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_locking.c",
          "line": 175,
          "match": "deadlock",
          "context": [
            "static int abort_lock(struct lock_graph *g, struct trans_waiting_for_lock *i)",
            "{",
            "\tif (i == g->g) {",
            "\t\ttrace_would_deadlock(g, i->trans);",
            "\t\treturn btree_trans_restart_foreign_task(i->trans,",
            "\t\t\t\t\tBCH_ERR_transaction_restart_would_deadlock,",
            "\t\t\t\t\t_THIS_IP_);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_locking.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_locking.c",
          "line": 177,
          "match": "deadlock",
          "context": [
            "\tif (i == g->g) {",
            "\t\ttrace_would_deadlock(g, i->trans);",
            "\t\treturn btree_trans_restart_foreign_task(i->trans,",
            "\t\t\t\t\tBCH_ERR_transaction_restart_would_deadlock,",
            "\t\t\t\t\t_THIS_IP_);",
            "\t} else {",
            "\t\ti->trans->lock_must_abort = true;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_locking.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_locking.c",
          "line": 280,
          "match": "deadlock",
          "context": [
            "\t\tif (cycle)",
            "\t\t\treturn 0;",
            "",
            "\t\ttrace_and_count(trans->c, trans_restart_would_deadlock_recursion_limit, trans, _RET_IP_);",
            "\t\treturn btree_trans_restart(orig_trans, BCH_ERR_transaction_restart_deadlock_recursion_limit);",
            "\t}",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_locking.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_locking.c",
          "line": 281,
          "match": "deadlock",
          "context": [
            "\t\t\treturn 0;",
            "",
            "\t\ttrace_and_count(trans->c, trans_restart_would_deadlock_recursion_limit, trans, _RET_IP_);",
            "\t\treturn btree_trans_restart(orig_trans, BCH_ERR_transaction_restart_deadlock_recursion_limit);",
            "\t}",
            "",
            "\t__lock_graph_down(g, trans);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_locking.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_locking.c",
          "line": 293,
          "match": "deadlock",
          "context": [
            "\treturn t1 + t2 > 1;",
            "}",
            "",
            "int bch2_check_for_deadlock(struct btree_trans *trans, struct printbuf *cycle)",
            "{",
            "\tstruct lock_graph g;",
            "\tstruct trans_waiting_for_lock *top;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_locking.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_locking.c",
          "line": 307,
          "match": "deadlock",
          "context": [
            "\t\tif (cycle)",
            "\t\t\treturn -1;",
            "",
            "\t\ttrace_would_deadlock(&g, trans);",
            "\t\treturn btree_trans_restart(trans, BCH_ERR_transaction_restart_would_deadlock);",
            "\t}",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_locking.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_locking.c",
          "line": 308,
          "match": "deadlock",
          "context": [
            "\t\t\treturn -1;",
            "",
            "\t\ttrace_would_deadlock(&g, trans);",
            "\t\treturn btree_trans_restart(trans, BCH_ERR_transaction_restart_would_deadlock);",
            "\t}",
            "",
            "\tlock_graph_down(&g, trans);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_locking.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_locking.c",
          "line": 387,
          "match": "deadlock",
          "context": [
            "",
            "\t\t\t\ttop->lock_start_time = trans->locking_wait.start_time;",
            "",
            "\t\t\t\t/* Don't check for self deadlock: */",
            "\t\t\t\tif (trans == top->trans ||",
            "\t\t\t\t    !lock_type_conflicts(lock_held, trans->locking_wait.lock_want))",
            "\t\t\t\t\tcontinue;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_locking.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_locking.c",
          "line": 415,
          "match": "deadlock",
          "context": [
            "\treturn ret;",
            "}",
            "",
            "int bch2_six_check_for_deadlock(struct six_lock *lock, void *p)",
            "{",
            "\tstruct btree_trans *trans = p;",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_locking.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_locking.c",
          "line": 419,
          "match": "deadlock",
          "context": [
            "{",
            "\tstruct btree_trans *trans = p;",
            "",
            "\treturn bch2_check_for_deadlock(trans, NULL);",
            "}",
            "",
            "int __bch2_btree_node_lock_write(struct btree_trans *trans, struct btree_path *path,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_locking.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_key_cache.c",
          "line": 490,
          "match": "deadlock",
          "context": [
            "err:",
            "\tbch2_fs_fatal_err_on(ret &&",
            "\t\t\t     !bch2_err_matches(ret, BCH_ERR_transaction_restart) &&",
            "\t\t\t     !bch2_err_matches(ret, BCH_ERR_journal_reclaim_would_deadlock) &&",
            "\t\t\t     !bch2_journal_error(j), c,",
            "\t\t\t     \"flushing key cache: %s\", bch2_err_str(ret));",
            "\tif (ret)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_key_cache.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_trans_commit.c",
          "line": 115,
          "match": "deadlock",
          "context": [
            "\t\tbch2_btree_node_unlock_write(trans, trans->paths + i->path, insert_l(trans, i)->b);",
            "\t}",
            "",
            "\ttrace_and_count(trans->c, trans_restart_would_deadlock_write, trans);",
            "\treturn btree_trans_restart(trans, BCH_ERR_transaction_restart_would_deadlock_write);",
            "}",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_trans_commit.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_trans_commit.c",
          "line": 116,
          "match": "deadlock",
          "context": [
            "\t}",
            "",
            "\ttrace_and_count(trans->c, trans_restart_would_deadlock_write, trans);",
            "\treturn btree_trans_restart(trans, BCH_ERR_transaction_restart_would_deadlock_write);",
            "}",
            "",
            "static inline int bch2_trans_lock_write(struct btree_trans *trans)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_trans_commit.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_trans_commit.c",
          "line": 901,
          "match": "deadlock",
          "context": [
            "\t\t */",
            "\t\tif ((flags & BCH_TRANS_COMMIT_journal_reclaim) &&",
            "\t\t    watermark < BCH_WATERMARK_reclaim) {",
            "\t\t\tret = bch_err_throw(c, journal_reclaim_would_deadlock);",
            "\t\t\tgoto out;",
            "\t\t}",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_trans_commit.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_update_interior.c",
          "line": 1177,
          "match": "deadlock",
          "context": [
            "\tif (watermark < BCH_WATERMARK_reclaim &&",
            "\t    test_bit(JOURNAL_space_low, &c->journal.flags)) {",
            "\t\tif (flags & BCH_TRANS_COMMIT_journal_reclaim)",
            "\t\t\treturn ERR_PTR(-BCH_ERR_journal_reclaim_would_deadlock);",
            "",
            "\t\tret = drop_locks_do(trans,",
            "\t\t\t({ wait_event(c->journal.wait, !test_bit(JOURNAL_space_low, &c->journal.flags)); 0; }));"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_update_interior.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_update_interior.c",
          "line": 1253,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * We don't want to allocate if we're in an error state, that can cause",
            "\t * deadlock on emergency shutdown due to open buckets getting stuck in",
            "\t * the btree_reserve_cache after allocator shutdown has cleared it out.",
            "\t * This check needs to come after adding us to the btree_interior_update",
            "\t * list but before calling bch2_btree_reserve_get, to synchronize with"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_update_interior.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_update_interior.c",
          "line": 1282,
          "match": "deadlock",
          "context": [
            "\t\tif (bch2_err_matches(ret, ENOSPC) &&",
            "\t\t    (flags & BCH_TRANS_COMMIT_journal_reclaim) &&",
            "\t\t    watermark < BCH_WATERMARK_reclaim) {",
            "\t\t\tret = bch_err_throw(c, journal_reclaim_would_deadlock);",
            "\t\t\tgoto err;",
            "\t\t}",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_update_interior.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_update_interior.c",
          "line": 1313,
          "match": "deadlock",
          "context": [
            "\tbch2_btree_update_free(as, trans);",
            "\tif (!bch2_err_matches(ret, ENOSPC) &&",
            "\t    !bch2_err_matches(ret, EROFS) &&",
            "\t    ret != -BCH_ERR_journal_reclaim_would_deadlock &&",
            "\t    ret != -BCH_ERR_journal_shutdown)",
            "\t\tbch_err_fn_ratelimited(c, ret);",
            "\treturn ERR_PTR(ret);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_update_interior.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_update_interior.c",
          "line": 2027,
          "match": "deadlock",
          "context": [
            "\tBUG_ON(!btree_node_locked(&trans->paths[path], level));",
            "",
            "\t/*",
            "\t * Work around a deadlock caused by the btree write buffer not doing",
            "\t * merges and leaving tons of merges for us to do - we really don't need",
            "\t * to be doing merges at all from the interior update path, and if the",
            "\t * interior update path is generating too many new interior updates we"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_update_interior.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_update_interior.c",
          "line": 2031,
          "match": "deadlock",
          "context": [
            "\t * merges and leaving tons of merges for us to do - we really don't need",
            "\t * to be doing merges at all from the interior update path, and if the",
            "\t * interior update path is generating too many new interior updates we",
            "\t * deadlock:",
            "\t */",
            "\tif ((flags & BCH_WATERMARK_MASK) == BCH_WATERMARK_interior_updates)",
            "\t\treturn 0;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_update_interior.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_update_interior.c",
          "line": 2194,
          "match": "deadlock",
          "context": [
            "\t\tbch2_path_put(trans, new_path, true);",
            "\tbch2_path_put(trans, sib_path, true);",
            "\tbch2_trans_verify_locks(trans);",
            "\tif (ret == -BCH_ERR_journal_reclaim_would_deadlock)",
            "\t\tret = 0;",
            "\tif (!ret)",
            "\t\tret = bch2_trans_relock(trans);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_update_interior.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_write_buffer.c",
          "line": 321,
          "match": "deadlock",
          "context": [
            "\t *",
            "\t * However, since we're not flushing in the order they appear in the",
            "\t * journal we won't be able to drop our journal pin until everything is",
            "\t * flushed - which means this could deadlock the journal if we weren't",
            "\t * passing BCH_TRANS_COMMIT_journal_reclaim. This causes the update to fail",
            "\t * if it would block taking a journal reservation.",
            "\t *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_write_buffer.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_write_buffer.c",
          "line": 396,
          "match": "deadlock",
          "context": [
            "\t\tbool accounting_accumulated = false;",
            "\t\tdo {",
            "\t\t\tif (race_fault()) {",
            "\t\t\t\tret = bch_err_throw(c, journal_reclaim_would_deadlock);",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_write_buffer.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\btree_write_buffer.c",
          "line": 408,
          "match": "deadlock",
          "context": [
            "",
            "\t\tif (!ret) {",
            "\t\t\tk->journal_seq = 0;",
            "\t\t} else if (ret == -BCH_ERR_journal_reclaim_would_deadlock) {",
            "\t\t\tslowpath++;",
            "\t\t\tret = 0;",
            "\t\t} else"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\btree_write_buffer.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\debug.c",
          "line": 818,
          "match": "deadlock",
          "context": [
            "\t.read\t\t= btree_transaction_stats_read,",
            "};",
            "",
            "/* walk btree transactions until we find a deadlock and print it */",
            "static void btree_deadlock_to_text(struct printbuf *out, struct bch_fs *c)",
            "{",
            "\tstruct btree_trans *trans;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\debug.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\debug.c",
          "line": 819,
          "match": "deadlock",
          "context": [
            "};",
            "",
            "/* walk btree transactions until we find a deadlock and print it */",
            "static void btree_deadlock_to_text(struct printbuf *out, struct bch_fs *c)",
            "{",
            "\tstruct btree_trans *trans;",
            "\tulong iter = 0;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\debug.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\debug.c",
          "line": 838,
          "match": "deadlock",
          "context": [
            "",
            "\t\tu32 seq = seqmutex_unlock(&c->btree_trans_lock);",
            "",
            "\t\tbool found = bch2_check_for_deadlock(trans, out) != 0;",
            "",
            "\t\tclosure_put(&trans->ref);",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\debug.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\debug.c",
          "line": 879,
          "match": "deadlock",
          "context": [
            "\treturn ret ?: i->ret;",
            "}",
            "",
            "static ssize_t bch2_btree_deadlock_read(struct file *file, char __user *buf,",
            "\t\t\t\t\tsize_t size, loff_t *ppos)",
            "{",
            "\treturn bch2_simple_print(file, buf, size, ppos, btree_deadlock_to_text);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\debug.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\debug.c",
          "line": 882,
          "match": "deadlock",
          "context": [
            "static ssize_t bch2_btree_deadlock_read(struct file *file, char __user *buf,",
            "\t\t\t\t\tsize_t size, loff_t *ppos)",
            "{",
            "\treturn bch2_simple_print(file, buf, size, ppos, btree_deadlock_to_text);",
            "}",
            "",
            "static const struct file_operations btree_deadlock_ops = {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\debug.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\debug.c",
          "line": 885,
          "match": "deadlock",
          "context": [
            "\treturn bch2_simple_print(file, buf, size, ppos, btree_deadlock_to_text);",
            "}",
            "",
            "static const struct file_operations btree_deadlock_ops = {",
            "\t.owner\t\t= THIS_MODULE,",
            "\t.open\t\t= bch2_dump_open,",
            "\t.release\t= bch2_dump_release,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\debug.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\debug.c",
          "line": 889,
          "match": "deadlock",
          "context": [
            "\t.owner\t\t= THIS_MODULE,",
            "\t.open\t\t= bch2_dump_open,",
            "\t.release\t= bch2_dump_release,",
            "\t.read\t\t= bch2_btree_deadlock_read,",
            "};",
            "",
            "static ssize_t bch2_write_points_read(struct file *file, char __user *buf,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\debug.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\debug.c",
          "line": 957,
          "match": "deadlock",
          "context": [
            "\tdebugfs_create_file(\"btree_transaction_stats\", 0400, c->fs_debug_dir,",
            "\t\t\t    c, &btree_transaction_stats_op);",
            "",
            "\tdebugfs_create_file(\"btree_deadlock\", 0400, c->fs_debug_dir,",
            "\t\t\t    c->btree_debug, &btree_deadlock_ops);",
            "",
            "\tdebugfs_create_file(\"write_points\", 0400, c->fs_debug_dir,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\debug.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\debug.c",
          "line": 958,
          "match": "deadlock",
          "context": [
            "\t\t\t    c, &btree_transaction_stats_op);",
            "",
            "\tdebugfs_create_file(\"btree_deadlock\", 0400, c->fs_debug_dir,",
            "\t\t\t    c->btree_debug, &btree_deadlock_ops);",
            "",
            "\tdebugfs_create_file(\"write_points\", 0400, c->fs_debug_dir,",
            "\t\t\t    c->btree_debug, &write_points_ops);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\debug.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\fs-io-buffered.c",
          "line": 1003,
          "match": "deadlock",
          "context": [
            "again:",
            "\t\t/*",
            "\t\t * Bring in the user page that we will copy from _first_.",
            "\t\t * Otherwise there's a nasty deadlock on copying from the",
            "\t\t * same page as we're writing to, without it being marked",
            "\t\t * up-to-date.",
            "\t\t *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\fs-io-buffered.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\fs-io-direct.c",
          "line": 128,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * This is one of the sketchier things I've encountered: we have to skip",
            "\t * the dirtying of requests that are internal from the kernel (i.e. from",
            "\t * loopback), because we'll deadlock on page_lock.",
            "\t */",
            "\tdio->should_dirty = iter_is_iovec(iter);",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\fs-io-direct.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\fs.c",
          "line": 621,
          "match": "deadlock",
          "context": [
            "\t *",
            "\t * also, calling bch2_inode_hash_insert() without passing in the",
            "\t * transaction object is sketchy - if we could ever end up in",
            "\t * __wait_on_freeing_inode(), we'd risk deadlock.",
            "\t *",
            "\t * But that shouldn't be possible, since we still have the inode locked",
            "\t * that we just created, and we _really_ can't take a transaction"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\fs.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\recovery.c",
          "line": 382,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * First, attempt to replay keys in sorted order. This is more",
            "\t * efficient - better locality of btree access -  but some might fail if",
            "\t * that would cause a journal deadlock.",
            "\t */",
            "\tdarray_for_each(*keys, k) {",
            "\t\tcond_resched();"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\recovery.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\six.c",
          "line": 482,
          "match": "deadlock",
          "context": [
            "\t\t\t * If should_sleep_fn() returns an error, we are",
            "\t\t\t * required to return that error even if we already",
            "\t\t\t * acquired the lock - should_sleep_fn() might have",
            "\t\t\t * modified external state (e.g. when the deadlock cycle",
            "\t\t\t * detector in bcachefs issued a transaction restart)",
            "\t\t\t */",
            "\t\t\traw_spin_lock(&lock->wait_lock);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\six.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\six.c",
          "line": 521,
          "match": "deadlock",
          "context": [
            " * @ip:\t\tip parameter for lockdep/lockstat, i.e. _THIS_IP_",
            " *",
            " * This is the most general six_lock() variant, with parameters to support full",
            " * cycle detection for deadlock avoidance.",
            " *",
            " * The code calling this function must implement tracking of held locks, and the",
            " * @wait object should be embedded into the struct that tracks held locks -"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\six.c"
          ]
        },
        {
          "file": "linux\\fs\\bcachefs\\six.c",
          "line": 808,
          "match": "deadlock",
          "context": [
            " * When an upper layer is implementing lock reentrency, we may have both read",
            " * and intent locks on the same lock.",
            " *",
            " * When we need to take a write lock, the read locks will cause self-deadlock,",
            " * because six locks themselves do not track which read locks are held by the",
            " * current thread and which are held by a different thread - it does no",
            " * per-thread tracking of held locks."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\bcachefs\\six.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\acl.c",
          "line": 83,
          "match": "deadlock",
          "context": [
            "\t\tsize = posix_acl_xattr_size(acl->a_count);",
            "\t\t/*",
            "\t\t * We're holding a transaction handle, so use a NOFS memory",
            "\t\t * allocation context to avoid deadlock if reclaim happens.",
            "\t\t */",
            "\t\tnofs_flag = memalloc_nofs_save();",
            "\t\tvalue = kmalloc(size, GFP_KERNEL);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\acl.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\async-thread.c",
          "line": 270,
          "match": "deadlock",
          "context": [
            "\t\t\t * on another Btrfs filesystem via, e.g., a loop device.",
            "\t\t\t * Therefore, we must not allow the current work item to",
            "\t\t\t * be recycled until we are really done, otherwise we",
            "\t\t\t * break the above assumption and can deadlock.",
            "\t\t\t */",
            "\t\t\tfree_self = true;",
            "\t\t} else {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\async-thread.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\block-group.c",
          "line": 729,
          "match": "deadlock",
          "context": [
            "\t\twakeup = false;",
            "#endif",
            "\t/*",
            "\t * We don't want to deadlock with somebody trying to allocate a new",
            "\t * extent for the extent root while also trying to search the extent",
            "\t * root to add free space.  So we skip locking and search the commit",
            "\t * root, since its read-only"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\block-group.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\block-group.c",
          "line": 4031,
          "match": "deadlock",
          "context": [
            " *    group item to the extent btree and the device extent items to the devices",
            " *    btree.",
            " *",
            " * This is done to prevent deadlocks. For example when COWing a node from the",
            " * extent btree we are holding a write lock on the node's parent and if we",
            " * trigger chunk allocation and attempted to insert the new block group item",
            " * in the extent btree right way, we could deadlock because the path for the"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\block-group.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\block-group.c",
          "line": 4034,
          "match": "deadlock",
          "context": [
            " * This is done to prevent deadlocks. For example when COWing a node from the",
            " * extent btree we are holding a write lock on the node's parent and if we",
            " * trigger chunk allocation and attempted to insert the new block group item",
            " * in the extent btree right way, we could deadlock because the path for the",
            " * insertion can include that parent node. At first glance it seems impossible",
            " * to trigger chunk allocation after starting a transaction since tasks should",
            " * reserve enough transaction units (metadata space), however while that is true"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\block-group.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\block-group.c",
          "line": 4108,
          "match": "deadlock",
          "context": [
            " * as all the updates and insertions into the chunk btree must be done while",
            " * holding fs_info->chunk_mutex. This is important to guarantee that while COWing",
            " * an extent buffer from the chunks btree we never trigger allocation of a new",
            " * system chunk, which would result in a deadlock (trying to lock twice an",
            " * extent buffer of the chunk btree, first time before triggering the chunk",
            " * allocation and the second time during chunk allocation while attempting to",
            " * update the chunks btree). The system chunk array is also updated while holding"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\block-group.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\block-group.c",
          "line": 4149,
          "match": "deadlock",
          "context": [
            "\t\treturn -ENOSPC;",
            "\t/*",
            "\t * Allocation of system chunks can not happen through this path, as we",
            "\t * could end up in a deadlock if we are allocating a data or metadata",
            "\t * chunk and there is another task modifying the chunk btree.",
            "\t *",
            "\t * This is because while we are holding the chunk mutex, we will attempt"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\block-group.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\block-group.c",
          "line": 4157,
          "match": "deadlock",
          "context": [
            "\t * device item in the chunk btree, while the other task that is modifying",
            "\t * the chunk btree is attempting to COW an extent buffer while holding a",
            "\t * lock on it and on its parent - if the COW operation triggers a system",
            "\t * chunk allocation, then we can deadlock because we are holding the",
            "\t * chunk mutex and we may need to access that extent buffer or its parent",
            "\t * in order to add the chunk item or update a device item.",
            "\t *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\block-group.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\block-group.c",
          "line": 4380,
          "match": "deadlock",
          "context": [
            " *\t\t\tof an existing item.",
            " *",
            " * This is used in a context where we need to update the chunk btree outside",
            " * block group allocation and removal, to avoid a deadlock with a concurrent",
            " * task that is allocating a metadata or data block group and therefore needs to",
            " * update the chunk btree while holding the chunk mutex. After the update to the",
            " * chunk btree is done, btrfs_trans_release_chunk_metadata() should be called."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\block-group.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\compression.c",
          "line": 882,
          "match": "deadlock",
          "context": [
            "\t\t * time is bounded so we get to a workspace eventually. This",
            "\t\t * makes our caller's life easier.",
            "\t\t *",
            "\t\t * To prevent silent and low-probability deadlocks (when the",
            "\t\t * initial preallocation fails), check if there are any",
            "\t\t * workspaces at all.",
            "\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\compression.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\defrag.c",
          "line": 493,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * We don't need a lock on a leaf. btrfs_realloc_node() will lock all",
            "\t * leafs from path->nodes[1], so set lowest_level to 1 to avoid later",
            "\t * a deadlock (attempting to write lock an already write locked leaf).",
            "\t */",
            "\tpath->lowest_level = 1;",
            "\twret = btrfs_search_slot(trans, root, &key, path, 0, 1);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\defrag.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\defrag.c",
          "line": 1016,
          "match": "deadlock",
          "context": [
            "\t\t * If this range of the extent map is already flagged for delalloc,",
            "\t\t * skip it, because:",
            "\t\t *",
            "\t\t * 1) We could deadlock later, when trying to reserve space for",
            "\t\t *    delalloc, because in case we can't immediately reserve space",
            "\t\t *    the flusher can start delalloc and wait for the respective",
            "\t\t *    ordered extents to complete. The deadlock would happen"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\defrag.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\defrag.c",
          "line": 1019,
          "match": "deadlock",
          "context": [
            "\t\t * 1) We could deadlock later, when trying to reserve space for",
            "\t\t *    delalloc, because in case we can't immediately reserve space",
            "\t\t *    the flusher can start delalloc and wait for the respective",
            "\t\t *    ordered extents to complete. The deadlock would happen",
            "\t\t *    because we do the space reservation while holding the range",
            "\t\t *    locked, and starting writeback, or finishing an ordered",
            "\t\t *    extent, requires locking the range;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\defrag.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\defrag.c",
          "line": 1246,
          "match": "deadlock",
          "context": [
            "\t * which range really needs to be defragged.",
            "\t *",
            "\t * And this time we have extent locked already, pass @locked = true",
            "\t * so that we won't relock the extent range and cause deadlock.",
            "\t */",
            "\tret = defrag_collect_targets(inode, start, len, extent_thresh,",
            "\t\t\t\t     newer_than, do_compress, true,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\defrag.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\delalloc-space.c",
          "line": 333,
          "match": "deadlock",
          "context": [
            "\t * lockdep shut its filthy mouth.",
            "\t *",
            "\t * If we have a transaction open (can happen if we call truncate_block",
            "\t * from truncate), then we need FLUSH_LIMIT so we don't deadlock.",
            "\t */",
            "\tif (noflush || btrfs_is_free_space_inode(inode)) {",
            "\t\tflush = BTRFS_RESERVE_NO_FLUSH;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\delalloc-space.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\delayed-inode.c",
          "line": 1168,
          "match": "deadlock",
          "context": [
            "\t}",
            "",
            "\t/*",
            "\t * Release the path to avoid a potential deadlock and lockdep splat when",
            "\t * releasing the delayed node, as that requires taking the delayed node's",
            "\t * mutex. If another task starts running delayed items before we take",
            "\t * the mutex, it will first lock the mutex and then it may try to lock"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\delayed-inode.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\direct-io.c",
          "line": 93,
          "match": "deadlock",
          "context": [
            "\t\t\t * If we are doing a DIO read and the ordered extent we",
            "\t\t\t * found is for a buffered write, we can not wait for it",
            "\t\t\t * to complete and retry, because if we do so we can",
            "\t\t\t * deadlock with concurrent buffered writes on page",
            "\t\t\t * locks. This happens only if our DIO read covers more",
            "\t\t\t * than one extent map, if at this point has already",
            "\t\t\t * created an ordered extent for a previous extent map"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\direct-io.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\direct-io.c",
          "line": 115,
          "match": "deadlock",
          "context": [
            "\t\t\t * We could trigger writeback for this range (and wait",
            "\t\t\t * for it to complete) and then invalidate the pages for",
            "\t\t\t * this range (through invalidate_inode_pages2_range()),",
            "\t\t\t * but that can lead us to a deadlock with a concurrent",
            "\t\t\t * call to readahead (a buffered read or a defrag call",
            "\t\t\t * triggered a readahead) on a page lock due to an",
            "\t\t\t * ordered dio extent we created before but did not have"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\direct-io.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\direct-io.c",
          "line": 429,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * We always try to allocate data space and must do it before locking",
            "\t * the file range, to avoid deadlocks with concurrent writes to the same",
            "\t * range if the range has several extents and the writes don't expand the",
            "\t * current i_size (the inode lock is taken in shared mode). If we fail to",
            "\t * allocate data space here we continue and later, after locking the"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\direct-io.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\direct-io.c",
          "line": 730,
          "match": "deadlock",
          "context": [
            "\t * Check if we are doing a partial write.  If we are, we need to split",
            "\t * the ordered extent to match the submitted bio.  Hang on to the",
            "\t * remaining unfinishable ordered_extent in dio_data so that it can be",
            "\t * cancelled in iomap_end to avoid a deadlock wherein faulting the",
            "\t * remaining pages is blocked on the outstanding ordered extent.",
            "\t */",
            "\tif (iter->flags & IOMAP_WRITE) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\direct-io.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\direct-io.c",
          "line": 877,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * The iov_iter can be mapped to the same file range we are writing to.",
            "\t * If that's the case, then we will deadlock in the iomap code, because",
            "\t * it first calls our callback btrfs_dio_iomap_begin(), which will create",
            "\t * an ordered extent, and after that it will fault in the pages that the",
            "\t * iov_iter refers to. During the fault in we end up in the readahead"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\direct-io.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\direct-io.c",
          "line": 883,
          "match": "deadlock",
          "context": [
            "\t * iov_iter refers to. During the fault in we end up in the readahead",
            "\t * pages code (starting at btrfs_readahead()), which will lock the range,",
            "\t * find that ordered extent and then wait for it to complete (at",
            "\t * btrfs_lock_and_flush_ordered_range()), resulting in a deadlock since",
            "\t * obviously the ordered extent can never complete as we didn't submit",
            "\t * yet the respective bio(s). This always happens when the buffer is",
            "\t * memory mapped to the same file range, since the iomap DIO code always"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\direct-io.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\direct-io.c",
          "line": 904,
          "match": "deadlock",
          "context": [
            "\t\t/*",
            "\t\t * If we have a synchronous write, we must make sure the fsync",
            "\t\t * triggered by the iomap_dio_complete() call below doesn't",
            "\t\t * deadlock on the inode lock - we are already holding it and we",
            "\t\t * can't call it after unlocking because we may need to complete",
            "\t\t * partial writes due to the input buffer (or parts of it) not",
            "\t\t * being already faulted in."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\direct-io.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\direct-io.c",
          "line": 1038,
          "match": "deadlock",
          "context": [
            "\t * which can still trigger page fault ins despite having set ->nofault",
            "\t * to true of our 'to' iov_iter.",
            "\t *",
            "\t * The difference to direct IO writes is that we deadlock when trying",
            "\t * to lock the extent range in the inode's tree during he page reads",
            "\t * triggered by the fault in (while for writes it is due to waiting for",
            "\t * our own ordered extent). This is because for direct IO reads,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\direct-io.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\disk-io.c",
          "line": 852,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * We're holding a transaction handle, so use a NOFS memory allocation",
            "\t * context to avoid deadlock if reclaim happens.",
            "\t */",
            "\tnofs_flag = memalloc_nofs_save();",
            "\troot = btrfs_alloc_root(fs_info, objectid, GFP_KERNEL);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\disk-io.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\disk-io.c",
          "line": 4367,
          "match": "deadlock",
          "context": [
            "\t\t * and then a transaction commit runs the same delayed nodes",
            "\t\t * before any delayed worker has done something with the nodes.",
            "\t\t * We must wait for any worker here and not at transaction",
            "\t\t * commit time since that could cause a deadlock.",
            "\t\t * This is a very rare case.",
            "\t\t */",
            "\t\tbtrfs_flush_workqueue(fs_info->delayed_workers);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\disk-io.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\extent_io.c",
          "line": 2431,
          "match": "deadlock",
          "context": [
            "\t\t/*",
            "\t\t * If we're looping we could run into a page that is locked by a",
            "\t\t * writer and that writer could be waiting on writeback for a",
            "\t\t * page in our current bio, and thus deadlock, so flush the",
            "\t\t * write bio here.",
            "\t\t */",
            "\t\tsubmit_write_bio(bio_ctrl, 0);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\extent_io.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\extent-tree.c",
          "line": 3407,
          "match": "deadlock",
          "context": [
            "\t\tgoto out;",
            "",
            "\t/*",
            "\t * waiting for the lock here would deadlock.  If someone else has it",
            "\t * locked they are already in the process of dropping it anyway",
            "\t */",
            "\tif (!mutex_trylock(&head->mutex))"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\extent-tree.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\extent-tree.c",
          "line": 4079,
          "match": "deadlock",
          "context": [
            "\t * We already reached the max active zones. Try to finish one block",
            "\t * group to make a room for a new block group. This is only possible",
            "\t * for a data block group because btrfs_zone_finish() may need to wait",
            "\t * for a running transaction which can cause a deadlock for metadata",
            "\t * allocation.",
            "\t */",
            "\tif (ffe_ctl->flags & BTRFS_BLOCK_GROUP_DATA) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\extent-tree.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\fiemap.c",
          "line": 35,
          "match": "deadlock",
          "context": [
            " *",
            " * - Store extents ready to be written to the fiemap buffer in an intermediary",
            " *   buffer. This intermediary buffer is to ensure that in case the fiemap",
            " *   buffer is memory mapped to the fiemap target file, we don't deadlock",
            " *   during btrfs_page_mkwrite(). This is because during fiemap we are locking",
            " *   an extent range in order to prevent races with delalloc flushing and",
            " *   ordered extent completion, which is needed in order to reliably detect"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\fiemap.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\fiemap.c",
          "line": 39,
          "match": "deadlock",
          "context": [
            " *   during btrfs_page_mkwrite(). This is because during fiemap we are locking",
            " *   an extent range in order to prevent races with delalloc flushing and",
            " *   ordered extent completion, which is needed in order to reliably detect",
            " *   delalloc in holes and prealloc extents. And this can lead to a deadlock",
            " *   if the fiemap buffer is memory mapped to the file we are running fiemap",
            " *   against (a silly, useless in practice scenario, but possible) because",
            " *   btrfs_page_mkwrite() will try to lock the same extent range."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\fiemap.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\fiemap.c",
          "line": 863,
          "match": "deadlock",
          "context": [
            "\t * may have a non-cloned leaf and if the fiemap buffer is memory mapped",
            "\t * to a file, a write into it (through btrfs_page_mkwrite()) may trigger",
            "\t * waiting for an ordered extent that in order to complete needs to",
            "\t * modify that leaf, therefore leading to a deadlock.",
            "\t */",
            "\tbtrfs_free_path(path);",
            "\tpath = NULL;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\fiemap.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\file-item.c",
          "line": 392,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * the free space stuff is only read when it hasn't been",
            "\t * updated in the current transaction.  So, we can safely",
            "\t * read from the commit root and sidestep a nasty deadlock",
            "\t * between reading the free space cache and updating the csum tree.",
            "\t */",
            "\tif (btrfs_is_free_space_inode(inode)) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\file-item.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\file.c",
          "line": 1762,
          "match": "deadlock",
          "context": [
            "\t *",
            "\t * If we didn't do a full sync we have to stop the trans handle, wait on",
            "\t * the ordered extents, start it again and commit the transaction.  If",
            "\t * we attempt to wait on the ordered extents here we could deadlock with",
            "\t * something like fallocate() that is holding the extent lock trying to",
            "\t * start a transaction while some other thread is trying to commit the",
            "\t * transaction while we (fsync) are currently holding the transaction"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\file.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\file.c",
          "line": 1859,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Reserving delalloc space after obtaining the page lock can lead to",
            "\t * deadlock. For example, if a dirty page is locked by this function",
            "\t * and the call to btrfs_delalloc_reserve_space() ends up triggering",
            "\t * dirty page write out, then the btrfs_writepages() function could",
            "\t * end up waiting indefinitely to get a lock on the page currently"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\file.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\free-space-tree.c",
          "line": 1670,
          "match": "deadlock",
          "context": [
            "\t\treturn -ENOMEM;",
            "",
            "\t/*",
            "\t * Just like caching_thread() doesn't want to deadlock on the extent",
            "\t * tree, we don't want to deadlock on the free space tree.",
            "\t */",
            "\tpath->skip_locking = 1;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\free-space-tree.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\free-space-tree.c",
          "line": 1671,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Just like caching_thread() doesn't want to deadlock on the extent",
            "\t * tree, we don't want to deadlock on the free space tree.",
            "\t */",
            "\tpath->skip_locking = 1;",
            "\tpath->search_commit_root = 1;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\free-space-tree.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\free-space-cache.c",
          "line": 116,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * We are often under a trans handle at this point, so we need to make",
            "\t * sure NOFS is set to keep us from deadlocking.",
            "\t */",
            "\tnofs_flag = memalloc_nofs_save();",
            "\tinode = btrfs_iget_path(location.objectid, root, path);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\free-space-cache.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\free-space-cache.c",
          "line": 976,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * We must pass a path with search_commit_root set to btrfs_iget in",
            "\t * order to avoid a deadlock when allocating extents for the tree root.",
            "\t *",
            "\t * When we are COWing an extent buffer from the tree root, when looking",
            "\t * for a free extent, at extent-tree.c:find_free_extent(), we can find"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\free-space-cache.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\free-space-cache.c",
          "line": 984,
          "match": "deadlock",
          "context": [
            "\t * we must load its space cache which requires reading its free space",
            "\t * cache's inode item from the root tree. If this inode item is located",
            "\t * in the same leaf that we started COWing before, then we end up in",
            "\t * deadlock on the extent buffer (trying to read lock it when we",
            "\t * previously write locked it).",
            "\t *",
            "\t * It's safe to read the inode item using the commit root because"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\free-space-cache.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\ioctl.c",
          "line": 1907,
          "match": "deadlock",
          "context": [
            "",
            "\t\t\t/*",
            "\t\t\t * We don't need the path anymore, so release it and",
            "\t\t\t * avoid deadlocks and lockdep warnings in case",
            "\t\t\t * btrfs_iget() needs to lookup the inode from its root",
            "\t\t\t * btree and lock the same leaf.",
            "\t\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\ioctl.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\ioctl.c",
          "line": 3698,
          "match": "deadlock",
          "context": [
            "\t\t * cleaner_mutex -> inode_lock -> subvol_sem",
            "\t\t *",
            "\t\t * so we must take the cleaner_mutex here before we take the",
            "\t\t * subvol_sem.  The deadlock can't actually happen, but this",
            "\t\t * quiets lockdep.",
            "\t\t */",
            "\t\tmutex_lock(&fs_info->cleaner_mutex);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\ioctl.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\locking.c",
          "line": 28,
          "match": "deadlock",
          "context": [
            " * roots have separate keysets.",
            " *",
            " * Lock-nesting across peer nodes is always done with the immediate parent",
            " * node locked thus preventing deadlock.  As lockdep doesn't know this, use",
            " * subclass to avoid triggering lockdep warning in such cases.",
            " *",
            " * The key is set by the readpage_end_io_hook after the buffer has passed"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\locking.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\inode.c",
          "line": 2849,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * As a precaution, do a delayed iput in case it would be the last iput",
            "\t * that could need flushing space. Recursing back to fixup worker would",
            "\t * deadlock.",
            "\t */",
            "\tbtrfs_add_delayed_iput(inode);",
            "}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\inode.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\inode.c",
          "line": 3123,
          "match": "deadlock",
          "context": [
            "\t * inserting/replacing file extent items and unpinning an extent map.",
            "\t * This must be taken before joining a transaction, as it's a higher",
            "\t * level lock (like the inode's VFS lock), otherwise we can run into an",
            "\t * ABBA deadlock with other tasks (transactions work like a lock,",
            "\t * depending on their current state).",
            "\t */",
            "\tif (!test_bit(BTRFS_ORDERED_NOCOW, &ordered_extent->flags)) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\inode.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\inode.c",
          "line": 3463,
          "match": "deadlock",
          "context": [
            "\t * btrfs_put_ordered_extent() can run in irq context (see bio.c), which",
            "\t * calls btrfs_add_delayed_iput() and that needs to lock",
            "\t * fs_info->delayed_iput_lock. So we need to disable irqs here to",
            "\t * prevent a deadlock.",
            "\t */",
            "\tspin_lock_irq(&fs_info->delayed_iput_lock);",
            "\twhile (!list_empty(&fs_info->delayed_iputs)) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\inode.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\inode.c",
          "line": 4166,
          "match": "deadlock",
          "context": [
            "\tint ret;",
            "",
            "\t/*",
            "\t * If the inode is a free space inode, we can deadlock during commit",
            "\t * if we put it into the delayed code.",
            "\t *",
            "\t * The data relocation inode should also be directly updated"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\inode.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\inode.c",
          "line": 5398,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Eviction should be taking place at some place safe because of our",
            "\t * delayed iputs.  However the normal flushing code will run delayed",
            "\t * iputs, so we cannot use FLUSH_ALL otherwise we'll deadlock.",
            "\t *",
            "\t * We reserve the delayed_refs_extra here again because we can't use",
            "\t * btrfs_start_transaction(root, 0) for the same deadlocky reason as"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\inode.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\inode.c",
          "line": 5401,
          "match": "deadlock",
          "context": [
            "\t * iputs, so we cannot use FLUSH_ALL otherwise we'll deadlock.",
            "\t *",
            "\t * We reserve the delayed_refs_extra here again because we can't use",
            "\t * btrfs_start_transaction(root, 0) for the same deadlocky reason as",
            "\t * above.  We reserve our extra bit here because we generate a ton of",
            "\t * delayed refs activity by truncating.",
            "\t *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\inode.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\inode.c",
          "line": 7740,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * We can't call btrfs_truncate_block inside a trans handle as we could",
            "\t * deadlock with freeze, if we got BTRFS_NEED_TRUNCATE_BLOCK then we",
            "\t * know we've truncated everything except the last little bit, and can",
            "\t * do btrfs_truncate_block and then update the disk_i_size.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\inode.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\inode.c",
          "line": 10231,
          "match": "deadlock",
          "context": [
            "\t\tbackref_ctx->curr_leaf_bytenr = leaf->start;",
            "",
            "\t\t/*",
            "\t\t * Don't need the path anymore, release to avoid deadlocks when",
            "\t\t * calling btrfs_is_data_extent_shared() because when joining a",
            "\t\t * transaction it can block waiting for the current one's commit",
            "\t\t * which in turn may be trying to lock the same leaf to flush"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\inode.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\messages.c",
          "line": 178,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Note that a running device replace operation is not canceled here",
            "\t * although there is no way to update the progress. It would add the",
            "\t * risk of a deadlock, therefore the canceling is omitted. The only",
            "\t * penalty is that some I/O remains active until the procedure",
            "\t * completes. The next time when the filesystem is mounted writable",
            "\t * again, the device replace operation continues."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\messages.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\raid56.c",
          "line": 2209,
          "match": "deadlock",
          "context": [
            "\t *   Then we are doing IO for tree blocks, no need to search csums.",
            "\t *",
            "\t * - The rbio belongs to mixed block groups",
            "\t *   This is to avoid deadlock, as we're already holding the full",
            "\t *   stripe lock, if we trigger a metadata read, and it needs to do",
            "\t *   raid56 recovery, we will deadlock.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\raid56.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\raid56.c",
          "line": 2211,
          "match": "deadlock",
          "context": [
            "\t * - The rbio belongs to mixed block groups",
            "\t *   This is to avoid deadlock, as we're already holding the full",
            "\t *   stripe lock, if we trigger a metadata read, and it needs to do",
            "\t *   raid56 recovery, we will deadlock.",
            "\t */",
            "\tif (!(rbio->bioc->map_type & BTRFS_BLOCK_GROUP_DATA) ||",
            "\t    rbio->bioc->map_type & BTRFS_BLOCK_GROUP_METADATA)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\raid56.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\qgroup.c",
          "line": 1219,
          "match": "deadlock",
          "context": [
            "\tmutex_unlock(&fs_info->qgroup_ioctl_lock);",
            "\t/*",
            "\t * Commit the transaction while not holding qgroup_ioctl_lock, to avoid",
            "\t * a deadlock with tasks concurrently doing other qgroup operations, such",
            "\t * adding/removing qgroups or adding/deleting qgroup relations for example,",
            "\t * because all qgroup operations first start or join a transaction and then",
            "\t * lock the qgroup_ioctl_lock mutex."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\qgroup.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\qgroup.c",
          "line": 1234,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Set quota enabled flag after committing the transaction, to avoid",
            "\t * deadlocks on fs_info->qgroup_ioctl_lock with concurrent snapshot",
            "\t * creation.",
            "\t */",
            "\tspin_lock(&fs_info->qgroup_lock);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\qgroup.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\qgroup.c",
          "line": 1341,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Unlock the qgroup_ioctl_lock mutex before waiting for the rescan worker to",
            "\t * complete. Otherwise we can deadlock because btrfs_remove_qgroup() needs",
            "\t * to lock that mutex while holding a transaction handle and the rescan",
            "\t * worker needs to commit a transaction.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\qgroup.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\qgroup.c",
          "line": 1350,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Request qgroup rescan worker to complete and wait for it. This wait",
            "\t * must be done before transaction start for quota disable since it may",
            "\t * deadlock with transaction by the qgroup rescan worker.",
            "\t */",
            "\tclear_bit(BTRFS_FS_QUOTA_ENABLED, &fs_info->flags);",
            "\tbtrfs_qgroup_wait_for_completion(fs_info, false);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\qgroup.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\qgroup.c",
          "line": 2083,
          "match": "deadlock",
          "context": [
            "\t * So we want btrfs_find_all_roots() to not acquire the commit_root_sem",
            "\t * but we can't pass it a non-NULL transaction handle, because otherwise",
            "\t * it would not use commit roots and would lock extent buffers, causing",
            "\t * a deadlock if it ends up trying to read lock the same extent buffer",
            "\t * that was previously write locked at btrfs_truncate_inode_items().",
            "\t *",
            "\t * So pass a NULL transaction handle to btrfs_find_all_roots() and"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\qgroup.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\qgroup.c",
          "line": 4171,
          "match": "deadlock",
          "context": [
            "{",
            "\tint ret;",
            "",
            "\t/* Can't hold an open transaction or we run the risk of deadlocking. */",
            "\tASSERT(current->journal_info == NULL);",
            "\tif (WARN_ON(current->journal_info))",
            "\t\treturn 0;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\qgroup.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\reflink.c",
          "line": 79,
          "match": "deadlock",
          "context": [
            "\t * We have flushed and locked the ranges of the source and destination",
            "\t * inodes, we also have locked the inodes, so we are safe to do a",
            "\t * reservation here. Also we must not do the reservation while holding",
            "\t * a transaction open, otherwise we would deadlock.",
            "\t */",
            "\tret = btrfs_delalloc_reserve_space(inode, &data_reserved, file_offset,",
            "\t\t\t\t\t   block_size);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\reflink.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\reflink.c",
          "line": 109,
          "match": "deadlock",
          "context": [
            "\t * and if we are low on metadata free space, that can cause flushing of",
            "\t * delalloc for all inodes in order to get metadata space released.",
            "\t * However we are holding the range locked for the whole duration of",
            "\t * the clone/dedupe operation, so we may deadlock if that happens and no",
            "\t * other task releases enough space. So mark this inode as not being",
            "\t * possible to flush to avoid such deadlock. We will clear that flag",
            "\t * when we finish cloning all extents, since a transaction is started"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\reflink.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\reflink.c",
          "line": 111,
          "match": "deadlock",
          "context": [
            "\t * However we are holding the range locked for the whole duration of",
            "\t * the clone/dedupe operation, so we may deadlock if that happens and no",
            "\t * other task releases enough space. So mark this inode as not being",
            "\t * possible to flush to avoid such deadlock. We will clear that flag",
            "\t * when we finish cloning all extents, since a transaction is started",
            "\t * after finding each extent to clone.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\reflink.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\reflink.c",
          "line": 314,
          "match": "deadlock",
          "context": [
            "\t * Release our path because we don't need it anymore and also because",
            "\t * copy_inline_to_page() needs to reserve data and metadata, which may",
            "\t * need to flush delalloc when we are low on available space and",
            "\t * therefore cause a deadlock if writeback of an inline extent needs to",
            "\t * write to the same leaf or an ordered extent completion needs to write",
            "\t * to the same leaf.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\reflink.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\relocation.c",
          "line": 2688,
          "match": "deadlock",
          "context": [
            "",
            "\t\t/*",
            "\t\t * Subpage can't handle page with DIRTY but without UPTODATE",
            "\t\t * bit as it can lead to the following deadlock:",
            "\t\t *",
            "\t\t * btrfs_read_folio()",
            "\t\t * | Page already *locked*"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\relocation.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\relocation.c",
          "line": 3934,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Relocation of a data block group creates ordered extents.  Without",
            "\t * sb_start_write(), we can freeze the filesystem while unfinished",
            "\t * ordered extents are left. Such ordered extents can cause a deadlock",
            "\t * e.g. when syncfs() is waiting for their completion but they can't",
            "\t * finish because they block when joining a transaction, due to the",
            "\t * fact that the freeze locks are being held in write mode."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\relocation.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\scrub.c",
          "line": 2722,
          "match": "deadlock",
          "context": [
            "",
            "\t\t/*",
            "\t\t * we need call btrfs_inc_block_group_ro() with scrubs_paused,",
            "\t\t * to avoid deadlock caused by:",
            "\t\t * btrfs_inc_block_group_ro()",
            "\t\t * -> btrfs_wait_for_commit()",
            "\t\t * -> btrfs_commit_transaction()"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\scrub.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\scrub.c",
          "line": 3101,
          "match": "deadlock",
          "context": [
            "\tmutex_unlock(&fs_info->scrub_lock);",
            "",
            "\t/*",
            "\t * In order to avoid deadlock with reclaim when there is a transaction",
            "\t * trying to pause scrub, make sure we use GFP_NOFS for all the",
            "\t * allocations done at btrfs_scrub_sectors() and scrub_sectors_for_parity()",
            "\t * invoked by our callees. The pausing request is done when the"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\scrub.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\send.c",
          "line": 7172,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * We can not hold the commit root semaphore here. This is because in",
            "\t * the case of sending and receiving to the same filesystem, using a",
            "\t * pipe, could result in a deadlock:",
            "\t *",
            "\t * 1) The task running send blocks on the pipe because it's full;",
            "\t *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\send.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\space-info.c",
          "line": 99,
          "match": "deadlock",
          "context": [
            " *   Same as the above, except we add ourselves to the",
            " *   space_info->priority_tickets, and we do not use ticket->wait, we simply",
            " *   call flush_space() ourselves for the states that are safe for us to call",
            " *   without deadlocking and hope for the best.",
            " *",
            " * THE FLUSHING STATES",
            " *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\space-info.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\space-info.c",
          "line": 1745,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * If have a transaction handle (current->journal_info != NULL), then",
            "\t * the flush method can not be neither BTRFS_RESERVE_FLUSH_ALL* nor",
            "\t * BTRFS_RESERVE_FLUSH_EVICT, as we could deadlock because those",
            "\t * flushing methods can trigger transaction commits.",
            "\t */",
            "\tif (current->journal_info) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\space-info.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\subpage.c",
          "line": 59,
          "match": "deadlock",
          "context": [
            " * - Metadata",
            " *   Since we have multiple tree blocks inside one page, we can't rely on page",
            " *   locking anymore, or we will have greatly reduced concurrency or even",
            " *   deadlocks (hold one tree lock while trying to lock another tree lock in",
            " *   the same page).",
            " *",
            " *   Thus for metadata locking, subpage support relies on io_tree locking only."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\subpage.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\super.c",
          "line": 1023,
          "match": "deadlock",
          "context": [
            "\t\t\t\treturn 0;",
            "\t\t\t/*",
            "\t\t\t * A non-blocking test if the fs is frozen. We must not",
            "\t\t\t * start a new transaction here otherwise a deadlock",
            "\t\t\t * happens. The pending operations are delayed to the",
            "\t\t\t * next commit after thawing.",
            "\t\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\super.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\sysfs.c",
          "line": 1861,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Setup a NOFS context because kobject_add(), deep in its call chain,",
            "\t * does GFP_KERNEL allocations, and we are often called in a context",
            "\t * where if reclaim is triggered we can deadlock (we are either holding",
            "\t * a transaction handle or some lock required for a transaction",
            "\t * commit).",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\sysfs.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\transaction.c",
          "line": 693,
          "match": "deadlock",
          "context": [
            "\t * waiting on this guy, so we don't need to do the sb_start_intwrite",
            "\t * because we're already holding a ref.  We need this because we could",
            "\t * have raced in and did an fsync() on a file which can kick a commit",
            "\t * and then we deadlock with somebody doing a freeze.",
            "\t *",
            "\t * If we are ATTACH, it means we just want to catch the current",
            "\t * transaction and commit it, so we needn't do sb_start_intwrite(). "
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\transaction.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\transaction.c",
          "line": 777,
          "match": "deadlock",
          "context": [
            "\t * transaction.",
            "\t *",
            "\t * Thus it need to be called after current->journal_info initialized,",
            "\t * or we can deadlock.",
            "\t */",
            "\tret = btrfs_record_root_in_trans(h, root);",
            "\tif (ret) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\transaction.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\transaction.c",
          "line": 2078,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * If relocation is running, we can't cancel scrub because that will",
            "\t * result in a deadlock. Before relocating a block group, relocation",
            "\t * pauses scrub, then starts and commits a transaction before unpausing",
            "\t * scrub. If the transaction commit is being done by the relocation",
            "\t * task or triggered by another task and the relocation task is waiting"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\transaction.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\transaction.c",
          "line": 2083,
          "match": "deadlock",
          "context": [
            "\t * scrub. If the transaction commit is being done by the relocation",
            "\t * task or triggered by another task and the relocation task is waiting",
            "\t * for the commit, and we end up here due to an error in the commit",
            "\t * path, then calling btrfs_scrub_cancel() will deadlock, as we are",
            "\t * asking for scrub to stop while having it asked to be paused higher",
            "\t * above in relocation code.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\transaction.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\transaction.c",
          "line": 2119,
          "match": "deadlock",
          "context": [
            "{",
            "\t/*",
            "\t * We use try_to_writeback_inodes_sb() here because if we used",
            "\t * btrfs_start_delalloc_roots we would deadlock with fs freeze.",
            "\t * Currently are holding the fs freeze lock, if we do an async flush",
            "\t * we'll do btrfs_join_transaction() and deadlock because we need to",
            "\t * wait for the fs freeze lock.  Using the direct flushing we benefit"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\transaction.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\transaction.c",
          "line": 2121,
          "match": "deadlock",
          "context": [
            "\t * We use try_to_writeback_inodes_sb() here because if we used",
            "\t * btrfs_start_delalloc_roots we would deadlock with fs freeze.",
            "\t * Currently are holding the fs freeze lock, if we do an async flush",
            "\t * we'll do btrfs_join_transaction() and deadlock because we need to",
            "\t * wait for the fs freeze lock.  Using the direct flushing we benefit",
            "\t * from already being in a transaction and our join_transaction doesn't",
            "\t * have to re-take the fs freeze lock."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\transaction.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\tree-log.c",
          "line": 151,
          "match": "deadlock",
          "context": [
            "\t * replaying a log tree, so we must make sure NOFS semantics apply",
            "\t * because btrfs_alloc_inode() may be triggered and it uses GFP_KERNEL",
            "\t * to allocate an inode, which can recurse back into the filesystem and",
            "\t * attempt a transaction commit, resulting in a deadlock.",
            "\t */",
            "\tnofs_flag = memalloc_nofs_save();",
            "\tinode = btrfs_iget(objectid, root);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\tree-log.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\tree-log.c",
          "line": 3103,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * As described above, -EAGAIN indicates a hole in the extents. We",
            "\t * cannot wait for these write outs since the waiting cause a",
            "\t * deadlock. Bail out to the full commit instead.",
            "\t */",
            "\tif (ret == -EAGAIN && btrfs_is_zoned(fs_info)) {",
            "\t\tbtrfs_set_log_full_commit(trans);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\tree-log.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\tree-log.c",
          "line": 4347,
          "match": "deadlock",
          "context": [
            "\tconst u64 i_size = i_size_read(&inode->vfs_inode);",
            "",
            "\t/*",
            "\t * To keep lockdep happy and avoid deadlocks, clone the source leaf and",
            "\t * use the clone. This is because otherwise we would be changing the log",
            "\t * tree, to insert items from the subvolume tree or insert csum items,",
            "\t * while holding a read lock on a leaf from the subvolume tree, which"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\tree-log.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\tree-log.c",
          "line": 4369,
          "match": "deadlock",
          "context": [
            "\t *    on the parent extent buffer in the log tree.",
            "\t *",
            "\t * So one task in scenario 1) running in parallel with another task in",
            "\t * scenario 2) could lead to a deadlock, one wanting to lock a delayed",
            "\t * node mutex while having a read lock on a leaf from the subvolume,",
            "\t * while the other is holding the delayed node's mutex and wants to",
            "\t * write lock the same subvolume leaf for flushing delayed items."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\tree-log.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\tree-log.c",
          "line": 5179,
          "match": "deadlock",
          "context": [
            "\t\t\tconst u64 hole_len = key.offset - prev_extent_end;",
            "",
            "\t\t\t/*",
            "\t\t\t * Release the path to avoid deadlocks with other code",
            "\t\t\t * paths that search the root while holding locks on",
            "\t\t\t * leafs from the log root.",
            "\t\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\tree-log.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\tree-log.c",
          "line": 5410,
          "match": "deadlock",
          "context": [
            " * directory, that directory's new entries are logged too (same behaviour as",
            " * ext3/4, xfs, f2fs, reiserfs, nilfs2). Note that when logging the inodes",
            " * the dentries point to we do not acquire their VFS lock, otherwise lockdep",
            " * complains about the following circular lock dependency / possible deadlock:",
            " *",
            " *        CPU0                                        CPU1",
            " *        ----                                        ----"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\tree-log.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\tree-log.c",
          "line": 6322,
          "match": "deadlock",
          "context": [
            "\tint ret = 0;",
            "",
            "\t/*",
            "\t * No need for the log mutex, plus to avoid potential deadlocks or",
            "\t * lockdep annotations due to nesting of delayed inode mutexes and log",
            "\t * mutexes.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\tree-log.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\tree-log.c",
          "line": 7020,
          "match": "deadlock",
          "context": [
            "",
            "\t\t/*",
            "\t\t * Logging ancestors needs to do more searches on the fs/subvol",
            "\t\t * tree, so it releases the path as needed to avoid deadlocks.",
            "\t\t * Keep track of the last inode ref key and resume from that key",
            "\t\t * after logging all new ancestors for the current hard link.",
            "\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\tree-log.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\volumes.c",
          "line": 3262,
          "match": "deadlock",
          "context": [
            "\t * We take the device_list_mutex to avoid racing with the finishing phase",
            "\t * of a device replace operation. See the comment below before acquiring",
            "\t * fs_info->chunk_mutex. Note that here we do not acquire the chunk_mutex",
            "\t * because that can result in a deadlock when deleting the device extent",
            "\t * items from the devices btree - COWing an extent buffer from the btree",
            "\t * may result in allocating a new metadata chunk, which would attempt to",
            "\t * lock again fs_info->chunk_mutex."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\volumes.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\xattr.c",
          "line": 509,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * We're holding a transaction handle, so use a NOFS memory allocation",
            "\t * context to avoid deadlock if reclaim happens.",
            "\t */",
            "\tnofs_flag = memalloc_nofs_save();",
            "\tfor (xattr = xattr_array; xattr->name != NULL; xattr++) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\xattr.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\zoned.c",
          "line": 1225,
          "match": "deadlock",
          "context": [
            "\t * For new a block group, this function is called from",
            "\t * btrfs_make_block_group() which is already taking the chunk mutex.",
            "\t * Thus, we cannot call calculate_alloc_pointer() which takes extent",
            "\t * buffer locks to avoid deadlock.",
            "\t */",
            "\tif (new) {",
            "\t\t*offset_ret = 0;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\zoned.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\zoned.c",
          "line": 1966,
          "match": "deadlock",
          "context": [
            "\t\tif (tgt) {",
            "\t\t\t/*",
            "\t\t\t * If there is an unsent IO left in the allocated area,",
            "\t\t\t * we cannot wait for them as it may cause a deadlock.",
            "\t\t\t */",
            "\t\t\tif (tgt->meta_write_pointer < tgt->start + tgt->alloc_offset) {",
            "\t\t\t\tif (wbc->sync_mode == WB_SYNC_NONE ||"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\zoned.c"
          ]
        },
        {
          "file": "linux\\fs\\ceph\\caps.c",
          "line": 3150,
          "match": "deadlock",
          "context": [
            "\t\t\t}",
            "\t\t\t/*",
            "\t\t\t * drop cap refs first because getattr while",
            "\t\t\t * holding * caps refs can cause deadlock.",
            "\t\t\t */",
            "\t\t\tceph_put_cap_refs(ci, _got);",
            "\t\t\t_got = 0;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ceph\\caps.c"
          ]
        },
        {
          "file": "linux\\fs\\ceph\\file.c",
          "line": 2759,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Since we're already holding the FILE_WR capability for the dst file,",
            "\t * we would risk a deadlock by using ceph_get_caps.  Thus, we'll do some",
            "\t * retry dance instead to try to get both capabilities.",
            "\t */",
            "\tret = ceph_try_get_caps(file_inode(src_filp),"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ceph\\file.c"
          ]
        },
        {
          "file": "linux\\fs\\ceph\\inode.c",
          "line": 2062,
          "match": "deadlock",
          "context": [
            "\t\t\tunlock_new_inode(in);",
            "",
            "\t\tif (d_really_is_negative(dn)) {",
            "\t\t\tif (ceph_security_xattr_deadlock(in)) {",
            "\t\t\t\tdoutc(cl, \" skip splicing dn %p to inode %p\"",
            "\t\t\t\t      \" (security xattr deadlock)\\n\", dn, in);",
            "\t\t\t\tiput(in);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ceph\\inode.c"
          ]
        },
        {
          "file": "linux\\fs\\ceph\\inode.c",
          "line": 2064,
          "match": "deadlock",
          "context": [
            "\t\tif (d_really_is_negative(dn)) {",
            "\t\t\tif (ceph_security_xattr_deadlock(in)) {",
            "\t\t\t\tdoutc(cl, \" skip splicing dn %p to inode %p\"",
            "\t\t\t\t      \" (security xattr deadlock)\\n\", dn, in);",
            "\t\t\t\tiput(in);",
            "\t\t\t\tskipped++;",
            "\t\t\t\tgoto next_item;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ceph\\inode.c"
          ]
        },
        {
          "file": "linux\\fs\\ceph\\locks.c",
          "line": 303,
          "match": "deadlock",
          "context": [
            "\t\t\tif (err) {",
            "\t\t\t\t/* undo! This should only happen if",
            "\t\t\t\t * the kernel detects local",
            "\t\t\t\t * deadlock. */",
            "\t\t\t\tceph_lock_message(CEPH_LOCK_FCNTL, op, inode,",
            "\t\t\t\t\t\t  CEPH_LOCK_UNLOCK, 0, fl);",
            "\t\t\t\tdoutc(cl, \"got %d on posix_lock_file, undid lock\\n\","
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ceph\\locks.c"
          ]
        },
        {
          "file": "linux\\fs\\ceph\\mds_client.c",
          "line": 3877,
          "match": "deadlock",
          "context": [
            "\t\t\t\t       session->s_con.peer_features);",
            "\tmutex_unlock(&mdsc->mutex);",
            "",
            "\t/* Must find target inode outside of mutexes to avoid deadlocks */",
            "\trinfo = &req->r_reply_info;",
            "\tif ((err >= 0) && rinfo->head->is_target) {",
            "\t\tstruct inode *in = xchg(&req->r_new_inode, NULL);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ceph\\mds_client.c"
          ]
        },
        {
          "file": "linux\\fs\\ceph\\xattr.c",
          "line": 1361,
          "match": "deadlock",
          "context": [
            "\treturn in->i_security != NULL;",
            "}",
            "",
            "bool ceph_security_xattr_deadlock(struct inode *in)",
            "{",
            "\tstruct ceph_inode_info *ci;",
            "\tbool ret;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ceph\\xattr.c"
          ]
        },
        {
          "file": "linux\\fs\\configfs\\symlink.c",
          "line": 177,
          "match": "deadlock",
          "context": [
            "\t * attempts to resolve the target (which might very well",
            "\t * not even exist yet) done prior to locking the parent",
            "\t * directory.  This perversion, OTOH, needs to resolve",
            "\t * the target, which would lead to obvious deadlocks if",
            "\t * attempted with any directories locked.",
            "\t *",
            "\t * Unfortunately, that garbage is userland ABI and we should've"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\configfs\\symlink.c"
          ]
        },
        {
          "file": "linux\\fs\\crypto\\bio.c",
          "line": 145,
          "match": "deadlock",
          "context": [
            "\t * from a mempool, with __GFP_DIRECT_RECLAIM set so that it can't fail.",
            "\t *",
            "\t * Any additional page allocations are allowed to fail, as they only",
            "\t * help performance, and waiting on the mempool for them could deadlock.",
            "\t */",
            "\tfor (i = 0; i < nr_pages; i++) {",
            "\t\tpages[i] = fscrypt_alloc_bounce_page(i == 0 ? GFP_NOFS :"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\crypto\\bio.c"
          ]
        },
        {
          "file": "linux\\fs\\crypto\\crypto.c",
          "line": 176,
          "match": "deadlock",
          "context": [
            " * The bounce page allocation is mempool-backed, so it will always succeed when",
            " * @gfp_flags includes __GFP_DIRECT_RECLAIM, e.g. when it's GFP_NOFS.  However,",
            " * only the first page of each bio can be allocated this way.  To prevent",
            " * deadlocks, for any additional pages a mask like GFP_NOWAIT must be used.",
            " *",
            " * Return: the new encrypted bounce page on success; an ERR_PTR() on failure",
            " */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\crypto\\crypto.c"
          ]
        },
        {
          "file": "linux\\fs\\debugfs\\file.c",
          "line": 211,
          "match": "deadlock",
          "context": [
            " * operations to complete. However, the operation itself may need",
            " * to wait for hardware or completion of some asynchronous process",
            " * or similar. As such, it may need to be cancelled to avoid long",
            " * waits or even deadlocks.",
            " *",
            " * This function can be used inside a debugfs handler that may",
            " * need to be cancelled. As soon as this function is called, the"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\debugfs\\file.c"
          ]
        },
        {
          "file": "linux\\fs\\dlm\\lock.c",
          "line": 298,
          "match": "DEADLOCK",
          "context": [
            "\tDLM_ASSERT(lkb->lkb_lksb, dlm_print_lkb(lkb););",
            "",
            "\tif (rv == -DLM_ECANCEL &&",
            "\t    test_and_clear_bit(DLM_IFL_DEADLOCK_CANCEL_BIT, &lkb->lkb_iflags))",
            "\t\trv = -EDEADLK;",
            "",
            "\tdlm_add_cb(lkb, DLM_CB_CAST, lkb->lkb_grmode, rv, dlm_sbflags_val(lkb));"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\dlm\\lock.c"
          ]
        },
        {
          "file": "linux\\fs\\dlm\\lock.c",
          "line": 2104,
          "match": "deadlock",
          "context": [
            "   change the granted/requested modes.  We're munging things accordingly in",
            "   the process copy.",
            "   CONVDEADLK: our grmode may have been forced down to NL to resolve a",
            "   conversion deadlock",
            "   ALTPR/ALTCW: our rqmode may have been changed to PR or CW to become",
            "   compatible with other granted locks */",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\dlm\\lock.c"
          ]
        },
        {
          "file": "linux\\fs\\dlm\\lock.c",
          "line": 2164,
          "match": "deadlock",
          "context": [
            "}",
            "",
            "/*",
            " * \"A conversion deadlock arises with a pair of lock requests in the converting",
            " * queue for one resource.  The granted mode of each lock blocks the requested",
            " * mode of the other lock.\"",
            " *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\dlm\\lock.c"
          ]
        },
        {
          "file": "linux\\fs\\dlm\\lock.c",
          "line": 2191,
          "match": "deadlock",
          "context": [
            " *",
            " * That second condition meant we'd only say there was conv-deadlk if",
            " * resolving it (by demotion) would lead to the first lock on the convert",
            " * queue being granted right away.  It allowed conversion deadlocks to exist",
            " * between locks on the convert queue while they couldn't be granted anyway.",
            " *",
            " * Now, we detect and take action on conversion deadlocks immediately when"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\dlm\\lock.c"
          ]
        },
        {
          "file": "linux\\fs\\dlm\\lock.c",
          "line": 2194,
          "match": "deadlock",
          "context": [
            " * queue being granted right away.  It allowed conversion deadlocks to exist",
            " * between locks on the convert queue while they couldn't be granted anyway.",
            " *",
            " * Now, we detect and take action on conversion deadlocks immediately when",
            " * they're created, even if they may not be immediately consequential.  If",
            " * lkb1 exists anywhere in the convert queue and lkb2 comes in with a granted",
            " * mode that would prevent lkb1's conversion from being granted, we do a"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\dlm\\lock.c"
          ]
        },
        {
          "file": "linux\\fs\\dlm\\lock.c",
          "line": 2204,
          "match": "deadlock",
          "context": [
            " * both already on the convert queue.",
            " */",
            "",
            "static int conversion_deadlock_detect(struct dlm_rsb *r, struct dlm_lkb *lkb2)",
            "{",
            "\tstruct dlm_lkb *lkb1;",
            "\tint lkb_is_ahead = 0;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\dlm\\lock.c"
          ]
        },
        {
          "file": "linux\\fs\\dlm\\lock.c",
          "line": 2229,
          "match": "deadlock",
          "context": [
            "",
            "/*",
            " * Return 1 if the lock can be granted, 0 otherwise.",
            " * Also detect and resolve conversion deadlocks.",
            " *",
            " * lkb is the lock to be granted",
            " *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\dlm\\lock.c"
          ]
        },
        {
          "file": "linux\\fs\\dlm\\lock.c",
          "line": 2294,
          "match": "deadlock",
          "context": [
            "\t * order than they were in on the previous master.  So, granting",
            "\t * queued conversions in order after recovery doesn't make sense",
            "\t * since the order hasn't been preserved anyway.  The new order",
            "\t * could also have created a new \"in place\" conversion deadlock.",
            "\t * (e.g. old, failed master held granted EX, with PR->EX, NL->EX.",
            "\t * After recovery, there would be no granted locks, and possibly",
            "\t * NL->EX, PR->EX, an in-place conversion deadlock.)  So, after"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\dlm\\lock.c"
          ]
        },
        {
          "file": "linux\\fs\\dlm\\lock.c",
          "line": 2297,
          "match": "deadlock",
          "context": [
            "\t * could also have created a new \"in place\" conversion deadlock.",
            "\t * (e.g. old, failed master held granted EX, with PR->EX, NL->EX.",
            "\t * After recovery, there would be no granted locks, and possibly",
            "\t * NL->EX, PR->EX, an in-place conversion deadlock.)  So, after",
            "\t * recovery, grant conversions without considering order.",
            "\t */",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\dlm\\lock.c"
          ]
        },
        {
          "file": "linux\\fs\\dlm\\lock.c",
          "line": 2405,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * The CONVDEADLK flag is non-standard and tells the dlm to resolve",
            "\t * conversion deadlocks by demoting grmode to NL, otherwise the dlm",
            "\t * cancels one of the locks.",
            "\t */",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\dlm\\lock.c"
          ]
        },
        {
          "file": "linux\\fs\\dlm\\lock.c",
          "line": 2410,
          "match": "deadlock",
          "context": [
            "\t */",
            "",
            "\tif (is_convert && can_be_queued(lkb) &&",
            "\t    conversion_deadlock_detect(r, lkb)) {",
            "\t\tif (lkb->lkb_exflags & DLM_LKF_CONVDEADLK) {",
            "\t\t\tlkb->lkb_grmode = DLM_LOCK_NL;",
            "\t\t\tset_bit(DLM_SBF_DEMOTED_BIT, &lkb->lkb_sbflags);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\dlm\\lock.c"
          ]
        },
        {
          "file": "linux\\fs\\dlm\\lock.c",
          "line": 2417,
          "match": "deadlock",
          "context": [
            "\t\t} else if (err) {",
            "\t\t\t*err = -EDEADLK;",
            "\t\t} else {",
            "\t\t\tlog_print(\"can_be_granted deadlock %x now %d\",",
            "\t\t\t\t  lkb->lkb_id, now);",
            "\t\t\tdlm_dump_rsb(r);",
            "\t\t}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\dlm\\lock.c"
          ]
        },
        {
          "file": "linux\\fs\\dlm\\lock.c",
          "line": 2487,
          "match": "deadlock",
          "context": [
            "\t\tif (deadlk) {",
            "\t\t\t/*",
            "\t\t\t * If DLM_LKB_NODLKWT flag is set and conversion",
            "\t\t\t * deadlock is detected, we request blocking AST and",
            "\t\t\t * down (or cancel) conversion.",
            "\t\t\t */",
            "\t\t\tif (lkb->lkb_exflags & DLM_LKF_NODLCKWT) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\dlm\\lock.c"
          ]
        },
        {
          "file": "linux\\fs\\dlm\\lock.c",
          "line": 2496,
          "match": "deadlock",
          "context": [
            "\t\t\t\t\tlkb->lkb_highbast = lkb->lkb_rqmode;",
            "\t\t\t\t}",
            "\t\t\t} else {",
            "\t\t\t\tlog_print(\"WARN: pending deadlock %x node %d %s\",",
            "\t\t\t\t\t  lkb->lkb_id, lkb->lkb_nodeid,",
            "\t\t\t\t\t  r->res_name);",
            "\t\t\t\tdlm_dump_rsb(r);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\dlm\\lock.c"
          ]
        },
        {
          "file": "linux\\fs\\dlm\\lock.c",
          "line": 3087,
          "match": "deadlock",
          "context": [
            "\t}",
            "",
            "\t/* can_be_granted() detected that this lock would block in a conversion",
            "\t   deadlock, so we leave it on the granted queue and return EDEADLK in",
            "\t   the ast for the convert. */",
            "",
            "\tif (deadlk && !(lkb->lkb_exflags & DLM_LKF_NODLCKWT)) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\dlm\\lock.c"
          ]
        },
        {
          "file": "linux\\fs\\dlm\\lock.c",
          "line": 6037,
          "match": "deadlock",
          "context": [
            "\treturn error;",
            "}",
            "",
            "int dlm_user_deadlock(struct dlm_ls *ls, uint32_t flags, uint32_t lkid)",
            "{",
            "\tstruct dlm_lkb *lkb;",
            "\tstruct dlm_args args;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\dlm\\lock.c"
          ]
        },
        {
          "file": "linux\\fs\\dlm\\lock.c",
          "line": 6059,
          "match": "DEADLOCK",
          "context": [
            "\tif (error)",
            "\t\tgoto out_put;",
            "",
            "\t/* same as cancel_lock(), but set DEADLOCK_CANCEL after lock_rsb */",
            "",
            "\tr = lkb->lkb_resource;",
            "\thold_rsb(r);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\dlm\\lock.c"
          ]
        },
        {
          "file": "linux\\fs\\dlm\\lock.c",
          "line": 6068,
          "match": "DEADLOCK",
          "context": [
            "\terror = validate_unlock_args(lkb, &args);",
            "\tif (error)",
            "\t\tgoto out_r;",
            "\tset_bit(DLM_IFL_DEADLOCK_CANCEL_BIT, &lkb->lkb_iflags);",
            "",
            "\terror = _cancel_lock(r, lkb);",
            " out_r:"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\dlm\\lock.c"
          ]
        },
        {
          "file": "linux\\fs\\dlm\\lock.c",
          "line": 6129,
          "match": "deadlock",
          "context": [
            "}",
            "",
            "/* We have to release clear_proc_locks mutex before calling unlock_proc_lock()",
            "   (which does lock_rsb) due to deadlock with receiving a message that does",
            "   lock_rsb followed by dlm_user_add_cb() */",
            "",
            "static struct dlm_lkb *del_proc_lock(struct dlm_ls *ls,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\dlm\\lock.c"
          ]
        },
        {
          "file": "linux\\fs\\dlm\\lowcomms.c",
          "line": 1512,
          "match": "deadlock",
          "context": [
            "\t\tbreak;",
            "\tcase DLM_IO_FLUSH:",
            "\t\t/* we can't flush the process_workqueue here because a",
            "\t\t * WQ_MEM_RECLAIM workequeue can occurr a deadlock for a non",
            "\t\t * WQ_MEM_RECLAIM workqueue such as process_workqueue. Instead",
            "\t\t * we have a waitqueue to wait until all messages are",
            "\t\t * processed."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\dlm\\lowcomms.c"
          ]
        },
        {
          "file": "linux\\fs\\dlm\\user.c",
          "line": 328,
          "match": "deadlock",
          "context": [
            "\treturn error;",
            "}",
            "",
            "static int device_user_deadlock(struct dlm_user_proc *proc,",
            "\t\t\t\tstruct dlm_lock_params *params)",
            "{",
            "\tstruct dlm_ls *ls;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\dlm\\user.c"
          ]
        },
        {
          "file": "linux\\fs\\dlm\\user.c",
          "line": 338,
          "match": "deadlock",
          "context": [
            "\tif (!ls)",
            "\t\treturn -ENOENT;",
            "",
            "\terror = dlm_user_deadlock(ls, params->flags, params->lkid);",
            "",
            "\tdlm_put_lockspace(ls);",
            "\treturn error;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\dlm\\user.c"
          ]
        },
        {
          "file": "linux\\fs\\dlm\\user.c",
          "line": 593,
          "match": "DEADLOCK",
          "context": [
            "\t\terror = device_user_unlock(proc, &kbuf->i.lock);",
            "\t\tbreak;",
            "",
            "\tcase DLM_USER_DEADLOCK:",
            "\t\tif (!proc) {",
            "\t\t\tlog_print(\"no locking on control device\");",
            "\t\t\tgoto out_free;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\dlm\\user.c"
          ]
        },
        {
          "file": "linux\\fs\\dlm\\user.c",
          "line": 598,
          "match": "deadlock",
          "context": [
            "\t\t\tlog_print(\"no locking on control device\");",
            "\t\t\tgoto out_free;",
            "\t\t}",
            "\t\terror = device_user_deadlock(proc, &kbuf->i.lock);",
            "\t\tbreak;",
            "",
            "\tcase DLM_USER_CREATE_LOCKSPACE:"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\dlm\\user.c"
          ]
        },
        {
          "file": "linux\\fs\\erofs\\decompressor_lzma.c",
          "line": 97,
          "match": "deadlock",
          "context": [
            "\t\treturn -EINVAL;",
            "\t}",
            "",
            "\t/* in case 2 z_erofs_load_lzma_config() race to avoid deadlock */",
            "\tmutex_lock(&lzma_resize_mutex);",
            "",
            "\tif (z_erofs_lzma_max_dictsize >= dict_size) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\erofs\\decompressor_lzma.c"
          ]
        },
        {
          "file": "linux\\fs\\erofs\\decompressor_zstd.c",
          "line": 95,
          "match": "deadlock",
          "context": [
            "\t}",
            "\tdict_size = 1U << (zstd->windowlog + 10);",
            "",
            "\t/* in case 2 z_erofs_load_zstd_config() race to avoid deadlock */",
            "\tmutex_lock(&zstd_resize_mutex);",
            "\tif (z_erofs_zstd_max_dictsize >= dict_size) {",
            "\t\tmutex_unlock(&zstd_resize_mutex);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\erofs\\decompressor_zstd.c"
          ]
        },
        {
          "file": "linux\\fs\\ext2\\xattr.c",
          "line": 54,
          "match": "deadlock",
          "context": [
            " * holding xattr_sem also means that nothing but the EA block's reference",
            " * count will change. Multiple writers to an EA block are synchronized",
            " * by the bh lock. No more than a single bh lock is held at any time",
            " * to avoid deadlocks.",
            " */",
            "",
            "#include <linux/buffer_head.h>"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ext2\\xattr.c"
          ]
        },
        {
          "file": "linux\\fs\\ext4\\extents.c",
          "line": 95,
          "match": "deadlock",
          "context": [
            "static int ext4_ext_trunc_restart_fn(struct inode *inode, int *dropped)",
            "{",
            "\t/*",
            "\t * Drop i_data_sem to avoid deadlock with ext4_map_blocks.  At this",
            "\t * moment, get_block can be called only for blocks inside i_size since",
            "\t * page cache has been already dropped and writes are blocked by",
            "\t * i_rwsem. So we can safely drop the i_data_sem here."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ext4\\extents.c"
          ]
        },
        {
          "file": "linux\\fs\\ext4\\indirect.c",
          "line": 704,
          "match": "deadlock",
          "context": [
            "\tif (unlikely(err))",
            "\t\treturn err;",
            "\t/*",
            "\t * Drop i_data_sem to avoid deadlock with ext4_map_blocks.  At this",
            "\t * moment, get_block can be called only for blocks inside i_size since",
            "\t * page cache has been already dropped and writes are blocked by",
            "\t * i_rwsem. So we can safely drop the i_data_sem here."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ext4\\indirect.c"
          ]
        },
        {
          "file": "linux\\fs\\ext4\\move_extent.c",
          "line": 676,
          "match": "deadlock",
          "context": [
            "\t\t\tcur_len = blocks_per_page - offset_in_page;",
            "\t\t/*",
            "\t\t * Up semaphore to avoid following problems:",
            "\t\t * a. transaction deadlock among ext4_journal_start,",
            "\t\t *    ->write_begin via pagefault, and jbd2_journal_commit",
            "\t\t * b. racing with ->read_folio, ->write_begin, and",
            "\t\t *    ext4_get_block in move_extent_per_page"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ext4\\move_extent.c"
          ]
        },
        {
          "file": "linux\\fs\\ext4\\readpage.c",
          "line": 104,
          "match": "deadlock",
          "context": [
            "\t * fsverity_verify_bio() may call readahead() again, and although verity",
            "\t * will be disabled for that, decryption may still be needed, causing",
            "\t * another bio_post_read_ctx to be allocated.  So to guarantee that",
            "\t * mempool_alloc() never deadlocks we must free the current ctx first.",
            "\t * This is safe because verity is the last post-read step.",
            "\t */",
            "\tBUILD_BUG_ON(STEP_VERITY + 1 != STEP_MAX);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ext4\\readpage.c"
          ]
        },
        {
          "file": "linux\\fs\\ext4\\page-io.c",
          "line": 547,
          "match": "deadlock",
          "context": [
            "\t\t/*",
            "\t\t * Since bounce page allocation uses a mempool, we can only use",
            "\t\t * a waiting mask (i.e. request guaranteed allocation) on the",
            "\t\t * first page of the bio.  Otherwise it can deadlock.",
            "\t\t */",
            "\t\tif (io->io_bio)",
            "\t\t\tgfp_flags = GFP_NOWAIT | __GFP_NOWARN;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ext4\\page-io.c"
          ]
        },
        {
          "file": "linux\\fs\\ext4\\super.c",
          "line": 729,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * We don't set SB_RDONLY because that requires sb->s_umount",
            "\t * semaphore and setting it without proper remount procedure is",
            "\t * confusing code such as freeze_super() leading to deadlocks",
            "\t * and other problems.",
            "\t */",
            "\tset_bit(EXT4_FLAGS_EMERGENCY_RO, &EXT4_SB(sb)->s_ext4_flags);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ext4\\super.c"
          ]
        },
        {
          "file": "linux\\fs\\ext4\\super.c",
          "line": 6948,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Trying to sb_start_intwrite() in a running transaction",
            "\t * can result in a deadlock. Further, running transactions",
            "\t * are already protected from freezing.",
            "\t */",
            "\tif (!ext4_journal_current_handle()) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ext4\\super.c"
          ]
        },
        {
          "file": "linux\\fs\\f2fs\\compress.c",
          "line": 1571,
          "match": "deadlock",
          "context": [
            "\t\t\t\tret = 0;",
            "\t\t\t\t/*",
            "\t\t\t\t * for quota file, just redirty left pages to",
            "\t\t\t\t * avoid deadlock caused by cluster update race",
            "\t\t\t\t * from foreground operation.",
            "\t\t\t\t */",
            "\t\t\t\tif (IS_NOQUOTA(cc->inode))"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\f2fs\\compress.c"
          ]
        },
        {
          "file": "linux\\fs\\f2fs\\compress.c",
          "line": 1836,
          "match": "deadlock",
          "context": [
            "",
            "\tif (!failed && dic->need_verity) {",
            "\t\t/*",
            "\t\t * Note that to avoid deadlocks, the verity work can't be done",
            "\t\t * on the decompression workqueue.  This is because verifying",
            "\t\t * the data pages can involve reading metadata pages from the",
            "\t\t * file, and these metadata pages may be compressed."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\f2fs\\compress.c"
          ]
        },
        {
          "file": "linux\\fs\\f2fs\\data.c",
          "line": 173,
          "match": "deadlock",
          "context": [
            "\t * fsverity_verify_bio() may call readahead() again, and while verity",
            "\t * will be disabled for this, decryption and/or decompression may still",
            "\t * be needed, resulting in another bio_post_read_ctx being allocated.",
            "\t * So to prevent deadlocks we need to release the current ctx to the",
            "\t * mempool first.  This assumes that verity is the last post-read step.",
            "\t */",
            "\tmempool_free(ctx, bio_post_read_ctx_pool);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\f2fs\\data.c"
          ]
        },
        {
          "file": "linux\\fs\\f2fs\\data.c",
          "line": 207,
          "match": "deadlock",
          "context": [
            " * If the bio's data needs to be verified with fs-verity, then enqueue the",
            " * verity work for the bio.  Otherwise finish the bio now.",
            " *",
            " * Note that to avoid deadlocks, the verity work can't be done on the",
            " * decryption/decompression workqueue.  This is because verifying the data pages",
            " * can involve reading verity metadata pages from the file, and these verity",
            " * metadata pages may be encrypted and/or compressed."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\f2fs\\data.c"
          ]
        },
        {
          "file": "linux\\fs\\f2fs\\data.c",
          "line": 2673,
          "match": "Deadlock",
          "context": [
            "\t\tgoto got_it;",
            "\t}",
            "",
            "\t/* Deadlock due to between page->lock and f2fs_lock_op */",
            "\tif (fio->need_lock == LOCK_REQ && !f2fs_trylock_op(fio->sbi))",
            "\t\treturn -EAGAIN;",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\f2fs\\data.c"
          ]
        },
        {
          "file": "linux\\fs\\f2fs\\data.c",
          "line": 3218,
          "match": "deadlock",
          "context": [
            "static inline bool __should_serialize_io(struct inode *inode,",
            "\t\t\t\t\tstruct writeback_control *wbc)",
            "{",
            "\t/* to avoid deadlock in path of data flush */",
            "\tif (F2FS_I(inode)->wb_task)",
            "\t\treturn false;",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\f2fs\\data.c"
          ]
        },
        {
          "file": "linux\\fs\\f2fs\\data.c",
          "line": 3270,
          "match": "deadlock",
          "context": [
            "\tif (wbc->sync_mode == WB_SYNC_ALL)",
            "\t\tatomic_inc(&sbi->wb_sync_req[DATA]);",
            "\telse if (atomic_read(&sbi->wb_sync_req[DATA])) {",
            "\t\t/* to avoid potential deadlock */",
            "\t\tif (current->plug)",
            "\t\t\tblk_finish_plug(current->plug);",
            "\t\tgoto skip_write;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\f2fs\\data.c"
          ]
        },
        {
          "file": "linux\\fs\\f2fs\\data.c",
          "line": 3542,
          "match": "deadlock",
          "context": [
            "\t}",
            "",
            "\t/*",
            "\t * We should check this at this moment to avoid deadlock on inode page",
            "\t * and #0 page. The locking rule for inline_data conversion should be:",
            "\t * folio_lock(folio #0) -> folio_lock(inode_page)",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\f2fs\\data.c"
          ]
        },
        {
          "file": "linux\\fs\\f2fs\\data.c",
          "line": 3576,
          "match": "deadlock",
          "context": [
            "",
            "repeat:",
            "\t/*",
            "\t * Do not use FGP_STABLE to avoid deadlock.",
            "\t * Will wait that below with our IO control.",
            "\t */",
            "\tfolio = __filemap_get_folio(mapping, index,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\f2fs\\data.c"
          ]
        },
        {
          "file": "linux\\fs\\f2fs\\gc.c",
          "line": 1813,
          "match": "deadlock",
          "context": [
            "\t\t}",
            "",
            "\t\t/*",
            "\t\t * this is to avoid deadlock:",
            "\t\t * - lock_page(sum_page)         - f2fs_replace_block",
            "\t\t *  - check_valid_map()            - down_write(sentry_lock)",
            "\t\t *   - down_read(sentry_lock)     - change_curseg()"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\f2fs\\gc.c"
          ]
        },
        {
          "file": "linux\\fs\\f2fs\\node.c",
          "line": 2172,
          "match": "deadlock",
          "context": [
            "\tif (wbc->sync_mode == WB_SYNC_ALL)",
            "\t\tatomic_inc(&sbi->wb_sync_req[NODE]);",
            "\telse if (atomic_read(&sbi->wb_sync_req[NODE])) {",
            "\t\t/* to avoid potential deadlock */",
            "\t\tif (current->plug)",
            "\t\t\tblk_finish_plug(current->plug);",
            "\t\tgoto skip_write;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\f2fs\\node.c"
          ]
        },
        {
          "file": "linux\\fs\\f2fs\\super.c",
          "line": 1478,
          "match": "deadlock",
          "context": [
            "\t}",
            "",
            "\t/*",
            "\t * This is to avoid a deadlock condition like below.",
            "\t * writeback_single_inode(inode)",
            "\t *  - f2fs_write_data_page",
            "\t *    - f2fs_gc -> iput -> evict"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\f2fs\\super.c"
          ]
        },
        {
          "file": "linux\\fs\\f2fs\\super.c",
          "line": 1772,
          "match": "deadlock",
          "context": [
            "",
            "\tsbi->umount_lock_holder = NULL;",
            "",
            "\t/* to avoid deadlock on f2fs_evict_inode->SB_FREEZE_FS */",
            "\tset_sbi_flag(sbi, SBI_IS_FREEZING);",
            "\treturn 0;",
            "}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\f2fs\\super.c"
          ]
        },
        {
          "file": "linux\\fs\\f2fs\\super.c",
          "line": 4277,
          "match": "deadlock",
          "context": [
            "",
            "\t\t/*",
            "\t\t * always create an asynchronous task to record stop_reason",
            "\t\t * in order to avoid potential deadlock when running into",
            "\t\t * f2fs_record_stop_reason() synchronously.",
            "\t\t */",
            "\t\tschedule_work(&sbi->s_error_work);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\f2fs\\super.c"
          ]
        },
        {
          "file": "linux\\fs\\f2fs\\super.c",
          "line": 4316,
          "match": "deadlock",
          "context": [
            "\t * to filesystem, so it doesn't need to set SB_RDONLY flag here",
            "\t * because the flag should be set covered w/ sb->s_umount semaphore",
            "\t * via remount procedure, otherwise, it will confuse code like",
            "\t * freeze_super() which will lead to deadlocks and other problems.",
            "\t */",
            "}",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\f2fs\\super.c"
          ]
        },
        {
          "file": "linux\\fs\\fuse\\dax.c",
          "line": 373,
          "match": "deadlock",
          "context": [
            " * It is called from evict_inode() and by that time inode is going away. So",
            " * this function does not take any locks like fi->dax->sem for traversing",
            " * that fuse inode interval tree. If that lock is taken then lock validator",
            " * complains of deadlock situation w.r.t fs_reclaim lock.",
            " */",
            "void fuse_dax_inode_cleanup(struct inode *inode)",
            "{"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\fuse\\dax.c"
          ]
        },
        {
          "file": "linux\\fs\\fuse\\dax.c",
          "line": 1013,
          "match": "deadlock",
          "context": [
            "\t\t * had a reference or some other temporary failure,",
            "\t\t * Try again. We want to give up inline reclaim only",
            "\t\t * if there is no range assigned to this node. Otherwise",
            "\t\t * if a deadlock is possible if we sleep with",
            "\t\t * mapping->invalidate_lock held and worker to free memory",
            "\t\t * can't make progress due to unavailability of",
            "\t\t * mapping->invalidate_lock.  So sleep only if fi->dax->nr=0"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\fuse\\dax.c"
          ]
        },
        {
          "file": "linux\\fs\\fuse\\dev.c",
          "line": 2391,
          "match": "deadlock",
          "context": [
            "/*",
            " * Abort all requests.",
            " *",
            " * Emergency exit in case of a malicious or accidental deadlock, or just a hung",
            " * filesystem.",
            " *",
            " * The same effect is usually achievable through killing the filesystem daemon"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\fuse\\dev.c"
          ]
        },
        {
          "file": "linux\\fs\\fuse\\dev.c",
          "line": 2396,
          "match": "deadlock",
          "context": [
            " *",
            " * The same effect is usually achievable through killing the filesystem daemon",
            " * and all users of the filesystem.  The exception is the combination of an",
            " * asynchronous request and the tricky deadlock (see",
            " * Documentation/filesystems/fuse.rst).",
            " *",
            " * Aborting requests under I/O goes as follows: 1: Separate out unlocked"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\fuse\\dev.c"
          ]
        },
        {
          "file": "linux\\fs\\fuse\\dir.c",
          "line": 2099,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Only call invalidate_inode_pages2() after removing",
            "\t * FUSE_NOWRITE, otherwise fuse_launder_folio() would deadlock.",
            "\t */",
            "\tif ((is_truncate || !is_wb) &&",
            "\t    S_ISREG(inode->i_mode) && oldsize != outarg.attr.size) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\fuse\\dir.c"
          ]
        },
        {
          "file": "linux\\fs\\fuse\\file.c",
          "line": 1935,
          "match": "deadlock",
          "context": [
            "\t * Inode is always written before the last reference is dropped and",
            "\t * hence this should not be reached from reclaim.",
            "\t *",
            "\t * Writing back the inode from reclaim can deadlock if the request",
            "\t * processing itself needs an allocation.  Allocations triggering",
            "\t * reclaim while serving a request can't be prevented, because it can",
            "\t * involve any number of unrelated userspace processes."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\fuse\\file.c"
          ]
        },
        {
          "file": "linux\\fs\\fuse\\file.c",
          "line": 3163,
          "match": "deadlock",
          "context": [
            "\tinode->i_fop = &fuse_file_operations;",
            "\tinode->i_data.a_ops = &fuse_file_aops;",
            "\tif (fc->writeback_cache)",
            "\t\tmapping_set_writeback_may_deadlock_on_reclaim(&inode->i_data);",
            "",
            "\tINIT_LIST_HEAD(&fi->write_files);",
            "\tINIT_LIST_HEAD(&fi->queued_writes);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\fuse\\file.c"
          ]
        },
        {
          "file": "linux\\fs\\gfs2\\glock.c",
          "line": 633,
          "match": "deadlock",
          "context": [
            "\t\t\t}",
            "\t\t}",
            "\t\tswitch(state) {",
            "\t\t/* Unlocked due to conversion deadlock, try again */",
            "\t\tcase LM_ST_UNLOCKED:",
            "\t\t\tdo_xmote(gl, gh, gl->gl_target);",
            "\t\t\tbreak;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\gfs2\\glock.c"
          ]
        },
        {
          "file": "linux\\fs\\gfs2\\glock.c",
          "line": 1777,
          "match": "deadlock",
          "context": [
            "}",
            "",
            "/**",
            " * nq_m_sync - synchronously acquire more than one glock in deadlock free order",
            " * @num_gh: the number of structures",
            " * @ghs: an array of struct gfs2_holder structures",
            " * @p: placeholder for the holder structure to pass back"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\gfs2\\glock.c"
          ]
        },
        {
          "file": "linux\\fs\\gfs2\\lock_dlm.c",
          "line": 145,
          "match": "Deadlock",
          "context": [
            "\t\tret |= LM_OUT_CANCELED;",
            "\t\tgoto out;",
            "\tcase -EAGAIN: /* Try lock fails */",
            "\tcase -EDEADLK: /* Deadlock detected */",
            "\t\tgoto out;",
            "\tcase -ETIMEDOUT: /* Canceled due to timeout */",
            "\t\tret |= LM_OUT_ERROR;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\gfs2\\lock_dlm.c"
          ]
        },
        {
          "file": "linux\\fs\\gfs2\\super.c",
          "line": 1036,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * When under memory pressure when an inode's link count has dropped to",
            "\t * zero, defer deleting the inode to the delete workqueue.  This avoids",
            "\t * calling into DLM under memory pressure, which can deadlock.",
            "\t */",
            "\tif (!inode->i_nlink &&",
            "\t    unlikely(current->flags & PF_MEMALLOC) &&"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\gfs2\\super.c"
          ]
        },
        {
          "file": "linux\\fs\\gfs2\\super.c",
          "line": 1177,
          "match": "deadlock",
          "context": [
            " * @gl:\tThe glock to put",
            " *",
            " * When under memory pressure, trigger a deferred glock put to make sure we",
            " * won't call into DLM and deadlock.  Otherwise, put the glock directly.",
            " */",
            "",
            "static void gfs2_glock_put_eventually(struct gfs2_glock *gl)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\gfs2\\super.c"
          ]
        },
        {
          "file": "linux\\fs\\iomap\\buffered-io.c",
          "line": 966,
          "match": "deadlock",
          "context": [
            "",
            "\t\t/*",
            "\t\t * Bring in the user page that we'll copy from _first_.",
            "\t\t * Otherwise there's a nasty deadlock on copying from the",
            "\t\t * same page as we're writing to, without it being marked",
            "\t\t * up-to-date.",
            "\t\t *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\iomap\\buffered-io.c"
          ]
        },
        {
          "file": "linux\\fs\\iomap\\direct-io.c",
          "line": 261,
          "match": "deadlock",
          "context": [
            "\t\t * Try to avoid another context switch for the completion given",
            "\t\t * that we are already called from the ioend completion",
            "\t\t * workqueue, but never invalidate pages from this thread to",
            "\t\t * avoid deadlocks with buffered I/O completions.  Tough luck if",
            "\t\t * you hit the tiny race with someone dirtying the range now",
            "\t\t * between this check and the actual completion.",
            "\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\iomap\\direct-io.c"
          ]
        },
        {
          "file": "linux\\fs\\jbd2\\journal.c",
          "line": 494,
          "match": "deadlock",
          "context": [
            "",
            "/*",
            " * Force and wait any uncommitted transactions.  We can only force the running",
            " * transaction if we don't have an active handle, otherwise, we will deadlock.",
            " * Returns: <0 in case of error,",
            " *           0 if nothing to commit,",
            " *           1 if transaction was successfully committed."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\jbd2\\journal.c"
          ]
        },
        {
          "file": "linux\\fs\\jbd2\\journal.c",
          "line": 552,
          "match": "deadlock",
          "context": [
            " * @journal: journal to force",
            " *",
            " * Caller want unconditional commit. We can only force the running transaction",
            " * if we don't have an active handle, otherwise, we will deadlock.",
            " */",
            "int jbd2_journal_force_commit(journal_t *journal)",
            "{"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\jbd2\\journal.c"
          ]
        },
        {
          "file": "linux\\fs\\jbd2\\transaction.c",
          "line": 265,
          "match": "deadlock",
          "context": [
            "\t * The commit code assumes that it can get enough log space",
            "\t * without forcing a checkpoint.  This is *critical* for",
            "\t * correctness: a checkpoint of a buffer which is also",
            "\t * associated with a committing transaction creates a deadlock,",
            "\t * so commit simply cannot force through checkpoints.",
            "\t *",
            "\t * We must therefore ensure the necessary space in the journal"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\jbd2\\transaction.c"
          ]
        },
        {
          "file": "linux\\fs\\jbd2\\transaction.c",
          "line": 376,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Wait on the journal's transaction barrier if necessary. Specifically",
            "\t * we allow reserved handles to proceed because otherwise commit could",
            "\t * deadlock on page writeback not being able to complete.",
            "\t */",
            "\tif (!handle->h_reserved && journal->j_barrier_count) {",
            "\t\tread_unlock(&journal->j_state_lock);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\jbd2\\transaction.c"
          ]
        },
        {
          "file": "linux\\fs\\jffs2\\dir.c",
          "line": 200,
          "match": "deadlock",
          "context": [
            "\t   space and taking c-alloc_sem. If we keep it locked here,",
            "\t   lockdep gets unhappy (although it's a false positive;",
            "\t   nothing else will be looking at this inode yet so there's",
            "\t   no chance of AB-BA deadlock involving its f->sem). */",
            "\tmutex_unlock(&f->sem);",
            "",
            "\tret = jffs2_do_create(c, dir_f, f, ri, &dentry->d_name);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\jffs2\\dir.c"
          ]
        },
        {
          "file": "linux\\fs\\jffs2\\file.c",
          "line": 204,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * While getting a page and reading data in, lock c->alloc_sem until",
            "\t * the page is Uptodate. Otherwise GC task may attempt to read the same",
            "\t * page in read_cache_page(), which causes a deadlock.",
            "\t */",
            "\tmutex_lock(&c->alloc_sem);",
            "\tfolio = __filemap_get_folio(mapping, index, FGP_WRITEBEGIN,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\jffs2\\file.c"
          ]
        },
        {
          "file": "linux\\fs\\jffs2\\file.c",
          "line": 260,
          "match": "deadlock",
          "context": [
            "\t\t  __func__, inode->i_ino, folio_pos(folio),",
            "\t\t  start, end, folio->flags);",
            "",
            "\t/* We need to avoid deadlock with page_cache_read() in",
            "\t   jffs2_garbage_collect_pass(). So the folio must be",
            "\t   up to date to prevent page_cache_read() from trying",
            "\t   to re-lock it. */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\jffs2\\file.c"
          ]
        },
        {
          "file": "linux\\fs\\jffs2\\gc.c",
          "line": 1327,
          "match": "deadlock",
          "context": [
            "\t * It is important to note that jffs2_write_begin() will ensure that its",
            "\t * folio is marked uptodate before allocating space. That means that if we",
            "\t * end up here trying to GC the *same* folio that jffs2_write_begin() is",
            "\t * trying to write out, read_cache_folio() will not deadlock. */",
            "\tmutex_unlock(&f->sem);",
            "\tfolio = read_cache_folio(inode->i_mapping, start >> PAGE_SHIFT,",
            "\t\t\t       __jffs2_read_folio, NULL);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\jffs2\\gc.c"
          ]
        },
        {
          "file": "linux\\fs\\jfs\\jfs_imap.c",
          "line": 22,
          "match": "deadlock",
          "context": [
            " *\tlevel information is modified or an atomic operation needs to be used.",
            " *",
            " *\tIf more than one IAG is read at one time, the read lock may not",
            " *\tbe given up until all of the IAG's are read.  Otherwise, a deadlock",
            " *\tmay occur when trying to obtain the read lock while another thread",
            " *\tholding the read lock is waiting on the IAG already being held.",
            " *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\jfs\\jfs_imap.c"
          ]
        },
        {
          "file": "linux\\fs\\jfs\\jfs_imap.c",
          "line": 1083,
          "match": "deadlock",
          "context": [
            "\t\t * list.  before reading these iags, we must make",
            "\t\t * sure that we already don't have them in hand",
            "\t\t * from up above, since re-reading an iag (buffer)",
            "\t\t * we are currently holding would cause a deadlock.",
            "\t\t */",
            "\t\tif (inofreefwd >= 0) {",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\jfs\\jfs_imap.c"
          ]
        },
        {
          "file": "linux\\fs\\jfs\\jfs_logmgr.c",
          "line": 1807,
          "match": "deadlock",
          "context": [
            "\t * the page cache (for the log).  This would be bad, since page",
            "\t * allocation waits on the kswapd thread that may be committing inodes",
            "\t * which would cause log activity.  Was that clear?  I'm trying to",
            "\t * avoid deadlock here.",
            "\t */",
            "\tinit_waitqueue_head(&log->free_wait);",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\jfs\\jfs_logmgr.c"
          ]
        },
        {
          "file": "linux\\fs\\jfs\\jfs_txnmgr.c",
          "line": 346,
          "match": "deadlock",
          "context": [
            " * RETURN:\ttid\t- transaction id",
            " *",
            " * note: flag force allows to start tx for nested tx",
            " * to prevent deadlock on logsync barrier;",
            " */",
            "tid_t txBegin(struct super_block *sb, int flag)",
            "{"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\jfs\\jfs_txnmgr.c"
          ]
        },
        {
          "file": "linux\\fs\\jfs\\jfs_txnmgr.c",
          "line": 1191,
          "match": "deadlock",
          "context": [
            "\t * on the on-disk inode of file object",
            "\t *",
            "\t * sort the inodes array by inode number in descending order",
            "\t * to prevent deadlock when acquiring transaction lock",
            "\t * of on-disk inodes on multiple on-disk inode pages by",
            "\t * multiple concurrent transactions",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\jfs\\jfs_txnmgr.c"
          ]
        },
        {
          "file": "linux\\fs\\jfs\\jfs_txnmgr.c",
          "line": 1219,
          "match": "deadlock",
          "context": [
            "\t\t *",
            "\t\t * The problem now is that we are holding the IWRITELOCK",
            "\t\t * on the inode, and calling filemap_fdatawrite on an",
            "\t\t * unmapped page will cause a deadlock in jfs_get_block.",
            "\t\t *",
            "\t\t * The long term solution is to pare down the use of",
            "\t\t * IWRITELOCK.  We are currently holding it too long."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\jfs\\jfs_txnmgr.c"
          ]
        },
        {
          "file": "linux\\fs\\jfs\\jfs_txnmgr.c",
          "line": 1273,
          "match": "deadlock",
          "context": [
            "\tif (tblk->xflag & COMMIT_DELETE) {",
            "\t\tihold(tblk->u.ip);",
            "\t\t/*",
            "\t\t * Avoid a rare deadlock",
            "\t\t *",
            "\t\t * If the inode is locked, we may be blocked in",
            "\t\t * jfs_commit_inode.  If so, we don't want the"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\jfs\\jfs_txnmgr.c"
          ]
        },
        {
          "file": "linux\\fs\\jfs\\jfs_txnmgr.c",
          "line": 1285,
          "match": "deadlock",
          "context": [
            "\t\t/*",
            "\t\t * I believe this code is no longer needed.  Splitting I_LOCK",
            "\t\t * into two bits, I_NEW and I_SYNC should prevent this",
            "\t\t * deadlock as well.  But since I don't have a JFS testload",
            "\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.",
            "\t\t * Joern",
            "\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\jfs\\jfs_txnmgr.c"
          ]
        },
        {
          "file": "linux\\fs\\jfs\\jfs_txnmgr.c",
          "line": 2808,
          "match": "deadlock",
          "context": [
            " *\tcompletion",
            " *",
            " *\tThis does almost the same thing as jfs_sync below.  We don't",
            " *\tworry about deadlocking when jfs_tlocks_low is set, since we would",
            " *\texpect jfs_sync to get us out of that jam.",
            " */",
            "void txQuiesce(struct super_block *sb)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\jfs\\jfs_txnmgr.c"
          ]
        },
        {
          "file": "linux\\fs\\jfs\\jfs_xtree.c",
          "line": 2128,
          "match": "deadlock",
          "context": [
            "",
            "",
            "/*",
            " * We can run into a deadlock truncating a file with a large number of",
            " * xtree pages (large fragmented file).  A robust fix would entail a",
            " * reservation system where we would reserve a number of metadata pages",
            " * and tlocks which we would be guaranteed without a deadlock.  Without"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\jfs\\jfs_xtree.c"
          ]
        },
        {
          "file": "linux\\fs\\jfs\\jfs_xtree.c",
          "line": 2131,
          "match": "deadlock",
          "context": [
            " * We can run into a deadlock truncating a file with a large number of",
            " * xtree pages (large fragmented file).  A robust fix would entail a",
            " * reservation system where we would reserve a number of metadata pages",
            " * and tlocks which we would be guaranteed without a deadlock.  Without",
            " * this, a partial fix is to limit number of metadata pages we will lock",
            " * in a single transaction.  Currently we will truncate the file so that",
            " * no more than 50 leaf pages will be locked.  The caller of xtTruncate"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\jfs\\jfs_xtree.c"
          ]
        },
        {
          "file": "linux\\fs\\jfs\\jfs_xtree.c",
          "line": 2739,
          "match": "deadlock",
          "context": [
            " *",
            " * note:",
            " *",
            " *\tTo avoid deadlock by holding too many transaction locks, the",
            " *\ttruncation may be broken up into multiple transactions.",
            " *\tThe committed_size keeps track of part of the file has been",
            " *\tfreed from the pmaps."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\jfs\\jfs_xtree.c"
          ]
        },
        {
          "file": "linux\\fs\\jfs\\namei.c",
          "line": 88,
          "match": "Deadlock",
          "context": [
            "\t\tgoto out1;",
            "",
            "\t/*",
            "\t * Either iAlloc() or txBegin() may block.  Deadlock can occur if we",
            "\t * block there while holding dtree page, so we allocate the inode &",
            "\t * begin the transaction before we search the directory.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\jfs\\namei.c"
          ]
        },
        {
          "file": "linux\\fs\\jfs\\namei.c",
          "line": 221,
          "match": "Deadlock",
          "context": [
            "\t\tgoto out1;",
            "",
            "\t/*",
            "\t * Either iAlloc() or txBegin() may block.  Deadlock can occur if we",
            "\t * block there while holding dtree page, so we allocate the inode &",
            "\t * begin the transaction before we search the directory.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\jfs\\namei.c"
          ]
        },
        {
          "file": "linux\\fs\\jfs\\namei.c",
          "line": 1157,
          "match": "deadlock",
          "context": [
            "\ttid = txBegin(new_dir->i_sb, 0);",
            "",
            "\t/*",
            "\t * How do we know the locking is safe from deadlocks?",
            "\t * The vfs does the hard part for us.  Any time we are taking nested",
            "\t * commit_mutexes, the vfs already has i_mutex held on the parent.",
            "\t * Here, the vfs has already taken i_mutex on both old_dir and new_dir."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\jfs\\namei.c"
          ]
        },
        {
          "file": "linux\\fs\\kernfs\\dir.c",
          "line": 24,
          "match": "deadlock",
          "context": [
            " * Don't use rename_lock to piggy back on pr_cont_buf. We don't want to",
            " * call pr_cont() while holding rename_lock. Because sometimes pr_cont()",
            " * will perform wakeups when releasing console_sem. Holding rename_lock",
            " * will introduce deadlock if the scheduler reads the kernfs_name in the",
            " * wakeup path.",
            " */",
            "static DEFINE_SPINLOCK(kernfs_pr_cont_lock);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\kernfs\\dir.c"
          ]
        },
        {
          "file": "linux\\fs\\kernfs\\mount.c",
          "line": 72,
          "match": "deadlock",
          "context": [
            "\t * writing to various files in /sys/power/. As filesystems may",
            "\t * be automatically frozen during suspend/hibernate implementing",
            "\t * freeze/thaw support for kernfs generically will cause",
            "\t * deadlocks as the suspending/hibernation initiating task will",
            "\t * hold a VFS lock that it will then wait upon to be released.",
            "\t * If freeze/thaw for kernfs is needed talk to the VFS.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\kernfs\\mount.c"
          ]
        },
        {
          "file": "linux\\fs\\lockd\\svclock.c",
          "line": 37,
          "match": "deadlock",
          "context": [
            "#define NLMDBG_FACILITY\t\tNLMDBG_SVCLOCK",
            "",
            "#ifdef CONFIG_LOCKD_V4",
            "#define nlm_deadlock\tnlm4_deadlock",
            "#else",
            "#define nlm_deadlock\tnlm_lck_denied",
            "#endif"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\lockd\\svclock.c"
          ]
        },
        {
          "file": "linux\\fs\\lockd\\svclock.c",
          "line": 37,
          "match": "deadlock",
          "context": [
            "#define NLMDBG_FACILITY\t\tNLMDBG_SVCLOCK",
            "",
            "#ifdef CONFIG_LOCKD_V4",
            "#define nlm_deadlock\tnlm4_deadlock",
            "#else",
            "#define nlm_deadlock\tnlm_lck_denied",
            "#endif"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\lockd\\svclock.c"
          ]
        },
        {
          "file": "linux\\fs\\lockd\\svclock.c",
          "line": 39,
          "match": "deadlock",
          "context": [
            "#ifdef CONFIG_LOCKD_V4",
            "#define nlm_deadlock\tnlm4_deadlock",
            "#else",
            "#define nlm_deadlock\tnlm_lck_denied",
            "#endif",
            "",
            "static void nlmsvc_release_block(struct nlm_block *block);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\lockd\\svclock.c"
          ]
        },
        {
          "file": "linux\\fs\\lockd\\svclock.c",
          "line": 589,
          "match": "deadlock",
          "context": [
            "\t\t\tgoto out;",
            "\t\tcase -EDEADLK:",
            "\t\t\tnlmsvc_remove_block(block);",
            "\t\t\tret = nlm_deadlock;",
            "\t\t\tgoto out;",
            "\t\tdefault:\t\t\t/* includes ENOLCK */",
            "\t\t\tnlmsvc_remove_block(block);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\lockd\\svclock.c"
          ]
        },
        {
          "file": "linux\\fs\\lockd\\svcproc.c",
          "line": 33,
          "match": "deadlock",
          "context": [
            "\t\tcase nlm_lck_denied_grace_period:",
            "\t\tcase nlm_drop_reply:",
            "\t\t\tbreak;",
            "\t\tcase nlm4_deadlock:",
            "\t\t\tstatus = nlm_lck_denied;",
            "\t\t\tbreak;",
            "\t\tdefault:"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\lockd\\svcproc.c"
          ]
        },
        {
          "file": "linux\\fs\\netfs\\buffered_write.c",
          "line": 155,
          "match": "deadlock",
          "context": [
            "\t\tpart = min(max_chunk - offset, iov_iter_count(iter));",
            "",
            "\t\t/* Bring in the user pages that we will copy from _first_ lest",
            "\t\t * we hit a nasty deadlock on copying from the same page as",
            "\t\t * we're writing to, without it being marked uptodate.",
            "\t\t *",
            "\t\t * Not only is this an optimisation, but it is also required to"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\netfs\\buffered_write.c"
          ]
        },
        {
          "file": "linux\\fs\\netfs\\write_collect.c",
          "line": 54,
          "match": "deadlock",
          "context": [
            "",
            "/*",
            " * Successful completion of write of a folio to the server and/or cache.  Note",
            " * that we are not allowed to lock the folio here on pain of deadlocking with",
            " * truncate.",
            " */",
            "int netfs_folio_written_back(struct folio *folio)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\netfs\\write_collect.c"
          ]
        },
        {
          "file": "linux\\fs\\nfs\\delegation.c",
          "line": 721,
          "match": "deadlock",
          "context": [
            " *",
            " * Note that this function is designed to be called by the state",
            " * manager thread. For this reason, it cannot flush the dirty data,",
            " * since that could deadlock in case of a state recovery error.",
            " *",
            " * Returns zero on success, or a negative errno value.",
            " */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\nfs\\delegation.c"
          ]
        },
        {
          "file": "linux\\fs\\nfs\\nfs4state.c",
          "line": 2604,
          "match": "deadlock",
          "context": [
            "\tconst char *section = \"\", *section_sep = \"\";",
            "",
            "\t/*",
            "\t * State recovery can deadlock if the direct reclaim code tries",
            "\t * start NFS writeback. So ensure memory allocations are all",
            "\t * GFP_NOFS.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\nfs\\nfs4state.c"
          ]
        },
        {
          "file": "linux\\fs\\nfs\\nfs4proc.c",
          "line": 654,
          "match": "DEADLOCK",
          "context": [
            "\t}",
            "\tif (exception->recovering) {",
            "\t\tif (exception->task_is_privileged)",
            "\t\t\treturn -EDEADLOCK;",
            "\t\tret = nfs4_wait_clnt_recover(clp);",
            "\t\tif (test_bit(NFS_MIG_FAILED, &server->mig_status))",
            "\t\t\treturn -EIO;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\nfs\\nfs4proc.c"
          ]
        },
        {
          "file": "linux\\fs\\nfs\\nfs4proc.c",
          "line": 695,
          "match": "DEADLOCK",
          "context": [
            "\t}",
            "\tif (exception->recovering) {",
            "\t\tif (exception->task_is_privileged)",
            "\t\t\treturn -EDEADLOCK;",
            "\t\trpc_sleep_on(&clp->cl_rpcwaitq, task, NULL);",
            "\t\tif (test_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) == 0)",
            "\t\t\trpc_wake_up_queued_task(&clp->cl_rpcwaitq, task);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\nfs\\nfs4proc.c"
          ]
        },
        {
          "file": "linux\\fs\\nfs\\nfs4proc.c",
          "line": 2836,
          "match": "deadlock",
          "context": [
            "\t\treturn PTR_ERR(opendata);",
            "\t/*",
            "\t * We're not recovering a delegation, so ask for no delegation.",
            "\t * Otherwise the recovery thread could deadlock with an outstanding",
            "\t * delegation return.",
            "\t */",
            "\topendata->o_arg.open_flags = O_DIRECT;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\nfs\\nfs4proc.c"
          ]
        },
        {
          "file": "linux\\fs\\nfs\\nfs4proc.c",
          "line": 6521,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Since this string is allocated at mount time, and held until the",
            "\t * nfs_client is destroyed, we can use GFP_KERNEL here w/o worrying",
            "\t * about a memory-reclaim deadlock.",
            "\t */",
            "\tstr = kmalloc(len, GFP_KERNEL);",
            "\tif (!str)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\nfs\\nfs4proc.c"
          ]
        },
        {
          "file": "linux\\fs\\nfs\\nfs4proc.c",
          "line": 6568,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Since this string is allocated at mount time, and held until the",
            "\t * nfs_client is destroyed, we can use GFP_KERNEL here w/o worrying",
            "\t * about a memory-reclaim deadlock.",
            "\t */",
            "\tstr = kmalloc(len, GFP_KERNEL);",
            "\tif (!str)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\nfs\\nfs4proc.c"
          ]
        },
        {
          "file": "linux\\fs\\nfs\\pagelist.c",
          "line": 1424,
          "match": "deadlock",
          "context": [
            " * @index: page index",
            " *",
            " * It is important to ensure that processes don't try to take locks",
            " * on non-contiguous ranges of pages as that might deadlock. This",
            " * function should be called before attempting to wait on a locked",
            " * nfs_page. It will complete the I/O if the page index 'index'",
            " * is not contiguous with the existing list of pages in 'desc'."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\nfs\\pagelist.c"
          ]
        },
        {
          "file": "linux\\fs\\nfs\\pnfs.c",
          "line": 1417,
          "match": "deadlock",
          "context": [
            "\t\tsend = pnfs_prepare_layoutreturn(lo, &stateid, &cred, &iomode);",
            "\t\tspin_unlock(&inode->i_lock);",
            "\t\tif (send) {",
            "\t\t\t/* Send an async layoutreturn so we dont deadlock */",
            "\t\t\tpnfs_send_layoutreturn(lo, &stateid, &cred, iomode,",
            "\t\t\t\t\t       PNFS_FL_LAYOUTRETURN_ASYNC);",
            "\t\t}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\nfs\\pnfs.c"
          ]
        },
        {
          "file": "linux\\fs\\nfs\\pnfs.c",
          "line": 3181,
          "match": "deadlock",
          "context": [
            "\tstruct nfs_pageio_descriptor pgio;",
            "",
            "\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {",
            "\t\t/* Prevent deadlocks with layoutreturn! */",
            "\t\tpnfs_put_lseg(hdr->lseg);",
            "\t\thdr->lseg = NULL;",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\nfs\\pnfs.c"
          ]
        },
        {
          "file": "linux\\fs\\nfsd\\nfs4callback.c",
          "line": 218,
          "match": "DEADLOCK",
          "context": [
            "\t{ NFS4ERR_RESOURCE,\t-EREMOTEIO\t},",
            "\t{ NFS4ERR_SYMLINK,\t-ELOOP\t\t},",
            "\t{ NFS4ERR_OP_ILLEGAL,\t-EOPNOTSUPP\t},",
            "\t{ NFS4ERR_DEADLOCK,\t-EDEADLK\t},",
            "\t{ -1,\t\t\t-EIO\t\t}",
            "};",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\nfsd\\nfs4callback.c"
          ]
        },
        {
          "file": "linux\\fs\\nfsd\\nfs4state.c",
          "line": 5332,
          "match": "deadlock",
          "context": [
            " * @rqstp: the RPC transaction being executed",
            " * @inode: in-core inode of the file being waited for",
            " *",
            " * The timeout prevents deadlock if all nfsd threads happen to be",
            " * tied up waiting for returning delegations.",
            " *",
            " * Return values:"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\nfsd\\nfs4state.c"
          ]
        },
        {
          "file": "linux\\fs\\nfsd\\nfs4state.c",
          "line": 8306,
          "match": "deadlock",
          "context": [
            "\t\tnfs4_set_lock_denied(conflock, &lock->lk_denied);",
            "\t\tbreak;",
            "\tcase -EDEADLK:",
            "\t\tstatus = nfserr_deadlock;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tdprintk(\"NFSD: nfsd4_lock: vfs_lock_file() failed! status %d\\n\",err);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\nfsd\\nfs4state.c"
          ]
        },
        {
          "file": "linux\\fs\\nfsd\\vfs.c",
          "line": 2116,
          "match": "deadlock",
          "context": [
            "/*",
            " * We do this buffering because we must not call back into the file",
            " * system's ->lookup() method from the filldir callback. That may well",
            " * deadlock a number of file systems.",
            " *",
            " * This is based heavily on the implementation of same in XFS.",
            " */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\nfsd\\vfs.c"
          ]
        },
        {
          "file": "linux\\fs\\nfs_common\\common.c",
          "line": 105,
          "match": "DEADLOCK",
          "context": [
            "\t{ NFS4ERR_TOOSMALL,\t-ETOOSMALL\t},",
            "\t{ NFS4ERR_BADTYPE,\t-EBADTYPE\t},",
            "\t{ NFS4ERR_SYMLINK,\t-ELOOP\t\t},",
            "\t{ NFS4ERR_DEADLOCK,\t-EDEADLK\t},",
            "};",
            "",
            "static const struct {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\nfs_common\\common.c"
          ]
        },
        {
          "file": "linux\\fs\\nilfs2\\segment.c",
          "line": 184,
          "match": "deadlock",
          "context": [
            " * the segment semaphore, to make a segment construction and write tasks",
            " * exclusive.  The function is used with nilfs_transaction_commit() in pairs.",
            " * The region enclosed by these two functions can be nested.  To avoid a",
            " * deadlock, the semaphore is only acquired or released in the outermost call.",
            " *",
            " * This function allocates a nilfs_transaction_info struct to keep context",
            " * information on it.  It is initialized and hooked onto the current task in"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\nilfs2\\segment.c"
          ]
        },
        {
          "file": "linux\\fs\\nilfs2\\segment.c",
          "line": 2071,
          "match": "deadlock",
          "context": [
            "\t\tlist_del_init(&ii->i_dirty);",
            "\t\tif (!ii->vfs_inode.i_nlink || during_mount) {",
            "\t\t\t/*",
            "\t\t\t * Defer calling iput() to avoid deadlocks if",
            "\t\t\t * i_nlink == 0 or mount is not yet finished.",
            "\t\t\t */",
            "\t\t\tlist_add_tail(&ii->i_dirty, &sci->sc_iput_queue);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\nilfs2\\segment.c"
          ]
        },
        {
          "file": "linux\\fs\\nilfs2\\segment.c",
          "line": 2323,
          "match": "deadlock",
          "context": [
            "\tif (sb_rdonly(sb) || unlikely(!sci))",
            "\t\treturn -EROFS;",
            "",
            "\t/* A call inside transactions causes a deadlock. */",
            "\tBUG_ON((ti = current->journal_info) && ti->ti_magic == NILFS_TI_MAGIC);",
            "",
            "\treturn nilfs_segctor_sync(sci);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\nilfs2\\segment.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\aops.c",
          "line": 1823,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * The mmapped page won't be unlocked in ocfs2_free_write_ctxt(),",
            "\t * even in case of error here like ENOSPC and ENOMEM. So, we need",
            "\t * to unlock the target page manually to prevent deadlocks when",
            "\t * retrying again on ENOSPC, or when returning non-VM_FAULT_LOCKED",
            "\t * to VM code.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\aops.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\aops.c",
          "line": 2033,
          "match": "deadlock",
          "context": [
            "",
            "out:",
            "\t/* unlock pages before dealloc since it needs acquiring j_trans_barrier",
            "\t * lock, or it will cause a deadlock since journal commit threads holds",
            "\t * this lock and will ask for the page lock when flushing the data.",
            "\t * put it here to preserve the unlock order.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\aops.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\alloc.c",
          "line": 6392,
          "match": "deadlock",
          "context": [
            " *",
            " * These structures allow the delay of block de-allocation until a",
            " * later time, when locking of multiple cluster inodes won't cause",
            " * deadlock.",
            " */",
            "",
            "/*"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\alloc.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\dlmglue.c",
          "line": 1966,
          "match": "deadlock",
          "context": [
            " *   no-lock at unlock time. This also means flock locks never go on",
            " *   the blocking list).",
            " *",
            " * - Since userspace can trivially deadlock itself with flock, we make",
            " *   sure to allow cancellation of a misbehaving applications flock()",
            " *   request.",
            " *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\dlmglue.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\dlmglue.c",
          "line": 2042,
          "match": "deadlock",
          "context": [
            "\tret = ocfs2_wait_for_mask_interruptible(&mw, lockres);",
            "\tif (ret == -ERESTARTSYS) {",
            "\t\t/*",
            "\t\t * Userspace can cause deadlock itself with",
            "\t\t * flock(). Current behavior locally is to allow the",
            "\t\t * deadlock, but abort the system call if a signal is",
            "\t\t * received. We follow this example, otherwise a"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\dlmglue.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\dlmglue.c",
          "line": 2044,
          "match": "deadlock",
          "context": [
            "\t\t/*",
            "\t\t * Userspace can cause deadlock itself with",
            "\t\t * flock(). Current behavior locally is to allow the",
            "\t\t * deadlock, but abort the system call if a signal is",
            "\t\t * received. We follow this example, otherwise a",
            "\t\t * poorly written program could sit in kernel until",
            "\t\t * reboot."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\dlmglue.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\dlmglue.c",
          "line": 3521,
          "match": "deadlock",
          "context": [
            "\t\t * because we are the downconvert thread and processing",
            "\t\t * different lock. So we can just remove the lock from the",
            "\t\t * queue. This is not only an optimization but also a way",
            "\t\t * to avoid the following deadlock:",
            "\t\t *   ocfs2_dentry_post_unlock()",
            "\t\t *     ocfs2_dentry_lock_put()",
            "\t\t *       ocfs2_drop_dentry_lock()"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\dlmglue.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\dlmglue.c",
          "line": 3541,
          "match": "deadlock",
          "context": [
            "\t\t/*",
            "\t\t * Warn if we recurse into another post_unlock call.  Strictly",
            "\t\t * speaking it isn't a problem but we need to be careful if",
            "\t\t * that happens (stack overflow, deadlocks, ...) so warn if",
            "\t\t * ocfs2 grows a path for which this can happen.",
            "\t\t */",
            "\t\tWARN_ON_ONCE(lockres->l_ops->post_unlock);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\dlmglue.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\file.c",
          "line": 1161,
          "match": "deadlock",
          "context": [
            "\tif (size_change) {",
            "\t\t/*",
            "\t\t * Here we should wait dio to finish before inode lock",
            "\t\t * to avoid a deadlock between ocfs2_setattr() and",
            "\t\t * ocfs2_dio_end_io_write()",
            "\t\t */",
            "\t\tinode_dio_wait(inode);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\file.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\journal.c",
          "line": 425,
          "match": "deadlock",
          "context": [
            " *",
            " * WARNING: This will not release any semaphores or disk locks taken",
            " * during the transaction, so make sure they were taken *before*",
            " * start_trans or we'll have ordering deadlocks.",
            " *",
            " * WARNING2: Note that we do *not* drop j_trans_barrier here. This is",
            " * good because transaction ids haven't yet been recorded on the"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\journal.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\journal.c",
          "line": 2286,
          "match": "deadlock",
          "context": [
            " * - We grab as many inodes as we can under the orphan dir lock -",
            " *   doing iget() outside the orphan dir risks getting a reference on",
            " *   an invalid inode.",
            " * - We must be sure not to deadlock with other processes on the",
            " *   system wanting to run delete_inode(). This can happen when they go",
            " *   to lock the orphan dir and the orphan recovery process attempts to",
            " *   iget() inside the orphan dir lock. This can be avoided by"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\journal.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\inode.c",
          "line": 447,
          "match": "deadlock",
          "context": [
            "\t *",
            "\t * 3) If the process doing the iget() is responsible for",
            "\t *    orphan dir recovery. We're holding the orphan dir lock and",
            "\t *    can get into a deadlock with another process on another",
            "\t *    node in ->delete_inode().",
            "\t *",
            "\t * #1 and #2 can be simply solved by never taking the lock"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\inode.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\inode.c",
          "line": 730,
          "match": "deadlock",
          "context": [
            "/*",
            " * Serialize with orphan dir recovery. If the process doing",
            " * recovery on this orphan dir does an iget() with the dir",
            " * i_rwsem held, we'll deadlock here. Instead we detect this",
            " * and exit early - recovery will wipe this inode for us.",
            " */",
            "static int ocfs2_check_orphan_recovery_state(struct ocfs2_super *osb,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\inode.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\inode.c",
          "line": 872,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * If we're coming from downconvert_thread we can't go into our own",
            "\t * voting [hello, deadlock city!] so we cannot delete the inode. But",
            "\t * since we dropped last inode ref when downconverting dentry lock,",
            "\t * we cannot have the file open and thus the node doing unlink will",
            "\t * take care of deleting the inode."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\inode.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\inode.c",
          "line": 972,
          "match": "deadlock",
          "context": [
            "\t * is no longer live and can be deleted.",
            "\t *",
            "\t * Though we call this with the meta data lock held, the",
            "\t * trylock keeps us from ABBA deadlock.",
            "\t */",
            "\tstatus = ocfs2_try_open_lock(inode, 1);",
            "\tif (status == -EAGAIN) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\inode.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\quota_global.c",
          "line": 653,
          "match": "deadlock",
          "context": [
            "\tstruct super_block *sb = oinfo->dqi_gqinode->i_sb;",
            "",
            "\t/*",
            "\t * We have to be careful here not to deadlock on s_umount as umount",
            "\t * disabling quotas may be in progress and it waits for this work to",
            "\t * complete. If trylock fails, we'll do the sync next time...",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\quota_global.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\quota_global.c",
          "line": 726,
          "match": "deadlock",
          "context": [
            "/*",
            " * Called when the last reference to dquot is dropped. If we are called from",
            " * downconvert thread, we cannot do all the handling here because grabbing",
            " * quota lock could deadlock (the node holding the quota lock could need some",
            " * other cluster lock to proceed but with blocked downconvert thread we cannot",
            " * release any lock).",
            " */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\quota_global.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\stack_o2cb.c",
          "line": 133,
          "match": "DEADLOCK",
          "context": [
            "\t[DLM_ABORT]\t\t\t= -EINVAL,",
            "\t[DLM_CANCEL]\t\t\t= -DLM_ECANCEL,\t/* Successful cancel */",
            "\t[DLM_IVRESHANDLE]\t\t= -EINVAL,",
            "\t[DLM_DEADLOCK]\t\t\t= -EDEADLK,",
            "\t[DLM_DENIED_NOASTS]\t\t= -EINVAL,",
            "\t[DLM_FORWARD]\t\t\t= -EINVAL,",
            "\t[DLM_TIMEOUT]\t\t\t= -ETIMEDOUT,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\stack_o2cb.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\xattr.c",
          "line": 5749,
          "match": "deadlock",
          "context": [
            " *",
            " * We have to do CoW before ocfs2_init_xattr_set_ctxt since",
            " * currently CoW is a completed transaction, while this function",
            " * will also lock the allocators and let us deadlock. So we will",
            " * CoW the whole xattr value.",
            " */",
            "static int ocfs2_prepare_refcount_xattr(struct inode *inode,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\xattr.c"
          ]
        },
        {
          "file": "linux\\fs\\orangefs\\orangefs-utils.c",
          "line": 466,
          "match": "DEADLOCK",
          "context": [
            "\tEFAULT, EBUSY, EEXIST, ENODEV, ENOTDIR, EISDIR, EINVAL, EMFILE,",
            "\tEFBIG, ENOSPC, EROFS, EMLINK, EPIPE, EDEADLK, ENAMETOOLONG,",
            "\tENOLCK, ENOSYS, ENOTEMPTY, ELOOP, EWOULDBLOCK, ENOMSG, EUNATCH,",
            "\tEBADR, EDEADLOCK, ENODATA, ETIME, ENONET, EREMOTE, ECOMM,",
            "\tEPROTO, EBADMSG, EOVERFLOW, ERESTART, EMSGSIZE, EPROTOTYPE,",
            "\tENOPROTOOPT, EPROTONOSUPPORT, EOPNOTSUPP, EADDRINUSE,",
            "\tEADDRNOTAVAIL, ENETDOWN, ENETUNREACH, ENETRESET, ENOBUFS,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\orangefs\\orangefs-utils.c"
          ]
        },
        {
          "file": "linux\\fs\\overlayfs\\file.c",
          "line": 410,
          "match": "deadlock",
          "context": [
            "}",
            "",
            "/*",
            " * Calling iter_file_splice_write() directly from overlay's f_op may deadlock",
            " * due to lock order inversion between pipe->mutex in iter_file_splice_write()",
            " * and file_start_write(realfile) in ovl_write_iter().",
            " *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\overlayfs\\file.c"
          ]
        },
        {
          "file": "linux\\fs\\quota\\dquot.c",
          "line": 26,
          "match": "deadlock",
          "context": [
            " *\t\tinvalidate_dquots() now writes modified dquots.",
            " *\t\tSerialized quota_off() and quota_on() for mount point.",
            " *\t\tFixed a few bugs in grow_dquots().",
            " *\t\tFixed deadlock in write_dquot() - we no longer account quotas on",
            " *\t\tquota files",
            " *\t\tremove_dquot_ref() moved to inode.c - it now traverses through inodes",
            " *\t\tadd_dquot_ref() restarts after blocking"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\quota\\dquot.c"
          ]
        },
        {
          "file": "linux\\fs\\quota\\dquot.c",
          "line": 2389,
          "match": "deadlock",
          "context": [
            "\tif (!dqopt->files[type])",
            "\t\treturn -EIO;",
            "\tif (!(dqopt->flags & DQUOT_QUOTA_SYS_FILE)) {",
            "\t\t/* We don't want quota and atime on quota files (deadlocks",
            "\t\t * possible) Also nobody should write to the file - we use",
            "\t\t * special IO operations which ignore the immutable bit. */",
            "\t\tinode_lock(inode);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\quota\\dquot.c"
          ]
        },
        {
          "file": "linux\\fs\\quota\\netlink.c",
          "line": 49,
          "match": "deadlock",
          "context": [
            "",
            "\t/* We have to allocate using GFP_NOFS as we are called from a",
            "\t * filesystem performing write and thus further recursion into",
            "\t * the fs to free some data could cause deadlocks. */",
            "\tskb = genlmsg_new(msg_size, GFP_NOFS);",
            "\tif (!skb) {",
            "\t\tprintk(KERN_ERR"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\quota\\netlink.c"
          ]
        },
        {
          "file": "linux\\fs\\quota\\quota.c",
          "line": 945,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Path for quotaon has to be resolved before grabbing superblock",
            "\t * because that gets s_umount sem which is also possibly needed by path",
            "\t * resolution (think about autofs) and thus deadlocks could arise.",
            "\t */",
            "\tif (cmds == Q_QUOTAON) {",
            "\t\tret = user_path_at(AT_FDCWD, addr, LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT, &path);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\quota\\quota.c"
          ]
        },
        {
          "file": "linux\\fs\\quota\\quota_tree.c",
          "line": 436,
          "match": "deadlock",
          "context": [
            "}",
            "",
            "/*",
            " * We don't have to be afraid of deadlocks as we never have quotas on quota",
            " * files...",
            " */",
            "int qtree_write_dquot(struct qtree_mem_dqinfo *info, struct dquot *dquot)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\quota\\quota_tree.c"
          ]
        },
        {
          "file": "linux\\fs\\resctrl\\rdtgroup.c",
          "line": 4283,
          "match": "deadlock",
          "context": [
            "\t * &mm->mmap_lock --> rdtgroup_mutex for the latter that can cause",
            "\t * issues considering the other two lock dependencies.",
            "\t * By creating the debugfs directory here we avoid a dependency",
            "\t * that may cause deadlock (even though file operations cannot",
            "\t * occur until the filesystem is mounted, but I do not know how to",
            "\t * tell lockdep that).",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\resctrl\\rdtgroup.c"
          ]
        },
        {
          "file": "linux\\fs\\resctrl\\pseudo_lock.c",
          "line": 861,
          "match": "deadlock",
          "context": [
            "\t * pseudo-locked region will still be here on return.",
            "\t *",
            "\t * The mutex has to be released temporarily to avoid a potential",
            "\t * deadlock with the mm->mmap_lock which is obtained in the",
            "\t * device_create() and debugfs_create_dir() callpath below as well as",
            "\t * before the mmap() callback is called.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\resctrl\\pseudo_lock.c"
          ]
        },
        {
          "file": "linux\\fs\\tracefs\\event_inode.c",
          "line": 710,
          "match": "deadlock",
          "context": [
            " *",
            " * NB. @callback is called while holding internal locks of the eventfs",
            " *     system. The callback must not call any code that might also call into",
            " *     the tracefs or eventfs system or it will risk creating a deadlock.",
            " */",
            "struct eventfs_inode *eventfs_create_dir(const char *name, struct eventfs_inode *parent,",
            "\t\t\t\t\t const struct eventfs_entry *entries,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\tracefs\\event_inode.c"
          ]
        },
        {
          "file": "linux\\fs\\ubifs\\dir.c",
          "line": 1429,
          "match": "deadlock",
          "context": [
            "\t\twht_req.new_ino = 1;",
            "\t\twht_req.new_ino_d = ALIGN(whiteout_ui->data_len, 8);",
            "\t\t/*",
            "\t\t * To avoid deadlock between space budget (holds ui_mutex and",
            "\t\t * waits wb work) and writeback work(waits ui_mutex), do space",
            "\t\t * budget before ubifs inodes locked.",
            "\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ubifs\\dir.c"
          ]
        },
        {
          "file": "linux\\fs\\ubifs\\file.c",
          "line": 221,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * At the slow path we have to budget before locking the folio, because",
            "\t * budgeting may force write-back, which would wait on locked folios and",
            "\t * deadlock if we had the folio locked. At this point we do not know",
            "\t * anything about the folio, so assume that this is a new folio which is",
            "\t * written to a hole. This corresponds to largest budget. Later the",
            "\t * budget will be amended if this is not true."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ubifs\\file.c"
          ]
        },
        {
          "file": "linux\\fs\\ubifs\\file.c",
          "line": 468,
          "match": "deadlock",
          "context": [
            "\t\t * Budgeting failed which means it would have to force",
            "\t\t * write-back but didn't, because we set the @fast flag in the",
            "\t\t * request. Write-back cannot be done now, while we have the",
            "\t\t * page locked, because it would deadlock. Unlock and free",
            "\t\t * everything and fall-back to slow-path.",
            "\t\t */",
            "\t\tif (appending) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ubifs\\file.c"
          ]
        },
        {
          "file": "linux\\fs\\ubifs\\file.c",
          "line": 960,
          "match": "deadlock",
          "context": [
            " * we have to call 'truncate_setsize()', which first changes @inode->i_size,",
            " * then drops the truncated pages. And while dropping the pages, it takes the",
            " * page lock. This means that 'do_truncation()' cannot call 'truncate_setsize()'",
            " * with @ui_mutex locked, because it would deadlock with 'ubifs_writepage()'.",
            " * This means that @inode->i_size is changed while @ui_mutex is unlocked.",
            " *",
            " * XXX(truncate): with the new truncate sequence this is not true anymore,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ubifs\\file.c"
          ]
        },
        {
          "file": "linux\\fs\\ubifs\\file.c",
          "line": 1506,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * We have not locked @folio so far so we may budget for changing the",
            "\t * folio. Note, we cannot do this after we locked the folio, because",
            "\t * budgeting may cause write-back which would cause deadlock.",
            "\t *",
            "\t * At the moment we do not know whether the folio is dirty or not, so we",
            "\t * assume that it is not and budget for a new folio. We could look at"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ubifs\\file.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_aops.c",
          "line": 119,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * We can allocate memory here while doing writeback on behalf of",
            "\t * memory reclaim.  To avoid memory allocation deadlocks set the",
            "\t * task-wide nofs context for the following operations.",
            "\t */",
            "\tnofs_flag = memalloc_nofs_save();"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_aops.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_aops.c",
          "line": 468,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * We can allocate memory here while doing writeback on behalf of",
            "\t * memory reclaim.  To avoid memory allocation deadlocks set the",
            "\t * task-wide nofs context for the following operations.",
            "\t */",
            "\tnofs_flag = memalloc_nofs_save();"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_aops.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_buf.c",
          "line": 758,
          "match": "deadlock",
          "context": [
            "}",
            "",
            "/*",
            " *\tIf we are not low on memory then do the readahead in a deadlock",
            " *\tsafe manner.",
            " */",
            "void"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_buf.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_dir2_readdir.c",
          "line": 506,
          "match": "deadlock",
          "context": [
            " * Read a directory.",
            " *",
            " * If supplied, the transaction collects locked dir buffers to avoid",
            " * nested buffer deadlocks.  This function does not dirty the",
            " * transaction.  The caller must hold the IOLOCK (shared or exclusive)",
            " * before calling this function.",
            " */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_dir2_readdir.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_dquot.c",
          "line": 1116,
          "match": "deadlock",
          "context": [
            " * Release a reference to the dquot (decrement ref-count) and unlock it.",
            " *",
            " * If there is a group quota attached to this dquot, carefully release that",
            " * too without tripping over deadlocks'n'stuff.",
            " */",
            "void",
            "xfs_qm_dqput("
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_dquot.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_dquot.c",
          "line": 1479,
          "match": "deadlock",
          "context": [
            "/*",
            " * Lock two xfs_dquot structures.",
            " *",
            " * To avoid deadlocks we always lock the quota structure with",
            " * the lowerd id first.",
            " */",
            "void"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_dquot.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_extent_busy.c",
          "line": 605,
          "match": "deadlock",
          "context": [
            " *",
            " * If we are freeing extents, we might actually be holding the only free extents",
            " * in the transaction busy list and the log force won't resolve that situation.",
            " * In this case, we must return -EAGAIN to avoid a deadlock by informing the",
            " * caller it needs to commit the busy extents it holds before retrying the",
            " * extent free operation.",
            " */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_extent_busy.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_extent_busy.c",
          "line": 624,
          "match": "deadlock",
          "context": [
            "\tif (error)",
            "\t\treturn error;",
            "",
            "\t/* Avoid deadlocks on uncommitted busy extents. */",
            "\tif (!list_empty(&tp->t_busy)) {",
            "\t\tif (alloc_flags & XFS_ALLOC_FLAG_TRYFLUSH)",
            "\t\t\treturn 0;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_extent_busy.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_file.c",
          "line": 573,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * We can allocate memory here while doing writeback on behalf of",
            "\t * memory reclaim.  To avoid memory allocation deadlocks set the",
            "\t * task-wide nofs context for the following operations.",
            "\t */",
            "\tnofs_flag = memalloc_nofs_save();"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_file.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_file.c",
          "line": 1657,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * If we can't get the iolock just skip truncating the blocks past EOF",
            "\t * because we could deadlock with the mmap_lock otherwise. We'll get",
            "\t * another chance to drop them once the last reference to the inode is",
            "\t * dropped, so we'll never leak blocks permanently.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_file.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_fsmap.c",
          "line": 1271,
          "match": "deadlock",
          "context": [
            "\t\t/*",
            "\t\t * Grab an empty transaction so that we can use its recursive",
            "\t\t * buffer locking abilities to detect cycles in the rmapbt",
            "\t\t * without deadlocking.",
            "\t\t */",
            "\t\terror = xfs_trans_alloc_empty(mp, &tp);",
            "\t\tif (error)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_fsmap.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_icache.c",
          "line": 545,
          "match": "deadlock",
          "context": [
            "\t * previously marked the inode as free on disk but hasn't finished",
            "\t * updating the incore state yet.  The AGI buffer will be dirty and",
            "\t * locked to the icreate transaction, so a synchronous push of the",
            "\t * inodegc workers would result in deadlock.  For a regular iget, the",
            "\t * worker is running already, so we might as well wait.",
            "\t *",
            "\t * XXX(hch): eventually we should do something equivalent to"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_icache.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_icache.c",
          "line": 1972,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * We can allocate memory here while doing writeback on behalf of",
            "\t * memory reclaim.  To avoid memory allocation deadlocks set the",
            "\t * task-wide nofs context for the following operations.",
            "\t */",
            "\tnofs_flag = memalloc_nofs_save();"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_icache.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_icache.c",
          "line": 2142,
          "match": "deadlock",
          "context": [
            " * Note: If we are in a NOFS context here (e.g. current thread is running a",
            " * transaction) the we don't want to block here as inodegc progress may require",
            " * filesystem resources we hold to make progress and that could result in a",
            " * deadlock. Hence we skip out of here if we are in a scoped NOFS context.",
            " */",
            "static inline bool",
            "xfs_inodegc_want_flush_work("
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_icache.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_inode.c",
          "line": 115,
          "match": "deadlock",
          "context": [
            " * various combinations of the locks to be obtained.",
            " *",
            " * The 3 locks should always be ordered so that the IO lock is obtained first,",
            " * the mmap lock second and the ilock last in order to prevent deadlock.",
            " *",
            " * Basic locking order:",
            " *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_inode.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_inode.c",
          "line": 370,
          "match": "deadlock",
          "context": [
            " * The following routine will lock n inodes in exclusive mode.  We assume the",
            " * caller calls us with the inodes in i_ino order.",
            " *",
            " * We need to detect deadlock where an inode that we lock is in the AIL and we",
            " * start waiting for another inode that is locked by a thread in a long running",
            " * transaction (such as truncate). This can result in deadlock since the long",
            " * running trans might need to wait for the inode we just locked in order to"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_inode.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_inode.c",
          "line": 372,
          "match": "deadlock",
          "context": [
            " *",
            " * We need to detect deadlock where an inode that we lock is in the AIL and we",
            " * start waiting for another inode that is locked by a thread in a long running",
            " * transaction (such as truncate). This can result in deadlock since the long",
            " * running trans might need to wait for the inode we just locked in order to",
            " * push the tail and free space in the log.",
            " *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_inode.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_inode.c",
          "line": 773,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Wait until after the current transaction is aborted to finish the",
            "\t * setup of the inode and release the inode.  This prevents recursive",
            "\t * transactions and deadlocks from xfs_inactive.",
            "\t */",
            "\tif (du.ip) {",
            "\t\txfs_iunlock(du.ip, XFS_ILOCK_EXCL);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_inode.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_inode.c",
          "line": 865,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Wait until after the current transaction is aborted to finish the",
            "\t * setup of the inode and release the inode.  This prevents recursive",
            "\t * transactions and deadlocks from xfs_inactive.",
            "\t */",
            "\tif (ip) {",
            "\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_inode.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_inode.c",
          "line": 1875,
          "match": "deadlock",
          "context": [
            " * Hence the ordering that is imposed by other parts of the code is AGI before",
            " * AGF. This means we cannot remove the directory entry before we drop the inode",
            " * reference count and put it on the unlinked list as this results in a lock",
            " * order of AGF then AGI, and this can deadlock against inode allocation and",
            " * freeing. Therefore we must drop the link counts before we remove the",
            " * directory entry.",
            " *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_inode.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_itable.c",
          "line": 240,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Grab an empty transaction so that we can use its recursive buffer",
            "\t * locking abilities to detect cycles in the inobt without deadlocking.",
            "\t */",
            "\terror = xfs_trans_alloc_empty(breq->mp, &tp);",
            "\tif (error)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_itable.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_itable.c",
          "line": 332,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Grab an empty transaction so that we can use its recursive buffer",
            "\t * locking abilities to detect cycles in the inobt without deadlocking.",
            "\t */",
            "\terror = xfs_trans_alloc_empty(breq->mp, &tp);",
            "\tif (error)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_itable.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_itable.c",
          "line": 465,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Grab an empty transaction so that we can use its recursive buffer",
            "\t * locking abilities to detect cycles in the inobt without deadlocking.",
            "\t */",
            "\terror = xfs_trans_alloc_empty(breq->mp, &tp);",
            "\tif (error)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_itable.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_iomap.c",
          "line": 648,
          "match": "deadlock",
          "context": [
            "\t\t *",
            "\t\t * Note that we can't risk to recursing back into the filesystem",
            "\t\t * here as we might be asked to write out the same inode that we",
            "\t\t * complete here and might deadlock on the iolock.",
            "\t\t */",
            "\t\terror = xfs_trans_alloc_inode(ip, &M_RES(mp)->tr_write, resblks,",
            "\t\t\t\t0, true, &tp);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_iomap.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_iops.c",
          "line": 966,
          "match": "deadlock",
          "context": [
            "\t * it already held by the VFS.  So for now chicken out and try to",
            "\t * allocate space under it.",
            "\t *",
            "\t * To avoid deadlocks this means we can't block waiting for space, which",
            "\t * can lead to spurious -ENOSPC if there are no directly available",
            "\t * blocks.  We mitigate this a bit by allowing zeroing to dip into the",
            "\t * reserved pool, but eventually the VFS calling convention needs to"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_iops.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_iops.c",
          "line": 1458,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Ensure all page cache allocations are done from GFP_NOFS context to",
            "\t * prevent direct reclaim recursion back into the filesystem and blowing",
            "\t * stacks or deadlocking.",
            "\t */",
            "\tgfp_mask = mapping_gfp_mask(inode->i_mapping);",
            "\tmapping_set_gfp_mask(inode->i_mapping, (gfp_mask & ~(__GFP_FS)));"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_iops.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_iwalk.c",
          "line": 618,
          "match": "deadlock",
          "context": [
            "\t\tgoto out;",
            "\t/*",
            "\t * Grab an empty transaction so that we can use its recursive buffer",
            "\t * locking abilities to detect cycles in the inobt without deadlocking.",
            "\t */",
            "\terror = xfs_trans_alloc_empty(mp, &iwag->tp);",
            "\tif (error)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_iwalk.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_log_recover.c",
          "line": 2798,
          "match": "deadlock",
          "context": [
            " *",
            " * This behaviour is bad for latency on single CPU and non-preemptible kernels,",
            " * and can prevent other filesystem work (such as CIL pushes) from running. This",
            " * can lead to deadlocks if the recovery process runs out of log reservation",
            " * space. Hence we need to yield the CPU when there is other kernel work",
            " * scheduled on this CPU to ensure other scheduled work can run without undue",
            " * latency."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_log_recover.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_log_cil.c",
          "line": 232,
          "match": "deadlock",
          "context": [
            " *",
            " * If we do this allocation within xlog_cil_insert_format_items(), it is done",
            " * under the xc_ctx_lock, which means that a CIL push cannot occur during",
            " * the memory allocation. This means that we have a potential deadlock situation",
            " * under low memory conditions when we have lots of dirty metadata pinned in",
            " * the CIL and we need a CIL commit to occur to free memory.",
            " *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_log_cil.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_log_cil.c",
          "line": 1746,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Do all necessary memory allocation before we lock the CIL.",
            "\t * This ensures the allocation does not deadlock with a CIL",
            "\t * push in memory reclaim (e.g. from kswapd).",
            "\t */",
            "\txlog_cil_alloc_shadow_bufs(log, tp);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_log_cil.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_log.c",
          "line": 1128,
          "match": "deadlock",
          "context": [
            " *",
            " * If there are any items in the AIl or CIL, then we do not want to attempt to",
            " * cover the log as we may be in a situation where there isn't log space",
            " * available to run a dummy transaction and this can lead to deadlocks when the",
            " * tail of the log is pinned by an item that is modified in the CIL.  Hence",
            " * there's no point in running a dummy transaction at this point because we",
            " * can't start trying to idle the log until both the CIL and AIL are empty."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_log.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_log.c",
          "line": 3440,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Ensure that there is only ever one log shutdown being processed.",
            "\t * If we allow the log force below on a second pass after shutting",
            "\t * down the log, we risk deadlocking the CIL push as it may require",
            "\t * locks on objects the current shutdown context holds (e.g. taking",
            "\t * buffer locks to abort buffers on last unpin of buf log items).",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_log.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_qm.c",
          "line": 1995,
          "match": "deadlock",
          "context": [
            "\t\t\t * takes priority over what's sent in the uid argument.",
            "\t\t\t * We must unlock inode here before calling dqget if",
            "\t\t\t * we're not sending the inode, because otherwise",
            "\t\t\t * we'll deadlock by doing trans_reserve while",
            "\t\t\t * holding ilock.",
            "\t\t\t */",
            "\t\t\txfs_iunlock(ip, lockflags);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_qm.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_rtalloc.c",
          "line": 1611,
          "match": "deadlock",
          "context": [
            "/*",
            " * Read in the bmbt of an rt metadata inode so that we never have to load them",
            " * at runtime.  This enables the use of shared ILOCKs for rtbitmap scans.  Use",
            " * an empty transaction to avoid deadlocking on loops in the bmbt.",
            " */",
            "static inline int",
            "xfs_rtmount_iread_extents("
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_rtalloc.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_super.c",
          "line": 1015,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * The filesystem is now frozen far enough that memory reclaim",
            "\t * cannot safely operate on the filesystem. Hence we need to",
            "\t * set a GFP_NOFS context here to avoid recursion deadlocks.",
            "\t */",
            "\tflags = memalloc_nofs_save();",
            "\txfs_save_resvblks(mp);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_super.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_super.c",
          "line": 2104,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Cancel background eofb scanning so it cannot race with the final",
            "\t * log force+buftarg wait and deadlock the remount.",
            "\t */",
            "\txfs_blockgc_stop(mp);",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_super.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_symlink.c",
          "line": 231,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Wait until after the current transaction is aborted to finish the",
            "\t * setup of the inode and release the inode.  This prevents recursive",
            "\t * transactions and deadlocks from xfs_inactive.",
            "\t */",
            "\tif (du.ip) {",
            "\t\txfs_iunlock(du.ip, XFS_ILOCK_EXCL);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_symlink.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_trans.c",
          "line": 315,
          "match": "deadlock",
          "context": [
            " * Create an empty transaction with no reservation.  This is a defensive",
            " * mechanism for routines that query metadata without actually modifying them --",
            " * if the metadata being queried is somehow cross-linked (think a btree block",
            " * pointer that points higher in the tree), we risk deadlock.  However, blocks",
            " * grabbed as part of a transaction can be re-grabbed.  The verifiers will",
            " * notice the corrupt block and the operation will fail back to userspace",
            " * without deadlocking."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_trans.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_trans.c",
          "line": 318,
          "match": "deadlock",
          "context": [
            " * pointer that points higher in the tree), we risk deadlock.  However, blocks",
            " * grabbed as part of a transaction can be re-grabbed.  The verifiers will",
            " * notice the corrupt block and the operation will fail back to userspace",
            " * without deadlocking.",
            " *",
            " * Note the zero-length reservation; this transaction MUST be cancelled without",
            " * any dirty data."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_trans.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_trans.c",
          "line": 810,
          "match": "deadlock",
          "context": [
            "\tint\t\t\terror = 0;",
            "",
            "\t/*",
            "\t * Sort the item list to avoid ABBA deadlocks with other transactions",
            "\t * running precommit operations that lock multiple shared items such as",
            "\t * inode cluster buffers.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_trans.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_zone_alloc.c",
          "line": 1147,
          "match": "deadlock",
          "context": [
            " *",
            " * If the device doesn't report an open zone limit and there is no override,",
            " * allow to hold about a quarter of the zones open.  In theory we could allow",
            " * all to be open, but at that point we run into GC deadlocks because we can't",
            " * reclaim open zones.",
            " *",
            " * When used on conventional SSDs a lower open limit is advisable as we'll"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_zone_alloc.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_zone_gc.c",
          "line": 646,
          "match": "deadlock",
          "context": [
            "\t *",
            "\t * If we'd take them from the normal pool we could be stealing blocks",
            "\t * from a regular writer, which would then have to wait for GC and",
            "\t * deadlock.",
            "\t */",
            "\tspin_lock(&mp->m_sb_lock);",
            "\t*count_fsb = min(*count_fsb,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_zone_gc.c"
          ]
        },
        {
          "file": "linux\\fs\\zonefs\\super.c",
          "line": 395,
          "match": "deadlock",
          "context": [
            "\t * Memory allocations in blkdev_report_zones() can trigger a memory",
            "\t * reclaim which may in turn cause a recursion into zonefs as well as",
            "\t * struct request allocations for the same device. The former case may",
            "\t * end up in a deadlock on the inode truncate mutex, while the latter",
            "\t * may prevent IO forward progress. Executing the report zones under",
            "\t * the GFP_NOIO context avoids both problems.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\zonefs\\super.c"
          ]
        },
        {
          "file": "linux\\fs\\notify\\fanotify\\fanotify_user.c",
          "line": 1767,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Some filesystems such as 'proc' acquire unusual locks when opening",
            "\t * files. For them fanotify permission events have high chances of",
            "\t * deadlocking the system - open done when reporting fanotify event",
            "\t * blocks on this \"unusual\" lock while another process holding the lock",
            "\t * waits for fanotify permission event to be answered. Just disallow",
            "\t * permission events for such filesystems."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\notify\\fanotify\\fanotify_user.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\dlm\\dlmdebug.c",
          "line": 154,
          "match": "DEADLOCK",
          "context": [
            "\t[DLM_ABORT] =\t\t\t\"DLM_ABORT\",",
            "\t[DLM_CANCEL] =\t\t\t\"DLM_CANCEL\",",
            "\t[DLM_IVRESHANDLE] =\t\t\"DLM_IVRESHANDLE\",",
            "\t[DLM_DEADLOCK] =\t\t\"DLM_DEADLOCK\",",
            "\t[DLM_DENIED_NOASTS] =\t\t\"DLM_DENIED_NOASTS\",",
            "\t[DLM_FORWARD] =\t\t\t\"DLM_FORWARD\",",
            "\t[DLM_TIMEOUT] =\t\t\t\"DLM_TIMEOUT\","
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\dlm\\dlmdebug.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\dlm\\dlmdebug.c",
          "line": 154,
          "match": "DEADLOCK",
          "context": [
            "\t[DLM_ABORT] =\t\t\t\"DLM_ABORT\",",
            "\t[DLM_CANCEL] =\t\t\t\"DLM_CANCEL\",",
            "\t[DLM_IVRESHANDLE] =\t\t\"DLM_IVRESHANDLE\",",
            "\t[DLM_DEADLOCK] =\t\t\"DLM_DEADLOCK\",",
            "\t[DLM_DENIED_NOASTS] =\t\t\"DLM_DENIED_NOASTS\",",
            "\t[DLM_FORWARD] =\t\t\t\"DLM_FORWARD\",",
            "\t[DLM_TIMEOUT] =\t\t\t\"DLM_TIMEOUT\","
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\dlm\\dlmdebug.c"
          ]
        },
        {
          "file": "linux\\fs\\smb\\client\\connect.c",
          "line": 1719,
          "match": "deadlock",
          "context": [
            "",
            "\tif (from_reconnect)",
            "\t\t/*",
            "\t\t * Avoid deadlock here: reconnect work calls",
            "\t\t * cifs_put_tcp_session() at its end. Need to be sure",
            "\t\t * that reconnect work does nothing with server pointer after",
            "\t\t * that step."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\smb\\client\\connect.c"
          ]
        },
        {
          "file": "linux\\fs\\smb\\client\\dir.c",
          "line": 708,
          "match": "deadlock",
          "context": [
            "\t}",
            "",
            "\t/* can not grab the rename sem here since it would",
            "\tdeadlock in the cases (beginning of sys_rename itself)",
            "\tin which we already have the sb rename sem */",
            "\tpage = alloc_dentry_path();",
            "\tfull_path = build_path_from_dentry(direntry, page);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\smb\\client\\dir.c"
          ]
        },
        {
          "file": "linux\\fs\\smb\\client\\file.c",
          "line": 1321,
          "match": "deadlock",
          "context": [
            "\t\t}",
            "\t}",
            "\t/*",
            "\t * Else we are writing out data to server already and could deadlock if",
            "\t * we tried to flush data, and since we do not know if we have data that",
            "\t * would invalidate the current end of file on the server we can not go",
            "\t * to the server to get the new inode info."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\smb\\client\\file.c"
          ]
        },
        {
          "file": "linux\\fs\\smb\\client\\netmisc.c",
          "line": 638,
          "match": "DEADLOCK",
          "context": [
            "\tERRHRD, ERRgeneral, NT_STATUS_MUTANT_LIMIT_EXCEEDED}, {",
            "\tERRDOS, ERRnetlogonNotStarted, NT_STATUS_NETLOGON_NOT_STARTED}, {",
            "\tERRSRV, ERRaccountexpired, NT_STATUS_ACCOUNT_EXPIRED}, {",
            "\tERRHRD, ERRgeneral, NT_STATUS_POSSIBLE_DEADLOCK}, {",
            "\tERRHRD, ERRgeneral, NT_STATUS_NETWORK_CREDENTIAL_CONFLICT}, {",
            "\tERRHRD, ERRgeneral, NT_STATUS_REMOTE_SESSION_LIMIT}, {",
            "\tERRHRD, ERRgeneral, NT_STATUS_EVENTLOG_FILE_CHANGED}, {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\smb\\client\\netmisc.c"
          ]
        },
        {
          "file": "linux\\fs\\smb\\client\\nterr.c",
          "line": 532,
          "match": "DEADLOCK",
          "context": [
            "\t NT_STATUS_MUTANT_LIMIT_EXCEEDED},",
            "\t{\"NT_STATUS_NETLOGON_NOT_STARTED\", NT_STATUS_NETLOGON_NOT_STARTED},",
            "\t{\"NT_STATUS_ACCOUNT_EXPIRED\", NT_STATUS_ACCOUNT_EXPIRED},",
            "\t{\"NT_STATUS_POSSIBLE_DEADLOCK\", NT_STATUS_POSSIBLE_DEADLOCK},",
            "\t{\"NT_STATUS_NETWORK_CREDENTIAL_CONFLICT\",",
            "\t NT_STATUS_NETWORK_CREDENTIAL_CONFLICT},",
            "\t{\"NT_STATUS_REMOTE_SESSION_LIMIT\", NT_STATUS_REMOTE_SESSION_LIMIT},"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\smb\\client\\nterr.c"
          ]
        },
        {
          "file": "linux\\fs\\smb\\client\\nterr.c",
          "line": 532,
          "match": "DEADLOCK",
          "context": [
            "\t NT_STATUS_MUTANT_LIMIT_EXCEEDED},",
            "\t{\"NT_STATUS_NETLOGON_NOT_STARTED\", NT_STATUS_NETLOGON_NOT_STARTED},",
            "\t{\"NT_STATUS_ACCOUNT_EXPIRED\", NT_STATUS_ACCOUNT_EXPIRED},",
            "\t{\"NT_STATUS_POSSIBLE_DEADLOCK\", NT_STATUS_POSSIBLE_DEADLOCK},",
            "\t{\"NT_STATUS_NETWORK_CREDENTIAL_CONFLICT\",",
            "\t NT_STATUS_NETWORK_CREDENTIAL_CONFLICT},",
            "\t{\"NT_STATUS_REMOTE_SESSION_LIMIT\", NT_STATUS_REMOTE_SESSION_LIMIT},"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\smb\\client\\nterr.c"
          ]
        },
        {
          "file": "linux\\fs\\smb\\client\\smb2maperror.c",
          "line": 723,
          "match": "DEADLOCK",
          "context": [
            "\t{STATUS_MUTANT_LIMIT_EXCEEDED, -EIO, \"STATUS_MUTANT_LIMIT_EXCEEDED\"},",
            "\t{STATUS_NETLOGON_NOT_STARTED, -EIO, \"STATUS_NETLOGON_NOT_STARTED\"},",
            "\t{STATUS_ACCOUNT_EXPIRED, -EKEYEXPIRED, \"STATUS_ACCOUNT_EXPIRED\"},",
            "\t{STATUS_POSSIBLE_DEADLOCK, -EIO, \"STATUS_POSSIBLE_DEADLOCK\"},",
            "\t{STATUS_NETWORK_CREDENTIAL_CONFLICT, -EIO,",
            "\t\"STATUS_NETWORK_CREDENTIAL_CONFLICT\"},",
            "\t{STATUS_REMOTE_SESSION_LIMIT, -EIO, \"STATUS_REMOTE_SESSION_LIMIT\"},"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\smb\\client\\smb2maperror.c"
          ]
        },
        {
          "file": "linux\\fs\\smb\\client\\smb2maperror.c",
          "line": 723,
          "match": "DEADLOCK",
          "context": [
            "\t{STATUS_MUTANT_LIMIT_EXCEEDED, -EIO, \"STATUS_MUTANT_LIMIT_EXCEEDED\"},",
            "\t{STATUS_NETLOGON_NOT_STARTED, -EIO, \"STATUS_NETLOGON_NOT_STARTED\"},",
            "\t{STATUS_ACCOUNT_EXPIRED, -EKEYEXPIRED, \"STATUS_ACCOUNT_EXPIRED\"},",
            "\t{STATUS_POSSIBLE_DEADLOCK, -EIO, \"STATUS_POSSIBLE_DEADLOCK\"},",
            "\t{STATUS_NETWORK_CREDENTIAL_CONFLICT, -EIO,",
            "\t\"STATUS_NETWORK_CREDENTIAL_CONFLICT\"},",
            "\t{STATUS_REMOTE_SESSION_LIMIT, -EIO, \"STATUS_REMOTE_SESSION_LIMIT\"},"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\smb\\client\\smb2maperror.c"
          ]
        },
        {
          "file": "linux\\fs\\smb\\client\\smb2ops.c",
          "line": 264,
          "match": "deadlock",
          "context": [
            "\t\t\tspin_lock(&server->req_lock);",
            "\t\t} else {",
            "\t\t\tscredits = server->credits;",
            "\t\t\t/* can deadlock with reopen */",
            "\t\t\tif (scredits <= 8) {",
            "\t\t\t\t*num = SMB2_MAX_BUFFER_SIZE;",
            "\t\t\t\tcredits->value = 0;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\smb\\client\\smb2ops.c"
          ]
        },
        {
          "file": "linux\\fs\\smb\\client\\smb2pdu.c",
          "line": 4590,
          "match": "deadlock",
          "context": [
            "#ifdef CONFIG_CIFS_SMB_DIRECT",
            "\t/*",
            "\t * If this rdata has a memory registered, the MR can be freed",
            "\t * MR needs to be freed as soon as I/O finishes to prevent deadlock",
            "\t * because they have limited number and are used for future I/Os",
            "\t */",
            "\tif (rdata->mr) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\smb\\client\\smb2pdu.c"
          ]
        },
        {
          "file": "linux\\fs\\smb\\client\\smb2pdu.c",
          "line": 4880,
          "match": "deadlock",
          "context": [
            "\t * If this wdata has a memory registered, the MR can be freed",
            "\t * The number of MRs available is limited, it's important to recover",
            "\t * used MR as soon as I/O is finished. Hold MR longer in the later",
            "\t * I/O process can possibly result in I/O deadlock due to lack of MR",
            "\t * to send request on I/O retry",
            "\t */",
            "\tif (wdata->mr) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\smb\\client\\smb2pdu.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\libxfs\\xfs_alloc.c",
          "line": 99,
          "match": "deadlock",
          "context": [
            " * Compute the number of blocks that we set aside to guarantee the ability to",
            " * refill the AGFL and handle a full bmap btree split.",
            " *",
            " * In order to avoid ENOSPC-related deadlock caused by out-of-order locking of",
            " * AGF buffer (PV 947395), we place constraints on the relationship among",
            " * actual allocations for data blocks, freelist blocks, and potential file data",
            " * bmap btree blocks. However, these restrictions may result in no actual space"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\libxfs\\xfs_alloc.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\libxfs\\xfs_alloc.c",
          "line": 1755,
          "match": "deadlock",
          "context": [
            "\t\t\t/*",
            "\t\t\t * Our only valid extents must have been busy. Flush and",
            "\t\t\t * retry the allocation again. If we get an -EAGAIN",
            "\t\t\t * error, we're being told that a deadlock was avoided",
            "\t\t\t * and the current transaction needs committing before",
            "\t\t\t * the allocation can be retried.",
            "\t\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\libxfs\\xfs_alloc.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\libxfs\\xfs_alloc.c",
          "line": 1872,
          "match": "deadlock",
          "context": [
            "\t\t\t/*",
            "\t\t\t * Our only valid extents must have been busy. Flush and",
            "\t\t\t * retry the allocation again. If we get an -EAGAIN",
            "\t\t\t * error, we're being told that a deadlock was avoided",
            "\t\t\t * and the current transaction needs committing before",
            "\t\t\t * the allocation can be retried.",
            "\t\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\libxfs\\xfs_alloc.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\libxfs\\xfs_alloc.c",
          "line": 1972,
          "match": "deadlock",
          "context": [
            "\t\t\t/*",
            "\t\t\t * Our only valid extents must have been busy. Flush and",
            "\t\t\t * retry the allocation again. If we get an -EAGAIN",
            "\t\t\t * error, we're being told that a deadlock was avoided",
            "\t\t\t * and the current transaction needs committing before",
            "\t\t\t * the allocation can be retried.",
            "\t\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\libxfs\\xfs_alloc.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\libxfs\\xfs_alloc.c",
          "line": 3515,
          "match": "deadlock",
          "context": [
            "\t}",
            "",
            "\tif (args->agno != NULLAGNUMBER && *minimum_agno > args->agno) {",
            "\t\ttrace_xfs_alloc_vextent_skip_deadlock(args);",
            "\t\treturn -ENOSPC;",
            "\t}",
            "\treturn 0;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\libxfs\\xfs_alloc.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\libxfs\\xfs_alloc.c",
          "line": 3583,
          "match": "deadlock",
          "context": [
            "\t * to do BMBT block allocation, we have to do a new allocation.",
            "\t *",
            "\t * Hence leaving this function with the AGF locked opens up potential",
            "\t * ABBA AGF deadlocks because a future allocation attempt in this",
            "\t * transaction may attempt to lock a lower number AGF.",
            "\t *",
            "\t * We can't release the AGF until the transaction is commited, so at"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\libxfs\\xfs_alloc.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\libxfs\\xfs_alloc.c",
          "line": 3590,
          "match": "deadlock",
          "context": [
            "\t * this point we must update the \"first allocation\" tracker to point at",
            "\t * this AG if the tracker is empty or points to a lower AG. This allows",
            "\t * the next allocation attempt to be modified appropriately to avoid",
            "\t * deadlocks.",
            "\t */",
            "\tif (args->agbp &&",
            "\t    (args->tp->t_highest_agno == NULLAGNUMBER ||"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\libxfs\\xfs_alloc.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\libxfs\\xfs_alloc.c",
          "line": 3704,
          "match": "deadlock",
          "context": [
            " * When we wrap the AG iteration at the end of the filesystem, we have to be",
            " * careful not to wrap into AGs below ones we already have locked in the",
            " * transaction if we are doing a blocking iteration. This will result in an",
            " * out-of-order locking of AGFs and hence can cause deadlocks.",
            " */",
            "static int",
            "xfs_alloc_vextent_iterate_ags("
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\libxfs\\xfs_alloc.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\libxfs\\xfs_attr.c",
          "line": 634,
          "match": "deadlock",
          "context": [
            "\t * If there was an out-of-line value, allocate the blocks we",
            "\t * identified for its storage and copy the value.  This is done",
            "\t * after we create the attribute so that we don't overflow the",
            "\t * maximum size of a transaction and/or hit a deadlock.",
            "\t */",
            "\tif (attr->xattri_blkcnt > 0) {",
            "\t\terror = xfs_attr_rmtval_set_blk(attr);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\libxfs\\xfs_attr.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\libxfs\\xfs_btree_mem.c",
          "line": 263,
          "match": "deadlock",
          "context": [
            " * of a transaction.",
            " *",
            " * In other words, online repair only needs the transaction to collect buffer",
            " * pointers and to avoid buffer deadlocks, not to guarantee consistency of",
            " * updates.",
            " */",
            "int"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\libxfs\\xfs_btree_mem.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\libxfs\\xfs_btree.c",
          "line": 3045,
          "match": "deadlock",
          "context": [
            " * btree types, just call directly to avoid the context switch overhead here.",
            " *",
            " * Care must be taken here - the work queue rescuer thread introduces potential",
            " * AGF <> worker queue deadlocks if the BMBT block allocation has to lock new",
            " * AGFs to allocate blocks. A task being run by the rescuer could attempt to",
            " * lock an AGF that is already locked by a task queued to run by the rescuer,",
            " * resulting in an ABBA deadlock as the rescuer cannot run the lock holder to"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\libxfs\\xfs_btree.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\libxfs\\xfs_btree.c",
          "line": 3048,
          "match": "deadlock",
          "context": [
            " * AGF <> worker queue deadlocks if the BMBT block allocation has to lock new",
            " * AGFs to allocate blocks. A task being run by the rescuer could attempt to",
            " * lock an AGF that is already locked by a task queued to run by the rescuer,",
            " * resulting in an ABBA deadlock as the rescuer cannot run the lock holder to",
            " * release it until the current thread it is running gains the lock.",
            " *",
            " * To avoid this issue, we only ever queue BMBT splits that don't have an AGF"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\libxfs\\xfs_btree.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\libxfs\\xfs_ialloc.c",
          "line": 1975,
          "match": "deadlock",
          "context": [
            "\t * Protect against obviously corrupt allocation btree records. Later",
            "\t * xfs_iget checks will catch re-allocation of other active in-memory",
            "\t * and on-disk inodes. If we don't catch reallocating the parent inode",
            "\t * here we will deadlock in xfs_iget() so we have to do these checks",
            "\t * first.",
            "\t */",
            "\tif (ino == parent || !xfs_verify_dir_ino(mp, ino)) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\libxfs\\xfs_ialloc.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\libxfs\\xfs_refcount.c",
          "line": 1379,
          "match": "deadlock",
          "context": [
            "/*",
            " * Process one of the deferred refcount operations.  We pass back the",
            " * btree cursor to maintain our lock on the btree between calls.",
            " * This saves time and eliminates a buffer deadlock between the",
            " * superblock and the AGF because we'll always grab them in the same",
            " * order.",
            " */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\libxfs\\xfs_refcount.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\libxfs\\xfs_refcount.c",
          "line": 2096,
          "match": "deadlock",
          "context": [
            "\t * In this first part, we use an empty transaction to gather up",
            "\t * all the leftover CoW extents so that we can subsequently",
            "\t * delete them.  The empty transaction is used to avoid",
            "\t * a buffer lock deadlock if there happens to be a loop in the",
            "\t * refcountbt because we're allowed to re-grab a buffer that is",
            "\t * already attached to our transaction.  When we're done",
            "\t * recording the CoW debris we cancel the (empty) transaction"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\libxfs\\xfs_refcount.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\libxfs\\xfs_rmap.c",
          "line": 2675,
          "match": "deadlock",
          "context": [
            "/*",
            " * Process one of the deferred rmap operations.  We pass back the",
            " * btree cursor to maintain our lock on the rmapbt between calls.",
            " * This saves time and eliminates a buffer deadlock between the",
            " * superblock and the AGF because we'll always grab them in the same",
            " * order.",
            " */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\libxfs\\xfs_rmap.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\libxfs\\xfs_rtgroup.c",
          "line": 318,
          "match": "deadlock",
          "context": [
            " * Most of the time each of the RTG inode locks are only taken one at a time.",
            " * But when committing deferred ops, more than one of a kind can be taken.",
            " * However, deferred rt ops will be committed in rgno order so there is no",
            " * potential for deadlocks.  The code here is needed to tell lockdep about this",
            " * order.",
            " */",
            "static inline void"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\libxfs\\xfs_rtgroup.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\libxfs\\xfs_sb.c",
          "line": 1357,
          "match": "deadlock",
          "context": [
            " * filesystem. This procedure uses the non-blocking transaction allocator and",
            " * thus will allow modifications to a frozen fs. This is required because this",
            " * code can be called during the process of freezing where use of the high-level",
            " * allocator would deadlock.",
            " */",
            "int",
            "xfs_sync_sb("
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\libxfs\\xfs_sb.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\alloc_repair.c",
          "line": 874,
          "match": "DEADLOCK",
          "context": [
            "\t * let's not risk the filesystem.",
            "\t */",
            "\tif (!xfs_extent_busy_list_empty(pag_group(sc->sa.pag), &busy_gen)) {",
            "\t\terror = -EDEADLOCK;",
            "\t\tgoto out_ra;",
            "\t}",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\alloc_repair.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\attr_repair.c",
          "line": 363,
          "match": "DEADLOCK",
          "context": [
            "\t */",
            "\terror = xchk_setup_xattr_buf(rx->sc, args.valuelen);",
            "\tif (error == -ENOMEM)",
            "\t\terror = -EDEADLOCK;",
            "\tif (error)",
            "\t\treturn error;",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\attr_repair.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\attr_repair.c",
          "line": 1553,
          "match": "DEADLOCK",
          "context": [
            "\tmax_len = xfs_attr_leaf_entsize_local_max(sc->mp->m_attr_geo->blksize);",
            "\terror = xchk_setup_xattr_buf(rx->sc, max_len);",
            "\tif (error == -ENOMEM)",
            "\t\terror = -EDEADLOCK;",
            "\tif (error)",
            "\t\tgoto out_rx;",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\attr_repair.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\attr.c",
          "line": 221,
          "match": "DEADLOCK",
          "context": [
            "",
            "\t/*",
            "\t * Try to allocate enough memory to extract the attr value.  If that",
            "\t * doesn't work, return -EDEADLOCK as a signal to try again with a",
            "\t * maximally sized buffer.",
            "\t */",
            "\terror = xchk_setup_xattr_buf(sc, valuelen);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\attr.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\attr.c",
          "line": 226,
          "match": "DEADLOCK",
          "context": [
            "\t */",
            "\terror = xchk_setup_xattr_buf(sc, valuelen);",
            "\tif (error == -ENOMEM)",
            "\t\terror = -EDEADLOCK;",
            "\tif (error)",
            "\t\treturn error;",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\attr.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\attr.c",
          "line": 652,
          "match": "DEADLOCK",
          "context": [
            "\t/* Allocate memory for xattr checking. */",
            "\terror = xchk_setup_xattr_buf(sc, 0);",
            "\tif (error == -ENOMEM)",
            "\t\treturn -EDEADLOCK;",
            "\tif (error)",
            "\t\treturn error;",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\attr.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\btree.c",
          "line": 38,
          "match": "DEADLOCK",
          "context": [
            "\t\treturn true;",
            "",
            "\tswitch (*error) {",
            "\tcase -EDEADLOCK:",
            "\tcase -ECHRNG:",
            "\t\t/* Used to restart an op with deadlock avoidance. */",
            "\t\ttrace_xchk_deadlock_retry(sc->ip, sc->sm, *error);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\btree.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\btree.c",
          "line": 40,
          "match": "deadlock",
          "context": [
            "\tswitch (*error) {",
            "\tcase -EDEADLOCK:",
            "\tcase -ECHRNG:",
            "\t\t/* Used to restart an op with deadlock avoidance. */",
            "\t\ttrace_xchk_deadlock_retry(sc->ip, sc->sm, *error);",
            "\t\tbreak;",
            "\tcase -EFSBADCRC:"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\btree.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\btree.c",
          "line": 41,
          "match": "deadlock",
          "context": [
            "\tcase -EDEADLOCK:",
            "\tcase -ECHRNG:",
            "\t\t/* Used to restart an op with deadlock avoidance. */",
            "\t\ttrace_xchk_deadlock_retry(sc->ip, sc->sm, *error);",
            "\t\tbreak;",
            "\tcase -EFSBADCRC:",
            "\tcase -EFSCORRUPTED:"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\btree.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\common.c",
          "line": 88,
          "match": "DEADLOCK",
          "context": [
            "\tswitch (*error) {",
            "\tcase 0:",
            "\t\treturn true;",
            "\tcase -EDEADLOCK:",
            "\tcase -ECHRNG:",
            "\t\t/* Used to restart an op with deadlock avoidance. */",
            "\t\ttrace_xchk_deadlock_retry("
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\common.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\common.c",
          "line": 90,
          "match": "deadlock",
          "context": [
            "\t\treturn true;",
            "\tcase -EDEADLOCK:",
            "\tcase -ECHRNG:",
            "\t\t/* Used to restart an op with deadlock avoidance. */",
            "\t\ttrace_xchk_deadlock_retry(",
            "\t\t\t\tsc->ip ? sc->ip : XFS_I(file_inode(sc->file)),",
            "\t\t\t\tsc->sm, *error);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\common.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\common.c",
          "line": 91,
          "match": "deadlock",
          "context": [
            "\tcase -EDEADLOCK:",
            "\tcase -ECHRNG:",
            "\t\t/* Used to restart an op with deadlock avoidance. */",
            "\t\ttrace_xchk_deadlock_retry(",
            "\t\t\t\tsc->ip ? sc->ip : XFS_I(file_inode(sc->file)),",
            "\t\t\t\tsc->sm, *error);",
            "\t\tbreak;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\common.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\common.c",
          "line": 163,
          "match": "DEADLOCK",
          "context": [
            "\tswitch (*error) {",
            "\tcase 0:",
            "\t\treturn true;",
            "\tcase -EDEADLOCK:",
            "\tcase -ECHRNG:",
            "\t\t/* Used to restart an op with deadlock avoidance. */",
            "\t\ttrace_xchk_deadlock_retry(sc->ip, sc->sm, *error);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\common.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\common.c",
          "line": 165,
          "match": "deadlock",
          "context": [
            "\t\treturn true;",
            "\tcase -EDEADLOCK:",
            "\tcase -ECHRNG:",
            "\t\t/* Used to restart an op with deadlock avoidance. */",
            "\t\ttrace_xchk_deadlock_retry(sc->ip, sc->sm, *error);",
            "\t\tbreak;",
            "\tcase -ECANCELED:"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\common.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\common.c",
          "line": 166,
          "match": "deadlock",
          "context": [
            "\tcase -EDEADLOCK:",
            "\tcase -ECHRNG:",
            "\t\t/* Used to restart an op with deadlock avoidance. */",
            "\t\ttrace_xchk_deadlock_retry(sc->ip, sc->sm, *error);",
            "\t\tbreak;",
            "\tcase -ECANCELED:",
            "\t\t/*"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\common.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\common.c",
          "line": 682,
          "match": "deadlock",
          "context": [
            "/*",
            " * For scrub, grab the perag structure, the AGI, and the AGF headers, in that",
            " * order.  Locking order requires us to get the AGI before the AGF.  We use the",
            " * transaction to avoid deadlocking on crosslinked metadata buffers; either the",
            " * caller passes one in (bmap scrub) or we have to create a transaction",
            " * ourselves.  Returns ENOENT if the perag struct cannot be grabbed.",
            " */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\common.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\common.c",
          "line": 1010,
          "match": "deadlock",
          "context": [
            "\t\treturn error;",
            "",
            "\t/*",
            "\t * Attach the AGI buffer to the scrub transaction to avoid deadlocks",
            "\t * in the iget cache miss path.",
            "\t */",
            "\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, inum));"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\common.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\dabtree.c",
          "line": 41,
          "match": "DEADLOCK",
          "context": [
            "\t\treturn true;",
            "",
            "\tswitch (*error) {",
            "\tcase -EDEADLOCK:",
            "\tcase -ECHRNG:",
            "\t\t/* Used to restart an op with deadlock avoidance. */",
            "\t\ttrace_xchk_deadlock_retry(sc->ip, sc->sm, *error);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\dabtree.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\dabtree.c",
          "line": 43,
          "match": "deadlock",
          "context": [
            "\tswitch (*error) {",
            "\tcase -EDEADLOCK:",
            "\tcase -ECHRNG:",
            "\t\t/* Used to restart an op with deadlock avoidance. */",
            "\t\ttrace_xchk_deadlock_retry(sc->ip, sc->sm, *error);",
            "\t\tbreak;",
            "\tcase -EFSBADCRC:"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\dabtree.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\dabtree.c",
          "line": 44,
          "match": "deadlock",
          "context": [
            "\tcase -EDEADLOCK:",
            "\tcase -ECHRNG:",
            "\t\t/* Used to restart an op with deadlock avoidance. */",
            "\t\ttrace_xchk_deadlock_retry(sc->ip, sc->sm, *error);",
            "\t\tbreak;",
            "\tcase -EFSBADCRC:",
            "\tcase -EFSCORRUPTED:"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\dabtree.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\dirtree_repair.c",
          "line": 212,
          "match": "DEADLOCK",
          "context": [
            "}",
            "",
            "/*",
            " * Figure out what to do with the paths we tried to find.  Returns -EDEADLOCK",
            " * if the scan results have become stale.",
            " */",
            "STATIC void"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\dirtree_repair.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\fscounters.c",
          "line": 381,
          "match": "DEADLOCK",
          "context": [
            "\tif (fsc->ifree > fsc->icount) {",
            "\t\tif (tries--)",
            "\t\t\tgoto retry;",
            "\t\treturn -EDEADLOCK;",
            "\t}",
            "",
            "\treturn 0;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\fscounters.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\fscounters.c",
          "line": 540,
          "match": "DEADLOCK",
          "context": [
            "\t */",
            "\tif (fdblocks < 0 || frextents < 0) {",
            "\t\tif (!fsc->frozen)",
            "\t\t\treturn -EDEADLOCK;",
            "",
            "\t\txchk_set_corrupt(sc);",
            "\t\treturn 0;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\fscounters.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\fscounters.c",
          "line": 617,
          "match": "DEADLOCK",
          "context": [
            "\t}",
            "",
            "\tif (try_again)",
            "\t\treturn -EDEADLOCK;",
            "",
            "\treturn 0;",
            "}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\fscounters.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\ialloc.c",
          "line": 335,
          "match": "DEADLOCK",
          "context": [
            "\t\t/* Not cached, just read the disk buffer */",
            "\t\tfreemask_ok = irec_free ^ !!(dip->di_mode);",
            "\t\tif (!(bs->sc->flags & XCHK_TRY_HARDER) && !freemask_ok)",
            "\t\t\treturn -EDEADLOCK;",
            "\t} else if (error < 0) {",
            "\t\t/*",
            "\t\t * Inode is only half assembled, or there was an IO error,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\ialloc.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\inode_repair.c",
          "line": 445,
          "match": "DEADLOCK",
          "context": [
            "\t\t\t * the reason for the delay is an inode from the same",
            "\t\t\t * cluster buffer waiting on the inactivation list.",
            "\t\t\t */",
            "\t\t\terror = -EDEADLOCK;",
            "\t\t}",
            "\t}",
            "\tif (error)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\inode_repair.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\inode_repair.c",
          "line": 502,
          "match": "DEADLOCK",
          "context": [
            "\tswitch (error) {",
            "\tcase -EINTR:",
            "\tcase -EBUSY:",
            "\tcase -EDEADLOCK:",
            "\t\t/* temporary failure or fatal signal */",
            "\t\treturn error;",
            "\tcase 0:"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\inode_repair.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\nlinks.c",
          "line": 550,
          "match": "deadlock",
          "context": [
            "\t * the filesystem.",
            "\t *",
            "\t * Create a new empty transaction to eliminate the possibility of the",
            "\t * inode scan deadlocking on cyclical metadata.",
            "\t *",
            "\t * We pass the empty transaction to the file scanning function to avoid",
            "\t * repeatedly cycling empty transactions.  This can be done even though"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\nlinks.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\nlinks.c",
          "line": 879,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Create a new empty transaction so that we can advance the iscan",
            "\t * cursor without deadlocking if the inobt has a cycle and push on the",
            "\t * inactivation workqueue.",
            "\t */",
            "\txchk_trans_cancel(sc);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\nlinks.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\nlinks_repair.c",
          "line": 339,
          "match": "deadlock",
          "context": [
            "",
            "\t\t/*",
            "\t\t * Create a new empty transaction so that we can advance the",
            "\t\t * iscan cursor without deadlocking if the inobt has a cycle.",
            "\t\t * We can only push the inactivation workqueues with an empty",
            "\t\t * transaction.",
            "\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\nlinks_repair.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\parent_repair.c",
          "line": 919,
          "match": "DEADLOCK",
          "context": [
            "",
            "\t/*",
            "\t * If we need a larger value buffer, try to allocate one.  If that",
            "\t * fails, return with -EDEADLOCK to try harder.",
            "\t */",
            "\terror = xrep_parent_alloc_xattr_value(rp, valuelen);",
            "\tif (error == -ENOMEM)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\parent_repair.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\parent_repair.c",
          "line": 923,
          "match": "DEADLOCK",
          "context": [
            "\t */",
            "\terror = xrep_parent_alloc_xattr_value(rp, valuelen);",
            "\tif (error == -ENOMEM)",
            "\t\treturn -EDEADLOCK;",
            "\tif (error)",
            "\t\treturn error;",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\parent_repair.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\quotacheck.c",
          "line": 499,
          "match": "deadlock",
          "context": [
            "\t * the filesystem.",
            "\t *",
            "\t * Create a new empty transaction to eliminate the possibility of the",
            "\t * inode scan deadlocking on cyclical metadata.",
            "\t *",
            "\t * We pass the empty transaction to the file scanning function to avoid",
            "\t * repeatedly cycling empty transactions.  This can be done without"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\quotacheck.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\quotacheck.c",
          "line": 503,
          "match": "deadlock",
          "context": [
            "\t *",
            "\t * We pass the empty transaction to the file scanning function to avoid",
            "\t * repeatedly cycling empty transactions.  This can be done without",
            "\t * risk of deadlock between sb_internal and the IOLOCK (we take the",
            "\t * IOLOCK to quiesce the file before scanning) because empty",
            "\t * transactions do not take sb_internal.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\quotacheck.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\readdir.c",
          "line": 390,
          "match": "DEADLOCK",
          "context": [
            " *",
            " * If the trylocks succeed, *lockmode will be set to the locks held for @ip;",
            " * @sc->ilock_flags will be set for the locks held for @sc->ip; and zero will",
            " * be returned.  If not, returns -EDEADLOCK to try again; or -ETIMEDOUT if",
            " * XCHK_TRY_HARDER was set.  Returns -EINTR if the process has been killed.",
            " */",
            "int"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\readdir.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\readdir.c",
          "line": 420,
          "match": "DEADLOCK",
          "context": [
            "\t\treturn -ETIMEDOUT;",
            "\t}",
            "",
            "\treturn -EDEADLOCK;",
            "}",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\readdir.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\reap.c",
          "line": 284,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * If there are incore buffers for these blocks, invalidate them.  We",
            "\t * assume that the lack of any other known owners means that the buffer",
            "\t * can be locked without risk of deadlocking.  The buffer cache cannot",
            "\t * detect aliasing, so employ nested loops to scan for incore buffers",
            "\t * of any plausible size.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\reap.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\repair.c",
          "line": 95,
          "match": "DEADLOCK",
          "context": [
            "\t\tsc->flags |= XCHK_NEED_DRAIN;",
            "\t\trun->retries++;",
            "\t\treturn -EAGAIN;",
            "\tcase -EDEADLOCK:",
            "\t\t/* Tell the caller to try again having grabbed all the locks. */",
            "\t\tif (!(sc->flags & XCHK_TRY_HARDER)) {",
            "\t\t\tsc->flags |= XCHK_TRY_HARDER;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\repair.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\rmap_repair.c",
          "line": 944,
          "match": "deadlock",
          "context": [
            "\t * the log grant space while we scan the filesystem.",
            "\t *",
            "\t * Create a new empty transaction to eliminate the possibility of the",
            "\t * inode scan deadlocking on cyclical metadata.",
            "\t *",
            "\t * We pass the empty transaction to the file scanning function to avoid",
            "\t * repeatedly cycling empty transactions.  This can be done even though"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\rmap_repair.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\rtrmap_repair.c",
          "line": 574,
          "match": "deadlock",
          "context": [
            "\t * release the log grant space while we scan the filesystem.",
            "\t *",
            "\t * Create a new empty transaction to eliminate the possibility of the",
            "\t * inode scan deadlocking on cyclical metadata.",
            "\t *",
            "\t * We pass the empty transaction to the file scanning function to avoid",
            "\t * repeatedly cycling empty transactions.  This can be done even though"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\rtrmap_repair.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\scrub.c",
          "line": 63,
          "match": "deadlock",
          "context": [
            " * Block maps and b-trees rooted in an inode present a special challenge",
            " * because they can involve extents from any AG.  The general scrubber",
            " * structure of lock -> check -> xref -> unlock still holds, but AG",
            " * locking order rules /must/ be obeyed to avoid deadlocks.  The",
            " * ordering rule, of course, is that we must lock in increasing AG",
            " * order.  Helper functions are provided to track which AG headers we've",
            " * already locked.  If we detect an imminent locking order violation, we"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\scrub.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\scrub.c",
          "line": 67,
          "match": "deadlock",
          "context": [
            " * ordering rule, of course, is that we must lock in increasing AG",
            " * order.  Helper functions are provided to track which AG headers we've",
            " * already locked.  If we detect an imminent locking order violation, we",
            " * can signal a potential deadlock, in which case the scrubber can jump",
            " * out to the top level, lock all the AGs in order, and retry the scrub.",
            " *",
            " * For file data (directories, extended attributes, symlinks) scrub, we"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\scrub.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\scrub.c",
          "line": 75,
          "match": "deadlock",
          "context": [
            " * (directories and attributes) we follow the same btree-scrubbing",
            " * strategy outlined previously to check the records.",
            " *",
            " * We use a bit of trickery with transactions to avoid buffer deadlocks",
            " * if there is a cycle in the metadata.  The basic problem is that",
            " * travelling down a btree involves locking the current buffer at each",
            " * tree level.  If a pointer should somehow point back to a buffer that"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\scrub.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\scrub.c",
          "line": 79,
          "match": "deadlock",
          "context": [
            " * if there is a cycle in the metadata.  The basic problem is that",
            " * travelling down a btree involves locking the current buffer at each",
            " * tree level.  If a pointer should somehow point back to a buffer that",
            " * we've already examined, we will deadlock due to the second buffer",
            " * locking attempt.  Note however that grabbing a buffer in transaction",
            " * context links the locked buffer to the transaction.  If we try to",
            " * re-grab the buffer in the context of the same transaction, we avoid"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\scrub.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\scrub.c",
          "line": 710,
          "match": "DEADLOCK",
          "context": [
            "",
            "\t/* Set up for the operation. */",
            "\terror = sc->ops->setup(sc);",
            "\tif (error == -EDEADLOCK && !(sc->flags & XCHK_TRY_HARDER))",
            "\t\tgoto try_harder;",
            "\tif (error == -ECHRNG && !(sc->flags & XCHK_NEED_DRAIN))",
            "\t\tgoto need_drain;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\scrub.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\scrub.c",
          "line": 724,
          "match": "DEADLOCK",
          "context": [
            "\telse",
            "\t\terror = sc->ops->scrub(sc);",
            "\trun.scrub_ns += xchk_stats_elapsed_ns(check_start);",
            "\tif (error == -EDEADLOCK && !(sc->flags & XCHK_TRY_HARDER))",
            "\t\tgoto try_harder;",
            "\tif (error == -ECHRNG && !(sc->flags & XCHK_NEED_DRAIN))",
            "\t\tgoto need_drain;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\scrub.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\scrub.c",
          "line": 787,
          "match": "DEADLOCK",
          "context": [
            "\tgoto retry_op;",
            "try_harder:",
            "\t/*",
            "\t * Scrubbers return -EDEADLOCK to mean 'try harder'.  Tear down",
            "\t * everything we hold, then set up again with preparation for",
            "\t * worst-case scenarios.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\scrub.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\tempfile.c",
          "line": 171,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Wait until after the current transaction is aborted to finish the",
            "\t * setup of the inode and release the inode.  This prevents recursive",
            "\t * transactions and deadlocks from xfs_inactive.",
            "\t */",
            "\tif (sc->tempip) {",
            "\t\txfs_iunlock(sc->tempip, XFS_ILOCK_EXCL);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\tempfile.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\scrub\\tempfile.c",
          "line": 310,
          "match": "deadlock",
          "context": [
            "/*",
            " * Take the temporary file's IOLOCK while holding a different inode's IOLOCK.",
            " * In theory nobody else should hold the tempfile's IOLOCK, but we use trylock",
            " * to avoid deadlocks and lockdep complaints.",
            " */",
            "int",
            "xrep_tempfile_iolock_polled("
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\scrub\\tempfile.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\bpf_local_storage.c",
          "line": 792,
          "match": "deadlock",
          "context": [
            "}",
            "",
            "/* When bpf_ma == true, the bpf_mem_alloc is used to allocate and free memory.",
            " * A deadlock free allocator is useful for storage that the bpf prog can easily",
            " * get a hold of the owner PTR_TO_BTF_ID in any context. eg. bpf_get_current_task_btf.",
            " * The task and cgroup storage fall into this case. The bpf_mem_alloc reuses",
            " * memory immediately. To be reuse-immediate safe, the owner destruction"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\bpf_local_storage.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\cgroup.c",
          "line": 31,
          "match": "deadlock",
          "context": [
            " * cgroup bpf destruction makes heavy use of work items and there can be a lot",
            " * of concurrent destructions.  Use a separate workqueue so that cgroup bpf",
            " * destruction work items don't end up filling up max_active of system_wq",
            " * which may lead to deadlock.",
            " */",
            "static struct workqueue_struct *cgroup_bpf_destroy_wq;",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\cgroup.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\hashtab.c",
          "line": 46,
          "match": "deadlock",
          "context": [
            " * BPF programs can execute in any context including perf, kprobes and",
            " * tracing. As there are almost no limits where perf, kprobes and tracing",
            " * can be invoked from the lock operations need to be protected against",
            " * deadlocks. Deadlocks can be caused by recursion and by an invocation in",
            " * the lock held section when functions which acquire this lock are invoked",
            " * from sys_bpf(). BPF recursion is prevented by incrementing the per CPU",
            " * variable bpf_prog_active, which prevents BPF programs attached to perf"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\hashtab.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\hashtab.c",
          "line": 46,
          "match": "Deadlock",
          "context": [
            " * BPF programs can execute in any context including perf, kprobes and",
            " * tracing. As there are almost no limits where perf, kprobes and tracing",
            " * can be invoked from the lock operations need to be protected against",
            " * deadlocks. Deadlocks can be caused by recursion and by an invocation in",
            " * the lock held section when functions which acquire this lock are invoked",
            " * from sys_bpf(). BPF recursion is prevented by incrementing the per CPU",
            " * variable bpf_prog_active, which prevents BPF programs attached to perf"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\hashtab.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\hashtab.c",
          "line": 296,
          "match": "deadlock",
          "context": [
            " * bpf_lru_pop_free(), which is called by function prealloc_lru_pop(),",
            " * will acquire lru_lock first followed by acquiring bucket_lock.",
            " *",
            " * In hashtab.c, to avoid deadlock, lock acquisition of",
            " * bucket_lock followed by lru_lock is not allowed. In such cases,",
            " * bucket_lock needs to be released first before acquiring lru_lock.",
            " */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\hashtab.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\hashtab.c",
          "line": 1836,
          "match": "deadlock",
          "context": [
            "\t\t\thlist_nulls_del_rcu(&l->hash_node);",
            "",
            "\t\t\t/* bpf_lru_push_free() will acquire lru_lock, which",
            "\t\t\t * may cause deadlock. See comments in function",
            "\t\t\t * prealloc_lru_pop(). Let us do bpf_lru_push_free()",
            "\t\t\t * after releasing the bucket lock.",
            "\t\t\t *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\hashtab.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\helpers.c",
          "line": 1163,
          "match": "deadlock",
          "context": [
            "\t/* bpf_timer_cb() runs in hrtimer_run_softirq. It doesn't migrate and",
            "\t * cannot be preempted by another bpf_timer_cb() on the same cpu.",
            "\t * Remember the timer this callback is servicing to prevent",
            "\t * deadlock if callback_fn() calls bpf_timer_cancel() or",
            "\t * bpf_map_delete_elem() on the same timer.",
            "\t */",
            "\tthis_cpu_write(hrtimer_running, t);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\helpers.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\helpers.c",
          "line": 1483,
          "match": "deadlock",
          "context": [
            "\tcur_t = this_cpu_read(hrtimer_running);",
            "\tif (cur_t == t) {",
            "\t\t/* If bpf callback_fn is trying to bpf_timer_cancel()",
            "\t\t * its own timer the hrtimer_cancel() will deadlock",
            "\t\t * since it waits for callback_fn to finish.",
            "\t\t */",
            "\t\tret = -EDEADLK;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\helpers.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\helpers.c",
          "line": 1506,
          "match": "deadlock",
          "context": [
            "\t\t * attempting to cancel us. In such a case, it might be possible",
            "\t\t * that timer t belongs to the other callback, or some other",
            "\t\t * callback waiting upon it (creating transitive dependencies",
            "\t\t * upon us), and we will enter a deadlock if we continue",
            "\t\t * cancelling and waiting for it synchronously, since it might",
            "\t\t * do the same. Bail!",
            "\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\helpers.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\helpers.c",
          "line": 1570,
          "match": "deadlock",
          "context": [
            "\t\treturn;",
            "\t/* We check that bpf_map_delete/update_elem() was called from timer",
            "\t * callback_fn. In such case we don't call hrtimer_cancel() (since it",
            "\t * will deadlock) and don't call hrtimer_try_to_cancel() (since it will",
            "\t * just return -1). Though callback_fn is still running on this cpu it's",
            "\t * safe to do kfree(t) because bpf_timer_cb() read everything it needed",
            "\t * from 't'. The bpf subprog callback_fn won't be able to access 't',"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\helpers.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\helpers.c",
          "line": 2108,
          "match": "deadlock",
          "context": [
            "\tBUILD_BUG_ON(__alignof__(struct list_head) > __alignof__(struct bpf_list_head));",
            "",
            "\t/* Do the actual list draining outside the lock to not hold the lock for",
            "\t * too long, and also prevent deadlocks if tracing programs end up",
            "\t * executing on entry/exit of functions called inside the critical",
            "\t * section, and end up doing map ops that call bpf_list_head_free for",
            "\t * the same map value again."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\helpers.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\memalloc.c",
          "line": 982,
          "match": "deadlock",
          "context": [
            "}",
            "",
            "/* When flags == GFP_KERNEL, it signals that the caller will not cause",
            " * deadlock when using kmalloc. bpf_mem_cache_alloc_flags() will use",
            " * kmalloc if the free_llist is empty.",
            " */",
            "void notrace *bpf_mem_cache_alloc_flags(struct bpf_mem_alloc *ma, gfp_t flags)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\memalloc.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\rqspinlock.c",
          "line": 99,
          "match": "deadlock",
          "context": [
            "\treturn false;",
            "}",
            "",
            "static noinline int check_deadlock_AA(rqspinlock_t *lock, u32 mask,",
            "\t\t\t\t      struct rqspinlock_timeout *ts)",
            "{",
            "\tstruct rqspinlock_held *rqh = this_cpu_ptr(&rqspinlock_held_locks);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\rqspinlock.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\rqspinlock.c",
          "line": 117,
          "match": "deadlock",
          "context": [
            "}",
            "",
            "/*",
            " * This focuses on the most common case of ABBA deadlocks (or ABBA involving",
            " * more locks, which reduce to ABBA). This is not exhaustive, and we rely on",
            " * timeouts as the final line of defense.",
            " */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\rqspinlock.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\rqspinlock.c",
          "line": 121,
          "match": "deadlock",
          "context": [
            " * more locks, which reduce to ABBA). This is not exhaustive, and we rely on",
            " * timeouts as the final line of defense.",
            " */",
            "static noinline int check_deadlock_ABBA(rqspinlock_t *lock, u32 mask,",
            "\t\t\t\t\tstruct rqspinlock_timeout *ts)",
            "{",
            "\tstruct rqspinlock_held *rqh = this_cpu_ptr(&rqspinlock_held_locks);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\rqspinlock.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\rqspinlock.c",
          "line": 131,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * Find the CPU holding the lock that we want to acquire. If there is a",
            "\t * deadlock scenario, we will read a stable set on the remote CPU and",
            "\t * find the target. This would be a constant time operation instead of",
            "\t * O(NR_CPUS) if we could determine the owning CPU from a lock value, but",
            "\t * that requires increasing the size of the lock word."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\rqspinlock.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\rqspinlock.c",
          "line": 151,
          "match": "deadlock",
          "context": [
            "\t\t/*",
            "\t\t * Skip ourselves, and CPUs whose count is less than 2, as they need at",
            "\t\t * least one held lock and one acquisition attempt (reflected as top",
            "\t\t * most entry) to participate in an ABBA deadlock.",
            "\t\t *",
            "\t\t * If cnt is more than RES_NR_HELD, it means the current lock being",
            "\t\t * acquired won't appear in the table, and other locks in the table are"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\rqspinlock.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\rqspinlock.c",
          "line": 162,
          "match": "deadlock",
          "context": [
            "",
            "\t\t/*",
            "\t\t * Obtain the entry at the top, this corresponds to the lock the",
            "\t\t * remote CPU is attempting to acquire in a deadlock situation,",
            "\t\t * and would be one of the locks we hold on the current CPU.",
            "\t\t */",
            "\t\tremote_lock = READ_ONCE(rqh_cpu->locks[cnt - 1]);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\rqspinlock.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\rqspinlock.c",
          "line": 167,
          "match": "deadlock",
          "context": [
            "\t\t */",
            "\t\tremote_lock = READ_ONCE(rqh_cpu->locks[cnt - 1]);",
            "\t\t/*",
            "\t\t * If it is NULL, we've raced and cannot determine a deadlock",
            "\t\t * conclusively, skip this CPU.",
            "\t\t */",
            "\t\tif (!remote_lock)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\rqspinlock.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\rqspinlock.c",
          "line": 175,
          "match": "deadlock",
          "context": [
            "\t\t/*",
            "\t\t * Find if the lock we're attempting to acquire is held by this CPU.",
            "\t\t * Don't consider the topmost entry, as that must be the latest lock",
            "\t\t * being held or acquired.  For a deadlock, the target CPU must also",
            "\t\t * attempt to acquire a lock we hold, so for this search only 'cnt - 1'",
            "\t\t * entries are important.",
            "\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\rqspinlock.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\rqspinlock.c",
          "line": 185,
          "match": "deadlock",
          "context": [
            "\t\t\t/*",
            "\t\t\t * We found our lock as held on the remote CPU.  Is the",
            "\t\t\t * acquisition attempt on the remote CPU for a lock held",
            "\t\t\t * by us?  If so, we have a deadlock situation, and need",
            "\t\t\t * to recover.",
            "\t\t\t */",
            "\t\t\tfor (int i = 0; i < rqh_cnt - 1; i++) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\rqspinlock.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\rqspinlock.c",
          "line": 201,
          "match": "deadlock",
          "context": [
            "\treturn 0;",
            "}",
            "",
            "static noinline int check_deadlock(rqspinlock_t *lock, u32 mask,",
            "\t\t\t\t   struct rqspinlock_timeout *ts)",
            "{",
            "\tint ret;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\rqspinlock.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\rqspinlock.c",
          "line": 206,
          "match": "deadlock",
          "context": [
            "{",
            "\tint ret;",
            "",
            "\tret = check_deadlock_AA(lock, mask, ts);",
            "\tif (ret)",
            "\t\treturn ret;",
            "\tret = check_deadlock_ABBA(lock, mask, ts);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\rqspinlock.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\rqspinlock.c",
          "line": 209,
          "match": "deadlock",
          "context": [
            "\tret = check_deadlock_AA(lock, mask, ts);",
            "\tif (ret)",
            "\t\treturn ret;",
            "\tret = check_deadlock_ABBA(lock, mask, ts);",
            "\tif (ret)",
            "\t\treturn ret;",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\rqspinlock.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\rqspinlock.c",
          "line": 232,
          "match": "deadlock",
          "context": [
            "\t\treturn -ETIMEDOUT;",
            "",
            "\t/*",
            "\t * A millisecond interval passed from last time? Trigger deadlock",
            "\t * checks.",
            "\t */",
            "\tif (prev + NSEC_PER_MSEC < time) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\rqspinlock.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\rqspinlock.c",
          "line": 237,
          "match": "deadlock",
          "context": [
            "\t */",
            "\tif (prev + NSEC_PER_MSEC < time) {",
            "\t\tts->cur = time;",
            "\t\treturn check_deadlock(lock, mask, ts);",
            "\t}",
            "",
            "\treturn 0;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\rqspinlock.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\rqspinlock.c",
          "line": 329,
          "match": "deadlock",
          "context": [
            " *",
            " * Return:",
            " * * 0\t\t- Lock was acquired successfully.",
            " * * -EDEADLK\t- Lock acquisition failed because of AA/ABBA deadlock.",
            " * * -ETIMEDOUT - Lock acquisition failed because of timeout.",
            " *",
            " * (queue tail, pending bit, lock value)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\rqspinlock.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\rqspinlock.c",
          "line": 404,
          "match": "deadlock",
          "context": [
            "\t}",
            "",
            "\t/*",
            "\t * Grab an entry in the held locks array, to enable deadlock detection.",
            "\t */",
            "\tgrab_held_lock_entry(lock);",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\rqspinlock.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\rqspinlock.c",
          "line": 455,
          "match": "deadlock",
          "context": [
            "queue:",
            "\tlockevent_inc(lock_slowpath);",
            "\t/*",
            "\t * Grab deadlock detection entry for the queue path.",
            "\t */",
            "\tgrab_held_lock_entry(lock);",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\rqspinlock.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\trampoline.c",
          "line": 72,
          "match": "deadlock",
          "context": [
            "\t *   cleanup_direct_functions_after_ipmodify",
            "\t *",
            "\t * In both cases, direct_mutex is already locked. Use",
            "\t * mutex_trylock(&tr->mutex) to avoid deadlock in race condition",
            "\t * (something else is making changes to this same trampoline).",
            "\t */",
            "\tif (!mutex_trylock(&tr->mutex)) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\trampoline.c"
          ]
        },
        {
          "file": "linux\\kernel\\cgroup\\cgroup.c",
          "line": 128,
          "match": "deadlock",
          "context": [
            " * cgroup destruction makes heavy use of work items and there can be a lot",
            " * of concurrent destructions.  Use a separate workqueue so that cgroup",
            " * destruction work items don't end up filling up max_active of system_wq",
            " * which may lead to deadlock.",
            " */",
            "static struct workqueue_struct *cgroup_destroy_wq;",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\cgroup\\cgroup.c"
          ]
        },
        {
          "file": "linux\\kernel\\cgroup\\cgroup.c",
          "line": 2463,
          "match": "deadlock",
          "context": [
            " * exits by write-locking cgroup_threadgroup_rwsem. However, some ->attach()",
            " * implementations (e.g. cpuset), also need to disable CPU hotplug.",
            " * Unfortunately, letting ->attach() operations acquire cpus_read_lock() can",
            " * lead to deadlocks.",
            " *",
            " * Bringing up a CPU may involve creating and destroying tasks which requires",
            " * read-locking threadgroup_rwsem, so threadgroup_rwsem nests inside"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\cgroup\\cgroup.c"
          ]
        },
        {
          "file": "linux\\kernel\\bpf\\verifier.c",
          "line": 8321,
          "match": "deadlock",
          "context": [
            "\t\t\t}",
            "\t\t} else if (is_res_lock && cur->active_locks) {",
            "\t\t\tif (find_lock_state(env->cur_state, REF_TYPE_RES_LOCK | REF_TYPE_RES_LOCK_IRQ, reg->id, ptr)) {",
            "\t\t\t\tverbose(env, \"Acquiring the same lock again, AA deadlock detected\\n\");",
            "\t\t\t\treturn -EINVAL;",
            "\t\t\t}",
            "\t\t}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\bpf\\verifier.c"
          ]
        },
        {
          "file": "linux\\kernel\\debug\\debug_core.c",
          "line": 662,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * For single stepping, try to only enter on the processor",
            "\t * that was single stepping.  To guard against a deadlock, the",
            "\t * kernel will only try for the value of sstep_tries before",
            "\t * giving up and continuing on.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\debug\\debug_core.c"
          ]
        },
        {
          "file": "linux\\kernel\\dma\\debug.c",
          "line": 411,
          "match": "deadlock",
          "context": [
            " * entries into the tree.",
            " *",
            " * Use __GFP_NOWARN because the printk from an OOM, to netconsole, could end",
            " * up right back in the DMA debugging code, leading to a deadlock.",
            " */",
            "static RADIX_TREE(dma_active_cacheline, GFP_ATOMIC | __GFP_NOWARN);",
            "static DEFINE_SPINLOCK(radix_lock);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\dma\\debug.c"
          ]
        },
        {
          "file": "linux\\kernel\\dma\\debug.c",
          "line": 636,
          "match": "deadlock",
          "context": [
            "",
            "/*",
            " * This should be called outside of free_entries_lock scope to avoid potential",
            " * deadlocks with serial consoles that use DMA.",
            " */",
            "static void __dma_entry_alloc_check_leak(u32 nr_entries)",
            "{"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\dma\\debug.c"
          ]
        },
        {
          "file": "linux\\kernel\\dma\\debug.c",
          "line": 1048,
          "match": "deadlock",
          "context": [
            "\tput_hash_bucket(bucket, flags);",
            "",
            "\t/*",
            "\t * Free the entry outside of bucket_lock to avoid ABBA deadlocks",
            "\t * between that and radix_lock.",
            "\t */",
            "\tdma_entry_free(entry);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\dma\\debug.c"
          ]
        },
        {
          "file": "linux\\kernel\\events\\hw_breakpoint.c",
          "line": 123,
          "match": "deadlock",
          "context": [
            "\t\t/*",
            "\t\t * Fully analogous to the perf_try_init_event() nesting",
            "\t\t * argument in the comment near perf_event_ctx_lock_nested();",
            "\t\t * this child->perf_event_mutex cannot ever deadlock against",
            "\t\t * the parent->perf_event_mutex usage from",
            "\t\t * perf_event_task_{en,dis}able().",
            "\t\t *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\events\\hw_breakpoint.c"
          ]
        },
        {
          "file": "linux\\kernel\\events\\core.c",
          "line": 1320,
          "match": "deadlock",
          "context": [
            " *              perf_init_event()",
            " *                perf_try_init_event()\t[ child , 1 ]",
            " *",
            " * While it appears there is an obvious deadlock here -- the parent and child",
            " * nesting levels are inverted between the two. This is in fact safe because",
            " * life-time rules separate them. That is an exiting task cannot fork, and a",
            " * spawning task cannot (yet) exit."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\events\\core.c"
          ]
        },
        {
          "file": "linux\\kernel\\events\\core.c",
          "line": 11698,
          "match": "deadlock",
          "context": [
            "\t\t/*",
            "\t\t * Beware, here be dragons!!",
            "\t\t *",
            "\t\t * the tracepoint muck will deadlock against ctx->mutex, but",
            "\t\t * the tracepoint stuff does not actually need it. So",
            "\t\t * temporarily drop ctx->mutex. As per perf_event_ctx_lock() we",
            "\t\t * already have a reference on ctx."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\events\\core.c"
          ]
        },
        {
          "file": "linux\\kernel\\futex\\pi.c",
          "line": 537,
          "match": "deadlock",
          "context": [
            "\t\treturn -EFAULT;",
            "",
            "\t/*",
            "\t * Detect deadlocks.",
            "\t */",
            "\tif ((unlikely((uval & FUTEX_TID_MASK) == vpid)))",
            "\t\treturn -EDEADLK;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\futex\\pi.c"
          ]
        },
        {
          "file": "linux\\kernel\\futex\\pi.c",
          "line": 1050,
          "match": "deadlock",
          "context": [
            "",
            "cleanup:",
            "\t\t/*",
            "\t\t * If we failed to acquire the lock (deadlock/signal/timeout), we must",
            "\t\t * unwind the above, however we canont lock hb->lock because",
            "\t\t * rt_mutex already has a waiter enqueued and hb->lock can itself try",
            "\t\t * and enqueue an rt_waiter through rtlock."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\futex\\pi.c"
          ]
        },
        {
          "file": "linux\\kernel\\futex\\requeue.c",
          "line": 48,
          "match": "deadlock",
          "context": [
            " * to wait for the requeue side to change the state. Either to DONE/LOCKED",
            " * or to IGNORE. DONE/LOCKED means the waiter q is now on the uaddr2 futex",
            " * and either blocked (DONE) or has acquired it (LOCKED). IGNORE is set by",
            " * the requeue side when the requeue attempt failed via deadlock detection",
            " * and therefore the waiter q is still on the uaddr1 futex.",
            " */",
            "enum {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\futex\\requeue.c"
          ]
        },
        {
          "file": "linux\\kernel\\futex\\requeue.c",
          "line": 147,
          "match": "Deadlock",
          "context": [
            "\t\t\t\t     old != Q_REQUEUE_PI_WAIT);",
            "\t\t\tnew = Q_REQUEUE_PI_DONE + locked;",
            "\t\t} else if (old == Q_REQUEUE_PI_IN_PROGRESS) {",
            "\t\t\t/* Deadlock, no early wakeup interleave */",
            "\t\t\tnew = Q_REQUEUE_PI_NONE;",
            "\t\t} else {",
            "\t\t\t/* Deadlock, early wakeup interleave. */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\futex\\requeue.c"
          ]
        },
        {
          "file": "linux\\kernel\\futex\\requeue.c",
          "line": 150,
          "match": "Deadlock",
          "context": [
            "\t\t\t/* Deadlock, no early wakeup interleave */",
            "\t\t\tnew = Q_REQUEUE_PI_NONE;",
            "\t\t} else {",
            "\t\t\t/* Deadlock, early wakeup interleave. */",
            "\t\t\tWARN_ON_ONCE(old != Q_REQUEUE_PI_WAIT);",
            "\t\t\tnew = Q_REQUEUE_PI_IGNORE;",
            "\t\t}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\futex\\requeue.c"
          ]
        },
        {
          "file": "linux\\kernel\\futex\\requeue.c",
          "line": 664,
          "match": "deadlock",
          "context": [
            "\t\t\t} else {",
            "\t\t\t\t/*",
            "\t\t\t\t * rt_mutex_start_proxy_lock() detected a potential",
            "\t\t\t\t * deadlock when we tried to queue that waiter.",
            "\t\t\t\t * Drop the pi_state reference which we took above",
            "\t\t\t\t * and remove the pointer to the state from the",
            "\t\t\t\t * waiters futex_q object."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\futex\\requeue.c"
          ]
        },
        {
          "file": "linux\\kernel\\futex\\waitwake.c",
          "line": 417,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Enqueuing multiple futexes is tricky, because we need to enqueue",
            "\t * each futex on the list before dealing with the next one to avoid",
            "\t * deadlocking on the hash bucket. But, before enqueuing, we need to",
            "\t * make sure that current->state is TASK_INTERRUPTIBLE, so we don't",
            "\t * lose any wake events, which cannot be done before the get_futex_key",
            "\t * of the next key, because it calls get_user_pages, which can sleep."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\futex\\waitwake.c"
          ]
        },
        {
          "file": "linux\\kernel\\irq\\irqdomain.c",
          "line": 1726,
          "match": "deadlock",
          "context": [
            "\t * hierarchy.  This will catch gross misuse.  Attempting to",
            "\t * make the check race free would require holding locks across",
            "\t * calls to struct irq_domain_ops->alloc(), which could lead",
            "\t * to deadlock, so we just do a simple check before starting.",
            "\t */",
            "\tdesc = irq_to_desc(virq);",
            "\tif (!desc)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\irq\\irqdomain.c"
          ]
        },
        {
          "file": "linux\\kernel\\irq\\irqdomain.c",
          "line": 1807,
          "match": "deadlock",
          "context": [
            "\t * This will catch gross misuse.  Attempting to make the check",
            "\t * race free would require holding locks across calls to",
            "\t * struct irq_domain_ops->free(), which could lead to",
            "\t * deadlock, so we just do a simple check before starting.",
            "\t */",
            "\tdesc = irq_to_desc(virq);",
            "\tif (!desc)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\irq\\irqdomain.c"
          ]
        },
        {
          "file": "linux\\kernel\\irq\\manage.c",
          "line": 80,
          "match": "deadlock",
          "context": [
            " *",
            " * This function waits for any pending hard IRQ handlers for this interrupt",
            " * to complete before returning. If you use this function while holding a",
            " * resource the IRQ handler may need you will deadlock. It does not take",
            " * associated threaded handlers into account.",
            " *",
            " * Do not use this for shutdown scenarios where you must be sure that all"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\irq\\manage.c"
          ]
        },
        {
          "file": "linux\\kernel\\irq\\manage.c",
          "line": 91,
          "match": "deadlock",
          "context": [
            " * This function may be called - with care - from IRQ context.",
            " *",
            " * It does not check whether there is an interrupt in flight at the",
            " * hardware level, but not serviced yet, as this might deadlock when called",
            " * with interrupts disabled and the target CPU of the interrupt is the",
            " * current CPU.",
            " */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\irq\\manage.c"
          ]
        },
        {
          "file": "linux\\kernel\\irq\\manage.c",
          "line": 124,
          "match": "deadlock",
          "context": [
            " *",
            " * This function waits for any pending IRQ handlers for this interrupt to",
            " * complete before returning. If you use this function while holding a",
            " * resource the IRQ handler may need you will deadlock.",
            " *",
            " * Can only be called from preemptible code as it might sleep when",
            " * an interrupt thread is associated to @irq."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\irq\\manage.c"
          ]
        },
        {
          "file": "linux\\kernel\\irq\\manage.c",
          "line": 694,
          "match": "deadlock",
          "context": [
            " *",
            " * This function waits for any pending IRQ handlers for this interrupt to",
            " * complete before returning. If you use this function while holding a",
            " * resource the IRQ handler may need you will deadlock.",
            " *",
            " * Can only be called from preemptible code as it might sleep when an",
            " * interrupt thread is associated to @irq."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\irq\\manage.c"
          ]
        },
        {
          "file": "linux\\kernel\\irq\\manage.c",
          "line": 716,
          "match": "deadlock",
          "context": [
            " *",
            " * This function waits for any pending hard IRQ handlers for this interrupt",
            " * to complete before returning. If you use this function while holding a",
            " * resource the hard IRQ handler may need you will deadlock.",
            " *",
            " * When used to optimistically disable an interrupt from atomic context the",
            " * return value must be checked."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\irq\\manage.c"
          ]
        },
        {
          "file": "linux\\kernel\\irq\\manage.c",
          "line": 1143,
          "match": "deadlock",
          "context": [
            "/*",
            " * Interrupts which are not explicitly requested as threaded",
            " * interrupts rely on the implicit bh/preempt disable of the hard irq",
            " * context. So we need to disable bh here to avoid deadlocks and other",
            " * side effects.",
            " */",
            "static irqreturn_t irq_forced_thread_fn(struct irq_desc *desc, struct irqaction *action)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\irq\\manage.c"
          ]
        },
        {
          "file": "linux\\kernel\\irq\\manage.c",
          "line": 1866,
          "match": "deadlock",
          "context": [
            "\t * behind a slow bus (I2C, SPI) before calling synchronize_hardirq().",
            "\t *",
            "\t * Aside of that the bus_lock can also be taken from the threaded",
            "\t * handler in irq_finalize_oneshot() which results in a deadlock",
            "\t * because kthread_stop() would wait forever for the thread to",
            "\t * complete, which is blocked on the bus lock.",
            "\t *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\irq\\manage.c"
          ]
        },
        {
          "file": "linux\\kernel\\kcsan\\report.c",
          "line": 57,
          "match": "deadlock",
          "context": [
            "\t *",
            "\t * We cannot rely on get_task_struct/put_task_struct in case",
            "\t * release_report() races with a task being released, and would have to",
            "\t * free it in release_report(). This may result in deadlock if we want",
            "\t * to use KCSAN on the allocators.",
            "\t *",
            "\t * Since we also want to reliably print held locks for"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\kcsan\\report.c"
          ]
        },
        {
          "file": "linux\\kernel\\kcsan\\report.c",
          "line": 92,
          "match": "deadlock",
          "context": [
            "",
            "/*",
            " * Since we also want to be able to debug allocators with KCSAN, to avoid",
            " * deadlock, report_times cannot be dynamically resized with krealloc in",
            " * rate_limit_report.",
            " *",
            " * Therefore, we use a fixed-size array, which at most will occupy a page. This"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\kcsan\\report.c"
          ]
        },
        {
          "file": "linux\\kernel\\kcsan\\report.c",
          "line": 524,
          "match": "deadlock",
          "context": [
            "\t */",
            "\tconst bool is_running = task_is_running(current);",
            "\t/*",
            "\t * To avoid deadlock in case we are in an interrupt here and this is a",
            "\t * race with a task on the same CPU (KCSAN_INTERRUPT_WATCHER), provide a",
            "\t * timeout to ensure this works in all contexts.",
            "\t *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\kcsan\\report.c"
          ]
        },
        {
          "file": "linux\\kernel\\kcsan\\report.c",
          "line": 677,
          "match": "deadlock",
          "context": [
            "\tkcsan_disable_current();",
            "\t/*",
            "\t * Because we may generate reports when we're in scheduler code, the use",
            "\t * of printk() could deadlock. Until such time that all printing code",
            "\t * called in print_report() is scheduler-safe, accept the risk, and just",
            "\t * get our message out. As such, also disable lockdep to hide the",
            "\t * warning, and avoid disabling lockdep for the rest of the kernel."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\kcsan\\report.c"
          ]
        },
        {
          "file": "linux\\kernel\\livepatch\\core.c",
          "line": 751,
          "match": "deadlock",
          "context": [
            "static void klp_free_patch_finish(struct klp_patch *patch)",
            "{",
            "\t/*",
            "\t * Avoid deadlock with enabled_store() sysfs callback by",
            "\t * calling this outside klp_mutex. It is safe because",
            "\t * this is called when the patch gets disabled and it",
            "\t * cannot get enabled again."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\livepatch\\core.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 20,
          "match": "deadlock",
          "context": [
            " * - hardirq/softirq safe/unsafe locking bugs",
            " *",
            " * Bugs are reported even if the current locking scenario does not cause",
            " * any deadlock at this point.",
            " *",
            " * I.e. if anytime in the past two locks were taken in a different order,",
            " * even if it happened for another task, even if those were different"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 1465,
          "match": "deadlock",
          "context": [
            "/*",
            " * The circular_queue and helpers are used to implement graph",
            " * breadth-first search (BFS) algorithm, by which we can determine",
            " * whether there is a path from a lock to another. In deadlock checks,",
            " * a path from the next lock to be acquired to a previous held lock",
            " * indicates that adding the <prev> -> <next> lock dependency will",
            " * produce a circle in the graph. Breadth-first search instead of"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 1721,
          "match": "deadlock",
          "context": [
            " *",
            " * We may have multiple edges (considering different kinds of dependencies,",
            " * e.g. ER and SN) between two nodes in the dependency graph. But",
            " * only the strong dependency path in the graph is relevant to deadlocks. A",
            " * strong dependency path is a dependency path that doesn't have two adjacent",
            " * dependencies as -(*R)-> -(S*)->, please see:",
            " *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 1875,
          "match": "deadlock",
          "context": [
            "}",
            "",
            "/*",
            " * Print a dependency chain entry (this is only done when a deadlock",
            " * has been detected):",
            " */",
            "static noinline void"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 1903,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * A direct locking problem where unsafe_class lock is taken",
            "\t * directly by safe_class lock, then all we need to show",
            "\t * is the deadlock scenario, as it is obvious that the",
            "\t * unsafe lock is taken under the safe lock.",
            "\t *",
            "\t * But if there is a chain instead, where the safe lock takes"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 1946,
          "match": "DEADLOCK",
          "context": [
            "\t\tprintk(\"  lock(\");",
            "\t__print_lock_name(src, source);",
            "\tprintk(KERN_CONT \");\\n\");",
            "\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");",
            "}",
            "",
            "/*"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 1986,
          "match": "deadlock",
          "context": [
            " * strong dependency path A -> .. -> B is found: hlock_class equals",
            " * entry->class.",
            " *",
            " * We will have a deadlock case (conflict) if A -> .. -> B -> A is a strong",
            " * dependency cycle, that means:",
            " *",
            " * Either"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 2142,
          "match": "deadlock",
          "context": [
            "\treturn ret;",
            "}",
            "",
            "static void print_deadlock_bug(struct task_struct *, struct held_lock *, struct held_lock *);",
            "",
            "/*",
            " * Prove that the dependency graph starting at <src> can not"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 2176,
          "match": "deadlock",
          "context": [
            "\t\t}",
            "",
            "\t\tif (src->class_idx == target->class_idx)",
            "\t\t\tprint_deadlock_bug(current, src, target);",
            "\t\telse",
            "\t\t\tprint_circular_bug(&src_entry, target_entry, src, target);",
            "\t}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 2191,
          "match": "deadlock",
          "context": [
            " * proving that two subgraphs can be connected by a new dependency",
            " * without creating any illegal irq-safe -> irq-unsafe lock dependency.",
            " *",
            " * A irq safe->unsafe deadlock happens with the following conditions:",
            " *",
            " * 1) We have a strong dependency path A -> ... -> B",
            " *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 2240,
          "match": "deadlock",
          "context": [
            "/*",
            " * There is a strong dependency path in the dependency graph: A -> B, and now",
            " * we need to decide which usage bit of B conflicts with the usage bits of A,",
            " * i.e. which usage bit of B may introduce safe->unsafe deadlocks.",
            " *",
            " * As above, if only_xr is false, which means A -> B has -(*N)-> dependency",
            " * path, any usage of B should be considered. Otherwise, we should only"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 2365,
          "match": "deadlock",
          "context": [
            " *",
            " * After BFS we get a lock dependency path (linked via ->parent of lock_list),",
            " * printing out each lock in the dependency path will help on understanding how",
            " * the deadlock could happen. Here are some details about dependency path",
            " * printing:",
            " *",
            " * 1)\tA lock_list can be either forwards or backwards for a lock dependency,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 2509,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * A direct locking problem where unsafe_class lock is taken",
            "\t * directly by safe_class lock, then all we need to show",
            "\t * is the deadlock scenario, as it is obvious that the",
            "\t * unsafe lock is taken under the safe lock.",
            "\t *",
            "\t * But if there is a chain instead, where the safe lock takes"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 2546,
          "match": "DEADLOCK",
          "context": [
            "\tprintk(\"    lock(\");",
            "\t__print_lock_name(NULL, safe_class);",
            "\tprintk(KERN_CONT \");\\n\");",
            "\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");",
            "}",
            "",
            "static void"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 2691,
          "match": "deadlock",
          "context": [
            "",
            "/*",
            " * Note that a LOCK_ENABLED_IRQ_*_READ usage and a LOCK_USED_IN_IRQ_*_READ",
            " * usage may cause deadlock too, for example:",
            " *",
            " * P1\t\t\t\tP2",
            " * <irq disabled>"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 2703,
          "match": "deadlock",
          "context": [
            " *",
            " * , in above case, l1 will be marked as LOCK_USED_IN_IRQ_HARDIRQ_READ and l2",
            " * will marked as LOCK_ENABLE_IRQ_HARDIRQ_READ, and this is a possible",
            " * deadlock.",
            " *",
            " * In fact, all of the following cases may cause deadlocks:",
            " *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 2705,
          "match": "deadlock",
          "context": [
            " * will marked as LOCK_ENABLE_IRQ_HARDIRQ_READ, and this is a possible",
            " * deadlock.",
            " *",
            " * In fact, all of the following cases may cause deadlocks:",
            " *",
            " * \t LOCK_USED_IN_IRQ_* -> LOCK_ENABLED_IRQ_*",
            " * \t LOCK_USED_IN_IRQ_*_READ -> LOCK_ENABLED_IRQ_*"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 2759,
          "match": "deadlock",
          "context": [
            "\tfor_each_set_bit(bit, &mask, LOCK_USED) {",
            "\t\t/*",
            "\t\t * exclusive_bit() strips the read bit, however,",
            "\t\t * LOCK_ENABLED_IRQ_*_READ may cause deadlocks too, so we need",
            "\t\t * to search excl | LOCK_USAGE_READ_MASK as well.",
            "\t\t */",
            "\t\texcl = exclusive_bit(bit);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 2838,
          "match": "deadlock",
          "context": [
            "\t * that B -> ... -> M. However M is **softirq-safe**, if we use exact",
            "\t * invert bits of M's usage_mask, we will find another lock N that is",
            "\t * **softirq-unsafe** and N -> ... -> A, however N -> .. -> M will not",
            "\t * cause a inversion deadlock.",
            "\t */",
            "\tbackward_mask = original_mask(target_entry1->class->usage_mask & LOCKF_ENABLED_IRQ_ALL);",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 2994,
          "match": "deadlock",
          "context": [
            "}",
            "",
            "static void",
            "print_deadlock_scenario(struct held_lock *nxt, struct held_lock *prv)",
            "{",
            "\tstruct lock_class *next = hlock_class(nxt);",
            "\tstruct lock_class *prev = hlock_class(prv);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 3008,
          "match": "DEADLOCK",
          "context": [
            "\tprintk(\"  lock(\");",
            "\t__print_lock_name(nxt, next);",
            "\tprintk(KERN_CONT \");\\n\");",
            "\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");",
            "\tprintk(\" May be due to missing lock nesting notation\\n\\n\");",
            "}",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 3013,
          "match": "deadlock",
          "context": [
            "}",
            "",
            "static void",
            "print_deadlock_bug(struct task_struct *curr, struct held_lock *prev,",
            "\t\t   struct held_lock *next)",
            "{",
            "\tstruct lock_class *class = hlock_class(prev);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 3040,
          "match": "deadlock",
          "context": [
            "\t}",
            "",
            "\tpr_warn(\"\\nother info that might help us debug this:\\n\");",
            "\tprint_deadlock_scenario(next, prev);",
            "\tlockdep_print_held_locks(curr);",
            "",
            "\tpr_warn(\"\\nstack backtrace:\\n\");"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 3053,
          "match": "deadlock",
          "context": [
            " * Check whether we are holding such a class already.",
            " *",
            " * (Note that this has to be done separately, because the graph cannot",
            " * detect such classes of deadlocks.)",
            " *",
            " * Returns: 0 on deadlock detected, 1 on OK, 2 if another lock with the same",
            " * lock class is held but nest_lock is also held, i.e. we rely on the"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 3055,
          "match": "deadlock",
          "context": [
            " * (Note that this has to be done separately, because the graph cannot",
            " * detect such classes of deadlocks.)",
            " *",
            " * Returns: 0 on deadlock detected, 1 on OK, 2 if another lock with the same",
            " * lock class is held but nest_lock is also held, i.e. we rely on the",
            " * nest_lock to avoid the deadlock.",
            " */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 3057,
          "match": "deadlock",
          "context": [
            " *",
            " * Returns: 0 on deadlock detected, 1 on OK, 2 if another lock with the same",
            " * lock class is held but nest_lock is also held, i.e. we rely on the",
            " * nest_lock to avoid the deadlock.",
            " */",
            "static int",
            "check_deadlock(struct task_struct *curr, struct held_lock *next)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 3060,
          "match": "deadlock",
          "context": [
            " * nest_lock to avoid the deadlock.",
            " */",
            "static int",
            "check_deadlock(struct task_struct *curr, struct held_lock *next)",
            "{",
            "\tstruct lock_class *class;",
            "\tstruct held_lock *prev;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 3096,
          "match": "deadlock",
          "context": [
            "\t\tif (nest)",
            "\t\t\treturn 2;",
            "",
            "\t\tprint_deadlock_bug(curr, prev, next);",
            "\t\treturn 0;",
            "\t}",
            "\treturn 1;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 3107,
          "match": "deadlock",
          "context": [
            " * to a previous lock. We validate the following rules:",
            " *",
            " *  - would the adding of the <prev> -> <next> dependency create a",
            " *    circular dependency in the graph? [== circular deadlock]",
            " *",
            " *  - does the new prev->next dependency connect any hardirq-safe lock",
            " *    (in the full backwards-subgraph starting at <prev>) with any"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 3119,
          "match": "deadlock",
          "context": [
            " *    softirq-unsafe lock (in the full forwards-subgraph starting at",
            " *    <next>)? [== illegal lock inversion with softirq contexts]",
            " *",
            " * any of these scenarios could lead to a deadlock.",
            " *",
            " * Then if all the validations pass, we add the forwards and backwards",
            " * dependency."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 3892,
          "match": "deadlock",
          "context": [
            "\t\t * - within the current held-lock stack",
            "\t\t * - across our accumulated lock dependency records",
            "\t\t *",
            "\t\t * any of these scenarios could lead to a deadlock.",
            "\t\t */",
            "\t\t/*",
            "\t\t * The simple case: does the current hold the same lock"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 3898,
          "match": "deadlock",
          "context": [
            "\t\t * The simple case: does the current hold the same lock",
            "\t\t * already?",
            "\t\t */",
            "\t\tint ret = check_deadlock(curr, hlock);",
            "",
            "\t\tif (!ret)",
            "\t\t\treturn 0;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 3906,
          "match": "deadlock",
          "context": [
            "\t\t * Add dependency only if this lock is not the head",
            "\t\t * of the chain, and if the new lock introduces no more",
            "\t\t * lock dependency (because we already hold a lock with the",
            "\t\t * same lock class) nor deadlock (because the nest_lock",
            "\t\t * serializes nesting locks), see the comments for",
            "\t\t * check_deadlock().",
            "\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 3908,
          "match": "deadlock",
          "context": [
            "\t\t * lock dependency (because we already hold a lock with the",
            "\t\t * same lock class) nor deadlock (because the nest_lock",
            "\t\t * serializes nesting locks), see the comments for",
            "\t\t * check_deadlock().",
            "\t\t */",
            "\t\tif (!chain_head && ret != 2) {",
            "\t\t\tif (!check_prevs_add(curr, hlock))"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 4006,
          "match": "DEADLOCK",
          "context": [
            "\tprintk(\"    lock(\");",
            "\t__print_lock_name(lock, class);",
            "\tprintk(KERN_CONT \");\\n\");",
            "\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");",
            "}",
            "",
            "static void"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 4288,
          "match": "deadlock",
          "context": [
            "\tif (dir) {",
            "\t\t/*",
            "\t\t * mark ENABLED has to look backwards -- to ensure no dependee",
            "\t\t * has USED_IN state, which, again, would allow  recursion deadlocks.",
            "\t\t */",
            "\t\tif (!check_usage_backwards(curr, this, excl_bit))",
            "\t\t\treturn 0;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 4295,
          "match": "deadlock",
          "context": [
            "\t} else {",
            "\t\t/*",
            "\t\t * mark USED_IN has to look forwards -- to ensure no dependency",
            "\t\t * has ENABLED state, which would allow recursion deadlocks.",
            "\t\t */",
            "\t\tif (!check_usage_forwards(curr, this, excl_bit))",
            "\t\t\treturn 0;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 5785,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * READ locks only conflict with USED, such that if we only ever use",
            "\t * READ locks, there is no deadlock possible -- RCU.",
            "\t */",
            "\tif (!hlock->read)",
            "\t\tmask |= LOCKF_USED_READ;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 5905,
          "match": "deadlock",
          "context": [
            " * No actual critical section is created by the APIs annotated with this: these",
            " * APIs are used to wait for one or multiple critical sections (on other CPUs",
            " * or threads), and it means that calling these APIs inside these critical",
            " * sections is potential deadlock.",
            " */",
            "void lock_sync(struct lockdep_map *lock, unsigned subclass, int read,",
            "\t       int check, struct lockdep_map *nest_lock, unsigned long ip)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\mutex-debug.c",
          "line": 8,
          "match": "deadlock",
          "context": [
            " *",
            " *  Copyright (C) 2004, 2005, 2006 Red Hat, Inc., Ingo Molnar <mingo@redhat.com>",
            " *",
            " * lock debugging, locking tree, deadlock detection started by:",
            " *",
            " *  Copyright (C) 2004, LynuxWorks, Inc., Igor Manyilov, Bill Huey",
            " *  Released under the General Public License (GPL)."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\mutex-debug.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\mutex.c",
          "line": 269,
          "match": "deadlock",
          "context": [
            " *",
            " * (The CONFIG_DEBUG_MUTEXES .config option turns on debugging",
            " * checks that will enforce the restrictions and will also do",
            " * deadlock debugging)",
            " *",
            " * This function is similar to (but not equivalent to) down().",
            " */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\mutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\mutex.c",
          "line": 308,
          "match": "deadlock",
          "context": [
            "\t * by acquiring wait_lock there is a guarantee that",
            "\t * they are not invalid when reading.",
            "\t *",
            "\t * As such, when deadlock detection needs to be",
            "\t * performed the optimistic spinning cannot be done.",
            "\t *",
            "\t * Check this in every inner iteration because we may"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\mutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\mutex.c",
          "line": 762,
          "match": "deadlock",
          "context": [
            " * @ww: mutex to lock",
            " * @ww_ctx: optional w/w acquire context",
            " *",
            " * Trylocks a mutex with the optional acquire context; no deadlock detection is",
            " * possible. Returns 1 if the mutex has been acquired successfully, 0 otherwise.",
            " *",
            " * Unlike ww_mutex_lock, no deadlock handling is performed. However, if a @ctx is"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\mutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\mutex.c",
          "line": 765,
          "match": "deadlock",
          "context": [
            " * Trylocks a mutex with the optional acquire context; no deadlock detection is",
            " * possible. Returns 1 if the mutex has been acquired successfully, 0 otherwise.",
            " *",
            " * Unlike ww_mutex_lock, no deadlock handling is performed. However, if a @ctx is",
            " * specified, -EALREADY handling may happen in calls to ww_mutex_trylock.",
            " *",
            " * A mutex acquired with this function must be released with ww_mutex_unlock."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\mutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\mutex.c",
          "line": 841,
          "match": "deadlock",
          "context": [
            "EXPORT_SYMBOL_GPL(mutex_lock_io_nested);",
            "",
            "static inline int",
            "ww_mutex_deadlock_injection(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)",
            "{",
            "#ifdef CONFIG_DEBUG_WW_MUTEX_SLOWPATH",
            "\tunsigned tmp;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\mutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\mutex.c",
          "line": 846,
          "match": "deadlock",
          "context": [
            "#ifdef CONFIG_DEBUG_WW_MUTEX_SLOWPATH",
            "\tunsigned tmp;",
            "",
            "\tif (ctx->deadlock_inject_countdown-- == 0) {",
            "\t\ttmp = ctx->deadlock_inject_interval;",
            "\t\tif (tmp > UINT_MAX/4)",
            "\t\t\ttmp = UINT_MAX;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\mutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\mutex.c",
          "line": 847,
          "match": "deadlock",
          "context": [
            "\tunsigned tmp;",
            "",
            "\tif (ctx->deadlock_inject_countdown-- == 0) {",
            "\t\ttmp = ctx->deadlock_inject_interval;",
            "\t\tif (tmp > UINT_MAX/4)",
            "\t\t\ttmp = UINT_MAX;",
            "\t\telse"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\mutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\mutex.c",
          "line": 853,
          "match": "deadlock",
          "context": [
            "\t\telse",
            "\t\t\ttmp = tmp*2 + tmp + tmp/2;",
            "",
            "\t\tctx->deadlock_inject_interval = tmp;",
            "\t\tctx->deadlock_inject_countdown = tmp;",
            "\t\tctx->contending_lock = lock;",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\mutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\mutex.c",
          "line": 854,
          "match": "deadlock",
          "context": [
            "\t\t\ttmp = tmp*2 + tmp + tmp/2;",
            "",
            "\t\tctx->deadlock_inject_interval = tmp;",
            "\t\tctx->deadlock_inject_countdown = tmp;",
            "\t\tctx->contending_lock = lock;",
            "",
            "\t\tww_mutex_unlock(lock);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\mutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\mutex.c",
          "line": 875,
          "match": "deadlock",
          "context": [
            "\tret =  __ww_mutex_lock(&lock->base, TASK_UNINTERRUPTIBLE,",
            "\t\t\t       0, _RET_IP_, ctx);",
            "\tif (!ret && ctx && ctx->acquired > 1)",
            "\t\treturn ww_mutex_deadlock_injection(lock, ctx);",
            "",
            "\treturn ret;",
            "}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\mutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\mutex.c",
          "line": 891,
          "match": "deadlock",
          "context": [
            "\t\t\t      0, _RET_IP_, ctx);",
            "",
            "\tif (!ret && ctx && ctx->acquired > 1)",
            "\t\treturn ww_mutex_deadlock_injection(lock, ctx);",
            "",
            "\treturn ret;",
            "}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\mutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex_api.c",
          "line": 280,
          "match": "deadlock",
          "context": [
            " * @task:\t\tthe task to prepare",
            " * @wake_q:\t\tthe wake_q to wake tasks after we release the wait_lock",
            " *",
            " * Starts the rt_mutex acquire; it enqueues the @waiter and does deadlock",
            " * detection. It does not wait, see rt_mutex_wait_proxy_lock() for that.",
            " *",
            " * NOTE: does _NOT_ remove the @waiter on failure; must either call"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex_api.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex_api.c",
          "line": 305,
          "match": "deadlock",
          "context": [
            "\tif (try_to_take_rt_mutex(lock, task, NULL))",
            "\t\treturn 1;",
            "",
            "\t/* We enforce deadlock detection for futexes */",
            "\tret = task_blocks_on_rt_mutex(lock, waiter, task, NULL,",
            "\t\t\t\t      RT_MUTEX_FULL_CHAINWALK, wake_q);",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex_api.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex_api.c",
          "line": 328,
          "match": "deadlock",
          "context": [
            " * @waiter:\t\tthe pre-initialized rt_mutex_waiter",
            " * @task:\t\tthe task to prepare",
            " *",
            " * Starts the rt_mutex acquire; it enqueues the @waiter and does deadlock",
            " * detection. It does not wait, see rt_mutex_wait_proxy_lock() for that.",
            " *",
            " * NOTE: unlike __rt_mutex_start_proxy_lock this _DOES_ remove the @waiter"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex_api.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 579,
          "match": "Deadlock",
          "context": [
            "}",
            "",
            "/*",
            " * Deadlock detection is conditional:",
            " *",
            " * If CONFIG_DEBUG_RT_MUTEXES=n, deadlock detection is only conducted",
            " * if the detect argument is == RT_MUTEX_FULL_CHAINWALK."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 581,
          "match": "deadlock",
          "context": [
            "/*",
            " * Deadlock detection is conditional:",
            " *",
            " * If CONFIG_DEBUG_RT_MUTEXES=n, deadlock detection is only conducted",
            " * if the detect argument is == RT_MUTEX_FULL_CHAINWALK.",
            " *",
            " * If CONFIG_DEBUG_RT_MUTEXES=y, deadlock detection is always"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 584,
          "match": "deadlock",
          "context": [
            " * If CONFIG_DEBUG_RT_MUTEXES=n, deadlock detection is only conducted",
            " * if the detect argument is == RT_MUTEX_FULL_CHAINWALK.",
            " *",
            " * If CONFIG_DEBUG_RT_MUTEXES=y, deadlock detection is always",
            " * conducted independent of the detect argument.",
            " *",
            " * If the waiter argument is NULL this indicates the deboost path and"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 588,
          "match": "deadlock",
          "context": [
            " * conducted independent of the detect argument.",
            " *",
            " * If the waiter argument is NULL this indicates the deboost path and",
            " * deadlock detection is disabled independent of the detect argument",
            " * and the config settings.",
            " */",
            "static __always_inline bool"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 592,
          "match": "deadlock",
          "context": [
            " * and the config settings.",
            " */",
            "static __always_inline bool",
            "rt_mutex_cond_detect_deadlock(struct rt_mutex_waiter *waiter,",
            "\t\t\t      enum rtmutex_chainwalk chwalk)",
            "{",
            "\tif (IS_ENABLED(CONFIG_DEBUG_RT_MUTEXES))"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 606,
          "match": "deadlock",
          "context": [
            "}",
            "",
            "/*",
            " * Adjust the priority chain. Also used for deadlock detection.",
            " * Decreases task's usage by one - may thus free the task.",
            " *",
            " * @task:\tthe task owning the mutex (owner) for which a chain walk is"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 611,
          "match": "deadlock",
          "context": [
            " *",
            " * @task:\tthe task owning the mutex (owner) for which a chain walk is",
            " *\t\tprobably needed",
            " * @chwalk:\tdo we have to carry out deadlock detection?",
            " * @orig_lock:\tthe mutex (can be NULL if we are walking the chain to recheck",
            " *\t\tthings for a task that has just got its priority adjusted, and",
            " *\t\tis waiting on a mutex)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 689,
          "match": "deadlock",
          "context": [
            "\tstruct rt_mutex_waiter *prerequeue_top_waiter;",
            "\tint ret = 0, depth = 0;",
            "\tstruct rt_mutex_base *lock;",
            "\tbool detect_deadlock;",
            "\tbool requeue = true;",
            "",
            "\tdetect_deadlock = rt_mutex_cond_detect_deadlock(orig_waiter, chwalk);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 692,
          "match": "deadlock",
          "context": [
            "\tbool detect_deadlock;",
            "\tbool requeue = true;",
            "",
            "\tdetect_deadlock = rt_mutex_cond_detect_deadlock(orig_waiter, chwalk);",
            "",
            "\t/*",
            "\t * The (de)boosting is a step by step approach with a lot of"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 692,
          "match": "deadlock",
          "context": [
            "\tbool detect_deadlock;",
            "\tbool requeue = true;",
            "",
            "\tdetect_deadlock = rt_mutex_cond_detect_deadlock(orig_waiter, chwalk);",
            "",
            "\t/*",
            "\t * The (de)boosting is a step by step approach with a lot of"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 780,
          "match": "deadlock",
          "context": [
            "\t *",
            "\t * P3 should not return -EDEADLK because it gets trapped in the cycle",
            "\t * created by P1 and P2 (which will resolve -- and runs into",
            "\t * max_lock_depth above). Therefore disable detect_deadlock such that",
            "\t * the below termination condition can trigger once all relevant tasks",
            "\t * are boosted.",
            "\t *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 784,
          "match": "deadlock",
          "context": [
            "\t * the below termination condition can trigger once all relevant tasks",
            "\t * are boosted.",
            "\t *",
            "\t * Even when we start with ww_mutex we can disable deadlock detection,",
            "\t * since we would supress a ww_mutex induced deadlock at [6] anyway.",
            "\t * Supressing it here however is not sufficient since we might still",
            "\t * hit [6] due to adjustment driven iteration."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 785,
          "match": "deadlock",
          "context": [
            "\t * are boosted.",
            "\t *",
            "\t * Even when we start with ww_mutex we can disable deadlock detection,",
            "\t * since we would supress a ww_mutex induced deadlock at [6] anyway.",
            "\t * Supressing it here however is not sufficient since we might still",
            "\t * hit [6] due to adjustment driven iteration.",
            "\t *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 789,
          "match": "deadlock",
          "context": [
            "\t * Supressing it here however is not sufficient since we might still",
            "\t * hit [6] due to adjustment driven iteration.",
            "\t *",
            "\t * NOTE: if someone were to create a deadlock between 2 ww_classes we'd",
            "\t * utterly fail to report it; lockdep should.",
            "\t */",
            "\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && waiter->ww_ctx && detect_deadlock)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 792,
          "match": "deadlock",
          "context": [
            "\t * NOTE: if someone were to create a deadlock between 2 ww_classes we'd",
            "\t * utterly fail to report it; lockdep should.",
            "\t */",
            "\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && waiter->ww_ctx && detect_deadlock)",
            "\t\tdetect_deadlock = false;",
            "",
            "\t/*"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 793,
          "match": "deadlock",
          "context": [
            "\t * utterly fail to report it; lockdep should.",
            "\t */",
            "\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && waiter->ww_ctx && detect_deadlock)",
            "\t\tdetect_deadlock = false;",
            "",
            "\t/*",
            "\t * Drop out, when the task has no waiters. Note,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 804,
          "match": "deadlock",
          "context": [
            "\t\tif (!task_has_pi_waiters(task))",
            "\t\t\tgoto out_unlock_pi;",
            "\t\t/*",
            "\t\t * If deadlock detection is off, we stop here if we",
            "\t\t * are not the top pi waiter of the task. If deadlock",
            "\t\t * detection is enabled we continue, but stop the",
            "\t\t * requeueing in the chain walk."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 805,
          "match": "deadlock",
          "context": [
            "\t\t\tgoto out_unlock_pi;",
            "\t\t/*",
            "\t\t * If deadlock detection is off, we stop here if we",
            "\t\t * are not the top pi waiter of the task. If deadlock",
            "\t\t * detection is enabled we continue, but stop the",
            "\t\t * requeueing in the chain walk.",
            "\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 810,
          "match": "deadlock",
          "context": [
            "\t\t * requeueing in the chain walk.",
            "\t\t */",
            "\t\tif (top_waiter != task_top_pi_waiter(task)) {",
            "\t\t\tif (!detect_deadlock)",
            "\t\t\t\tgoto out_unlock_pi;",
            "\t\t\telse",
            "\t\t\t\trequeue = false;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 820,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * If the waiter priority is the same as the task priority",
            "\t * then there is no further priority adjustment necessary.  If",
            "\t * deadlock detection is off, we stop the chain walk. If its",
            "\t * enabled we continue, but stop the requeueing in the chain",
            "\t * walk.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 825,
          "match": "deadlock",
          "context": [
            "\t * walk.",
            "\t */",
            "\tif (rt_waiter_node_equal(&waiter->tree, task_to_waiter_node(task))) {",
            "\t\tif (!detect_deadlock)",
            "\t\t\tgoto out_unlock_pi;",
            "\t\telse",
            "\t\t\trequeue = false;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 855,
          "match": "Deadlock",
          "context": [
            "\t * [6] check_exit_conditions_2() protected by task->pi_lock and",
            "\t * lock->wait_lock.",
            "\t *",
            "\t * Deadlock detection. If the lock is the same as the original",
            "\t * lock which caused us to walk the lock chain or if the",
            "\t * current lock is owned by the task which initiated the chain",
            "\t * walk, we detected a deadlock."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 858,
          "match": "deadlock",
          "context": [
            "\t * Deadlock detection. If the lock is the same as the original",
            "\t * lock which caused us to walk the lock chain or if the",
            "\t * current lock is owned by the task which initiated the chain",
            "\t * walk, we detected a deadlock.",
            "\t */",
            "\tif (lock == orig_lock || rt_mutex_owner(lock) == top_task) {",
            "\t\tret = -EDEADLK;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 864,
          "match": "deadlock",
          "context": [
            "\t\tret = -EDEADLK;",
            "",
            "\t\t/*",
            "\t\t * When the deadlock is due to ww_mutex; also see above. Don't",
            "\t\t * report the deadlock and instead let the ww_mutex wound/die",
            "\t\t * logic pick which of the contending threads gets -EDEADLK.",
            "\t\t *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 865,
          "match": "deadlock",
          "context": [
            "",
            "\t\t/*",
            "\t\t * When the deadlock is due to ww_mutex; also see above. Don't",
            "\t\t * report the deadlock and instead let the ww_mutex wound/die",
            "\t\t * logic pick which of the contending threads gets -EDEADLK.",
            "\t\t *",
            "\t\t * NOTE: assumes the cycle only contains a single ww_class; any"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 880,
          "match": "deadlock",
          "context": [
            "\t}",
            "",
            "\t/*",
            "\t * If we just follow the lock chain for deadlock detection, no",
            "\t * need to do all the requeue operations. To avoid a truckload",
            "\t * of conditionals around the various places below, just do the",
            "\t * minimum chain walk checks."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 906,
          "match": "deadlock",
          "context": [
            "\t\traw_spin_lock(&task->pi_lock);",
            "",
            "\t\t/*",
            "\t\t * No requeue [11] here. We just do deadlock detection.",
            "\t\t *",
            "\t\t * [12] Store whether owner is blocked",
            "\t\t * itself. Decision is made after dropping the locks"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 1061,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * If the current waiter is not the top waiter on the lock,",
            "\t * then we can stop the chain walk here if we are not in full",
            "\t * deadlock detection mode.",
            "\t */",
            "\tif (!detect_deadlock && waiter != top_waiter)",
            "\t\tgoto out_put_task;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 1063,
          "match": "deadlock",
          "context": [
            "\t * then we can stop the chain walk here if we are not in full",
            "\t * deadlock detection mode.",
            "\t */",
            "\tif (!detect_deadlock && waiter != top_waiter)",
            "\t\tgoto out_put_task;",
            "",
            "\tgoto again;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 1218,
          "match": "deadlock",
          "context": [
            "\tlockdep_assert_held(&lock->wait_lock);",
            "",
            "\t/*",
            "\t * Early deadlock detection. We really don't want the task to",
            "\t * enqueue on itself just to untangle the mess later. It's not",
            "\t * only an optimization. We drop the locks, so another waiter",
            "\t * can come in before the chain walk detects the deadlock. So"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 1221,
          "match": "deadlock",
          "context": [
            "\t * Early deadlock detection. We really don't want the task to",
            "\t * enqueue on itself just to untangle the mess later. It's not",
            "\t * only an optimization. We drop the locks, so another waiter",
            "\t * can come in before the chain walk detects the deadlock. So",
            "\t * the other will detect the deadlock and return -EDEADLOCK,",
            "\t * which is wrong, as the other waiter is not in a deadlock",
            "\t * situation."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 1222,
          "match": "deadlock",
          "context": [
            "\t * enqueue on itself just to untangle the mess later. It's not",
            "\t * only an optimization. We drop the locks, so another waiter",
            "\t * can come in before the chain walk detects the deadlock. So",
            "\t * the other will detect the deadlock and return -EDEADLOCK,",
            "\t * which is wrong, as the other waiter is not in a deadlock",
            "\t * situation.",
            "\t *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 1222,
          "match": "DEADLOCK",
          "context": [
            "\t * enqueue on itself just to untangle the mess later. It's not",
            "\t * only an optimization. We drop the locks, so another waiter",
            "\t * can come in before the chain walk detects the deadlock. So",
            "\t * the other will detect the deadlock and return -EDEADLOCK,",
            "\t * which is wrong, as the other waiter is not in a deadlock",
            "\t * situation.",
            "\t *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 1223,
          "match": "deadlock",
          "context": [
            "\t * only an optimization. We drop the locks, so another waiter",
            "\t * can come in before the chain walk detects the deadlock. So",
            "\t * the other will detect the deadlock and return -EDEADLOCK,",
            "\t * which is wrong, as the other waiter is not in a deadlock",
            "\t * situation.",
            "\t *",
            "\t * Except for ww_mutex, in that case the chain walk must already deal"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 1273,
          "match": "deadlock",
          "context": [
            "\t\trt_mutex_adjust_prio(lock, owner);",
            "\t\tif (owner->pi_blocked_on)",
            "\t\t\tchain_walk = 1;",
            "\t} else if (rt_mutex_cond_detect_deadlock(waiter, chwalk)) {",
            "\t\tchain_walk = 1;",
            "\t}",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 1282,
          "match": "deadlock",
          "context": [
            "",
            "\traw_spin_unlock(&owner->pi_lock);",
            "\t/*",
            "\t * Even if full deadlock detection is on, if the owner is not",
            "\t * blocked itself, we can avoid finding this out in the chain",
            "\t * walk.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 1658,
          "match": "deadlock",
          "context": [
            "\treturn ret;",
            "}",
            "",
            "static void __sched rt_mutex_handle_deadlock(int res, int detect_deadlock,",
            "\t\t\t\t\t     struct rt_mutex_base *lock,",
            "\t\t\t\t\t     struct rt_mutex_waiter *w)",
            "{"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 1658,
          "match": "deadlock",
          "context": [
            "\treturn ret;",
            "}",
            "",
            "static void __sched rt_mutex_handle_deadlock(int res, int detect_deadlock,",
            "\t\t\t\t\t     struct rt_mutex_base *lock,",
            "\t\t\t\t\t     struct rt_mutex_waiter *w)",
            "{"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 1663,
          "match": "DEADLOCK",
          "context": [
            "\t\t\t\t\t     struct rt_mutex_waiter *w)",
            "{",
            "\t/*",
            "\t * If the result is not -EDEADLOCK or the caller requested",
            "\t * deadlock detection, nothing to do here.",
            "\t */",
            "\tif (res != -EDEADLOCK || detect_deadlock)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 1664,
          "match": "deadlock",
          "context": [
            "{",
            "\t/*",
            "\t * If the result is not -EDEADLOCK or the caller requested",
            "\t * deadlock detection, nothing to do here.",
            "\t */",
            "\tif (res != -EDEADLOCK || detect_deadlock)",
            "\t\treturn;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 1666,
          "match": "DEADLOCK",
          "context": [
            "\t * If the result is not -EDEADLOCK or the caller requested",
            "\t * deadlock detection, nothing to do here.",
            "\t */",
            "\tif (res != -EDEADLOCK || detect_deadlock)",
            "\t\treturn;",
            "",
            "\tif (build_ww_mutex() && w->ww_ctx)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 1666,
          "match": "deadlock",
          "context": [
            "\t * If the result is not -EDEADLOCK or the caller requested",
            "\t * deadlock detection, nothing to do here.",
            "\t */",
            "\tif (res != -EDEADLOCK || detect_deadlock)",
            "\t\treturn;",
            "",
            "\tif (build_ww_mutex() && w->ww_ctx)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 1674,
          "match": "deadlock",
          "context": [
            "",
            "\traw_spin_unlock_irq(&lock->wait_lock);",
            "",
            "\tWARN(1, \"rtmutex deadlock detected\\n\");",
            "",
            "\twhile (1) {",
            "\t\tset_current_state(TASK_INTERRUPTIBLE);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 1734,
          "match": "deadlock",
          "context": [
            "\t} else {",
            "\t\t__set_current_state(TASK_RUNNING);",
            "\t\tremove_waiter(lock, waiter);",
            "\t\trt_mutex_handle_deadlock(ret, chwalk, lock, waiter);",
            "\t\tlockevent_inc(rtmutex_deadlock);",
            "\t}",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\rtmutex.c",
          "line": 1735,
          "match": "deadlock",
          "context": [
            "\t\t__set_current_state(TASK_RUNNING);",
            "\t\tremove_waiter(lock, waiter);",
            "\t\trt_mutex_handle_deadlock(ret, chwalk, lock, waiter);",
            "\t\tlockevent_inc(rtmutex_deadlock);",
            "\t}",
            "",
            "\t/*"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\rtmutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\test-ww_mutex.c",
          "line": 22,
          "match": "deadlock",
          "context": [
            "#ifdef CONFIG_DEBUG_WW_MUTEX_SLOWPATH",
            "#define ww_acquire_init_noinject(a, b) do { \\",
            "\t\tww_acquire_init((a), (b)); \\",
            "\t\t(a)->deadlock_inject_countdown = ~0U; \\",
            "\t} while (0)",
            "#else",
            "#define ww_acquire_init_noinject(a, b) ww_acquire_init((a), (b))"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\test-ww_mutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\test-ww_mutex.c",
          "line": 163,
          "match": "deadlock",
          "context": [
            "",
            "\tret = ww_mutex_lock(&mutex, &ctx);",
            "\tif (ret != -EALREADY) {",
            "\t\tpr_err(\"%s: missed deadlock for recursing, ret=%d from %s\\n\",",
            "\t\t       __func__, ret, from);",
            "\t\tif (!ret)",
            "\t\t\tww_mutex_unlock(&mutex);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\test-ww_mutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\test-ww_mutex.c",
          "line": 265,
          "match": "deadlock",
          "context": [
            "\tret = 0;",
            "\tif (resolve) {",
            "\t\tif (err || abba.result) {",
            "\t\t\tpr_err(\"%s: failed to resolve ABBA deadlock, A err=%d, B err=%d\\n\",",
            "\t\t\t       __func__, err, abba.result);",
            "\t\t\tret = -EINVAL;",
            "\t\t}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\test-ww_mutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\test-ww_mutex.c",
          "line": 271,
          "match": "deadlock",
          "context": [
            "\t\t}",
            "\t} else {",
            "\t\tif (err != -EDEADLK && abba.result != -EDEADLK) {",
            "\t\t\tpr_err(\"%s: missed ABBA deadlock, A err=%d, B err=%d\\n\",",
            "\t\t\t       __func__, err, abba.result);",
            "\t\t\tret = -EINVAL;",
            "\t\t}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\test-ww_mutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\test-ww_mutex.c",
          "line": 358,
          "match": "deadlock",
          "context": [
            "\t\tif (!cycle->result)",
            "\t\t\tcontinue;",
            "",
            "\t\tpr_err(\"cyclic deadlock not resolved, ret[%d/%d] = %d\\n\",",
            "\t\t       n, nthreads, cycle->result);",
            "\t\tret = -EINVAL;",
            "\t\tbreak;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\test-ww_mutex.c"
          ]
        },
        {
          "file": "linux\\kernel\\module\\kallsyms.c",
          "line": 319,
          "match": "deadlock",
          "context": [
            "",
            "/*",
            " * For kallsyms to ask for address resolution.  NULL means not found.  Careful",
            " * not to lock to avoid deadlock on oopses, RCU is enough.",
            " */",
            "int module_address_lookup(unsigned long addr,",
            "\t\t\t  unsigned long *size,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\module\\kallsyms.c"
          ]
        },
        {
          "file": "linux\\kernel\\module\\kmod.c",
          "line": 141,
          "match": "deadlock",
          "context": [
            "\t * We don't allow synchronous module loading from async.  Module",
            "\t * init may invoke async_synchronize_full() which will end up",
            "\t * waiting for this task which already is waiting for the module",
            "\t * loading to complete, leading to a deadlock.",
            "\t */",
            "\tWARN_ON_ONCE(wait && current_is_async());",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\module\\kmod.c"
          ]
        },
        {
          "file": "linux\\kernel\\module\\main.c",
          "line": 3035,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * We need to finish all async code before the module init sequence",
            "\t * is done. This has potential to deadlock if synchronous module",
            "\t * loading is requested from async (which is not allowed!).",
            "\t *",
            "\t * See commit 0fdff3ec6d87 (\"async, kmod: warn on synchronous"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\module\\main.c"
          ]
        },
        {
          "file": "linux\\kernel\\module\\stats.c",
          "line": 60,
          "match": "deadlock",
          "context": [
            " * failures.",
            " *",
            " * All counters are designed to be incremental. Atomic counters are used so to",
            " * remain simple and avoid delays and deadlocks.",
            " */",
            "",
            "/**"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\module\\stats.c"
          ]
        },
        {
          "file": "linux\\kernel\\power\\autosleep.c",
          "line": 19,
          "match": "deadlock",
          "context": [
            "static struct workqueue_struct *autosleep_wq;",
            "/*",
            " * Note: it is only safe to mutex_lock(&autosleep_lock) if a wakeup_source",
            " * is active, otherwise a deadlock with try_to_suspend() is possible.",
            " * Alternatively mutex_lock_interruptible() can be used.  This will then fail",
            " * if an auto_sleep cycle tries to freeze processes.",
            " */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\power\\autosleep.c"
          ]
        },
        {
          "file": "linux\\kernel\\power\\user.c",
          "line": 341,
          "match": "deadlock",
          "context": [
            "\t\t * SNAPSHOT_FREE.  In that case, if kernel threads were not",
            "\t\t * thawed, the preallocation of memory carried out by",
            "\t\t * hibernation_snapshot() might run into problems (i.e. it",
            "\t\t * might fail or even deadlock).",
            "\t\t */",
            "\t\tthaw_kernel_threads();",
            "\t\tbreak;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\power\\user.c"
          ]
        },
        {
          "file": "linux\\kernel\\printk\\nbcon.c",
          "line": 1537,
          "match": "deadlock",
          "context": [
            "\t * Atomic flushing does not use console driver synchronization (i.e.",
            "\t * it does not hold the port lock for uart consoles). Therefore IRQs",
            "\t * must be disabled to avoid being interrupted and then calling into",
            "\t * a driver that will deadlock trying to acquire console ownership.",
            "\t */",
            "\tlocal_irq_save(flags);",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\printk\\nbcon.c"
          ]
        },
        {
          "file": "linux\\kernel\\printk\\nbcon.c",
          "line": 1550,
          "match": "deadlock",
          "context": [
            "\t * responsible for completing.",
            "\t *",
            "\t * Do not wait for records not yet finalized (-ENOENT) to avoid a",
            "\t * possible deadlock. They will either get flushed by the writer or",
            "\t * eventually skipped on panic CPU.",
            "\t */",
            "\tif (err)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\printk\\nbcon.c"
          ]
        },
        {
          "file": "linux\\kernel\\printk\\printk.c",
          "line": 323,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * Here and in __up_console_sem() we need to be in safe mode,",
            "\t * because spindump/WARN/etc from under console ->lock will",
            "\t * deadlock in printk()->down_trylock_console_sem() otherwise.",
            "\t */",
            "\tprintk_safe_enter_irqsave(flags);",
            "\tlock_failed = down_trylock(&console_sem);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\printk\\printk.c"
          ]
        },
        {
          "file": "linux\\kernel\\printk\\printk.c",
          "line": 1911,
          "match": "deadlock",
          "context": [
            "\t * Non-panic CPUs abandon the flush anyway.",
            "\t *",
            "\t * Just keep the lockdep annotation. The panic-CPU should avoid",
            "\t * taking console_owner_lock because it might cause a deadlock.",
            "\t * This looks like the easiest way how to prevent false lockdep",
            "\t * reports without handling races a lockless way.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\printk\\printk.c"
          ]
        },
        {
          "file": "linux\\kernel\\printk\\printk.c",
          "line": 3388,
          "match": "deadlock",
          "context": [
            "\t\t\treturn;",
            "",
            "\t\t/*",
            "\t\t * Attempting to trylock the console lock can deadlock",
            "\t\t * if another CPU was stopped while modifying the",
            "\t\t * semaphore. \"Hope and pray\" that this is not the",
            "\t\t * current situation."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\printk\\printk.c"
          ]
        },
        {
          "file": "linux\\kernel\\printk\\printk_safe.c",
          "line": 3,
          "match": "deadlock",
          "context": [
            "// SPDX-License-Identifier: GPL-2.0-or-later",
            "/*",
            " * printk_safe.c - Safe printk for printk-deadlock-prone contexts",
            " */",
            "",
            "#include <linux/preempt.h>"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\printk\\printk_safe.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\rcutorture.c",
          "line": 146,
          "match": "deadlock",
          "context": [
            "torture_param(int, test_boost_interval, 7, \"Interval between boost tests, seconds.\");",
            "torture_param(int, test_nmis, 0, \"End-test NMI tests, 0 to disable.\");",
            "torture_param(bool, test_no_idle_hz, true, \"Test support for tickless idle CPUs\");",
            "torture_param(int, test_srcu_lockdep, 0, \"Test specified SRCU deadlock scenario.\");",
            "torture_param(int, verbose, 1, \"Enable verbose debugging printk()s\");",
            "",
            "static char *torture_type = \"rcu\";"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\rcutorture.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\rcutorture.c",
          "line": 2664,
          "match": "deadlock",
          "context": [
            "\trcu_torture_enable_rt_throttle();",
            "\tmutex_unlock(&boost_mutex);",
            "",
            "\t/* This must be outside of the mutex, otherwise deadlock! */",
            "\ttorture_stop_kthread(rcu_torture_boost, t);",
            "\treturn 0;",
            "}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\rcutorture.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\rcutorture.c",
          "line": 3991,
          "match": "deadlock",
          "context": [
            "DEFINE_STATIC_SRCU(srcu9);",
            "",
            "static int srcu_lockdep_next(const char *f, const char *fl, const char *fs, const char *fu, int i,",
            "\t\t\t     int cyclelen, int deadlock)",
            "{",
            "\tint j = i + 1;",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\rcutorture.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\rcutorture.c",
          "line": 3996,
          "match": "deadlock",
          "context": [
            "\tint j = i + 1;",
            "",
            "\tif (j >= cyclelen)",
            "\t\tj = deadlock ? 0 : -1;",
            "\tif (j >= 0)",
            "\t\tpr_info(\"%s: %s(%d), %s(%d), %s(%d)\\n\", f, fl, i, fs, j, fu, i);",
            "\telse"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\rcutorture.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\rcutorture.c",
          "line": 4004,
          "match": "deadlock",
          "context": [
            "\treturn j;",
            "}",
            "",
            "// Test lockdep on SRCU-based deadlock scenarios.",
            "static void rcu_torture_init_srcu_lockdep(void)",
            "{",
            "\tint cyclelen;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\rcutorture.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\rcutorture.c",
          "line": 4008,
          "match": "deadlock",
          "context": [
            "static void rcu_torture_init_srcu_lockdep(void)",
            "{",
            "\tint cyclelen;",
            "\tint deadlock;",
            "\tbool err = false;",
            "\tint i;",
            "\tint j;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\rcutorture.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\rcutorture.c",
          "line": 4024,
          "match": "deadlock",
          "context": [
            "\tif (!test_srcu_lockdep)",
            "\t\treturn;",
            "",
            "\tdeadlock = test_srcu_lockdep / 1000;",
            "\ttesttype = (test_srcu_lockdep / 10) % 100;",
            "\tcyclelen = test_srcu_lockdep % 10;",
            "\tWARN_ON_ONCE(ARRAY_SIZE(muts) != ARRAY_SIZE(srcus));"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\rcutorture.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\rcutorture.c",
          "line": 4028,
          "match": "deadlock",
          "context": [
            "\ttesttype = (test_srcu_lockdep / 10) % 100;",
            "\tcyclelen = test_srcu_lockdep % 10;",
            "\tWARN_ON_ONCE(ARRAY_SIZE(muts) != ARRAY_SIZE(srcus));",
            "\tif (WARN_ONCE(deadlock != !!deadlock,",
            "\t\t      \"%s: test_srcu_lockdep=%d and deadlock digit %d must be zero or one.\\n\",",
            "\t\t      __func__, test_srcu_lockdep, deadlock))",
            "\t\terr = true;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\rcutorture.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\rcutorture.c",
          "line": 4028,
          "match": "deadlock",
          "context": [
            "\ttesttype = (test_srcu_lockdep / 10) % 100;",
            "\tcyclelen = test_srcu_lockdep % 10;",
            "\tWARN_ON_ONCE(ARRAY_SIZE(muts) != ARRAY_SIZE(srcus));",
            "\tif (WARN_ONCE(deadlock != !!deadlock,",
            "\t\t      \"%s: test_srcu_lockdep=%d and deadlock digit %d must be zero or one.\\n\",",
            "\t\t      __func__, test_srcu_lockdep, deadlock))",
            "\t\terr = true;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\rcutorture.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\rcutorture.c",
          "line": 4029,
          "match": "deadlock",
          "context": [
            "\tcyclelen = test_srcu_lockdep % 10;",
            "\tWARN_ON_ONCE(ARRAY_SIZE(muts) != ARRAY_SIZE(srcus));",
            "\tif (WARN_ONCE(deadlock != !!deadlock,",
            "\t\t      \"%s: test_srcu_lockdep=%d and deadlock digit %d must be zero or one.\\n\",",
            "\t\t      __func__, test_srcu_lockdep, deadlock))",
            "\t\terr = true;",
            "\tif (WARN_ONCE(cyclelen <= 0,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\rcutorture.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\rcutorture.c",
          "line": 4030,
          "match": "deadlock",
          "context": [
            "\tWARN_ON_ONCE(ARRAY_SIZE(muts) != ARRAY_SIZE(srcus));",
            "\tif (WARN_ONCE(deadlock != !!deadlock,",
            "\t\t      \"%s: test_srcu_lockdep=%d and deadlock digit %d must be zero or one.\\n\",",
            "\t\t      __func__, test_srcu_lockdep, deadlock))",
            "\t\terr = true;",
            "\tif (WARN_ONCE(cyclelen <= 0,",
            "\t\t      \"%s: test_srcu_lockdep=%d and cycle-length digit %d must be greater than zero.\\n\","
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\rcutorture.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\rcutorture.c",
          "line": 4040,
          "match": "deadlock",
          "context": [
            "\t\tgoto err_out;",
            "",
            "\tif (testtype == 0) {",
            "\t\tpr_info(\"%s: test_srcu_lockdep = %05d: SRCU %d-way %sdeadlock.\\n\",",
            "\t\t\t__func__, test_srcu_lockdep, cyclelen, deadlock ? \"\" : \"non-\");",
            "\t\tif (deadlock && cyclelen == 1)",
            "\t\t\tpr_info(\"%s: Expect hang.\\n\", __func__);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\rcutorture.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\rcutorture.c",
          "line": 4041,
          "match": "deadlock",
          "context": [
            "",
            "\tif (testtype == 0) {",
            "\t\tpr_info(\"%s: test_srcu_lockdep = %05d: SRCU %d-way %sdeadlock.\\n\",",
            "\t\t\t__func__, test_srcu_lockdep, cyclelen, deadlock ? \"\" : \"non-\");",
            "\t\tif (deadlock && cyclelen == 1)",
            "\t\t\tpr_info(\"%s: Expect hang.\\n\", __func__);",
            "\t\tfor (i = 0; i < cyclelen; i++) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\rcutorture.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\rcutorture.c",
          "line": 4042,
          "match": "deadlock",
          "context": [
            "\tif (testtype == 0) {",
            "\t\tpr_info(\"%s: test_srcu_lockdep = %05d: SRCU %d-way %sdeadlock.\\n\",",
            "\t\t\t__func__, test_srcu_lockdep, cyclelen, deadlock ? \"\" : \"non-\");",
            "\t\tif (deadlock && cyclelen == 1)",
            "\t\t\tpr_info(\"%s: Expect hang.\\n\", __func__);",
            "\t\tfor (i = 0; i < cyclelen; i++) {",
            "\t\t\tj = srcu_lockdep_next(__func__, \"srcu_read_lock\", \"synchronize_srcu\","
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\rcutorture.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\rcutorture.c",
          "line": 4046,
          "match": "deadlock",
          "context": [
            "\t\t\tpr_info(\"%s: Expect hang.\\n\", __func__);",
            "\t\tfor (i = 0; i < cyclelen; i++) {",
            "\t\t\tj = srcu_lockdep_next(__func__, \"srcu_read_lock\", \"synchronize_srcu\",",
            "\t\t\t\t\t      \"srcu_read_unlock\", i, cyclelen, deadlock);",
            "\t\t\tidx = srcu_read_lock(srcus[i]);",
            "\t\t\tif (j >= 0)",
            "\t\t\t\tsynchronize_srcu(srcus[j]);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\rcutorture.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\rcutorture.c",
          "line": 4056,
          "match": "deadlock",
          "context": [
            "\t}",
            "",
            "\tif (testtype == 1) {",
            "\t\tpr_info(\"%s: test_srcu_lockdep = %05d: SRCU/mutex %d-way %sdeadlock.\\n\",",
            "\t\t\t__func__, test_srcu_lockdep, cyclelen, deadlock ? \"\" : \"non-\");",
            "\t\tfor (i = 0; i < cyclelen; i++) {",
            "\t\t\tpr_info(\"%s: srcu_read_lock(%d), mutex_lock(%d), mutex_unlock(%d), srcu_read_unlock(%d)\\n\","
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\rcutorture.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\rcutorture.c",
          "line": 4057,
          "match": "deadlock",
          "context": [
            "",
            "\tif (testtype == 1) {",
            "\t\tpr_info(\"%s: test_srcu_lockdep = %05d: SRCU/mutex %d-way %sdeadlock.\\n\",",
            "\t\t\t__func__, test_srcu_lockdep, cyclelen, deadlock ? \"\" : \"non-\");",
            "\t\tfor (i = 0; i < cyclelen; i++) {",
            "\t\t\tpr_info(\"%s: srcu_read_lock(%d), mutex_lock(%d), mutex_unlock(%d), srcu_read_unlock(%d)\\n\",",
            "\t\t\t\t__func__, i, i, i, i);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\rcutorture.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\rcutorture.c",
          "line": 4067,
          "match": "deadlock",
          "context": [
            "\t\t\tsrcu_read_unlock(srcus[i], idx);",
            "",
            "\t\t\tj = srcu_lockdep_next(__func__, \"mutex_lock\", \"synchronize_srcu\",",
            "\t\t\t\t\t      \"mutex_unlock\", i, cyclelen, deadlock);",
            "\t\t\tmutex_lock(muts[i]);",
            "\t\t\tif (j >= 0)",
            "\t\t\t\tsynchronize_srcu(srcus[j]);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\rcutorture.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\rcutorture.c",
          "line": 4077,
          "match": "deadlock",
          "context": [
            "\t}",
            "",
            "\tif (testtype == 2) {",
            "\t\tpr_info(\"%s: test_srcu_lockdep = %05d: SRCU/rwsem %d-way %sdeadlock.\\n\",",
            "\t\t\t__func__, test_srcu_lockdep, cyclelen, deadlock ? \"\" : \"non-\");",
            "\t\tfor (i = 0; i < cyclelen; i++) {",
            "\t\t\tpr_info(\"%s: srcu_read_lock(%d), down_read(%d), up_read(%d), srcu_read_unlock(%d)\\n\","
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\rcutorture.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\rcutorture.c",
          "line": 4078,
          "match": "deadlock",
          "context": [
            "",
            "\tif (testtype == 2) {",
            "\t\tpr_info(\"%s: test_srcu_lockdep = %05d: SRCU/rwsem %d-way %sdeadlock.\\n\",",
            "\t\t\t__func__, test_srcu_lockdep, cyclelen, deadlock ? \"\" : \"non-\");",
            "\t\tfor (i = 0; i < cyclelen; i++) {",
            "\t\t\tpr_info(\"%s: srcu_read_lock(%d), down_read(%d), up_read(%d), srcu_read_unlock(%d)\\n\",",
            "\t\t\t\t__func__, i, i, i, i);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\rcutorture.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\rcutorture.c",
          "line": 4088,
          "match": "deadlock",
          "context": [
            "\t\t\tsrcu_read_unlock(srcus[i], idx);",
            "",
            "\t\t\tj = srcu_lockdep_next(__func__, \"down_write\", \"synchronize_srcu\",",
            "\t\t\t\t\t      \"up_write\", i, cyclelen, deadlock);",
            "\t\t\tdown_write(rwsems[i]);",
            "\t\t\tif (j >= 0)",
            "\t\t\t\tsynchronize_srcu(srcus[j]);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\rcutorture.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\rcutorture.c",
          "line": 4099,
          "match": "deadlock",
          "context": [
            "",
            "#ifdef CONFIG_TASKS_TRACE_RCU",
            "\tif (testtype == 3) {",
            "\t\tpr_info(\"%s: test_srcu_lockdep = %05d: SRCU and Tasks Trace RCU %d-way %sdeadlock.\\n\",",
            "\t\t\t__func__, test_srcu_lockdep, cyclelen, deadlock ? \"\" : \"non-\");",
            "\t\tif (deadlock && cyclelen == 1)",
            "\t\t\tpr_info(\"%s: Expect hang.\\n\", __func__);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\rcutorture.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\rcutorture.c",
          "line": 4100,
          "match": "deadlock",
          "context": [
            "#ifdef CONFIG_TASKS_TRACE_RCU",
            "\tif (testtype == 3) {",
            "\t\tpr_info(\"%s: test_srcu_lockdep = %05d: SRCU and Tasks Trace RCU %d-way %sdeadlock.\\n\",",
            "\t\t\t__func__, test_srcu_lockdep, cyclelen, deadlock ? \"\" : \"non-\");",
            "\t\tif (deadlock && cyclelen == 1)",
            "\t\t\tpr_info(\"%s: Expect hang.\\n\", __func__);",
            "\t\tfor (i = 0; i < cyclelen; i++) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\rcutorture.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\rcutorture.c",
          "line": 4101,
          "match": "deadlock",
          "context": [
            "\tif (testtype == 3) {",
            "\t\tpr_info(\"%s: test_srcu_lockdep = %05d: SRCU and Tasks Trace RCU %d-way %sdeadlock.\\n\",",
            "\t\t\t__func__, test_srcu_lockdep, cyclelen, deadlock ? \"\" : \"non-\");",
            "\t\tif (deadlock && cyclelen == 1)",
            "\t\t\tpr_info(\"%s: Expect hang.\\n\", __func__);",
            "\t\tfor (i = 0; i < cyclelen; i++) {",
            "\t\t\tchar *fl = i == 0 ? \"rcu_read_lock_trace\" : \"srcu_read_lock\";"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\rcutorture.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\rcutorture.c",
          "line": 4109,
          "match": "deadlock",
          "context": [
            "\t\t\t\t\t\t     : \"synchronize_srcu\";",
            "\t\t\tchar *fu = i == 0 ? \"rcu_read_unlock_trace\" : \"srcu_read_unlock\";",
            "",
            "\t\t\tj = srcu_lockdep_next(__func__, fl, fs, fu, i, cyclelen, deadlock);",
            "\t\t\tif (i == 0)",
            "\t\t\t\trcu_read_lock_trace();",
            "\t\t\telse"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\rcutorture.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\rcutorture.c",
          "line": 4132,
          "match": "Deadlock",
          "context": [
            "err_out:",
            "\tpr_info(\"%s: test_srcu_lockdep = %05d does nothing.\\n\", __func__, test_srcu_lockdep);",
            "\tpr_info(\"%s: test_srcu_lockdep = DNNL.\\n\", __func__);",
            "\tpr_info(\"%s: D: Deadlock if nonzero.\\n\", __func__);",
            "\tpr_info(\"%s: NN: Test number, 0=SRCU, 1=SRCU/mutex, 2=SRCU/rwsem, 3=SRCU/Tasks Trace RCU.\\n\", __func__);",
            "\tpr_info(\"%s: L: Cycle length.\\n\", __func__);",
            "\tif (!IS_ENABLED(CONFIG_TASKS_TRACE_RCU))"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\rcutorture.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\srcutree.c",
          "line": 1462,
          "match": "deadlock",
          "context": [
            " * Wait for an SRCU grace period to elapse, but be more aggressive about",
            " * spinning rather than blocking when waiting.",
            " *",
            " * Note that synchronize_srcu_expedited() has the same deadlock and",
            " * memory-ordering properties as does synchronize_srcu().",
            " */",
            "void synchronize_srcu_expedited(struct srcu_struct *ssp)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\srcutree.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\srcutree.c",
          "line": 1484,
          "match": "deadlock",
          "context": [
            " * Can block; must be called from process context.",
            " *",
            " * Note that it is illegal to call synchronize_srcu() from the corresponding",
            " * SRCU read-side critical section; doing so will result in deadlock.",
            " * However, it is perfectly legal to call synchronize_srcu() on one",
            " * srcu_struct from some other srcu_struct's read-side critical section,",
            " * as long as the resulting graph of srcu_structs is acyclic."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\srcutree.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\tree.c",
          "line": 678,
          "match": "deadlock",
          "context": [
            "\t// from interrupts (as opposed to NMIs).  Therefore, (1) RCU is",
            "\t// already watching and (2) The fact that we are in an interrupt",
            "\t// handler and that the rcu_node lock is an irq-disabled lock",
            "\t// prevents self-deadlock.  So we can safely recheck under the lock.",
            "\t// Note that the nohz_full state currently cannot change.",
            "\traw_spin_lock_rcu_node(rdp->mynode);",
            "\tif (READ_ONCE(rdp->rcu_urgent_qs) && !rdp->rcu_forced_tick) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\tree.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\core.c",
          "line": 2247,
          "match": "deadlock",
          "context": [
            " *",
            " * The caller must ensure that the task *will* unschedule sometime soon,",
            " * else this function might spin for a *long* time. This function can't",
            " * be called with interrupts off, or it may introduce deadlock with",
            " * smp_call_function() if an IPI is sent by the same process we are",
            " * waiting to become inactive.",
            " */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\core.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\core.c",
          "line": 5213,
          "match": "deadlock",
          "context": [
            " *",
            " * Note that we may have delayed dropping an mm in context_switch(). If",
            " * so, we finish that here outside of the runqueue lock. (Doing it",
            " * with the lock held can cause deadlocks; see schedule() for",
            " * details.)",
            " *",
            " * The context switch have flipped the stack from under us and restored the"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\core.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\core.c",
          "line": 6833,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * spinlock and rwlock must not flush block requests.  This will",
            "\t * deadlock if the callback attempts to acquire a lock which is",
            "\t * already acquired.",
            "\t */",
            "\tWARN_ON_ONCE(current->__state & TASK_RTLOCK_WAIT);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\core.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\core.c",
          "line": 6840,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * If we are going to sleep and we have plugged IO queued,",
            "\t * make sure to submit it to avoid deadlocks.",
            "\t */",
            "\tblk_flush_plug(tsk->plug, true);",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\core.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\ext.c",
          "line": 2662,
          "match": "deadlock",
          "context": [
            " * dequeues and maintain the invariant that @p->scx.dsq can only change while",
            " * @src_rq is locked, which e.g. scx_dump_task() depends on.",
            " *",
            " * We want to grab @src_rq but that can deadlock if we try while locking @dsq,",
            " * so we want to unlink @p from @dsq, drop its lock and then lock @src_rq. As",
            " * this may race with dequeue, which can't drop the rq lock or fail, do a little",
            " * dancing from our side."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\ext.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\ext.c",
          "line": 7331,
          "match": "deadlock",
          "context": [
            "",
            "\t\t/*",
            "\t\t * When called with an rq lock held, restrict the operation",
            "\t\t * to the corresponding CPU to prevent ABBA deadlocks.",
            "\t\t */",
            "\t\tif (locked_rq && rq != locked_rq) {",
            "\t\t\tscx_kf_error(\"Invalid target CPU %d\", cpu);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\ext.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\psi.c",
          "line": 1457,
          "match": "deadlock",
          "context": [
            "\tsynchronize_rcu();",
            "\t/*",
            "\t * Stop kthread 'psimon' after releasing rtpoll_trigger_lock to prevent",
            "\t * a deadlock while waiting for psi_rtpoll_work to acquire",
            "\t * rtpoll_trigger_lock",
            "\t */",
            "\tif (task_to_destroy) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\psi.c"
          ]
        },
        {
          "file": "linux\\kernel\\time\\hrtimer.c",
          "line": 1966,
          "match": "deadlock",
          "context": [
            "\t * can switch to highres and / or nohz mode. The clocksource",
            "\t * switch happens with xtime_lock held. Notification from",
            "\t * there only sets the check bit in the tick_oneshot code,",
            "\t * otherwise we might deadlock vs. xtime_lock.",
            "\t */",
            "\tif (tick_check_oneshot_change(!hrtimer_is_hres_enabled())) {",
            "\t\thrtimer_switch_to_hres();"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\time\\hrtimer.c"
          ]
        },
        {
          "file": "linux\\kernel\\time\\hrtimer.c",
          "line": 2288,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * The caller is globally serialized and nobody else",
            "\t * takes two locks at once, deadlock is not possible.",
            "\t */",
            "\traw_spin_lock(&old_base->lock);",
            "\traw_spin_lock_nested(&new_base->lock, SINGLE_DEPTH_NESTING);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\time\\hrtimer.c"
          ]
        },
        {
          "file": "linux\\kernel\\time\\tick-broadcast.c",
          "line": 424,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * We run the handler of the local cpu after dropping",
            "\t * tick_broadcast_lock because the handler might deadlock when",
            "\t * trying to switch to oneshot mode.",
            "\t */",
            "\tif (bc_local)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\time\\tick-broadcast.c"
          ]
        },
        {
          "file": "linux\\kernel\\time\\timer.c",
          "line": 1608,
          "match": "deadlock",
          "context": [
            "#endif",
            "\t/*",
            "\t * don't use it in hardirq context, because it",
            "\t * could lead to deadlock.",
            "\t */",
            "\tWARN_ON(in_hardirq() && !(timer->flags & TIMER_IRQSAFE));",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\time\\timer.c"
          ]
        },
        {
          "file": "linux\\kernel\\time\\timer.c",
          "line": 2524,
          "match": "deadlock",
          "context": [
            "\t\tnew_base = get_cpu_ptr(&timer_bases[b]);",
            "\t\t/*",
            "\t\t * The caller is globally serialized and nobody else",
            "\t\t * takes two locks at once, deadlock is not possible.",
            "\t\t */",
            "\t\traw_spin_lock_irq(&new_base->lock);",
            "\t\traw_spin_lock_nested(&old_base->lock, SINGLE_DEPTH_NESTING);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\time\\timer.c"
          ]
        },
        {
          "file": "linux\\kernel\\trace\\ring_buffer.c",
          "line": 894,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * The events can happen in critical sections where",
            "\t * checking a work queue can cause deadlocks.",
            "\t * After adding a task to the queue, this flag is set",
            "\t * only to notify events to try to wake up the queue",
            "\t * using irq_work."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\trace\\ring_buffer.c"
          ]
        },
        {
          "file": "linux\\kernel\\trace\\ring_buffer.c",
          "line": 5699,
          "match": "deadlock",
          "context": [
            "",
            "\t/*",
            "\t * If an NMI die dumps out the content of the ring buffer",
            "\t * trylock must be used to prevent a deadlock if the NMI",
            "\t * preempted a task that holds the ring buffer locks. If",
            "\t * we get the lock then all is fine, if not, then continue",
            "\t * to do the read, but this can corrupt the ring buffer,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\trace\\ring_buffer.c"
          ]
        },
        {
          "file": "linux\\kernel\\trace\\trace.c",
          "line": 1985,
          "match": "deadlock",
          "context": [
            "\t/*",
            "\t * We cannot call queue_work(&tr->fsnotify_work) from here because it's",
            "\t * possible that we are called from __schedule() or do_idle(), which",
            "\t * could cause a deadlock.",
            "\t */",
            "\tirq_work_queue(&tr->fsnotify_irqwork);",
            "}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\trace\\trace.c"
          ]
        },
        {
          "file": "linux\\kernel\\trace\\trace_stack.c",
          "line": 174,
          "match": "deadlock",
          "context": [
            "\tif (!object_is_on_stack(stack))",
            "\t\treturn;",
            "",
            "\t/* Can't do this from NMI context (can cause deadlocks) */",
            "\tif (in_nmi())",
            "\t\treturn;",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\trace\\trace_stack.c"
          ]
        },
        {
          "file": "linux\\kernel\\debug\\kdb\\kdb_io.c",
          "line": 601,
          "match": "deadlock",
          "context": [
            "\t\t/*",
            "\t\t * Set oops_in_progress to encourage the console drivers to",
            "\t\t * disregard their internal spin locks: in the current calling",
            "\t\t * context the risk of deadlock is a bigger problem than risks",
            "\t\t * due to re-entering the console driver. We operate directly on",
            "\t\t * oops_in_progress rather than using bust_spinlocks() because",
            "\t\t * the calls bust_spinlocks() makes on exit are not appropriate"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\debug\\kdb\\kdb_io.c"
          ]
        },
        {
          "file": "linux\\net\\9p\\error.c",
          "line": 75,
          "match": "deadlock",
          "context": [
            "\t{\"Broken pipe\", EPIPE},",
            "\t{\"Numerical argument out of domain\", EDOM},",
            "\t{\"Numerical result out of range\", ERANGE},",
            "\t{\"Resource deadlock avoided\", EDEADLK},",
            "\t{\"File name too long\", ENAMETOOLONG},",
            "\t{\"No locks available\", ENOLCK},",
            "\t{\"Function not implemented\", ENOSYS},"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\9p\\error.c"
          ]
        },
        {
          "file": "linux\\net\\appletalk\\ddp.c",
          "line": 200,
          "match": "deadlock",
          "context": [
            "*                                                                          *",
            "\\**************************************************************************/",
            "",
            "/* Anti-deadlock ordering is atalk_routes_lock --> iface_lock -DaveM */",
            "struct atalk_route *atalk_routes;",
            "DEFINE_RWLOCK(atalk_routes_lock);",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\appletalk\\ddp.c"
          ]
        },
        {
          "file": "linux\\net\\bluetooth\\hci_core.c",
          "line": 3249,
          "match": "deadlock",
          "context": [
            "\t\t/* Queue all fragments atomically. We need to use spin_lock_bh",
            "\t\t * here because of 6LoWPAN links, as there this function is",
            "\t\t * called from softirq and using normal spin lock could cause",
            "\t\t * deadlocks.",
            "\t\t */",
            "\t\tspin_lock_bh(&queue->lock);",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\bluetooth\\hci_core.c"
          ]
        },
        {
          "file": "linux\\net\\bluetooth\\iso.c",
          "line": 1216,
          "match": "deadlock",
          "context": [
            "\t\terr = iso_listen_cis(sk);",
            "\t} else {",
            "\t\t/* Drop sock lock to avoid potential",
            "\t\t * deadlock with the hdev lock.",
            "\t\t */",
            "\t\trelease_sock(sk);",
            "\t\terr = iso_listen_bis(sk);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\bluetooth\\iso.c"
          ]
        },
        {
          "file": "linux\\net\\bridge\\br_multicast.c",
          "line": 4694,
          "match": "deadlock",
          "context": [
            "\t * an MLD Report/Leave to be delivered to br_multicast_rcv,",
            "\t * which would in turn call br_multicast_add_group, which would",
            "\t * attempt to acquire multicast_lock. This function should be",
            "\t * called after the lock has been released to avoid deadlocks on",
            "\t * multicast_lock.",
            "\t *",
            "\t * br_multicast_leave_snoopers does not have the problem since"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\bridge\\br_multicast.c"
          ]
        },
        {
          "file": "linux\\net\\ceph\\messenger.c",
          "line": 1399,
          "match": "deadlock",
          "context": [
            "/*",
            " * Process message.  This happens in the worker thread.  The callback should",
            " * be careful not to do anything that waits on other incoming messages or it",
            " * may deadlock.",
            " */",
            "void ceph_con_process_message(struct ceph_connection *con)",
            "{"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\ceph\\messenger.c"
          ]
        },
        {
          "file": "linux\\net\\core\\dev.c",
          "line": 4609,
          "match": "deadlock",
          "context": [
            " * this function. The function can be called from an interrupt.",
            " *",
            " * When calling this method, interrupts MUST be enabled. This is because",
            " * the BH enable code must have IRQs enabled so that it will not deadlock.",
            " *",
            " * Regardless of the return value, the skb is consumed, so it is currently",
            " * difficult to retry a send to this method. (You can bump the ref count"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\core\\dev.c"
          ]
        },
        {
          "file": "linux\\net\\core\\dev.c",
          "line": 4692,
          "match": "deadlock",
          "context": [
            "\t * However, it is possible, that they rely on protection",
            "\t * made by us here.",
            "",
            "\t * Check this and shot the lock. It is not prone from deadlocks.",
            "\t *Either shot noqueue qdisc, it is even simpler 8)",
            "\t */",
            "\tif (dev->flags & IFF_UP) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\core\\dev.c"
          ]
        },
        {
          "file": "linux\\net\\core\\dev.c",
          "line": 11344,
          "match": "deadlock",
          "context": [
            " * We are invoked by rtnl_unlock().",
            " * This allows us to deal with problems:",
            " * 1) We can delete sysfs objects which invoke hotplug",
            " *    without deadlocking with linkwatch via keventd.",
            " * 2) Since we run with the RTNL semaphore not held, we can sleep",
            " *    safely in order to wait for the netdev refcnt to drop to zero.",
            " *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\core\\dev.c"
          ]
        },
        {
          "file": "linux\\net\\core\\neighbour.c",
          "line": 88,
          "match": "deadlock",
          "context": [
            "   - All the scans/updates to hash buckets MUST be made under this lock.",
            "   - NOTHING clever should be made under this lock: no callbacks",
            "     to protocol backends, no attempts to send something to network.",
            "     It will result in deadlocks, if backend/driver wants to use neighbour",
            "     cache.",
            "   - If the entry requires some non-trivial actions, increase",
            "     its reference count and release table lock."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\core\\neighbour.c"
          ]
        },
        {
          "file": "linux\\net\\core\\net-sysfs.c",
          "line": 46,
          "match": "deadlock",
          "context": [
            "\treturn READ_ONCE(dev->reg_state) <= NETREG_REGISTERED;",
            "}",
            "",
            "/* There is a possible ABBA deadlock between rtnl_lock and kernfs_node->active,",
            " * when unregistering a net device and accessing associated sysfs files. The",
            " * potential deadlock is as follow:",
            " *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\core\\net-sysfs.c"
          ]
        },
        {
          "file": "linux\\net\\core\\net-sysfs.c",
          "line": 48,
          "match": "deadlock",
          "context": [
            "",
            "/* There is a possible ABBA deadlock between rtnl_lock and kernfs_node->active,",
            " * when unregistering a net device and accessing associated sysfs files. The",
            " * potential deadlock is as follow:",
            " *",
            " *         CPU 0                                         CPU 1",
            " *"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\core\\net-sysfs.c"
          ]
        },
        {
          "file": "linux\\net\\core\\net-sysfs.c",
          "line": 98,
          "match": "deadlock",
          "context": [
            "\t * (outside an rtnl lock section).",
            "\t */",
            "\tkn = sysfs_break_active_protection(kobj, attr);",
            "\t/* We can now try to take the rtnl lock. This can't deadlock us as the",
            "\t * unregistration path is able to drain sysfs files (kernfs_node) thanks",
            "\t * to the above dance.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\core\\net-sysfs.c"
          ]
        },
        {
          "file": "linux\\net\\core\\rtnetlink.c",
          "line": 136,
          "match": "DEADLOCK",
          "context": [
            "\t *     while (!list_empty(...))",
            "\t *       rtnl_lock()",
            "\t *\t\t\t\t  wiphy_lock()",
            "\t * **** DEADLOCK ****",
            "\t *",
            "\t * However, usage of __rtnl_unlock() is rare, and so we can ensure that",
            "\t * it's not used in cases where something is added to do the list."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\core\\rtnetlink.c"
          ]
        },
        {
          "file": "linux\\net\\devlink\\core.c",
          "line": 183,
          "match": "deadlock",
          "context": [
            " * taken during the notification preparation.",
            " * However, since the devlink lock of nested instance is held here,",
            " * we would end with wrong devlink instance lock ordering and",
            " * deadlock. Therefore the work is utilized to avoid that.",
            " */",
            "void devlink_rel_nested_in_notify(struct devlink *devlink)",
            "{"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\devlink\\core.c"
          ]
        },
        {
          "file": "linux\\net\\ipv4\\inet_connection_sock.c",
          "line": 259,
          "match": "deadlock",
          "context": [
            "\t/* Conflicts with an existing IPV6_ADDR_ANY (if ipv6) or INADDR_ANY (if",
            "\t * ipv4) should have been checked already. We need to do these two",
            "\t * checks separately because their spinlocks have to be acquired/released",
            "\t * independently of each other, to prevent possible deadlocks",
            "\t */",
            "\tif (inet_use_bhash2_on_bind(sk))",
            "\t\treturn tb2 && inet_bhash2_conflict(sk, tb2, uid, relax,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\ipv4\\inet_connection_sock.c"
          ]
        },
        {
          "file": "linux\\net\\ipv4\\tcp_input.c",
          "line": 5894,
          "match": "deadlock",
          "context": [
            "\t * such data and will stay in TCP_URG_NOTYET until will be eaten",
            "\t * by recvmsg(). Seems, we are not obliged to handle such wicked",
            "\t * situations. But it is worth to think about possibility of some",
            "\t * DoSes using some hypothetical application level deadlock.",
            "\t */",
            "\tif (before(ptr, tp->rcv_nxt))",
            "\t\treturn;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\ipv4\\tcp_input.c"
          ]
        },
        {
          "file": "linux\\net\\ipv4\\udp_tunnel_nic.c",
          "line": 293,
          "match": "deadlock",
          "context": [
            "",
            "\tutn->need_sync = 0;",
            "\t/* Can't replay directly here, in case we come from the tunnel driver's",
            "\t * notification - trying to replay may deadlock inside tunnel driver.",
            "\t */",
            "\tutn->need_replay = udp_tunnel_nic_should_replay(dev, utn);",
            "}"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\ipv4\\udp_tunnel_nic.c"
          ]
        },
        {
          "file": "linux\\net\\mac80211\\mesh_hwmp.c",
          "line": 231,
          "match": "deadlock",
          "context": [
            " * @ra: node this frame is addressed to",
            " *",
            " * Note: This function may be called with driver locks taken that the driver",
            " * also acquires in the TX path.  To avoid a deadlock we don't transmit the",
            " * frame directly but add it to the pending queue instead.",
            " *",
            " * Returns: 0 on success"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\mac80211\\mesh_hwmp.c"
          ]
        },
        {
          "file": "linux\\net\\mac80211\\main.c",
          "line": 592,
          "match": "deadlock",
          "context": [
            "\t * hold the notifier rwsem, that's the normal case. And yes,",
            "\t * we also acquire the notifier rwsem again when unregistering",
            "\t * a netdev while we already hold the wiphy mutex, so it does",
            "\t * look like a typical ABBA deadlock.",
            "\t *",
            "\t * However, both of these things happen with the RTNL held",
            "\t * already. Therefore, they can't actually happen, since the"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\mac80211\\main.c"
          ]
        },
        {
          "file": "linux\\net\\mac80211\\tx.c",
          "line": 1825,
          "match": "deadlock",
          "context": [
            "",
            "/*",
            " * Late handlers can be called while the sta lock is held. Handlers that can",
            " * cause packets to be generated will cause deadlock!",
            " */",
            "static int invoke_tx_handlers_late(struct ieee80211_tx_data *tx)",
            "{"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\mac80211\\tx.c"
          ]
        },
        {
          "file": "linux\\net\\mac80211\\tx.c",
          "line": 3529,
          "match": "deadlock",
          "context": [
            "",
            "/*",
            " * Can be called while the sta lock is held. Anything that can cause packets to",
            " * be generated will cause deadlock!",
            " */",
            "static ieee80211_tx_result",
            "ieee80211_xmit_fast_finish(struct ieee80211_sub_if_data *sdata,"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\mac80211\\tx.c"
          ]
        },
        {
          "file": "linux\\net\\mac80211\\util.c",
          "line": 1802,
          "match": "deadlock",
          "context": [
            "\t * cancel restart work, as we are reconfiguring the device",
            "\t * anyway.",
            "\t * Note that restart_work is scheduled on a frozen workqueue,",
            "\t * so we can't deadlock in this case.",
            "\t */",
            "\tif (suspended && local->in_reconfig && !reconfig_due_to_wowlan)",
            "\t\tcancel_work_sync(&local->restart_work);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\mac80211\\util.c"
          ]
        },
        {
          "file": "linux\\net\\mptcp\\protocol.c",
          "line": 730,
          "match": "deadlock",
          "context": [
            "}",
            "",
            "/* In most cases we will be able to lock the mptcp socket.  If its already",
            " * owned, we need to defer to the work queue to avoid ABBA deadlock.",
            " */",
            "static bool move_skbs_to_msk(struct mptcp_sock *msk, struct sock *ssk)",
            "{"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\mptcp\\protocol.c"
          ]
        },
        {
          "file": "linux\\net\\mptcp\\protocol.c",
          "line": 3363,
          "match": "deadlock",
          "context": [
            "\t\t/* the following actions acquire the subflow socket lock",
            "\t\t *",
            "\t\t * 1) can't be invoked in atomic scope",
            "\t\t * 2) must avoid ABBA deadlock with msk socket spinlock: the RX",
            "\t\t *    datapath acquires the msk socket spinlock while helding",
            "\t\t *    the subflow socket lock",
            "\t\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\mptcp\\protocol.c"
          ]
        },
        {
          "file": "linux\\net\\mptcp\\subflow.c",
          "line": 1894,
          "match": "deadlock",
          "context": [
            "\t\treturn;",
            "",
            "\t/* can't acquire the msk socket lock under the subflow one,",
            "\t * or will cause ABBA deadlock",
            "\t */",
            "\trelease_sock(listener_ssk);",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\mptcp\\subflow.c"
          ]
        },
        {
          "file": "linux\\net\\mptcp\\subflow.c",
          "line": 1914,
          "match": "deadlock",
          "context": [
            "\t\t__mptcp_unaccepted_force_close(sk);",
            "\t\trelease_sock(sk);",
            "",
            "\t\t/* lockdep will report a false positive ABBA deadlock",
            "\t\t * between cancel_work_sync and the listener socket.",
            "\t\t * The involved locks belong to different sockets WRT",
            "\t\t * the existing AB chain."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\mptcp\\subflow.c"
          ]
        },
        {
          "file": "linux\\net\\netfilter\\nf_conntrack_ftp.c",
          "line": 413,
          "match": "deadlock",
          "context": [
            "\t}",
            "\tdatalen = skb->len - dataoff;",
            "",
            "\t/* seqadj (nat) uses ct->lock internally, nf_nat_ftp would cause deadlock */",
            "\tspin_lock_bh(&nf_ftp_lock);",
            "\tfb_ptr = skb->data + dataoff;",
            ""
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\netfilter\\nf_conntrack_ftp.c"
          ]
        },
        {
          "file": "linux\\net\\netlink\\af_netlink.c",
          "line": 740,
          "match": "deadlock",
          "context": [
            "\t\tnlk->netlink_release(sk, nlk->groups);",
            "",
            "\t/* must not acquire netlink_table_lock in any way again before unbind",
            "\t * and notifying genetlink is done as otherwise it might deadlock",
            "\t */",
            "\tif (nlk->netlink_unbind) {",
            "\t\tint i;"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\netlink\\af_netlink.c"
          ]
        },
        {
          "file": "linux\\net\\rds\\cong.c",
          "line": 236,
          "match": "deadlock",
          "context": [
            "\t\t\t * 1. When we get here from the receive path, we",
            "\t\t\t *    are already holding the sock_lock (held by",
            "\t\t\t *    tcp_v4_rcv()). So inlining calls to",
            "\t\t\t *    tcp_setsockopt and/or tcp_sendmsg will deadlock",
            "\t\t\t *    when it tries to get the sock_lock())",
            "\t\t\t * 2. Interrupts are masked so that we can mark the",
            "\t\t\t *    port congested from both send and recv paths."
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\rds\\cong.c"
          ]
        },
        {
          "file": "linux\\net\\rds\\connection.c",
          "line": 377,
          "match": "deadlock",
          "context": [
            "\t\t * Quiesce the connection mgmt handlers before we start tearing",
            "\t\t * things down. We don't hold the mutex for the entire",
            "\t\t * duration of the shutdown operation, else we may be",
            "\t\t * deadlocking with the CM handler. Instead, the CM event",
            "\t\t * handler is supposed to check for state DISCONNECTING",
            "\t\t */",
            "\t\tmutex_lock(&cp->cp_cm_lock);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\rds\\connection.c"
          ]
        },
        {
          "file": "linux\\net\\rds\\tcp.c",
          "line": 163,
          "match": "deadlock",
          "context": [
            "\t * rds_send_xmi() threads through, so ideally we would",
            "\t * synchronize on RDS_CONN_UP after lock_sock(), but cannot",
            "\t * do that: waiting on !RDS_IN_XMIT after lock_sock() may",
            "\t * end up deadlocking with tcp_sendmsg(), and the RDS_IN_XMIT",
            "\t * would not get set. As a result, we set c_state to",
            "\t * RDS_CONN_RESETTTING, to ensure that rds_tcp_state_change",
            "\t * cannot mark rds_conn_path_up() in the window before lock_sock()"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\rds\\tcp.c"
          ]
        },
        {
          "file": "linux\\net\\rfkill\\core.c",
          "line": 96,
          "match": "deadlock",
          "context": [
            " * The locking here should be made much smarter, we currently have",
            " * a bit of a stupid situation because drivers might want to register",
            " * the rfkill struct under their own lock, and take this lock during",
            " * rfkill method calls -- which will cause an AB-BA deadlock situation.",
            " *",
            " * To fix that, we need to rework this code here to be mostly lock-free",
            " * and only use the mutex for list manipulations, not to protect the"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\rfkill\\core.c"
          ]
        },
        {
          "file": "linux\\net\\rxrpc\\call_object.c",
          "line": 133,
          "match": "deadlock",
          "context": [
            "",
            "\tmutex_init(&call->user_mutex);",
            "",
            "\t/* Prevent lockdep reporting a deadlock false positive between the afs",
            "\t * filesystem and sys_sendmsg() via the mmap sem.",
            "\t */",
            "\tif (rx->sk.sk_kern_sock)"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\rxrpc\\call_object.c"
          ]
        },
        {
          "file": "linux\\net\\unix\\af_unix.c",
          "line": 1694,
          "match": "deadlock",
          "context": [
            "\t}",
            "",
            "\t/* self connect and simultaneous connect are eliminated",
            "\t * by rejecting TCP_LISTEN socket to avoid deadlock.",
            "\t */",
            "\tstate = READ_ONCE(sk->sk_state);",
            "\tif (unlikely(state != TCP_CLOSE)) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\unix\\af_unix.c"
          ]
        },
        {
          "file": "linux\\net\\xdp\\xsk.c",
          "line": 1073,
          "match": "deadlock",
          "context": [
            "\t * the two locks involved. Each map has a lock synchronizing",
            "\t * updates to the entries, and each socket has a lock that",
            "\t * synchronizes access to the list of maps (map_list). For",
            "\t * deadlock avoidance the locks need to be taken in the order",
            "\t * \"map lock\"->\"socket map list lock\". We start off by",
            "\t * accessing the socket map list, and take a reference to the",
            "\t * map to guarantee existence between the"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\xdp\\xsk.c"
          ]
        },
        {
          "file": "linux\\net\\bluetooth\\hidp\\core.c",
          "line": 1300,
          "match": "deadlock",
          "context": [
            "\t * If we stopped ourself due to any internal signal, we should try to",
            "\t * unregister our own session here to avoid having it linger until the",
            "\t * parent l2cap_conn dies or user-space cleans it up.",
            "\t * This does not deadlock as we don't do any synchronous shutdown.",
            "\t * Instead, this call has the same semantics as if user-space tried to",
            "\t * delete the session.",
            "\t */"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\bluetooth\\hidp\\core.c"
          ]
        },
        {
          "file": "linux\\net\\bluetooth\\rfcomm\\sock.c",
          "line": 407,
          "match": "deadlock",
          "context": [
            "\td->sec_level = rfcomm_pi(sk)->sec_level;",
            "\td->role_switch = rfcomm_pi(sk)->role_switch;",
            "",
            "\t/* Drop sock lock to avoid potential deadlock with the RFCOMM lock */",
            "\trelease_sock(sk);",
            "\terr = rfcomm_dlc_open(d, &rfcomm_pi(sk)->src, &sa->rc_bdaddr,",
            "\t\t\t      sa->rc_channel);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\bluetooth\\rfcomm\\sock.c"
          ]
        },
        {
          "file": "linux\\net\\sunrpc\\xprtrdma\\rpc_rdma.c",
          "line": 1471,
          "match": "deadlock",
          "context": [
            "\tspin_unlock(&xprt->queue_lock);",
            "",
            "\tif (credits == 0)",
            "\t\tcredits = 1;\t/* don't deadlock */",
            "\telse if (credits > r_xprt->rx_ep->re_max_requests)",
            "\t\tcredits = r_xprt->rx_ep->re_max_requests;",
            "\trpcrdma_post_recvs(r_xprt, credits + (buf->rb_bc_srv_max_requests << 1));"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\sunrpc\\xprtrdma\\rpc_rdma.c"
          ]
        },
        {
          "file": "linux\\net\\sunrpc\\xprtrdma\\svc_rdma_backchannel.c",
          "line": 46,
          "match": "deadlock",
          "context": [
            "",
            "\tcredits = be32_to_cpup(rdma_resp + 2);",
            "\tif (credits == 0)",
            "\t\tcredits = 1;\t/* don't deadlock */",
            "\telse if (credits > r_xprt->rx_buf.rb_bc_max_requests)",
            "\t\tcredits = r_xprt->rx_buf.rb_bc_max_requests;",
            "\tspin_lock(&xprt->transport_lock);"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\sunrpc\\xprtrdma\\svc_rdma_backchannel.c"
          ]
        },
        {
          "file": "linux\\sound\\drivers\\aloop.c",
          "line": 863,
          "match": "deadlock",
          "context": [
            "\t * snd_timer_start()",
            "\t * spin_lock(&timer->lock)",
            "\t * Therefore when using the oposit order of locks here it could result",
            "\t * in a deadlock.",
            "\t */",
            "",
            "\tif (event == SNDRV_TIMER_EVENT_MSTOP) {"
          ],
          "pattern": "deadlock",
          "description": "Deadlock scenarios and lock ordering issues",
          "code_snippet": [
            "File not found: linux\\linux\\sound\\drivers\\aloop.c"
          ]
        }
      ]
    },
    "double_lock": {
      "count": 573,
      "description": "Double locking or reentrant lock issues",
      "issues": [
        {
          "file": "linux\\fs\\pipe.c",
          "line": 102,
          "match": "double_lock",
          "context": [
            "}",
            "EXPORT_SYMBOL(pipe_unlock);",
            "",
            "void pipe_double_lock(struct pipe_inode_info *pipe1,",
            "\t\t      struct pipe_inode_info *pipe2)",
            "{",
            "\tBUG_ON(pipe1 == pipe2);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\pipe.c"
          ]
        },
        {
          "file": "linux\\fs\\splice.c",
          "line": 1740,
          "match": "double_lock",
          "context": [
            "\t * grabbing by pipe info address. Otherwise two different processes",
            "\t * could deadlock (one doing tee from A -> B, the other from B -> A).",
            "\t */",
            "\tpipe_double_lock(ipipe, opipe);",
            "",
            "\ti_tail = ipipe->tail;",
            "\to_head = opipe->head;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\splice.c"
          ]
        },
        {
          "file": "linux\\fs\\splice.c",
          "line": 1863,
          "match": "double_lock",
          "context": [
            "\t * grabbing by pipe info address. Otherwise two different processes",
            "\t * could deadlock (one doing tee from A -> B, the other from B -> A).",
            "\t */",
            "\tpipe_double_lock(ipipe, opipe);",
            "",
            "\ti_tail = ipipe->tail;",
            "\to_head = opipe->head;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\splice.c"
          ]
        },
        {
          "file": "linux\\arch\\arm\\kernel\\hw_breakpoint.c",
          "line": 1079,
          "match": "double lock",
          "context": [
            "\t\tbreak;",
            "\tcase ARM_DEBUG_ARCH_V7_1:",
            "\t\t/*",
            "\t\t * Ensure the OS double lock is clear.",
            "\t\t */",
            "\t\tARM_DBG_READ(c1, c3, 4, val);",
            "\t\tif ((val & 0x1) == 1)"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\arch\\arm\\kernel\\hw_breakpoint.c"
          ]
        },
        {
          "file": "linux\\arch\\arm64\\kernel\\cpufeature.c",
          "line": 551,
          "match": "DoubleLock",
          "context": [
            "};",
            "",
            "static const struct arm64_ftr_bits ftr_id_aa64dfr0[] = {",
            "\tS_ARM64_FTR_BITS(FTR_HIDDEN, FTR_STRICT, FTR_LOWER_SAFE, ID_AA64DFR0_EL1_DoubleLock_SHIFT, 4, 0),",
            "\tARM64_FTR_BITS(FTR_HIDDEN, FTR_NONSTRICT, FTR_LOWER_SAFE, ID_AA64DFR0_EL1_PMSVer_SHIFT, 4, 0),",
            "\tARM64_FTR_BITS(FTR_HIDDEN, FTR_STRICT, FTR_LOWER_SAFE, ID_AA64DFR0_EL1_CTX_CMPs_SHIFT, 4, 0),",
            "\tARM64_FTR_BITS(FTR_HIDDEN, FTR_STRICT, FTR_LOWER_SAFE, ID_AA64DFR0_EL1_WRPs_SHIFT, 4, 0),"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\arch\\arm64\\kernel\\cpufeature.c"
          ]
        },
        {
          "file": "linux\\arch\\powerpc\\kernel\\watchdog.c",
          "line": 208,
          "match": "Double check some things under lock",
          "context": [
            "\tint c;",
            "",
            "\twd_smp_lock(&flags);",
            "\t/* Double check some things under lock */",
            "\ttb = get_tb();",
            "\tlast_reset = wd_smp_last_reset_tb;",
            "\tif ((s64)(tb - last_reset) < (s64)wd_smp_panic_timeout_tb)"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\arch\\powerpc\\kernel\\watchdog.c"
          ]
        },
        {
          "file": "linux\\arch\\powerpc\\kernel\\watchdog.c",
          "line": 331,
          "match": "Double check under lock",
          "context": [
            "",
            "none_pending:",
            "\t\t/*",
            "\t\t * Double check under lock because more than one CPU could see",
            "\t\t * a clear mask with the lockless check after clearing their",
            "\t\t * pending bits.",
            "\t\t */"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\arch\\powerpc\\kernel\\watchdog.c"
          ]
        },
        {
          "file": "linux\\drivers\\block\\ublk_drv.c",
          "line": 1595,
          "match": "double check after grabbing lock",
          "context": [
            "\t */",
            "\tmutex_lock(&ub->mutex);",
            "",
            "\t/* double check after grabbing lock */",
            "\tif (!ub->ub_disk)",
            "\t\tgoto unlock;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\block\\ublk_drv.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\dm-cache-metadata.c",
          "line": 1781,
          "match": "double-checked with cmd->root_lock",
          "context": [
            "\tint r = -EINVAL;",
            "\tstruct dm_block_manager *old_bm = NULL, *new_bm = NULL;",
            "",
            "\t/* fail_io is double-checked with cmd->root_lock held below */",
            "\tif (unlikely(cmd->fail_io))",
            "\t\treturn r;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\dm-cache-metadata.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\dm-thin-metadata.c",
          "line": 1901,
          "match": "double-checked with pmd->root_lock",
          "context": [
            "{",
            "\tint r = -EINVAL;",
            "",
            "\t/* fail_io is double-checked with pmd->root_lock held below */",
            "\tif (unlikely(pmd->fail_io))",
            "\t\treturn r;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\dm-thin-metadata.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\raid5.c",
          "line": 1290,
          "match": "DOUBLE_LOCK",
          "context": [
            "\t\t\tif (op == REQ_OP_DISCARD)",
            "\t\t\t\tbi->bi_vcnt = 0;",
            "\t\t\tif (rrdev)",
            "\t\t\t\tset_bit(R5_DOUBLE_LOCKED, &sh->dev[i].flags);",
            "",
            "\t\t\tmddev_trace_remap(conf->mddev, bi, sh->dev[i].sector);",
            "\t\t\tif (should_defer && op_is_write(op))"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\raid5.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\raid5.c",
          "line": 2898,
          "match": "DOUBLE_LOCK",
          "context": [
            "\t\tset_bit(STRIPE_BATCH_ERR, &sh->batch_head->state);",
            "",
            "\tbio_uninit(bi);",
            "\tif (!test_and_clear_bit(R5_DOUBLE_LOCKED, &sh->dev[i].flags))",
            "\t\tclear_bit(R5_LOCKED, &sh->dev[i].flags);",
            "\tset_bit(STRIPE_HANDLE, &sh->state);",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\raid5.c"
          ]
        },
        {
          "file": "linux\\drivers\\nvmem\\sprd-efuse.c",
          "line": 352,
          "match": "double, lock",
          "context": [
            "\telse",
            "\t\tlock = true;",
            "",
            "\tret = sprd_efuse_raw_prog(efuse, offset, blk_double, lock, val);",
            "",
            "\tclk_disable_unprepare(efuse->clk);",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\nvmem\\sprd-efuse.c"
          ]
        },
        {
          "file": "linux\\drivers\\pci\\access.c",
          "line": 338,
          "match": "double-block",
          "context": [
            "",
            "\t/*",
            "\t * This indicates a problem in the caller, but we don't need",
            "\t * to kill them, unlike a double-block above.",
            "\t */",
            "\tWARN_ON(!dev->block_cfg_access);",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\pci\\access.c"
          ]
        },
        {
          "file": "linux\\drivers\\clk\\tegra\\clk-tegra-audio.c",
          "line": 82,
          "match": "doubler_lock",
          "context": [
            "\t\t.div_offset\t= _offset,\\",
            "\t}",
            "",
            "static DEFINE_SPINLOCK(clk_doubler_lock);",
            "",
            "static const char * const mux_audio_sync_clk[] = { \"spdif_in_sync\",",
            "\t\"i2s0_sync\", \"i2s1_sync\", \"i2s2_sync\", \"i2s3_sync\", \"i2s4_sync\","
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\clk\\tegra\\clk-tegra-audio.c"
          ]
        },
        {
          "file": "linux\\drivers\\clk\\tegra\\clk-tegra-audio.c",
          "line": 240,
          "match": "doubler_lock",
          "context": [
            "\t\tclk = tegra_clk_register_divider(data->div_name,",
            "\t\t\t\tdata->name_2x, clk_base + AUDIO_SYNC_DOUBLER,",
            "\t\t\t\t0, 0, data->div_offset, 1, 0,",
            "\t\t\t\t&clk_doubler_lock);",
            "\t\tclk = tegra_clk_register_periph_gate(data->gate_name,",
            "\t\t\t\tdata->div_name, TEGRA_PERIPH_NO_RESET,",
            "\t\t\t\tclk_base, CLK_SET_RATE_PARENT, data->clk_num,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\clk\\tegra\\clk-tegra-audio.c"
          ]
        },
        {
          "file": "linux\\drivers\\crypto\\intel\\keembay\\keembay-ocs-hcu-core.c",
          "line": 81,
          "match": "double the block",
          "context": [
            "\tstruct ocs_hcu_dma_list\t*dma_list;",
            "\tstruct ocs_hcu_hash_ctx\thash_ctx;",
            "\t/*",
            "\t * Buffer is double the block size because we need space for SW HMAC",
            "\t * artifacts, i.e:",
            "\t * - ipad (1 block) + a possible partial block of data.",
            "\t * - opad (1 block) + digest of H(k ^ ipad || m)"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\crypto\\intel\\keembay\\keembay-ocs-hcu-core.c"
          ]
        },
        {
          "file": "linux\\drivers\\cxl\\core\\hdm.c",
          "line": 1139,
          "match": "double it to be tolerant of any clock",
          "context": [
            "\t * Since the register resource was recently claimed via request_region()",
            "\t * be careful about trusting the \"not-committed\" status until the commit",
            "\t * timeout has elapsed.  The commit timeout is 10ms (CXL 2.0",
            "\t * 8.2.5.12.20), but double it to be tolerant of any clock skew between",
            "\t * host and target.",
            "\t */",
            "\tfor (i = 0, committed = 0; i < cxlhdm->decoder_count; i++) {"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\cxl\\core\\hdm.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\bridge\\tda998x_drv.c",
          "line": 1524,
          "match": "double-clock",
          "context": [
            "\t}",
            "",
            "\t/*",
            "\t * Select pixel repeat depending on the double-clock flag",
            "\t * (which means we have to repeat each pixel once.)",
            "\t */",
            "\trep = mode->flags & DRM_MODE_FLAG_DBLCLK ? 1 : 0;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\bridge\\tda998x_drv.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\radeon\\atombios_crtc.c",
          "line": 339,
          "match": "DOUBLE_CLOCK",
          "context": [
            "\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)",
            "\t\tmisc |= ATOM_INTERLACE;",
            "\tif (mode->flags & DRM_MODE_FLAG_DBLCLK)",
            "\t\tmisc |= ATOM_DOUBLE_CLOCK_MODE;",
            "\tif (mode->flags & DRM_MODE_FLAG_DBLSCAN)",
            "\t\tmisc |= ATOM_H_REPLICATIONBY2 | ATOM_V_REPLICATIONBY2;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\radeon\\atombios_crtc.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\radeon\\atombios_crtc.c",
          "line": 385,
          "match": "DOUBLE_CLOCK",
          "context": [
            "\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)",
            "\t\tmisc |= ATOM_INTERLACE;",
            "\tif (mode->flags & DRM_MODE_FLAG_DBLCLK)",
            "\t\tmisc |= ATOM_DOUBLE_CLOCK_MODE;",
            "\tif (mode->flags & DRM_MODE_FLAG_DBLSCAN)",
            "\t\tmisc |= ATOM_H_REPLICATIONBY2 | ATOM_V_REPLICATIONBY2;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\radeon\\atombios_crtc.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\radeon\\radeon_atombios.c",
          "line": 1671,
          "match": "DOUBLE_CLOCK",
          "context": [
            "\t\t\tlvds->native_mode.flags |= DRM_MODE_FLAG_CSYNC;",
            "\t\tif (misc & ATOM_INTERLACE)",
            "\t\t\tlvds->native_mode.flags |= DRM_MODE_FLAG_INTERLACE;",
            "\t\tif (misc & ATOM_DOUBLE_CLOCK_MODE)",
            "\t\t\tlvds->native_mode.flags |= DRM_MODE_FLAG_DBLSCAN;",
            "",
            "\t\tlvds->native_mode.width_mm = le16_to_cpu(lvds_info->info.sLCDTiming.usImageHSize);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\radeon\\radeon_atombios.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\radeon\\radeon_atombios.c",
          "line": 1832,
          "match": "DOUBLE_CLOCK",
          "context": [
            "\t\t\tmode->flags |= DRM_MODE_FLAG_CSYNC;",
            "\t\tif (misc & ATOM_INTERLACE)",
            "\t\t\tmode->flags |= DRM_MODE_FLAG_INTERLACE;",
            "\t\tif (misc & ATOM_DOUBLE_CLOCK_MODE)",
            "\t\t\tmode->flags |= DRM_MODE_FLAG_DBLSCAN;",
            "",
            "\t\tmode->crtc_clock = mode->clock ="
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\radeon\\radeon_atombios.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\radeon\\radeon_atombios.c",
          "line": 1876,
          "match": "DOUBLE_CLOCK",
          "context": [
            "\t\t\tmode->flags |= DRM_MODE_FLAG_CSYNC;",
            "\t\tif (misc & ATOM_INTERLACE)",
            "\t\t\tmode->flags |= DRM_MODE_FLAG_INTERLACE;",
            "\t\tif (misc & ATOM_DOUBLE_CLOCK_MODE)",
            "\t\t\tmode->flags |= DRM_MODE_FLAG_DBLSCAN;",
            "",
            "\t\tmode->crtc_clock = mode->clock ="
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\radeon\\radeon_atombios.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\rockchip\\inno_hdmi.c",
          "line": 502,
          "match": "double-clock",
          "context": [
            "\tunsigned long mpixelclk, max_tolerance;",
            "\tlong rounded_refclk;",
            "",
            "\t/* No support for double-clock modes */",
            "\tif (mode->flags & DRM_MODE_FLAG_DBLCLK)",
            "\t\treturn MODE_BAD;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\rockchip\\inno_hdmi.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\tests\\drm_connector_test.c",
          "line": 1609,
          "match": "double the mode pixel clock",
          "context": [
            "",
            "/*",
            " * Test that for a mode with the pixel repetition flag, the TMDS",
            " * character rate is indeed double the mode pixel clock.",
            " */",
            "static void drm_test_drm_hdmi_compute_mode_clock_rgb_double(struct kunit *test)",
            "{"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\tests\\drm_connector_test.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\atombios_crtc.c",
          "line": 226,
          "match": "DOUBLE_CLOCK",
          "context": [
            "\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)",
            "\t\tmisc |= ATOM_INTERLACE;",
            "\tif (mode->flags & DRM_MODE_FLAG_DBLSCAN)",
            "\t\tmisc |= ATOM_DOUBLE_CLOCK_MODE;",
            "",
            "\targs.susModeMiscInfo.usAccess = cpu_to_le16(misc);",
            "\targs.ucCRTC = amdgpu_crtc->crtc_id;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\atombios_crtc.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\amdgpu\\atombios_encoders.c",
          "line": 2019,
          "match": "DOUBLE_CLOCK",
          "context": [
            "\t\t\tlvds->native_mode.flags |= DRM_MODE_FLAG_CSYNC;",
            "\t\tif (misc & ATOM_INTERLACE)",
            "\t\t\tlvds->native_mode.flags |= DRM_MODE_FLAG_INTERLACE;",
            "\t\tif (misc & ATOM_DOUBLE_CLOCK_MODE)",
            "\t\t\tlvds->native_mode.flags |= DRM_MODE_FLAG_DBLSCAN;",
            "",
            "\t\tlvds->native_mode.width_mm = le16_to_cpu(lvds_info->info.sLCDTiming.usImageHSize);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\amdgpu\\atombios_encoders.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\bios\\bios_parser.c",
          "line": 1294,
          "match": "DOUBLE_CLOCK",
          "context": [
            "\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.CompositeSync;",
            "\tinfo->lcd_timing.misc_info.INTERLACE =",
            "\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.Interlace;",
            "\tinfo->lcd_timing.misc_info.DOUBLE_CLOCK =",
            "\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.DoubleClock;",
            "\tinfo->ss_id = lvds->ucSS_Id;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\bios\\bios_parser.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\bios\\bios_parser.c",
          "line": 1295,
          "match": "DoubleClock",
          "context": [
            "\tinfo->lcd_timing.misc_info.INTERLACE =",
            "\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.Interlace;",
            "\tinfo->lcd_timing.misc_info.DOUBLE_CLOCK =",
            "\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.DoubleClock;",
            "\tinfo->ss_id = lvds->ucSS_Id;",
            "",
            "\t{"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\bios\\bios_parser.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\bios\\bios_parser.c",
          "line": 1319,
          "match": "DOUBLE_CLOCK",
          "context": [
            "\t\tinfo->drr_enabled = 1;",
            "",
            "\tif (ATOM_PANEL_MISC_DUAL & lvds->ucLVDS_Misc)",
            "\t\tinfo->lcd_timing.misc_info.DOUBLE_CLOCK = true;",
            "",
            "\tif (ATOM_PANEL_MISC_888RGB & lvds->ucLVDS_Misc)",
            "\t\tinfo->lcd_timing.misc_info.RGB888 = true;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\bios\\bios_parser.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\bios\\bios_parser.c",
          "line": 1412,
          "match": "DOUBLE_CLOCK",
          "context": [
            "\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.CompositeSync;",
            "\tinfo->lcd_timing.misc_info.INTERLACE =",
            "\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.Interlace;",
            "\tinfo->lcd_timing.misc_info.DOUBLE_CLOCK =",
            "\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.DoubleClock;",
            "\tinfo->ss_id = lvds->ucSS_Id;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\bios\\bios_parser.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\bios\\bios_parser.c",
          "line": 1413,
          "match": "DoubleClock",
          "context": [
            "\tinfo->lcd_timing.misc_info.INTERLACE =",
            "\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.Interlace;",
            "\tinfo->lcd_timing.misc_info.DOUBLE_CLOCK =",
            "\t\tlvds->sLCDTiming.susModeMiscInfo.sbfAccess.DoubleClock;",
            "\tinfo->ss_id = lvds->ucSS_Id;",
            "",
            "\t/* Drr panel support can be reported by VBIOS*/"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\bios\\bios_parser.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\bios\\bios_parser.c",
          "line": 1453,
          "match": "DOUBLE_CLOCK",
          "context": [
            "\t}",
            "",
            "\tif (ATOM_PANEL_MISC_V13_DUAL & lvds->ucLCD_Misc)",
            "\t\tinfo->lcd_timing.misc_info.DOUBLE_CLOCK = true;",
            "",
            "\tif (ATOM_PANEL_MISC_V13_8BIT_PER_COLOR & lvds->ucLCD_Misc)",
            "\t\tinfo->lcd_timing.misc_info.RGB888 = true;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\bios\\bios_parser.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\bios\\bios_parser2.c",
          "line": 1500,
          "match": "DOUBLE_CLOCK",
          "context": [
            "\tinfo->lcd_timing.misc_info.INTERLACE = !!(lvds->lcd_timing.miscinfo & ATOM_INTERLACE);",
            "",
            "\t/* not provided by VBIOS*/",
            "\tinfo->lcd_timing.misc_info.DOUBLE_CLOCK = 0;",
            "\t/* not provided by VBIOS*/",
            "\tinfo->ss_id = 0;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\bios\\bios_parser2.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\bios\\command_table.c",
          "line": 1888,
          "match": "DOUBLE_CLOCK",
          "context": [
            "",
            "\tif (bp_params->flags.HORZ_COUNT_BY_TWO)",
            "\t\tparams.susModeMiscInfo.usAccess =",
            "\t\t\t\tcpu_to_le16(le16_to_cpu(params.susModeMiscInfo.usAccess) | ATOM_DOUBLE_CLOCK_MODE);",
            "",
            "\tif (EXEC_BIOS_CMD_TABLE(SetCRTC_Timing, params))",
            "\t\tresult = BP_RESULT_OK;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\bios\\command_table.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\bios\\command_table.c",
          "line": 1969,
          "match": "DOUBLE_CLOCK",
          "context": [
            "",
            "\tif (bp_params->flags.HORZ_COUNT_BY_TWO)",
            "\t\tparams.susModeMiscInfo.usAccess =",
            "\t\t\t\tcpu_to_le16(le16_to_cpu(params.susModeMiscInfo.usAccess) | ATOM_DOUBLE_CLOCK_MODE);",
            "",
            "\tif (EXEC_BIOS_CMD_TABLE(SetCRTC_UsingDTDTiming, params))",
            "\t\tresult = BP_RESULT_OK;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\bios\\command_table.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\bios\\command_table2.c",
          "line": 687,
          "match": "DOUBLE_CLOCK",
          "context": [
            "\tif (bp_params->flags.HORZ_COUNT_BY_TWO)",
            "\t\tparams.modemiscinfo =",
            "\t\t\tcpu_to_le16(le16_to_cpu(params.modemiscinfo) |",
            "\t\t\t\t\t0x100); /* ATOM_DOUBLE_CLOCK_MODE */",
            "",
            "\tif (EXEC_BIOS_CMD_TABLE(setcrtc_usingdtdtiming, params))",
            "\t\tresult = BP_RESULT_OK;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\bios\\command_table2.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\display_mode_vba.c",
          "line": 1119,
          "match": "double PixelClock",
          "context": [
            "",
            "double CalculateWriteBackDISPCLK(",
            "\t\tenum source_format_class WritebackPixelFormat,",
            "\t\tdouble PixelClock,",
            "\t\tdouble WritebackHRatio,",
            "\t\tdouble WritebackVRatio,",
            "\t\tunsigned int WritebackLumaHTaps,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\display_mode_vba.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\display_mode_vba.c",
          "line": 1130,
          "match": "double CalculateWriteBackDISPCLK = 1.01 * PixelClock",
          "context": [
            "\t\tunsigned int HTotal,",
            "\t\tunsigned int WritebackChromaLineBufferWidth)",
            "{",
            "\tdouble CalculateWriteBackDISPCLK = 1.01 * PixelClock * dml_max(",
            "\t\tdml_ceil(WritebackLumaHTaps / 4.0, 1) / WritebackHRatio,",
            "\t\tdml_max((WritebackLumaVTaps * dml_ceil(1.0 / WritebackVRatio, 1) * dml_ceil(WritebackDestinationWidth / 4.0, 1)",
            "\t\t\t+ dml_ceil(WritebackDestinationWidth / 4.0, 1)) / (double) HTotal + dml_ceil(1.0 / WritebackVRatio, 1)"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\display_mode_vba.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dml1_display_rq_dlg_calc.c",
          "line": 1323,
          "match": "double) mode_lib->soc.dram_clock",
          "context": [
            "\tDTRACE(",
            "\t\t\t\"DLG: %s: soc.dram_clock_change_latency_us   = %3.2f\",",
            "\t\t\t__func__,",
            "\t\t\t(double) mode_lib->soc.dram_clock_change_latency_us);",
            "\tDTRACE(",
            "\t\t\t\"DLG: %s: soc.urgent_latency_us              = %3.2f\",",
            "\t\t\t__func__,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dml1_display_rq_dlg_calc.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\dcn20_fpu.c",
          "line": 2214,
          "match": "double dram_clock_change_latency_cached = dml->soc.dram_clock",
          "context": [
            "\t\t\t\t\tdisplay_e2e_pipe_params_st *pipes,",
            "\t\t\t\t\tint pipe_cnt)",
            "{",
            "\tdouble dram_clock_change_latency_cached = dml->soc.dram_clock_change_latency_us;",
            "",
            "\tASSERT(vlevel < dml->soc.num_states);",
            "\t/* only pipe 0 is read for voltage and dcf/soc clocks */"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\dcn20_fpu.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
          "line": 60,
          "match": "double PixelClock",
          "context": [
            "\t\tstruct display_mode_lib *mode_lib,",
            "\t\tdouble DPPCLK,",
            "\t\tdouble DISPCLK,",
            "\t\tdouble PixelClock,",
            "\t\tdouble DCFCLKDeepSleep,",
            "\t\tunsigned int DSCDelay,",
            "\t\tunsigned int DPPPerPlane,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
          "line": 120,
          "match": "double RoundToDFSGranularityUp(double Clock",
          "context": [
            "\t\tunsigned int *VUpdateOffsetPix,",
            "\t\tdouble *VUpdateWidthPix,",
            "\t\tdouble *VReadyOffsetPix);",
            "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed);",
            "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed);",
            "static double CalculatePrefetchSourceLines(",
            "\t\tstruct display_mode_lib *mode_lib,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
          "line": 121,
          "match": "double RoundToDFSGranularityDown(double Clock",
          "context": [
            "\t\tdouble *VUpdateWidthPix,",
            "\t\tdouble *VReadyOffsetPix);",
            "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed);",
            "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed);",
            "static double CalculatePrefetchSourceLines(",
            "\t\tstruct display_mode_lib *mode_lib,",
            "\t\tdouble VRatio,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
          "line": 158,
          "match": "double DRAMClock",
          "context": [
            "\t\tunsigned int *meta_row_height);",
            "static double CalculateTWait(",
            "\t\tunsigned int PrefetchMode,",
            "\t\tdouble DRAMClockChangeLatency,",
            "\t\tdouble UrgentLatencyPixelDataOnly,",
            "\t\tdouble SREnterPlusExitTime);",
            "static double CalculateRemoteSurfaceFlipDelay("
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
          "line": 443,
          "match": "double PixelClock",
          "context": [
            "\t\tstruct display_mode_lib *mode_lib,",
            "\t\tdouble DPPCLK,",
            "\t\tdouble DISPCLK,",
            "\t\tdouble PixelClock,",
            "\t\tdouble DCFCLKDeepSleep,",
            "\t\tunsigned int DSCDelay,",
            "\t\tunsigned int DPPPerPlane,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
          "line": 556,
          "match": "double) (*VUpdateOffsetPix + *VUpdateWidthPix + *VReadyOffsetPix) / PixelClock",
          "context": [
            "\t\t\tTotalRepeaterDelayTime + 20.0 / DCFCLKDeepSleep + 10.0 / DPPCLK)",
            "\t\t\t* PixelClock;",
            "",
            "\tTsetup = (double) (*VUpdateOffsetPix + *VUpdateWidthPix + *VReadyOffsetPix) / PixelClock;",
            "",
            "\tLineTime = (double) HTotal / PixelClock;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
          "line": 558,
          "match": "double) HTotal / PixelClock",
          "context": [
            "",
            "\tTsetup = (double) (*VUpdateOffsetPix + *VUpdateWidthPix + *VReadyOffsetPix) / PixelClock;",
            "",
            "\tLineTime = (double) HTotal / PixelClock;",
            "",
            "\tif (DynamicMetadataEnable) {",
            "\t\tdouble Tdmbf, Tdmec, Tdmsks;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
          "line": 799,
          "match": "double RoundToDFSGranularityUp(double Clock",
          "context": [
            "\treturn MyError;",
            "}",
            "",
            "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed)",
            "{",
            "\treturn VCOSpeed * 4 / dml_floor(VCOSpeed * 4 / Clock, 1);",
            "}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
          "line": 804,
          "match": "double RoundToDFSGranularityDown(double Clock",
          "context": [
            "\treturn VCOSpeed * 4 / dml_floor(VCOSpeed * 4 / Clock, 1);",
            "}",
            "",
            "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed)",
            "{",
            "\treturn VCOSpeed * 4 / dml_ceil(VCOSpeed * 4 / Clock, 1);",
            "}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
          "line": 2407,
          "match": "double ActiveDRAMClock",
          "context": [
            "\t\tdouble DPPOutputBufferLinesC;",
            "\t\tdouble DPPOPPBufferingY;",
            "\t\tdouble MaxDETBufferingTimeY;",
            "\t\tdouble ActiveDRAMClockChangeLatencyMarginY;",
            "",
            "\t\tmode_lib->vba.LBLatencyHidingSourceLinesY =",
            "\t\t\t\tdml_min("
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
          "line": 2495,
          "match": "double ActiveDRAMClock",
          "context": [
            "\t\t\t\t\t\t\t\t\t/ mode_lib->vba.SwathHeightC[k]",
            "\t\t\t\t\t\t\t\t\t* (mode_lib->vba.HTotal[k]",
            "\t\t\t\t\t\t\t\t\t\t\t/ mode_lib->vba.PixelClock[k]);",
            "\t\t\tdouble ActiveDRAMClockChangeLatencyMarginC = DPPOPPBufferingC",
            "\t\t\t\t\t+ EffectiveLBLatencyHidingC + MaxDETBufferingTimeC",
            "\t\t\t\t\t- mode_lib->vba.DRAMClockChangeWatermark;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
          "line": 2519,
          "match": "double WritebackDRAMClock",
          "context": [
            "\t\t}",
            "",
            "\t\tif (mode_lib->vba.WritebackEnable[k]) {",
            "\t\t\tdouble WritebackDRAMClockChangeLatencyMargin;",
            "",
            "\t\t\tif (mode_lib->vba.WritebackPixelFormat[k] == dm_444_32) {",
            "\t\t\t\tWritebackDRAMClockChangeLatencyMargin ="
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
          "line": 2715,
          "match": "double Read256BytesBlock",
          "context": [
            "{",
            "\tdouble BytePerPixDETY;",
            "\tdouble BytePerPixDETC;",
            "\tdouble Read256BytesBlockHeightY;",
            "\tdouble Read256BytesBlockHeightC;",
            "\tdouble Read256BytesBlockWidthY;",
            "\tdouble Read256BytesBlockWidthC;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
          "line": 2716,
          "match": "double Read256BytesBlock",
          "context": [
            "\tdouble BytePerPixDETY;",
            "\tdouble BytePerPixDETC;",
            "\tdouble Read256BytesBlockHeightY;",
            "\tdouble Read256BytesBlockHeightC;",
            "\tdouble Read256BytesBlockWidthY;",
            "\tdouble Read256BytesBlockWidthC;",
            "\tdouble MaximumSwathHeightY;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
          "line": 2717,
          "match": "double Read256BytesBlock",
          "context": [
            "\tdouble BytePerPixDETC;",
            "\tdouble Read256BytesBlockHeightY;",
            "\tdouble Read256BytesBlockHeightC;",
            "\tdouble Read256BytesBlockWidthY;",
            "\tdouble Read256BytesBlockWidthC;",
            "\tdouble MaximumSwathHeightY;",
            "\tdouble MaximumSwathHeightC;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
          "line": 2718,
          "match": "double Read256BytesBlock",
          "context": [
            "\tdouble Read256BytesBlockHeightY;",
            "\tdouble Read256BytesBlockHeightC;",
            "\tdouble Read256BytesBlockWidthY;",
            "\tdouble Read256BytesBlockWidthC;",
            "\tdouble MaximumSwathHeightY;",
            "\tdouble MaximumSwathHeightC;",
            "\tdouble MinimumSwathHeightY;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c",
          "line": 2922,
          "match": "double DRAMClock",
          "context": [
            "",
            "static double CalculateTWait(",
            "\t\tunsigned int PrefetchMode,",
            "\t\tdouble DRAMClockChangeLatency,",
            "\t\tdouble UrgentLatencyPixelDataOnly,",
            "\t\tdouble SREnterPlusExitTime)",
            "{"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
          "line": 66,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble DisplayPipeLineDeliveryTimeChroma,",
            "\t\tdouble DPPCLK,",
            "\t\tdouble DISPCLK,",
            "\t\tdouble PixelClock,",
            "\t\tunsigned int DSCDelay,",
            "\t\tunsigned int DPPPerPlane,",
            "\t\tbool ScalerEnabled,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
          "line": 95,
          "match": "double PixelClock",
          "context": [
            "\t\tstruct display_mode_lib *mode_lib,",
            "\t\tdouble DPPCLK,",
            "\t\tdouble DISPCLK,",
            "\t\tdouble PixelClock,",
            "\t\tdouble DCFCLKDeepSleep,",
            "\t\tunsigned int DPPPerPlane,",
            "\t\tunsigned int NumberOfCursors,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
          "line": 144,
          "match": "double RoundToDFSGranularityUp(double Clock",
          "context": [
            "\t\tunsigned int *VUpdateOffsetPix,",
            "\t\tdouble *VUpdateWidthPix,",
            "\t\tdouble *VReadyOffsetPix);",
            "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed);",
            "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed);",
            "static double CalculatePrefetchSourceLines(",
            "\t\tstruct display_mode_lib *mode_lib,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
          "line": 145,
          "match": "double RoundToDFSGranularityDown(double Clock",
          "context": [
            "\t\tdouble *VUpdateWidthPix,",
            "\t\tdouble *VReadyOffsetPix);",
            "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed);",
            "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed);",
            "static double CalculatePrefetchSourceLines(",
            "\t\tstruct display_mode_lib *mode_lib,",
            "\t\tdouble VRatio,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
          "line": 182,
          "match": "double DRAMClock",
          "context": [
            "\t\tunsigned int *meta_row_height);",
            "static double CalculateTWait(",
            "\t\tunsigned int PrefetchMode,",
            "\t\tdouble DRAMClockChangeLatency,",
            "\t\tdouble UrgentLatencyPixelDataOnly,",
            "\t\tdouble SREnterPlusExitTime);",
            "static double CalculateRemoteSurfaceFlipDelay("
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
          "line": 473,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble DisplayPipeLineDeliveryTimeChroma,",
            "\t\tdouble DPPCLK,",
            "\t\tdouble DISPCLK,",
            "\t\tdouble PixelClock,",
            "\t\tunsigned int DSCDelay,",
            "\t\tunsigned int DPPPerPlane,",
            "\t\tbool ScalerEnabled,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
          "line": 545,
          "match": "double PixelClock",
          "context": [
            "\t\tstruct display_mode_lib *mode_lib,",
            "\t\tdouble DPPCLK,",
            "\t\tdouble DISPCLK,",
            "\t\tdouble PixelClock,",
            "\t\tdouble DCFCLKDeepSleep,",
            "\t\tunsigned int DPPPerPlane,",
            "\t\tunsigned int NumberOfCursors,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
          "line": 619,
          "match": "double) (*VUpdateOffsetPix + *VUpdateWidthPix + *VReadyOffsetPix) / PixelClock",
          "context": [
            "\t\t\tTotalRepeaterDelayTime + 20.0 / DCFCLKDeepSleep + 10.0 / DPPCLK)",
            "\t\t\t* PixelClock;",
            "",
            "\tTsetup = (double) (*VUpdateOffsetPix + *VUpdateWidthPix + *VReadyOffsetPix) / PixelClock;",
            "",
            "\tLineTime = (double) HTotal / PixelClock;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
          "line": 621,
          "match": "double) HTotal / PixelClock",
          "context": [
            "",
            "\tTsetup = (double) (*VUpdateOffsetPix + *VUpdateWidthPix + *VReadyOffsetPix) / PixelClock;",
            "",
            "\tLineTime = (double) HTotal / PixelClock;",
            "",
            "\tif (DynamicMetadataEnable) {",
            "\t\tdouble Tdmbf, Tdmec, Tdmsks;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
          "line": 859,
          "match": "double RoundToDFSGranularityUp(double Clock",
          "context": [
            "\treturn MyError;",
            "}",
            "",
            "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed)",
            "{",
            "\treturn VCOSpeed * 4 / dml_floor(VCOSpeed * 4 / Clock, 1);",
            "}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
          "line": 864,
          "match": "double RoundToDFSGranularityDown(double Clock",
          "context": [
            "\treturn VCOSpeed * 4 / dml_floor(VCOSpeed * 4 / Clock, 1);",
            "}",
            "",
            "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed)",
            "{",
            "\treturn VCOSpeed * 4 / dml_ceil(VCOSpeed * 4 / Clock, 1);",
            "}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
          "line": 2441,
          "match": "double ActiveDRAMClock",
          "context": [
            "\t\tdouble DPPOutputBufferLinesC;",
            "\t\tdouble DPPOPPBufferingY;",
            "\t\tdouble MaxDETBufferingTimeY;",
            "\t\tdouble ActiveDRAMClockChangeLatencyMarginY;",
            "",
            "\t\tmode_lib->vba.LBLatencyHidingSourceLinesY =",
            "\t\t\t\tdml_min("
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
          "line": 2529,
          "match": "double ActiveDRAMClock",
          "context": [
            "\t\t\t\t\t\t\t\t\t/ mode_lib->vba.SwathHeightC[k]",
            "\t\t\t\t\t\t\t\t\t* (mode_lib->vba.HTotal[k]",
            "\t\t\t\t\t\t\t\t\t\t\t/ mode_lib->vba.PixelClock[k]);",
            "\t\t\tdouble ActiveDRAMClockChangeLatencyMarginC = DPPOPPBufferingC",
            "\t\t\t\t\t+ EffectiveLBLatencyHidingC + MaxDETBufferingTimeC",
            "\t\t\t\t\t- mode_lib->vba.DRAMClockChangeWatermark;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
          "line": 2553,
          "match": "double WritebackDRAMClock",
          "context": [
            "\t\t}",
            "",
            "\t\tif (mode_lib->vba.WritebackEnable[k]) {",
            "\t\t\tdouble WritebackDRAMClockChangeLatencyMargin;",
            "",
            "\t\t\tif (mode_lib->vba.WritebackPixelFormat[k] == dm_444_32) {",
            "\t\t\t\tWritebackDRAMClockChangeLatencyMargin ="
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
          "line": 2788,
          "match": "double Read256BytesBlock",
          "context": [
            "{",
            "\tdouble BytePerPixDETY;",
            "\tdouble BytePerPixDETC;",
            "\tdouble Read256BytesBlockHeightY;",
            "\tdouble Read256BytesBlockHeightC;",
            "\tdouble Read256BytesBlockWidthY;",
            "\tdouble Read256BytesBlockWidthC;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
          "line": 2789,
          "match": "double Read256BytesBlock",
          "context": [
            "\tdouble BytePerPixDETY;",
            "\tdouble BytePerPixDETC;",
            "\tdouble Read256BytesBlockHeightY;",
            "\tdouble Read256BytesBlockHeightC;",
            "\tdouble Read256BytesBlockWidthY;",
            "\tdouble Read256BytesBlockWidthC;",
            "\tdouble MaximumSwathHeightY;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
          "line": 2790,
          "match": "double Read256BytesBlock",
          "context": [
            "\tdouble BytePerPixDETC;",
            "\tdouble Read256BytesBlockHeightY;",
            "\tdouble Read256BytesBlockHeightC;",
            "\tdouble Read256BytesBlockWidthY;",
            "\tdouble Read256BytesBlockWidthC;",
            "\tdouble MaximumSwathHeightY;",
            "\tdouble MaximumSwathHeightC;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
          "line": 2791,
          "match": "double Read256BytesBlock",
          "context": [
            "\tdouble Read256BytesBlockHeightY;",
            "\tdouble Read256BytesBlockHeightC;",
            "\tdouble Read256BytesBlockWidthY;",
            "\tdouble Read256BytesBlockWidthC;",
            "\tdouble MaximumSwathHeightY;",
            "\tdouble MaximumSwathHeightC;",
            "\tdouble MinimumSwathHeightY;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c",
          "line": 2995,
          "match": "double DRAMClock",
          "context": [
            "",
            "static double CalculateTWait(",
            "\t\tunsigned int PrefetchMode,",
            "\t\tdouble DRAMClockChangeLatency,",
            "\t\tdouble UrgentLatencyPixelDataOnly,",
            "\t\tdouble SREnterPlusExitTime)",
            "{"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn20\\display_mode_vba_20v2.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\dcn30_fpu.c",
          "line": 659,
          "match": "double pstate_latency_us = base->ctx->dc->dml.soc.dram_clock",
          "context": [
            "void dcn3_fpu_build_wm_range_table(struct clk_mgr *base)",
            "{",
            "\t/* defaults */",
            "\tdouble pstate_latency_us = base->ctx->dc->dml.soc.dram_clock_change_latency_us;",
            "\tdouble sr_exit_time_us = base->ctx->dc->dml.soc.sr_exit_time_us;",
            "\tdouble sr_enter_plus_exit_time_us = base->ctx->dc->dml.soc.sr_enter_plus_exit_time_us;",
            "\tuint16_t min_uclk_mhz = base->bw_params->clk_table.entries[0].memclk_mhz;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\dcn30_fpu.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 44,
          "match": "double PixelClock",
          "context": [
            "typedef struct {",
            "\tdouble DPPCLK;",
            "\tdouble DISPCLK;",
            "\tdouble PixelClock;",
            "\tdouble DCFCLKDeepSleep;",
            "\tunsigned int DPPPerPlane;",
            "\tbool ScalerEnabled;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 144,
          "match": "double RoundToDFSGranularityUp(double Clock",
          "context": [
            "\t\tunsigned int *VUpdateOffsetPix,",
            "\t\tdouble *VUpdateWidthPix,",
            "\t\tdouble *VReadyOffsetPix);",
            "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed);",
            "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed);",
            "static double CalculateDCCConfiguration(",
            "\t\tbool                 DCCEnabled,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 145,
          "match": "double RoundToDFSGranularityDown(double Clock",
          "context": [
            "\t\tdouble *VUpdateWidthPix,",
            "\t\tdouble *VReadyOffsetPix);",
            "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed);",
            "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed);",
            "static double CalculateDCCConfiguration(",
            "\t\tbool                 DCCEnabled,",
            "\t\tbool                 DCCProgrammingAssumesScanDirectionUnknown,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 210,
          "match": "double DRAMClock",
          "context": [
            "",
            "static double CalculateTWait(",
            "\t\tunsigned int PrefetchMode,",
            "\t\tdouble DRAMClockChangeLatency,",
            "\t\tdouble UrgentLatency,",
            "\t\tdouble SREnterPlusExitTime);",
            "static double CalculateRemoteSurfaceFlipDelay("
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 306,
          "match": "double DRAMClock",
          "context": [
            "\t\tdouble WritebackLatency,",
            "\t\tdouble WritebackChunkSize,",
            "\t\tdouble SOCCLK,",
            "\t\tdouble DRAMClockChangeLatency,",
            "\t\tdouble SRExitTime,",
            "\t\tdouble SREnterPlusExitTime,",
            "\t\tdouble DCFCLKDeepSleep,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 325,
          "match": "double PixelClock",
          "context": [
            "\t\tunsigned int VTAPsChroma[],",
            "\t\tdouble VRatio[],",
            "\t\tunsigned int HTotal[],",
            "\t\tdouble PixelClock[],",
            "\t\tunsigned int BlendingAndTiming[],",
            "\t\tdouble BytePerPixelDETY[],",
            "\t\tdouble BytePerPixelDETC[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 337,
          "match": "double *DRAMClock",
          "context": [
            "\t\tenum clock_change_support *DRAMClockChangeSupport,",
            "\t\tdouble *UrgentWatermark,",
            "\t\tdouble *WritebackUrgentWatermark,",
            "\t\tdouble *DRAMClockChangeWatermark,",
            "\t\tdouble *WritebackDRAMClockChangeWatermark,",
            "\t\tdouble *StutterExitWatermark,",
            "\t\tdouble *StutterEnterPlusExitWatermark,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 338,
          "match": "double *WritebackDRAMClock",
          "context": [
            "\t\tdouble *UrgentWatermark,",
            "\t\tdouble *WritebackUrgentWatermark,",
            "\t\tdouble *DRAMClockChangeWatermark,",
            "\t\tdouble *WritebackDRAMClockChangeWatermark,",
            "\t\tdouble *StutterExitWatermark,",
            "\t\tdouble *StutterEnterPlusExitWatermark,",
            "\t\tdouble *MinActiveDRAMClockChangeLatencySupported);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 341,
          "match": "double *MinActiveDRAMClock",
          "context": [
            "\t\tdouble *WritebackDRAMClockChangeWatermark,",
            "\t\tdouble *StutterExitWatermark,",
            "\t\tdouble *StutterEnterPlusExitWatermark,",
            "\t\tdouble *MinActiveDRAMClockChangeLatencySupported);",
            "static void CalculateDCFCLKDeepSleep(",
            "\t\tstruct display_mode_lib *mode_lib,",
            "\t\tunsigned int NumberOfActivePlanes,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 351,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble SwathWidthY[],",
            "\t\tint DPPPerPlane[],",
            "\t\tdouble HRatio[],",
            "\t\tdouble PixelClock[],",
            "\t\tdouble PSCL_THROUGHPUT[],",
            "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
            "\t\tdouble DPPCLK[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 395,
          "match": "double                 PixelClock",
          "context": [
            "\t\tunsigned int           swath_width_chroma_ub[],",
            "\t\tint                    DPPPerPlane[],",
            "\t\tdouble                 HRatio[],",
            "\t\tdouble                 PixelClock[],",
            "\t\tdouble                 PSCL_THROUGHPUT[],",
            "\t\tdouble                 PSCL_THROUGHPUT_CHROMA[],",
            "\t\tdouble                 DPPCLK[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 429,
          "match": "double                 PixelClock",
          "context": [
            "\t\tdouble                 DestinationLinesToRequestVMInVBlank[],",
            "\t\tdouble                 DestinationLinesToRequestVMInImmediateFlip[],",
            "\t\tbool                   DCCEnable[],",
            "\t\tdouble                 PixelClock[],",
            "\t\tdouble                 BytePerPixelDETY[],",
            "\t\tdouble                 BytePerPixelDETC[],",
            "\t\tenum scan_direction_class SourceScan[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 765,
          "match": "double) (*VUpdateOffsetPix + *VUpdateWidthPix + *VReadyOffsetPix) / myPipe->PixelClock",
          "context": [
            "\t\t\tTotalRepeaterDelayTime + 20.0 / myPipe->DCFCLKDeepSleep + 10.0 / myPipe->DPPCLK)",
            "\t\t\t* myPipe->PixelClock;",
            "",
            "\tTsetup = (double) (*VUpdateOffsetPix + *VUpdateWidthPix + *VReadyOffsetPix) / myPipe->PixelClock;",
            "",
            "\tLineTime = (double) myPipe->HTotal / myPipe->PixelClock;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 767,
          "match": "double) myPipe->HTotal / myPipe->PixelClock",
          "context": [
            "",
            "\tTsetup = (double) (*VUpdateOffsetPix + *VUpdateWidthPix + *VReadyOffsetPix) / myPipe->PixelClock;",
            "",
            "\tLineTime = (double) myPipe->HTotal / myPipe->PixelClock;",
            "",
            "\tif (DynamicMetadataEnable) {",
            "\t\tdouble Tdmbf, Tdmec, Tdmsks;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 1064,
          "match": "double RoundToDFSGranularityUp(double Clock",
          "context": [
            "\treturn MyError;",
            "}",
            "",
            "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed)",
            "{",
            "\treturn VCOSpeed * 4 / dml_floor(VCOSpeed * 4 / Clock, 1);",
            "}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 1069,
          "match": "double RoundToDFSGranularityDown(double Clock",
          "context": [
            "\treturn VCOSpeed * 4 / dml_floor(VCOSpeed * 4 / Clock, 1);",
            "}",
            "",
            "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed)",
            "{",
            "\treturn VCOSpeed * 4 / dml_ceil(VCOSpeed * 4 / Clock, 1);",
            "}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 2813,
          "match": "double Read256BytesBlock",
          "context": [
            "\t// Display Pipe Configuration",
            "\tdouble BytePerPixDETY;",
            "\tdouble BytePerPixDETC;",
            "\tdouble Read256BytesBlockHeightY;",
            "\tdouble Read256BytesBlockHeightC;",
            "\tdouble Read256BytesBlockWidthY;",
            "\tdouble Read256BytesBlockWidthC;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 2814,
          "match": "double Read256BytesBlock",
          "context": [
            "\tdouble BytePerPixDETY;",
            "\tdouble BytePerPixDETC;",
            "\tdouble Read256BytesBlockHeightY;",
            "\tdouble Read256BytesBlockHeightC;",
            "\tdouble Read256BytesBlockWidthY;",
            "\tdouble Read256BytesBlockWidthC;",
            "\tdouble MaximumSwathHeightY;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 2815,
          "match": "double Read256BytesBlock",
          "context": [
            "\tdouble BytePerPixDETC;",
            "\tdouble Read256BytesBlockHeightY;",
            "\tdouble Read256BytesBlockHeightC;",
            "\tdouble Read256BytesBlockWidthY;",
            "\tdouble Read256BytesBlockWidthC;",
            "\tdouble MaximumSwathHeightY;",
            "\tdouble MaximumSwathHeightC;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 2816,
          "match": "double Read256BytesBlock",
          "context": [
            "\tdouble Read256BytesBlockHeightY;",
            "\tdouble Read256BytesBlockHeightC;",
            "\tdouble Read256BytesBlockWidthY;",
            "\tdouble Read256BytesBlockWidthC;",
            "\tdouble MaximumSwathHeightY;",
            "\tdouble MaximumSwathHeightC;",
            "\tdouble MinimumSwathHeightY;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 3009,
          "match": "double DRAMClock",
          "context": [
            "",
            "static double CalculateTWait(",
            "\t\tunsigned int PrefetchMode,",
            "\t\tdouble DRAMClockChangeLatency,",
            "\t\tdouble UrgentLatency,",
            "\t\tdouble SREnterPlusExitTime)",
            "{"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 5260,
          "match": "double DRAMClock",
          "context": [
            "\t\tdouble WritebackLatency,",
            "\t\tdouble WritebackChunkSize,",
            "\t\tdouble SOCCLK,",
            "\t\tdouble DRAMClockChangeLatency,",
            "\t\tdouble SRExitTime,",
            "\t\tdouble SREnterPlusExitTime,",
            "\t\tdouble DCFCLKDeepSleep,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 5279,
          "match": "double PixelClock",
          "context": [
            "\t\tunsigned int VTAPsChroma[],",
            "\t\tdouble VRatio[],",
            "\t\tunsigned int HTotal[],",
            "\t\tdouble PixelClock[],",
            "\t\tunsigned int BlendingAndTiming[],",
            "\t\tdouble BytePerPixelDETY[],",
            "\t\tdouble BytePerPixelDETC[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 5291,
          "match": "double *DRAMClock",
          "context": [
            "\t\tenum clock_change_support *DRAMClockChangeSupport,",
            "\t\tdouble *UrgentWatermark,",
            "\t\tdouble *WritebackUrgentWatermark,",
            "\t\tdouble *DRAMClockChangeWatermark,",
            "\t\tdouble *WritebackDRAMClockChangeWatermark,",
            "\t\tdouble *StutterExitWatermark,",
            "\t\tdouble *StutterEnterPlusExitWatermark,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 5292,
          "match": "double *WritebackDRAMClock",
          "context": [
            "\t\tdouble *UrgentWatermark,",
            "\t\tdouble *WritebackUrgentWatermark,",
            "\t\tdouble *DRAMClockChangeWatermark,",
            "\t\tdouble *WritebackDRAMClockChangeWatermark,",
            "\t\tdouble *StutterExitWatermark,",
            "\t\tdouble *StutterEnterPlusExitWatermark,",
            "\t\tdouble *MinActiveDRAMClockChangeLatencySupported)"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 5295,
          "match": "double *MinActiveDRAMClock",
          "context": [
            "\t\tdouble *WritebackDRAMClockChangeWatermark,",
            "\t\tdouble *StutterExitWatermark,",
            "\t\tdouble *StutterEnterPlusExitWatermark,",
            "\t\tdouble *MinActiveDRAMClockChangeLatencySupported)",
            "{",
            "\tdouble EffectiveLBLatencyHidingY;",
            "\tdouble EffectiveLBLatencyHidingC;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 5309,
          "match": "double ActiveDRAMClock",
          "context": [
            "\tunsigned int LinesInDETCRoundedDownToSwath;",
            "\tdouble FullDETBufferingTimeY[DC__NUM_DPP__MAX];",
            "\tdouble FullDETBufferingTimeC;",
            "\tdouble ActiveDRAMClockChangeLatencyMarginY;",
            "\tdouble ActiveDRAMClockChangeLatencyMarginC;",
            "\tdouble WritebackDRAMClockChangeLatencyMargin;",
            "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 5310,
          "match": "double ActiveDRAMClock",
          "context": [
            "\tdouble FullDETBufferingTimeY[DC__NUM_DPP__MAX];",
            "\tdouble FullDETBufferingTimeC;",
            "\tdouble ActiveDRAMClockChangeLatencyMarginY;",
            "\tdouble ActiveDRAMClockChangeLatencyMarginC;",
            "\tdouble WritebackDRAMClockChangeLatencyMargin;",
            "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;",
            "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 5311,
          "match": "double WritebackDRAMClock",
          "context": [
            "\tdouble FullDETBufferingTimeC;",
            "\tdouble ActiveDRAMClockChangeLatencyMarginY;",
            "\tdouble ActiveDRAMClockChangeLatencyMarginC;",
            "\tdouble WritebackDRAMClockChangeLatencyMargin;",
            "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;",
            "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank;",
            "\tdouble FullDETBufferingTimeYStutterCriticalPlane = 0;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 5312,
          "match": "double PlaneWithMinActiveDRAMClock",
          "context": [
            "\tdouble ActiveDRAMClockChangeLatencyMarginY;",
            "\tdouble ActiveDRAMClockChangeLatencyMarginC;",
            "\tdouble WritebackDRAMClockChangeLatencyMargin;",
            "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;",
            "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank;",
            "\tdouble FullDETBufferingTimeYStutterCriticalPlane = 0;",
            "\tdouble TimeToFinishSwathTransferStutterCriticalPlane = 0;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 5313,
          "match": "double SecondMinActiveDRAMClock",
          "context": [
            "\tdouble ActiveDRAMClockChangeLatencyMarginC;",
            "\tdouble WritebackDRAMClockChangeLatencyMargin;",
            "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;",
            "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank;",
            "\tdouble FullDETBufferingTimeYStutterCriticalPlane = 0;",
            "\tdouble TimeToFinishSwathTransferStutterCriticalPlane = 0;",
            "\tunsigned int k, j;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 5532,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble SwathWidthY[],",
            "\t\tint DPPPerPlane[],",
            "\t\tdouble HRatio[],",
            "\t\tdouble PixelClock[],",
            "\t\tdouble PSCL_THROUGHPUT[],",
            "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
            "\t\tdouble DPPCLK[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 5738,
          "match": "double PixelClock",
          "context": [
            "\t\tunsigned int swath_width_chroma_ub[],",
            "\t\tint DPPPerPlane[],",
            "\t\tdouble HRatio[],",
            "\t\tdouble PixelClock[],",
            "\t\tdouble PSCL_THROUGHPUT[],",
            "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
            "\t\tdouble DPPCLK[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c",
          "line": 5847,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble DestinationLinesToRequestVMInVBlank[],",
            "\t\tdouble DestinationLinesToRequestVMInImmediateFlip[],",
            "\t\tbool DCCEnable[],",
            "\t\tdouble PixelClock[],",
            "\t\tdouble BytePerPixelDETY[],",
            "\t\tdouble BytePerPixelDETC[],",
            "\t\tenum scan_direction_class SourceScan[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn21\\display_mode_vba_21.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn301\\dcn301_fpu.c",
          "line": 299,
          "match": "double dram_clock_change_latency_cached = dml->soc.dram_clock",
          "context": [
            "\t\tdisplay_e2e_pipe_params_st *pipes,",
            "\t\tint pipe_cnt)",
            "{",
            "\tdouble dram_clock_change_latency_cached = dml->soc.dram_clock_change_latency_us;",
            "",
            "\tASSERT(vlevel < dml->soc.num_states);",
            "\t/* only pipe 0 is read for voltage and dcf/soc clocks */"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn301\\dcn301_fpu.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 45,
          "match": "double PixelClock",
          "context": [
            "typedef struct {",
            "\tdouble DPPCLK;",
            "\tdouble DISPCLK;",
            "\tdouble PixelClock;",
            "\tdouble DCFCLKDeepSleep;",
            "\tunsigned int DPPPerPlane;",
            "\tbool ScalerEnabled;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 146,
          "match": "double RoundToDFSGranularityUp(double Clock",
          "context": [
            "\t\tunsigned int *VUpdateOffsetPix,",
            "\t\tdouble *VUpdateWidthPix,",
            "\t\tdouble *VReadyOffsetPix);",
            "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed);",
            "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed);",
            "static void CalculateDCCConfiguration(",
            "\t\tbool DCCEnabled,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 147,
          "match": "double RoundToDFSGranularityDown(double Clock",
          "context": [
            "\t\tdouble *VUpdateWidthPix,",
            "\t\tdouble *VReadyOffsetPix);",
            "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed);",
            "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed);",
            "static void CalculateDCCConfiguration(",
            "\t\tbool DCCEnabled,",
            "\t\tbool DCCProgrammingAssumesScanDirectionUnknown,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 219,
          "match": "double DRAMClock",
          "context": [
            "\t\tunsigned int *MetaPTEBytesFrame);",
            "static double CalculateTWait(",
            "\t\tunsigned int PrefetchMode,",
            "\t\tdouble DRAMClockChangeLatency,",
            "\t\tdouble UrgentLatency,",
            "\t\tdouble SREnterPlusExitTime);",
            "static void CalculateRowBandwidth("
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 283,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble DPPCLK,",
            "\t\tdouble DISPCLK,",
            "\t\tdouble DCFClkDeepSleep,",
            "\t\tdouble PixelClock,",
            "\t\tunsigned int HTotal,",
            "\t\tunsigned int VBlank,",
            "\t\tunsigned int DynamicMetadataTransmittedBytes,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 313,
          "match": "double DRAMClock",
          "context": [
            "\t\tdouble WritebackLatency,",
            "\t\tdouble WritebackChunkSize,",
            "\t\tdouble SOCCLK,",
            "\t\tdouble DRAMClockChangeLatency,",
            "\t\tdouble SRExitTime,",
            "\t\tdouble SREnterPlusExitTime,",
            "\t\tdouble DCFCLKDeepSleep,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 334,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble VRatio[],",
            "\t\tdouble VRatioChroma[],",
            "\t\tunsigned int HTotal[],",
            "\t\tdouble PixelClock[],",
            "\t\tunsigned int BlendingAndTiming[],",
            "\t\tdouble BytePerPixelDETY[],",
            "\t\tdouble BytePerPixelDETC[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 348,
          "match": "double *DRAMClock",
          "context": [
            "\t\tenum clock_change_support *DRAMClockChangeSupport,",
            "\t\tdouble *UrgentWatermark,",
            "\t\tdouble *WritebackUrgentWatermark,",
            "\t\tdouble *DRAMClockChangeWatermark,",
            "\t\tdouble *WritebackDRAMClockChangeWatermark,",
            "\t\tdouble *StutterExitWatermark,",
            "\t\tdouble *StutterEnterPlusExitWatermark,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 349,
          "match": "double *WritebackDRAMClock",
          "context": [
            "\t\tdouble *UrgentWatermark,",
            "\t\tdouble *WritebackUrgentWatermark,",
            "\t\tdouble *DRAMClockChangeWatermark,",
            "\t\tdouble *WritebackDRAMClockChangeWatermark,",
            "\t\tdouble *StutterExitWatermark,",
            "\t\tdouble *StutterEnterPlusExitWatermark,",
            "\t\tdouble *MinActiveDRAMClockChangeLatencySupported);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 352,
          "match": "double *MinActiveDRAMClock",
          "context": [
            "\t\tdouble *WritebackDRAMClockChangeWatermark,",
            "\t\tdouble *StutterExitWatermark,",
            "\t\tdouble *StutterEnterPlusExitWatermark,",
            "\t\tdouble *MinActiveDRAMClockChangeLatencySupported);",
            "static void CalculateDCFCLKDeepSleep(",
            "\t\tstruct display_mode_lib *mode_lib,",
            "\t\tunsigned int NumberOfActivePlanes,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 365,
          "match": "double PixelClock",
          "context": [
            "\t\tunsigned int DPPPerPlane[],",
            "\t\tdouble HRatio[],",
            "\t\tdouble HRatioChroma[],",
            "\t\tdouble PixelClock[],",
            "\t\tdouble PSCL_THROUGHPUT[],",
            "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
            "\t\tdouble DPPCLK[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 412,
          "match": "double PixelClock",
          "context": [
            "\t\tunsigned int DPPPerPlane[],",
            "\t\tdouble HRatio[],",
            "\t\tdouble HRatioChroma[],",
            "\t\tdouble PixelClock[],",
            "\t\tdouble PSCL_THROUGHPUT[],",
            "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
            "\t\tdouble DPPCLK[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 447,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble DestinationLinesToRequestRowInVBlank[],",
            "\t\tdouble DestinationLinesToRequestRowInImmediateFlip[],",
            "\t\tbool DCCEnable[],",
            "\t\tdouble PixelClock[],",
            "\t\tint BytePerPixelY[],",
            "\t\tint BytePerPixelC[],",
            "\t\tenum scan_direction_class SourceScan[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 496,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble DestinationLinesToRequestVMInVBlank[],",
            "\t\tdouble DestinationLinesToRequestVMInImmediateFlip[],",
            "\t\tbool DCCEnable[],",
            "\t\tdouble PixelClock[],",
            "\t\tint dpte_row_width_luma_ub[],",
            "\t\tint dpte_row_width_chroma_ub[],",
            "\t\tint vm_group_bytes[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 528,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble DCCRateChroma[],",
            "\t\tint HTotal[],",
            "\t\tint VTotal[],",
            "\t\tdouble PixelClock[],",
            "\t\tdouble VRatio[],",
            "\t\tenum scan_direction_class SourceScan[],",
            "\t\tint BlockHeight256BytesY[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 655,
          "match": "double UrgentLatencyAdjustmentFabricClock",
          "context": [
            "\t\tdouble UrgentLatencyPixelMixedWithVMData,",
            "\t\tdouble UrgentLatencyVMDataOnly,",
            "\t\tbool DoUrgentLatencyAdjustment,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
            "\t\tdouble FabricClockSingle);",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 656,
          "match": "double UrgentLatencyAdjustmentFabricClock",
          "context": [
            "\t\tdouble UrgentLatencyVMDataOnly,",
            "\t\tbool DoUrgentLatencyAdjustment,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
            "\t\tdouble FabricClockSingle);",
            "",
            "void dml30_recalculate(struct display_mode_lib *mode_lib)"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 657,
          "match": "double FabricClock",
          "context": [
            "\t\tbool DoUrgentLatencyAdjustment,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
            "\t\tdouble FabricClockSingle);",
            "",
            "void dml30_recalculate(struct display_mode_lib *mode_lib)",
            "{"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 1296,
          "match": "double RoundToDFSGranularityUp(double Clock",
          "context": [
            "\treturn MyError;",
            "}",
            "",
            "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed)",
            "{",
            "\treturn VCOSpeed * 4 / dml_floor(VCOSpeed * 4 / Clock, 1);",
            "}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 1301,
          "match": "double RoundToDFSGranularityDown(double Clock",
          "context": [
            "\treturn VCOSpeed * 4 / dml_floor(VCOSpeed * 4 / Clock, 1);",
            "}",
            "",
            "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed)",
            "{",
            "\treturn VCOSpeed * 4 / dml_ceil(VCOSpeed * 4.0 / Clock, 1);",
            "}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 2386,
          "match": "double) v->WritebackDelay[v->VoltageLevel][k] / (v->HTotal[k] / v->PixelClock",
          "context": [
            "\t\t\t\tv->WritebackDelay[v->VoltageLevel][k] = v->WritebackDelay[v->VoltageLevel][j];",
            "",
            "\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {",
            "\t\tv->MaxVStartupLines[k] = v->VTotal[k] - v->VActive[k] - dml_max(1.0, dml_ceil((double) v->WritebackDelay[v->VoltageLevel][k] / (v->HTotal[k] / v->PixelClock[k]), 1));",
            "\t}",
            "",
            "\tv->MaximumMaxVStartupLines = 0;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 3207,
          "match": "double DRAMClock",
          "context": [
            "",
            "static double CalculateTWait(",
            "\t\tunsigned int PrefetchMode,",
            "\t\tdouble DRAMClockChangeLatency,",
            "\t\tdouble UrgentLatency,",
            "\t\tdouble SREnterPlusExitTime)",
            "{"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 3223,
          "match": "double PixelClock",
          "context": [
            "",
            "double dml30_CalculateWriteBackDISPCLK(",
            "\t\tenum source_format_class WritebackPixelFormat,",
            "\t\tdouble PixelClock,",
            "\t\tdouble WritebackHRatio,",
            "\t\tdouble WritebackVRatio,",
            "\t\tunsigned int WritebackHTaps,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 3269,
          "match": "double DCFClkDeepSleep, double PixelClock",
          "context": [
            "",
            "",
            "static void CalculateDynamicMetadataParameters(int MaxInterDCNTileRepeaters, double DPPCLK, double DISPCLK,",
            "\t\tdouble DCFClkDeepSleep, double PixelClock, unsigned int HTotal, unsigned int VBlank, unsigned int DynamicMetadataTransmittedBytes,",
            "\t\tint DynamicMetadataLinesBeforeActiveRequired, int InterlaceEnable, bool ProgressiveToInterlaceUnitInOPP,",
            "\t\tdouble *Tsetup, double *Tdmbf, double *Tdmec, double *Tdmsks)",
            "{"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 3442,
          "match": "double PixelClock",
          "context": [
            "\t\tint Lanes,",
            "\t\tlong HTotal,",
            "\t\tlong HActive,",
            "\t\tdouble PixelClock,",
            "\t\tdouble DesiredBPP,",
            "\t\tbool DSCEnable,",
            "\t\tenum output_encoder_class Output,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 5198,
          "match": "double DRAMClock",
          "context": [
            "\t\tdouble WritebackLatency,",
            "\t\tdouble WritebackChunkSize,",
            "\t\tdouble SOCCLK,",
            "\t\tdouble DRAMClockChangeLatency,",
            "\t\tdouble SRExitTime,",
            "\t\tdouble SREnterPlusExitTime,",
            "\t\tdouble DCFCLKDeepSleep,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 5219,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble VRatio[],",
            "\t\tdouble VRatioChroma[],",
            "\t\tunsigned int HTotal[],",
            "\t\tdouble PixelClock[],",
            "\t\tunsigned int BlendingAndTiming[],",
            "\t\tdouble BytePerPixelDETY[],",
            "\t\tdouble BytePerPixelDETC[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 5233,
          "match": "double *DRAMClock",
          "context": [
            "\t\tenum clock_change_support *DRAMClockChangeSupport,",
            "\t\tdouble *UrgentWatermark,",
            "\t\tdouble *WritebackUrgentWatermark,",
            "\t\tdouble *DRAMClockChangeWatermark,",
            "\t\tdouble *WritebackDRAMClockChangeWatermark,",
            "\t\tdouble *StutterExitWatermark,",
            "\t\tdouble *StutterEnterPlusExitWatermark,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 5234,
          "match": "double *WritebackDRAMClock",
          "context": [
            "\t\tdouble *UrgentWatermark,",
            "\t\tdouble *WritebackUrgentWatermark,",
            "\t\tdouble *DRAMClockChangeWatermark,",
            "\t\tdouble *WritebackDRAMClockChangeWatermark,",
            "\t\tdouble *StutterExitWatermark,",
            "\t\tdouble *StutterEnterPlusExitWatermark,",
            "\t\tdouble *MinActiveDRAMClockChangeLatencySupported)"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 5237,
          "match": "double *MinActiveDRAMClock",
          "context": [
            "\t\tdouble *WritebackDRAMClockChangeWatermark,",
            "\t\tdouble *StutterExitWatermark,",
            "\t\tdouble *StutterEnterPlusExitWatermark,",
            "\t\tdouble *MinActiveDRAMClockChangeLatencySupported)",
            "{",
            "\tdouble EffectiveLBLatencyHidingY = 0;",
            "\tdouble EffectiveLBLatencyHidingC = 0;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 5247,
          "match": "double ActiveDRAMClock",
          "context": [
            "\tunsigned int LinesInDETCRoundedDownToSwath = 0;",
            "\tdouble FullDETBufferingTimeY[DC__NUM_DPP__MAX] = { 0 };",
            "\tdouble FullDETBufferingTimeC = 0;",
            "\tdouble ActiveDRAMClockChangeLatencyMarginY = 0;",
            "\tdouble ActiveDRAMClockChangeLatencyMarginC = 0;",
            "\tdouble WritebackDRAMClockChangeLatencyMargin = 0;",
            "\tdouble PlaneWithMinActiveDRAMClockChangeMargin = 0;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 5248,
          "match": "double ActiveDRAMClock",
          "context": [
            "\tdouble FullDETBufferingTimeY[DC__NUM_DPP__MAX] = { 0 };",
            "\tdouble FullDETBufferingTimeC = 0;",
            "\tdouble ActiveDRAMClockChangeLatencyMarginY = 0;",
            "\tdouble ActiveDRAMClockChangeLatencyMarginC = 0;",
            "\tdouble WritebackDRAMClockChangeLatencyMargin = 0;",
            "\tdouble PlaneWithMinActiveDRAMClockChangeMargin = 0;",
            "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank = 0;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 5249,
          "match": "double WritebackDRAMClock",
          "context": [
            "\tdouble FullDETBufferingTimeC = 0;",
            "\tdouble ActiveDRAMClockChangeLatencyMarginY = 0;",
            "\tdouble ActiveDRAMClockChangeLatencyMarginC = 0;",
            "\tdouble WritebackDRAMClockChangeLatencyMargin = 0;",
            "\tdouble PlaneWithMinActiveDRAMClockChangeMargin = 0;",
            "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank = 0;",
            "\tdouble FullDETBufferingTimeYStutterCriticalPlane = 0;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 5250,
          "match": "double PlaneWithMinActiveDRAMClock",
          "context": [
            "\tdouble ActiveDRAMClockChangeLatencyMarginY = 0;",
            "\tdouble ActiveDRAMClockChangeLatencyMarginC = 0;",
            "\tdouble WritebackDRAMClockChangeLatencyMargin = 0;",
            "\tdouble PlaneWithMinActiveDRAMClockChangeMargin = 0;",
            "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank = 0;",
            "\tdouble FullDETBufferingTimeYStutterCriticalPlane = 0;",
            "\tdouble TimeToFinishSwathTransferStutterCriticalPlane = 0;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 5251,
          "match": "double SecondMinActiveDRAMClock",
          "context": [
            "\tdouble ActiveDRAMClockChangeLatencyMarginC = 0;",
            "\tdouble WritebackDRAMClockChangeLatencyMargin = 0;",
            "\tdouble PlaneWithMinActiveDRAMClockChangeMargin = 0;",
            "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank = 0;",
            "\tdouble FullDETBufferingTimeYStutterCriticalPlane = 0;",
            "\tdouble TimeToFinishSwathTransferStutterCriticalPlane = 0;",
            "\tdouble WritebackDRAMClockChangeLatencyHiding = 0;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 5254,
          "match": "double WritebackDRAMClock",
          "context": [
            "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank = 0;",
            "\tdouble FullDETBufferingTimeYStutterCriticalPlane = 0;",
            "\tdouble TimeToFinishSwathTransferStutterCriticalPlane = 0;",
            "\tdouble WritebackDRAMClockChangeLatencyHiding = 0;",
            "\tunsigned int k, j;",
            "",
            "\tmode_lib->vba.TotalActiveDPP = 0;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 5408,
          "match": "double PixelClock",
          "context": [
            "\t\tunsigned int DPPPerPlane[],",
            "\t\tdouble HRatio[],",
            "\t\tdouble HRatioChroma[],",
            "\t\tdouble PixelClock[],",
            "\t\tdouble PSCL_THROUGHPUT[],",
            "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
            "\t\tdouble DPPCLK[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 5546,
          "match": "double PixelClock",
          "context": [
            "\t\tunsigned int DPPPerPlane[],",
            "\t\tdouble HRatio[],",
            "\t\tdouble HRatioChroma[],",
            "\t\tdouble PixelClock[],",
            "\t\tdouble PSCL_THROUGHPUT[],",
            "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
            "\t\tdouble DPPCLK[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 5661,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble DestinationLinesToRequestRowInVBlank[],",
            "\t\tdouble DestinationLinesToRequestRowInImmediateFlip[],",
            "\t\tbool DCCEnable[],",
            "\t\tdouble PixelClock[],",
            "\t\tint BytePerPixelY[],",
            "\t\tint BytePerPixelC[],",
            "\t\tenum scan_direction_class SourceScan[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 5832,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble DestinationLinesToRequestVMInVBlank[],",
            "\t\tdouble DestinationLinesToRequestVMInImmediateFlip[],",
            "\t\tbool DCCEnable[],",
            "\t\tdouble PixelClock[],",
            "\t\tint dpte_row_width_luma_ub[],",
            "\t\tint dpte_row_width_chroma_ub[],",
            "\t\tint vm_group_bytes[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 5953,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble DCCRateChroma[],",
            "\t\tint HTotal[],",
            "\t\tint VTotal[],",
            "\t\tdouble PixelClock[],",
            "\t\tdouble VRatio[],",
            "\t\tenum scan_direction_class SourceScan[],",
            "\t\tint BlockHeight256BytesY[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 6475,
          "match": "double UrgentLatencyAdjustmentFabricClock",
          "context": [
            "\t\tdouble UrgentLatencyPixelMixedWithVMData,",
            "\t\tdouble UrgentLatencyVMDataOnly,",
            "\t\tbool DoUrgentLatencyAdjustment,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
            "\t\tdouble FabricClock)",
            "{"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 6476,
          "match": "double UrgentLatencyAdjustmentFabricClock",
          "context": [
            "\t\tdouble UrgentLatencyVMDataOnly,",
            "\t\tbool DoUrgentLatencyAdjustment,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
            "\t\tdouble FabricClock)",
            "{",
            "\tdouble ret;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c",
          "line": 6477,
          "match": "double FabricClock",
          "context": [
            "\t\tbool DoUrgentLatencyAdjustment,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
            "\t\tdouble FabricClock)",
            "{",
            "\tdouble ret;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn30\\display_mode_vba_30.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 63,
          "match": "double PixelClock",
          "context": [
            "typedef struct {",
            "\tdouble DPPCLK;",
            "\tdouble DISPCLK;",
            "\tdouble PixelClock;",
            "\tdouble DCFCLKDeepSleep;",
            "\tunsigned int DPPPerPlane;",
            "\tbool ScalerEnabled;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 172,
          "match": "double RoundToDFSGranularityUp(double Clock",
          "context": [
            "\t\tint *VUpdateOffsetPix,",
            "\t\tdouble *VUpdateWidthPix,",
            "\t\tdouble *VReadyOffsetPix);",
            "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed);",
            "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed);",
            "static void CalculateDCCConfiguration(",
            "\t\tbool DCCEnabled,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 173,
          "match": "double RoundToDFSGranularityDown(double Clock",
          "context": [
            "\t\tdouble *VUpdateWidthPix,",
            "\t\tdouble *VReadyOffsetPix);",
            "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed);",
            "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed);",
            "static void CalculateDCCConfiguration(",
            "\t\tbool DCCEnabled,",
            "\t\tbool DCCProgrammingAssumesScanDirectionUnknown,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 243,
          "match": "double CalculateTWait(unsigned int PrefetchMode, double DRAMClock",
          "context": [
            "\t\tunsigned int *PTERequestSize,",
            "\t\tint *DPDE0BytesFrame,",
            "\t\tint *MetaPTEBytesFrame);",
            "static double CalculateTWait(unsigned int PrefetchMode, double DRAMClockChangeLatency, double UrgentLatency, double SREnterPlusExitTime);",
            "static void CalculateRowBandwidth(",
            "\t\tbool GPUVMEnable,",
            "\t\tenum source_format_class SourcePixelFormat,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 286,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble DPPCLK,",
            "\t\tdouble DISPCLK,",
            "\t\tdouble DCFClkDeepSleep,",
            "\t\tdouble PixelClock,",
            "\t\tint HTotal,",
            "\t\tint VBlank,",
            "\t\tint DynamicMetadataTransmittedBytes,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 339,
          "match": "double PixelClock",
          "context": [
            "\t\tunsigned int DPPPerPlane[],",
            "\t\tdouble HRatio[],",
            "\t\tdouble HRatioChroma[],",
            "\t\tdouble PixelClock[],",
            "\t\tdouble PSCL_THROUGHPUT[],",
            "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
            "\t\tdouble DPPCLK[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 385,
          "match": "double PixelClock",
          "context": [
            "\t\tunsigned int DPPPerPlane[],",
            "\t\tdouble HRatio[],",
            "\t\tdouble HRatioChroma[],",
            "\t\tdouble PixelClock[],",
            "\t\tdouble PSCL_THROUGHPUT[],",
            "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
            "\t\tdouble DPPCLK[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 420,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble DestinationLinesToRequestRowInVBlank[],",
            "\t\tdouble DestinationLinesToRequestRowInImmediateFlip[],",
            "\t\tbool DCCEnable[],",
            "\t\tdouble PixelClock[],",
            "\t\tint BytePerPixelY[],",
            "\t\tint BytePerPixelC[],",
            "\t\tenum scan_direction_class SourceScan[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 469,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble DestinationLinesToRequestVMInVBlank[],",
            "\t\tdouble DestinationLinesToRequestVMInImmediateFlip[],",
            "\t\tbool DCCEnable[],",
            "\t\tdouble PixelClock[],",
            "\t\tint dpte_row_width_luma_ub[],",
            "\t\tint dpte_row_width_chroma_ub[],",
            "\t\tint vm_group_bytes[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 517,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble DCCFractionOfZeroSizeRequestsChroma[],",
            "\t\tint HTotal[],",
            "\t\tint VTotal[],",
            "\t\tdouble PixelClock[],",
            "\t\tdouble VRatio[],",
            "\t\tenum scan_direction_class SourceScan[],",
            "\t\tint BlockHeight256BytesY[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 649,
          "match": "double UrgentLatencyAdjustmentFabricClock",
          "context": [
            "\t\tdouble UrgentLatencyPixelMixedWithVMData,",
            "\t\tdouble UrgentLatencyVMDataOnly,",
            "\t\tbool DoUrgentLatencyAdjustment,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
            "\t\tdouble FabricClockSingle);",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 650,
          "match": "double UrgentLatencyAdjustmentFabricClock",
          "context": [
            "\t\tdouble UrgentLatencyVMDataOnly,",
            "\t\tbool DoUrgentLatencyAdjustment,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
            "\t\tdouble FabricClockSingle);",
            "",
            "static void CalculateUnboundedRequestAndCompressedBufferSize("
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 651,
          "match": "double FabricClock",
          "context": [
            "\t\tbool DoUrgentLatencyAdjustment,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
            "\t\tdouble FabricClockSingle);",
            "",
            "static void CalculateUnboundedRequestAndCompressedBufferSize(",
            "\t\tunsigned int DETBufferSizeInKByte,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 671,
          "match": "double PixelClock",
          "context": [
            "\t\tunsigned int VActive,",
            "\t\tunsigned int VBlankNom,",
            "\t\tunsigned int HTotal,",
            "\t\tdouble PixelClock,",
            "\t\tbool ProgressiveTointerlaceUnitinOPP,",
            "\t\tbool Interlace,",
            "\t\tunsigned int VBlankNomDefaultUS,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 1477,
          "match": "double RoundToDFSGranularityUp(double Clock",
          "context": [
            "\treturn MyError;",
            "}",
            "",
            "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed)",
            "{",
            "\treturn VCOSpeed * 4 / dml_floor(VCOSpeed * 4 / Clock, 1);",
            "}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 1482,
          "match": "double RoundToDFSGranularityDown(double Clock",
          "context": [
            "\treturn VCOSpeed * 4 / dml_floor(VCOSpeed * 4 / Clock, 1);",
            "}",
            "",
            "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed)",
            "{",
            "\treturn VCOSpeed * 4 / dml_ceil(VCOSpeed * 4.0 / Clock, 1);",
            "}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 2605,
          "match": "double TWait = CalculateTWait(PrefetchMode, v->DRAMClock",
          "context": [
            "\t\tdouble MaxTotalRDBandwidthNoUrgentBurst = 0.0;",
            "\t\tbool DestinationLineTimesForPrefetchLessThan2 = false;",
            "\t\tbool VRatioPrefetchMoreThan4 = false;",
            "\t\tdouble TWait = CalculateTWait(PrefetchMode, v->DRAMClockChangeLatency, v->UrgentLatency, v->SREnterPlusExitTime);",
            "",
            "\t\tMaxTotalRDBandwidth = 0;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 3150,
          "match": "double Tvstartup_margin = (v->MaxVStartupLines[k] - v->VStartup[k]) * v->HTotal[k] / v->PixelClock",
          "context": [
            "\t// VStartup Adjustment",
            "\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {",
            "\t\tbool isInterlaceTiming;",
            "\t\tdouble Tvstartup_margin = (v->MaxVStartupLines[k] - v->VStartup[k]) * v->HTotal[k] / v->PixelClock[k];",
            "#ifdef __DML_VBA_DEBUG__",
            "\t\tdml_print(\"DML::%s: k=%d, MinTTUVBlank = %f (before margin)\\n\", __func__, k, v->MinTTUVBlank[k]);",
            "#endif"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 3176,
          "match": "double)v->HTotal[k] / v->PixelClock",
          "context": [
            "\t\t} else {",
            "\t\t\tv->MIN_DST_Y_NEXT_START[k] = v->VTotal[k] - v->VFrontPorch[k] + v->VTotal[k] - v->VActive[k] - v->VStartup[k];",
            "\t\t}",
            "\t\tv->MIN_DST_Y_NEXT_START[k] += dml_floor(4.0 * v->TSetup[k] / ((double)v->HTotal[k] / v->PixelClock[k]), 1.0) / 4.0;",
            "\t\tif (((v->VUpdateOffsetPix[k] + v->VUpdateWidthPix[k] + v->VReadyOffsetPix[k]) / v->HTotal[k])",
            "\t\t\t\t<= (isInterlaceTiming ?",
            "\t\t\t\t\t\tdml_floor((v->VTotal[k] - v->VActive[k] - v->VFrontPorch[k] - v->VStartup[k]) / 2.0, 1.0) :"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 3451,
          "match": "double CalculateTWait(unsigned int PrefetchMode, double DRAMClock",
          "context": [
            "\treturn true;",
            "}",
            "",
            "static double CalculateTWait(unsigned int PrefetchMode, double DRAMClockChangeLatency, double UrgentLatency, double SREnterPlusExitTime)",
            "{",
            "\tif (PrefetchMode == 0) {",
            "\t\treturn dml_max(DRAMClockChangeLatency + UrgentLatency, dml_max(SREnterPlusExitTime, UrgentLatency));"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 3464,
          "match": "double PixelClock",
          "context": [
            "",
            "double dml314_CalculateWriteBackDISPCLK(",
            "\t\tenum source_format_class WritebackPixelFormat,",
            "\t\tdouble PixelClock,",
            "\t\tdouble WritebackHRatio,",
            "\t\tdouble WritebackVRatio,",
            "\t\tunsigned int WritebackHTaps,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 3513,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble DPPCLK,",
            "\t\tdouble DISPCLK,",
            "\t\tdouble DCFClkDeepSleep,",
            "\t\tdouble PixelClock,",
            "\t\tint HTotal,",
            "\t\tint VBlank,",
            "\t\tint DynamicMetadataTransmittedBytes,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 3604,
          "match": "double LineTime = v->HTotal[k] / v->PixelClock",
          "context": [
            "\tdouble TimeForFetchingMetaPTEImmediateFlip;",
            "\tdouble TimeForFetchingRowInVBlankImmediateFlip;",
            "\tdouble ImmediateFlipBW = 1.0;",
            "\tdouble LineTime = v->HTotal[k] / v->PixelClock[k];",
            "",
            "\tif (v->GPUVMEnable == true && v->HostVMEnable == true) {",
            "\t\tHostVMDynamicLevelsTrips = v->HostVMMaxNonCachedPageTableLevels;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 3692,
          "match": "double PixelClock",
          "context": [
            "\t\tint Lanes,",
            "\t\tint HTotal,",
            "\t\tint HActive,",
            "\t\tdouble PixelClock,",
            "\t\tdouble DesiredBPP,",
            "\t\tbool DSCEnable,",
            "\t\tenum output_encoder_class Output,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 5672,
          "match": "double ActiveDRAMClock",
          "context": [
            "\tunsigned int LinesInDETCRoundedDownToSwath;",
            "\tdouble FullDETBufferingTimeY;",
            "\tdouble FullDETBufferingTimeC;",
            "\tdouble ActiveDRAMClockChangeLatencyMarginY;",
            "\tdouble ActiveDRAMClockChangeLatencyMarginC;",
            "\tdouble WritebackDRAMClockChangeLatencyMargin;",
            "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 5673,
          "match": "double ActiveDRAMClock",
          "context": [
            "\tdouble FullDETBufferingTimeY;",
            "\tdouble FullDETBufferingTimeC;",
            "\tdouble ActiveDRAMClockChangeLatencyMarginY;",
            "\tdouble ActiveDRAMClockChangeLatencyMarginC;",
            "\tdouble WritebackDRAMClockChangeLatencyMargin;",
            "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;",
            "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 5674,
          "match": "double WritebackDRAMClock",
          "context": [
            "\tdouble FullDETBufferingTimeC;",
            "\tdouble ActiveDRAMClockChangeLatencyMarginY;",
            "\tdouble ActiveDRAMClockChangeLatencyMarginC;",
            "\tdouble WritebackDRAMClockChangeLatencyMargin;",
            "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;",
            "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank;",
            "\tdouble WritebackDRAMClockChangeLatencyHiding;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 5675,
          "match": "double PlaneWithMinActiveDRAMClock",
          "context": [
            "\tdouble ActiveDRAMClockChangeLatencyMarginY;",
            "\tdouble ActiveDRAMClockChangeLatencyMarginC;",
            "\tdouble WritebackDRAMClockChangeLatencyMargin;",
            "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;",
            "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank;",
            "\tdouble WritebackDRAMClockChangeLatencyHiding;",
            "\tdouble TotalPixelBW = 0.0;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 5676,
          "match": "double SecondMinActiveDRAMClock",
          "context": [
            "\tdouble ActiveDRAMClockChangeLatencyMarginC;",
            "\tdouble WritebackDRAMClockChangeLatencyMargin;",
            "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;",
            "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank;",
            "\tdouble WritebackDRAMClockChangeLatencyHiding;",
            "\tdouble TotalPixelBW = 0.0;",
            "\tint k, j;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 5677,
          "match": "double WritebackDRAMClock",
          "context": [
            "\tdouble WritebackDRAMClockChangeLatencyMargin;",
            "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;",
            "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank;",
            "\tdouble WritebackDRAMClockChangeLatencyHiding;",
            "\tdouble TotalPixelBW = 0.0;",
            "\tint k, j;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 5754,
          "match": "double) v->DSTXAfterScaler[k] / v->HTotal[k] + v->DSTYAfterScaler[k]) * v->HTotal[k] / v->PixelClock[k] - v->UrgentWatermark - v->DRAMClock",
          "context": [
            "\t\t}",
            "",
            "\t\tActiveDRAMClockChangeLatencyMarginY = EffectiveLBLatencyHidingY + FullDETBufferingTimeY",
            "\t\t\t\t- ((double) v->DSTXAfterScaler[k] / v->HTotal[k] + v->DSTYAfterScaler[k]) * v->HTotal[k] / v->PixelClock[k] - v->UrgentWatermark - v->DRAMClockChangeWatermark;",
            "",
            "\t\tif (v->NumberOfActivePlanes > 1) {",
            "\t\t\tActiveDRAMClockChangeLatencyMarginY = ActiveDRAMClockChangeLatencyMarginY"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 5763,
          "match": "double) v->DSTXAfterScaler[k] / v->HTotal[k] + v->DSTYAfterScaler[k]) * v->HTotal[k] / v->PixelClock[k] - v->UrgentWatermark - v->DRAMClock",
          "context": [
            "",
            "\t\tif (BytePerPixelDETC[k] > 0) {",
            "\t\t\tActiveDRAMClockChangeLatencyMarginC = EffectiveLBLatencyHidingC + FullDETBufferingTimeC",
            "\t\t\t\t\t- ((double) v->DSTXAfterScaler[k] / v->HTotal[k] + v->DSTYAfterScaler[k]) * v->HTotal[k] / v->PixelClock[k] - v->UrgentWatermark - v->DRAMClockChangeWatermark;",
            "",
            "\t\t\tif (v->NumberOfActivePlanes > 1) {",
            "\t\t\t\tActiveDRAMClockChangeLatencyMarginC = ActiveDRAMClockChangeLatencyMarginC"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 5854,
          "match": "double PixelClock",
          "context": [
            "\t\tunsigned int DPPPerPlane[],",
            "\t\tdouble HRatio[],",
            "\t\tdouble HRatioChroma[],",
            "\t\tdouble PixelClock[],",
            "\t\tdouble PSCL_THROUGHPUT[],",
            "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
            "\t\tdouble DPPCLK[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 5992,
          "match": "double PixelClock",
          "context": [
            "\t\tunsigned int DPPPerPlane[],",
            "\t\tdouble HRatio[],",
            "\t\tdouble HRatioChroma[],",
            "\t\tdouble PixelClock[],",
            "\t\tdouble PSCL_THROUGHPUT[],",
            "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
            "\t\tdouble DPPCLK[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 6127,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble DestinationLinesToRequestRowInVBlank[],",
            "\t\tdouble DestinationLinesToRequestRowInImmediateFlip[],",
            "\t\tbool DCCEnable[],",
            "\t\tdouble PixelClock[],",
            "\t\tint BytePerPixelY[],",
            "\t\tint BytePerPixelC[],",
            "\t\tenum scan_direction_class SourceScan[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 6298,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble DestinationLinesToRequestVMInVBlank[],",
            "\t\tdouble DestinationLinesToRequestVMInImmediateFlip[],",
            "\t\tbool DCCEnable[],",
            "\t\tdouble PixelClock[],",
            "\t\tint dpte_row_width_luma_ub[],",
            "\t\tint dpte_row_width_chroma_ub[],",
            "\t\tint vm_group_bytes[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 6424,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble DCCFractionOfZeroSizeRequestsChroma[],",
            "\t\tint HTotal[],",
            "\t\tint VTotal[],",
            "\t\tdouble PixelClock[],",
            "\t\tdouble VRatio[],",
            "\t\tenum scan_direction_class SourceScan[],",
            "\t\tint BlockHeight256BytesY[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 7100,
          "match": "double UrgentLatencyAdjustmentFabricClock",
          "context": [
            "\t\tdouble UrgentLatencyPixelMixedWithVMData,",
            "\t\tdouble UrgentLatencyVMDataOnly,",
            "\t\tbool DoUrgentLatencyAdjustment,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
            "\t\tdouble FabricClock)",
            "{"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 7101,
          "match": "double UrgentLatencyAdjustmentFabricClock",
          "context": [
            "\t\tdouble UrgentLatencyVMDataOnly,",
            "\t\tbool DoUrgentLatencyAdjustment,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
            "\t\tdouble FabricClock)",
            "{",
            "\tdouble ret;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 7102,
          "match": "double FabricClock",
          "context": [
            "\t\tbool DoUrgentLatencyAdjustment,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
            "\t\tdouble FabricClock)",
            "{",
            "\tdouble ret;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 7321,
          "match": "double PixelClock",
          "context": [
            "\t\tunsigned int VActive,",
            "\t\tunsigned int VBlankNom,",
            "\t\tunsigned int HTotal,",
            "\t\tdouble PixelClock,",
            "\t\tbool ProgressiveTointerlaceUnitinOPP,",
            "\t\tbool Interlace,",
            "\t\tunsigned int VBlankNomDefaultUS,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c",
          "line": 7329,
          "match": "double line_time_us = HTotal / PixelClock",
          "context": [
            "{",
            "\tunsigned int MaxVStartup = 0;",
            "\tunsigned int vblank_size = 0;",
            "\tdouble line_time_us = HTotal / PixelClock;",
            "\tunsigned int vblank_actual = VTotal - VActive;",
            "\tunsigned int vblank_nom_default_in_line = dml_floor(VBlankNomDefaultUS / line_time_us, 1.0);",
            "\tunsigned int vblank_nom_input = VBlankNom; //dml_min(VBlankNom, vblank_nom_default_in_line);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn314\\display_mode_vba_314.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 65,
          "match": "double PixelClock",
          "context": [
            "typedef struct {",
            "\tdouble DPPCLK;",
            "\tdouble DISPCLK;",
            "\tdouble PixelClock;",
            "\tdouble DCFCLKDeepSleep;",
            "\tunsigned int DPPPerPlane;",
            "\tbool ScalerEnabled;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 163,
          "match": "double RoundToDFSGranularityUp(double Clock",
          "context": [
            "\t\tint *VUpdateOffsetPix,",
            "\t\tdouble *VUpdateWidthPix,",
            "\t\tdouble *VReadyOffsetPix);",
            "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed);",
            "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed);",
            "static void CalculateDCCConfiguration(",
            "\t\tbool DCCEnabled,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 164,
          "match": "double RoundToDFSGranularityDown(double Clock",
          "context": [
            "\t\tdouble *VUpdateWidthPix,",
            "\t\tdouble *VReadyOffsetPix);",
            "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed);",
            "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed);",
            "static void CalculateDCCConfiguration(",
            "\t\tbool DCCEnabled,",
            "\t\tbool DCCProgrammingAssumesScanDirectionUnknown,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 234,
          "match": "double CalculateTWait(unsigned int PrefetchMode, double DRAMClock",
          "context": [
            "\t\tunsigned int *PTERequestSize,",
            "\t\tint *DPDE0BytesFrame,",
            "\t\tint *MetaPTEBytesFrame);",
            "static double CalculateTWait(unsigned int PrefetchMode, double DRAMClockChangeLatency, double UrgentLatency, double SREnterPlusExitTime);",
            "static void CalculateRowBandwidth(",
            "\t\tbool GPUVMEnable,",
            "\t\tenum source_format_class SourcePixelFormat,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 277,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble DPPCLK,",
            "\t\tdouble DISPCLK,",
            "\t\tdouble DCFClkDeepSleep,",
            "\t\tdouble PixelClock,",
            "\t\tint HTotal,",
            "\t\tint VBlank,",
            "\t\tint DynamicMetadataTransmittedBytes,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 330,
          "match": "double PixelClock",
          "context": [
            "\t\tunsigned int DPPPerPlane[],",
            "\t\tdouble HRatio[],",
            "\t\tdouble HRatioChroma[],",
            "\t\tdouble PixelClock[],",
            "\t\tdouble PSCL_THROUGHPUT[],",
            "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
            "\t\tdouble DPPCLK[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 376,
          "match": "double PixelClock",
          "context": [
            "\t\tunsigned int DPPPerPlane[],",
            "\t\tdouble HRatio[],",
            "\t\tdouble HRatioChroma[],",
            "\t\tdouble PixelClock[],",
            "\t\tdouble PSCL_THROUGHPUT[],",
            "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
            "\t\tdouble DPPCLK[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 411,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble DestinationLinesToRequestRowInVBlank[],",
            "\t\tdouble DestinationLinesToRequestRowInImmediateFlip[],",
            "\t\tbool DCCEnable[],",
            "\t\tdouble PixelClock[],",
            "\t\tint BytePerPixelY[],",
            "\t\tint BytePerPixelC[],",
            "\t\tenum scan_direction_class SourceScan[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 460,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble DestinationLinesToRequestVMInVBlank[],",
            "\t\tdouble DestinationLinesToRequestVMInImmediateFlip[],",
            "\t\tbool DCCEnable[],",
            "\t\tdouble PixelClock[],",
            "\t\tint dpte_row_width_luma_ub[],",
            "\t\tint dpte_row_width_chroma_ub[],",
            "\t\tint vm_group_bytes[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 508,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble DCCFractionOfZeroSizeRequestsChroma[],",
            "\t\tint HTotal[],",
            "\t\tint VTotal[],",
            "\t\tdouble PixelClock[],",
            "\t\tdouble VRatio[],",
            "\t\tenum scan_direction_class SourceScan[],",
            "\t\tint BlockHeight256BytesY[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 641,
          "match": "double UrgentLatencyAdjustmentFabricClock",
          "context": [
            "\t\tdouble UrgentLatencyPixelMixedWithVMData,",
            "\t\tdouble UrgentLatencyVMDataOnly,",
            "\t\tbool DoUrgentLatencyAdjustment,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
            "\t\tdouble FabricClockSingle);",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 642,
          "match": "double UrgentLatencyAdjustmentFabricClock",
          "context": [
            "\t\tdouble UrgentLatencyVMDataOnly,",
            "\t\tbool DoUrgentLatencyAdjustment,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
            "\t\tdouble FabricClockSingle);",
            "",
            "static void CalculateUnboundedRequestAndCompressedBufferSize("
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 643,
          "match": "double FabricClock",
          "context": [
            "\t\tbool DoUrgentLatencyAdjustment,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
            "\t\tdouble FabricClockSingle);",
            "",
            "static void CalculateUnboundedRequestAndCompressedBufferSize(",
            "\t\tunsigned int DETBufferSizeInKByte,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 1460,
          "match": "double RoundToDFSGranularityUp(double Clock",
          "context": [
            "\treturn MyError;",
            "}",
            "",
            "static double RoundToDFSGranularityUp(double Clock, double VCOSpeed)",
            "{",
            "\treturn VCOSpeed * 4 / dml_floor(VCOSpeed * 4 / Clock, 1);",
            "}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 1465,
          "match": "double RoundToDFSGranularityDown(double Clock",
          "context": [
            "\treturn VCOSpeed * 4 / dml_floor(VCOSpeed * 4 / Clock, 1);",
            "}",
            "",
            "static double RoundToDFSGranularityDown(double Clock, double VCOSpeed)",
            "{",
            "\treturn VCOSpeed * 4 / dml_ceil(VCOSpeed * 4.0 / Clock, 1);",
            "}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 2587,
          "match": "double TWait = CalculateTWait(PrefetchMode, v->DRAMClock",
          "context": [
            "\t\tdouble MaxTotalRDBandwidthNoUrgentBurst = 0.0;",
            "\t\tbool DestinationLineTimesForPrefetchLessThan2 = false;",
            "\t\tbool VRatioPrefetchMoreThan4 = false;",
            "\t\tdouble TWait = CalculateTWait(PrefetchMode, v->DRAMClockChangeLatency, v->UrgentLatency, v->SREnterPlusExitTime);",
            "\t\tMaxTotalRDBandwidth = 0;",
            "",
            "\t\tdml_print(\"DML::%s: Start loop: VStartup = %d\\n\", __func__, v->VStartupLines);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 3131,
          "match": "double Tvstartup_margin = (v->MaxVStartupLines[k] - v->VStartup[k]) * v->HTotal[k] / v->PixelClock",
          "context": [
            "\t// VStartup Adjustment",
            "\tfor (k = 0; k < v->NumberOfActivePlanes; ++k) {",
            "\t\tbool isInterlaceTiming;",
            "\t\tdouble Tvstartup_margin = (v->MaxVStartupLines[k] - v->VStartup[k]) * v->HTotal[k] / v->PixelClock[k];",
            "#ifdef __DML_VBA_DEBUG__",
            "\t\tdml_print(\"DML::%s: k=%d, MinTTUVBlank = %f (before margin)\\n\", __func__, k, v->MinTTUVBlank[k]);",
            "#endif"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 3345,
          "match": "double CalculateTWait(unsigned int PrefetchMode, double DRAMClock",
          "context": [
            "\t\t\t&dummysinglestring);",
            "}",
            "",
            "static double CalculateTWait(unsigned int PrefetchMode, double DRAMClockChangeLatency, double UrgentLatency, double SREnterPlusExitTime)",
            "{",
            "\tif (PrefetchMode == 0) {",
            "\t\treturn dml_max(DRAMClockChangeLatency + UrgentLatency, dml_max(SREnterPlusExitTime, UrgentLatency));"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 3358,
          "match": "double PixelClock",
          "context": [
            "",
            "double dml31_CalculateWriteBackDISPCLK(",
            "\t\tenum source_format_class WritebackPixelFormat,",
            "\t\tdouble PixelClock,",
            "\t\tdouble WritebackHRatio,",
            "\t\tdouble WritebackVRatio,",
            "\t\tunsigned int WritebackHTaps,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 3407,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble DPPCLK,",
            "\t\tdouble DISPCLK,",
            "\t\tdouble DCFClkDeepSleep,",
            "\t\tdouble PixelClock,",
            "\t\tint HTotal,",
            "\t\tint VBlank,",
            "\t\tint DynamicMetadataTransmittedBytes,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 3498,
          "match": "double LineTime = v->HTotal[k] / v->PixelClock",
          "context": [
            "\tdouble TimeForFetchingMetaPTEImmediateFlip;",
            "\tdouble TimeForFetchingRowInVBlankImmediateFlip;",
            "\tdouble ImmediateFlipBW = 1.0;",
            "\tdouble LineTime = v->HTotal[k] / v->PixelClock[k];",
            "",
            "\tif (v->GPUVMEnable == true && v->HostVMEnable == true) {",
            "\t\tHostVMDynamicLevelsTrips = v->HostVMMaxNonCachedPageTableLevels;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 3586,
          "match": "double PixelClock",
          "context": [
            "\t\tint Lanes,",
            "\t\tint HTotal,",
            "\t\tint HActive,",
            "\t\tdouble PixelClock,",
            "\t\tdouble DesiredBPP,",
            "\t\tbool DSCEnable,",
            "\t\tenum output_encoder_class Output,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 5578,
          "match": "double ActiveDRAMClock",
          "context": [
            "\tunsigned int LinesInDETCRoundedDownToSwath;",
            "\tdouble FullDETBufferingTimeY;",
            "\tdouble FullDETBufferingTimeC;",
            "\tdouble ActiveDRAMClockChangeLatencyMarginY;",
            "\tdouble ActiveDRAMClockChangeLatencyMarginC;",
            "\tdouble WritebackDRAMClockChangeLatencyMargin;",
            "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 5579,
          "match": "double ActiveDRAMClock",
          "context": [
            "\tdouble FullDETBufferingTimeY;",
            "\tdouble FullDETBufferingTimeC;",
            "\tdouble ActiveDRAMClockChangeLatencyMarginY;",
            "\tdouble ActiveDRAMClockChangeLatencyMarginC;",
            "\tdouble WritebackDRAMClockChangeLatencyMargin;",
            "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;",
            "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 5580,
          "match": "double WritebackDRAMClock",
          "context": [
            "\tdouble FullDETBufferingTimeC;",
            "\tdouble ActiveDRAMClockChangeLatencyMarginY;",
            "\tdouble ActiveDRAMClockChangeLatencyMarginC;",
            "\tdouble WritebackDRAMClockChangeLatencyMargin;",
            "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;",
            "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank;",
            "\tdouble WritebackDRAMClockChangeLatencyHiding;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 5581,
          "match": "double PlaneWithMinActiveDRAMClock",
          "context": [
            "\tdouble ActiveDRAMClockChangeLatencyMarginY;",
            "\tdouble ActiveDRAMClockChangeLatencyMarginC;",
            "\tdouble WritebackDRAMClockChangeLatencyMargin;",
            "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;",
            "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank;",
            "\tdouble WritebackDRAMClockChangeLatencyHiding;",
            "\tdouble TotalPixelBW = 0.0;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 5582,
          "match": "double SecondMinActiveDRAMClock",
          "context": [
            "\tdouble ActiveDRAMClockChangeLatencyMarginC;",
            "\tdouble WritebackDRAMClockChangeLatencyMargin;",
            "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;",
            "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank;",
            "\tdouble WritebackDRAMClockChangeLatencyHiding;",
            "\tdouble TotalPixelBW = 0.0;",
            "\tint k, j;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 5583,
          "match": "double WritebackDRAMClock",
          "context": [
            "\tdouble WritebackDRAMClockChangeLatencyMargin;",
            "\tdouble PlaneWithMinActiveDRAMClockChangeMargin;",
            "\tdouble SecondMinActiveDRAMClockChangeMarginOneDisplayInVBLank;",
            "\tdouble WritebackDRAMClockChangeLatencyHiding;",
            "\tdouble TotalPixelBW = 0.0;",
            "\tint k, j;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 5660,
          "match": "double) v->DSTXAfterScaler[k] / v->HTotal[k] + v->DSTYAfterScaler[k]) * v->HTotal[k] / v->PixelClock[k] - v->UrgentWatermark - v->DRAMClock",
          "context": [
            "\t\t}",
            "",
            "\t\tActiveDRAMClockChangeLatencyMarginY = EffectiveLBLatencyHidingY + FullDETBufferingTimeY",
            "\t\t\t\t- ((double) v->DSTXAfterScaler[k] / v->HTotal[k] + v->DSTYAfterScaler[k]) * v->HTotal[k] / v->PixelClock[k] - v->UrgentWatermark - v->DRAMClockChangeWatermark;",
            "",
            "\t\tif (v->NumberOfActivePlanes > 1) {",
            "\t\t\tActiveDRAMClockChangeLatencyMarginY = ActiveDRAMClockChangeLatencyMarginY"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 5669,
          "match": "double) v->DSTXAfterScaler[k] / v->HTotal[k] + v->DSTYAfterScaler[k]) * v->HTotal[k] / v->PixelClock[k] - v->UrgentWatermark - v->DRAMClock",
          "context": [
            "",
            "\t\tif (BytePerPixelDETC[k] > 0) {",
            "\t\t\tActiveDRAMClockChangeLatencyMarginC = EffectiveLBLatencyHidingC + FullDETBufferingTimeC",
            "\t\t\t\t\t- ((double) v->DSTXAfterScaler[k] / v->HTotal[k] + v->DSTYAfterScaler[k]) * v->HTotal[k] / v->PixelClock[k] - v->UrgentWatermark - v->DRAMClockChangeWatermark;",
            "",
            "\t\t\tif (v->NumberOfActivePlanes > 1) {",
            "\t\t\t\tActiveDRAMClockChangeLatencyMarginC = ActiveDRAMClockChangeLatencyMarginC"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 5760,
          "match": "double PixelClock",
          "context": [
            "\t\tunsigned int DPPPerPlane[],",
            "\t\tdouble HRatio[],",
            "\t\tdouble HRatioChroma[],",
            "\t\tdouble PixelClock[],",
            "\t\tdouble PSCL_THROUGHPUT[],",
            "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
            "\t\tdouble DPPCLK[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 5898,
          "match": "double PixelClock",
          "context": [
            "\t\tunsigned int DPPPerPlane[],",
            "\t\tdouble HRatio[],",
            "\t\tdouble HRatioChroma[],",
            "\t\tdouble PixelClock[],",
            "\t\tdouble PSCL_THROUGHPUT[],",
            "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
            "\t\tdouble DPPCLK[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 6032,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble DestinationLinesToRequestRowInVBlank[],",
            "\t\tdouble DestinationLinesToRequestRowInImmediateFlip[],",
            "\t\tbool DCCEnable[],",
            "\t\tdouble PixelClock[],",
            "\t\tint BytePerPixelY[],",
            "\t\tint BytePerPixelC[],",
            "\t\tenum scan_direction_class SourceScan[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 6203,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble DestinationLinesToRequestVMInVBlank[],",
            "\t\tdouble DestinationLinesToRequestVMInImmediateFlip[],",
            "\t\tbool DCCEnable[],",
            "\t\tdouble PixelClock[],",
            "\t\tint dpte_row_width_luma_ub[],",
            "\t\tint dpte_row_width_chroma_ub[],",
            "\t\tint vm_group_bytes[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 6329,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble DCCFractionOfZeroSizeRequestsChroma[],",
            "\t\tint HTotal[],",
            "\t\tint VTotal[],",
            "\t\tdouble PixelClock[],",
            "\t\tdouble VRatio[],",
            "\t\tenum scan_direction_class SourceScan[],",
            "\t\tint BlockHeight256BytesY[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 7012,
          "match": "double UrgentLatencyAdjustmentFabricClock",
          "context": [
            "\t\tdouble UrgentLatencyPixelMixedWithVMData,",
            "\t\tdouble UrgentLatencyVMDataOnly,",
            "\t\tbool DoUrgentLatencyAdjustment,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
            "\t\tdouble FabricClock)",
            "{"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 7013,
          "match": "double UrgentLatencyAdjustmentFabricClock",
          "context": [
            "\t\tdouble UrgentLatencyVMDataOnly,",
            "\t\tbool DoUrgentLatencyAdjustment,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
            "\t\tdouble FabricClock)",
            "{",
            "\tdouble ret;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c",
          "line": 7014,
          "match": "double FabricClock",
          "context": [
            "\t\tbool DoUrgentLatencyAdjustment,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
            "\t\tdouble FabricClock)",
            "{",
            "\tdouble ret;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn31\\display_mode_vba_31.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\dcn32_fpu.c",
          "line": 189,
          "match": "double pstate_latency_us = clk_mgr->base.ctx->dc->dml.soc.dram_clock",
          "context": [
            "void dcn32_build_wm_range_table_fpu(struct clk_mgr_internal *clk_mgr)",
            "{",
            "\t/* defaults */",
            "\tdouble pstate_latency_us = clk_mgr->base.ctx->dc->dml.soc.dram_clock_change_latency_us;",
            "\tdouble fclk_change_latency_us = clk_mgr->base.ctx->dc->dml.soc.fclk_change_latency_us;",
            "\tdouble sr_exit_time_us = clk_mgr->base.ctx->dc->dml.soc.sr_exit_time_us;",
            "\tdouble sr_enter_plus_exit_time_us = clk_mgr->base.ctx->dc->dml.soc.sr_enter_plus_exit_time_us;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\dcn32_fpu.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\dcn32_fpu.c",
          "line": 2306,
          "match": "double dcfclk = dcn3_2_soc.clock",
          "context": [
            "\t\t\t\tint vlevel)",
            "{",
            "\tint i, pipe_idx, vlevel_temp = 0;",
            "\tdouble dcfclk = dcn3_2_soc.clock_limits[0].dcfclk_mhz;",
            "\tdouble dcfclk_from_validation = context->bw_ctx.dml.vba.DCFCLKState[vlevel][context->bw_ctx.dml.vba.maxMpcComb];",
            "\tdouble dram_speed_from_validation = context->bw_ctx.dml.vba.DRAMSpeed;",
            "\tdouble dcfclk_from_fw_based_mclk_switching = dcfclk_from_validation;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\dcn32_fpu.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 205,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble VRatioChroma,",
            "\t\tdouble MaxDCHUBToPSCLThroughput,",
            "\t\tdouble MaxPSCLToLBThroughput,",
            "\t\tdouble PixelClock,",
            "\t\tenum source_format_class SourcePixelFormat,",
            "\t\tunsigned int HTaps,",
            "\t\tunsigned int HTapsChroma,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 1192,
          "match": "double PixelClock",
          "context": [
            "\t\tbool DSCEnable,",
            "\t\tunsigned int TotalNumberOfActiveDPP,",
            "\t\tunsigned int MaxNumDPP,",
            "\t\tdouble PixelClock,",
            "\t\tdouble DISPCLKDPPCLKDSCCLKDownSpreading,",
            "\t\tdouble DISPCLKRampingMargin,",
            "\t\tdouble DISPCLKDPPCLKVCOSpeed,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 1286,
          "match": "double PixelClock",
          "context": [
            "",
            "double dml32_CalculateRequiredDispclk(",
            "\t\tenum odm_combine_mode ODMMode,",
            "\t\tdouble PixelClock,",
            "\t\tdouble DISPCLKDPPCLKDSCCLKDownSpreading,",
            "\t\tdouble DISPCLKRampingMargin,",
            "\t\tdouble DISPCLKDPPCLKVCOSpeed,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 1293,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble MaxDispclk)",
            "{",
            "\tdouble RequiredDispclk = 0.;",
            "\tdouble PixelClockAfterODM;",
            "\tdouble DISPCLKWithRampingRoundedToDFSGranularity;",
            "\tdouble DISPCLKWithoutRampingRoundedToDFSGranularity;",
            "\tdouble MaxDispclkRoundedDownToDFSGranularity;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 1325,
          "match": "double dml32_RoundToDFSGranularity(double Clock",
          "context": [
            "\treturn RequiredDispclk;",
            "}",
            "",
            "double dml32_RoundToDFSGranularity(double Clock, bool round_up, double VCOSpeed)",
            "{",
            "\tif (Clock <= 0.0)",
            "\t\treturn 0.0;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 1346,
          "match": "double PixelClock",
          "context": [
            "\t\tenum output_format_class OutputFormat,",
            "\t\tunsigned int HTotal,",
            "\t\tunsigned int HActive,",
            "\t\tdouble PixelClockBackEnd,",
            "\t\tdouble ForcedOutputLinkBPP,",
            "\t\tunsigned int DSCInputBitPerComponent,",
            "\t\tunsigned int NumberOfDSCSlices,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 1578,
          "match": "double PixelClock",
          "context": [
            "\t\tunsigned int Lanes,",
            "\t\tunsigned int HTotal,",
            "\t\tunsigned int HActive,",
            "\t\tdouble PixelClock,",
            "\t\tdouble DesiredBPP,",
            "\t\tbool DSCEnable,",
            "\t\tenum output_encoder_class Output,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 1689,
          "match": "double               PixelClock",
          "context": [
            "",
            "double dml32_RequiredDTBCLK(",
            "\t\tbool              DSCEnable,",
            "\t\tdouble               PixelClock,",
            "\t\tenum output_format_class  OutputFormat,",
            "\t\tdouble               OutputBpp,",
            "\t\tunsigned int              DSCSlices,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 1726,
          "match": "double PixelClock",
          "context": [
            "\t\tunsigned int NumberOfDSCSlices,",
            "\t\tenum output_format_class  OutputFormat,",
            "\t\tenum output_encoder_class Output,",
            "\t\tdouble PixelClock,",
            "\t\tdouble PixelClockBackEnd,",
            "\t\tdouble dsc_delay_factor_wa)",
            "{"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 1727,
          "match": "double PixelClock",
          "context": [
            "\t\tenum output_format_class  OutputFormat,",
            "\t\tenum output_encoder_class Output,",
            "\t\tdouble PixelClock,",
            "\t\tdouble PixelClockBackEnd,",
            "\t\tdouble dsc_delay_factor_wa)",
            "{",
            "\tunsigned int DSCDelayRequirement_val;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 2711,
          "match": "double UrgentLatencyAdjustmentFabricClock",
          "context": [
            "\t\tdouble UrgentLatencyPixelMixedWithVMData,",
            "\t\tdouble UrgentLatencyVMDataOnly,",
            "\t\tbool   DoUrgentLatencyAdjustment,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
            "\t\tdouble FabricClock)",
            "{"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 2712,
          "match": "double UrgentLatencyAdjustmentFabricClock",
          "context": [
            "\t\tdouble UrgentLatencyVMDataOnly,",
            "\t\tbool   DoUrgentLatencyAdjustment,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
            "\t\tdouble FabricClock)",
            "{",
            "\tdouble   ret;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 2713,
          "match": "double FabricClock",
          "context": [
            "\t\tbool   DoUrgentLatencyAdjustment,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
            "\t\tdouble UrgentLatencyAdjustmentFabricClockReference,",
            "\t\tdouble FabricClock)",
            "{",
            "\tdouble   ret;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 2820,
          "match": "double PixelClock",
          "context": [
            "\t\tunsigned int DPPPerSurface[],",
            "\t\tdouble HRatio[],",
            "\t\tdouble HRatioChroma[],",
            "\t\tdouble PixelClock[],",
            "\t\tdouble PSCL_THROUGHPUT[],",
            "\t\tdouble PSCL_THROUGHPUT_CHROMA[],",
            "\t\tdouble Dppclk[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 2929,
          "match": "double DRAMClock",
          "context": [
            "\t\tbool SynchronizeDRRDisplaysForUCLKPStateChangeFinal,",
            "\t\tunsigned int MaxInterDCNTileRepeaters,",
            "\t\tunsigned int MaxPrefetchMode,",
            "\t\tdouble DRAMClockChangeLatencyFinal,",
            "\t\tdouble FCLKChangeLatency,",
            "\t\tdouble SREnterPlusExitTime,",
            "\t\tunsigned int ReturnBusWidth,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 2969,
          "match": "double PixelClock",
          "context": [
            "\t\tunsigned int BytePerPixelY[],",
            "\t\tunsigned int BytePerPixelC[],",
            "\t\tunsigned int HTotal[],",
            "\t\tdouble PixelClock[],",
            "\t\tdouble PDEAndMetaPTEBytesPerFrame[][2][DC__NUM_DPP__MAX],",
            "\t\tdouble DPTEBytesPerRow[][2][DC__NUM_DPP__MAX],",
            "\t\tdouble MetaRowBytes[][2][DC__NUM_DPP__MAX],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 3198,
          "match": "double PixelClock",
          "context": [
            "\t\tdouble Dppclk,",
            "\t\tdouble Dispclk,",
            "\t\tdouble DCFClkDeepSleep,",
            "\t\tdouble PixelClock,",
            "\t\tunsigned int HTotal,",
            "\t\tunsigned int VBlank,",
            "\t\tunsigned int DynamicMetadataTransmittedBytes,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 3253,
          "match": "double DRAMClock",
          "context": [
            "\t\tenum dm_use_mall_for_pstate_change_mode UseMALLForPStateChange,",
            "\t\tbool SynchronizeDRRDisplaysForUCLKPStateChangeFinal,",
            "\t\tbool DRRDisplay,",
            "\t\tdouble DRAMClockChangeLatency,",
            "\t\tdouble FCLKChangeLatency,",
            "\t\tdouble UrgentLatency,",
            "\t\tdouble SREnterPlusExitTime)"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 3287,
          "match": "double FabricClock",
          "context": [
            "\t\tconst int VoltageLevel,",
            "\t\tconst bool HostVMEnable,",
            "\t\tconst double DCFCLK,",
            "\t\tconst double FabricClock,",
            "\t\tconst double DRAMSpeed)",
            "{",
            "\tdouble ReturnBW = 0.;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 3292,
          "match": "double IdealFabricBandwidth     = FabricClock",
          "context": [
            "{",
            "\tdouble ReturnBW = 0.;",
            "\tdouble IdealSDPPortBandwidth    = soc->return_bus_width_bytes /*mode_lib->vba.ReturnBusWidth*/ * DCFCLK;",
            "\tdouble IdealFabricBandwidth     = FabricClock * soc->fabric_datapath_to_dcn_data_return_bytes;",
            "\tdouble IdealDRAMBandwidth       = DRAMSpeed * soc->num_chans * soc->dram_channel_width_bytes;",
            "\tdouble PixelDataOnlyReturnBW    = dml_min3(IdealSDPPortBandwidth * soc->pct_ideal_sdp_bw_after_urgent / 100,",
            "\t\t\tIdealFabricBandwidth * soc->pct_ideal_fabric_bw_after_urgent / 100,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 3329,
          "match": "double FabricClock",
          "context": [
            "double dml32_get_return_bw_mbps_vm_only(const soc_bounding_box_st *soc,",
            "\t\tconst int VoltageLevel,",
            "\t\tconst double DCFCLK,",
            "\t\tconst double FabricClock,",
            "\t\tconst double DRAMSpeed)",
            "{",
            "\tdouble VMDataOnlyReturnBW = dml_min3("
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 4283,
          "match": "double MaxActiveDRAMClock",
          "context": [
            "",
            "\t\t/* Output */",
            "\t\tenum clock_change_support *DRAMClockChangeSupport,",
            "\t\tdouble MaxActiveDRAMClockChangeLatencySupported[],",
            "\t\tunsigned int SubViewportLinesNeededInMALL[],",
            "\t\tenum dm_fclock_change_support *FCLKChangeSupport,",
            "\t\tdouble *MinActiveFCLKChangeLatencySupported,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 4288,
          "match": "double ActiveDRAMClock",
          "context": [
            "\t\tenum dm_fclock_change_support *FCLKChangeSupport,",
            "\t\tdouble *MinActiveFCLKChangeLatencySupported,",
            "\t\tbool *USRRetrainingSupport,",
            "\t\tdouble ActiveDRAMClockChangeLatencyMargin[])",
            "{",
            "\tunsigned int i, j, k;",
            "\tunsigned int SurfaceWithMinActiveFCLKChangeMargin = 0;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 4298,
          "match": "double ActiveClock",
          "context": [
            "\tbool FoundFirstSurfaceWithMinActiveFCLKChangeMargin = false;",
            "\tdouble MinActiveFCLKChangeMargin = 0.;",
            "\tdouble SecondMinActiveFCLKChangeMarginOneDisplayInVBLank = 0.;",
            "\tdouble ActiveClockChangeLatencyHidingY;",
            "\tdouble ActiveClockChangeLatencyHidingC;",
            "\tdouble ActiveClockChangeLatencyHiding;",
            "\tdouble EffectiveDETBufferSizeY;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 4299,
          "match": "double ActiveClock",
          "context": [
            "\tdouble MinActiveFCLKChangeMargin = 0.;",
            "\tdouble SecondMinActiveFCLKChangeMarginOneDisplayInVBLank = 0.;",
            "\tdouble ActiveClockChangeLatencyHidingY;",
            "\tdouble ActiveClockChangeLatencyHidingC;",
            "\tdouble ActiveClockChangeLatencyHiding;",
            "\tdouble EffectiveDETBufferSizeY;",
            "\tdouble     ActiveFCLKChangeLatencyMargin[DC__NUM_DPP__MAX];"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 4300,
          "match": "double ActiveClock",
          "context": [
            "\tdouble SecondMinActiveFCLKChangeMarginOneDisplayInVBLank = 0.;",
            "\tdouble ActiveClockChangeLatencyHidingY;",
            "\tdouble ActiveClockChangeLatencyHidingC;",
            "\tdouble ActiveClockChangeLatencyHiding;",
            "\tdouble EffectiveDETBufferSizeY;",
            "\tdouble     ActiveFCLKChangeLatencyMargin[DC__NUM_DPP__MAX];",
            "\tdouble     USRRetrainingLatencyMargin[DC__NUM_DPP__MAX];"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 4314,
          "match": "double     WritebackDRAMClock",
          "context": [
            "\tunsigned int    LinesInDETCRoundedDownToSwath[DC__NUM_DPP__MAX];",
            "\tdouble     FullDETBufferingTimeY;",
            "\tdouble     FullDETBufferingTimeC;",
            "\tdouble     WritebackDRAMClockChangeLatencyMargin;",
            "\tdouble     WritebackFCLKChangeLatencyMargin;",
            "\tdouble     WritebackLatencyHiding;",
            "\tbool    SameTimingForFCLKChange;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 4647,
          "match": "double PixelClock",
          "context": [
            "",
            "double dml32_CalculateWriteBackDISPCLK(",
            "\t\tenum source_format_class WritebackPixelFormat,",
            "\t\tdouble PixelClock,",
            "\t\tdouble WritebackHRatio,",
            "\t\tdouble WritebackVRatio,",
            "\t\tunsigned int WritebackHTaps,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 4701,
          "match": "double              PixelClock",
          "context": [
            "\t\tunsigned int             DPPPerSurface[],",
            "\t\tdouble              HRatio[],",
            "\t\tdouble              HRatioChroma[],",
            "\t\tdouble              PixelClock[],",
            "\t\tdouble              PSCL_THROUGHPUT[],",
            "\t\tdouble              PSCL_THROUGHPUT_CHROMA[],",
            "\t\tdouble              Dppclk[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 4883,
          "match": "double  PixelClock",
          "context": [
            "\t\tdouble  DestinationLinesToRequestRowInVBlank[],",
            "\t\tdouble  DestinationLinesToRequestRowInImmediateFlip[],",
            "\t\tbool DCCEnable[],",
            "\t\tdouble  PixelClock[],",
            "\t\tunsigned int BytePerPixelY[],",
            "\t\tunsigned int BytePerPixelC[],",
            "\t\tenum dm_rotation_angle SourceRotation[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 5154,
          "match": "double      PixelClock",
          "context": [
            "\t\tdouble      DestinationLinesToRequestVMInVBlank[],",
            "\t\tdouble      DestinationLinesToRequestVMInImmediateFlip[],",
            "\t\tbool     DCCEnable[],",
            "\t\tdouble      PixelClock[],",
            "\t\tunsigned int        dpte_row_width_luma_ub[],",
            "\t\tunsigned int        dpte_row_width_chroma_ub[],",
            "\t\tunsigned int     vm_group_bytes[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 5623,
          "match": "double    PixelClock",
          "context": [
            "\t\tdouble    DCCFractionOfZeroSizeRequestsChroma[],",
            "\t\tunsigned int      HTotal[],",
            "\t\tunsigned int      VTotal[],",
            "\t\tdouble    PixelClock[],",
            "\t\tdouble    VRatio[],",
            "\t\tenum dm_rotation_angle SourceRotation[],",
            "\t\tunsigned int   BlockHeight256BytesY[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 5658,
          "match": "double doublePixelClock",
          "context": [
            "\tdouble LastZ8StutterPeriod = 0.0;",
            "\tdouble LastStutterPeriod = 0.0;",
            "\tunsigned int TotalNumberOfActiveOTG = 0;",
            "\tdouble doublePixelClock = 0;",
            "\tunsigned int doubleHTotal = 0;",
            "\tunsigned int doubleVTotal = 0;",
            "\tbool SameTiming = true;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 5842,
          "match": "double) HTotal[k] / PixelClock",
          "context": [
            "\t\t\t\t\t\t\t* ReadBandwidthSurfaceLuma[k] / TotalDataReadBandwidth)",
            "\t\t\t\t\t/ BytePerPixelDETY[k] / SwathWidthY[k];",
            "\t\t\tLinesInDETYRoundedDownToSwath = dml_floor(LinesInDETY, SwathHeightY[k]);",
            "\t\t\tDETBufferingTimeY = LinesInDETYRoundedDownToSwath * ((double) HTotal[k] / PixelClock[k])",
            "\t\t\t\t\t/ VRatio[k];",
            "#ifdef __DML_VBA_DEBUG__",
            "\t\t\tdml_print(\"DML::%s: k=%0d, DETBufferSizeY = %d\\n\", __func__, k, DETBufferSizeY[k]);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 5869,
          "match": "double) HTotal[k] / PixelClock",
          "context": [
            "\t\t\t\tFrameTimeCriticalSurface = (",
            "\t\t\t\t\t\tisInterlaceTiming ?",
            "\t\t\t\t\t\t\t\tdml_floor((double) VTotal[k] / 2.0, 1.0) : VTotal[k])",
            "\t\t\t\t\t\t* (double) HTotal[k] / PixelClock[k];",
            "\t\t\t\tVActiveTimeCriticalSurface = (",
            "\t\t\t\t\t\tisInterlaceTiming ?",
            "\t\t\t\t\t\t\t\tdml_floor((double) VActive[k] / 2.0, 1.0) : VActive[k])"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 5873,
          "match": "double) HTotal[k] / PixelClock",
          "context": [
            "\t\t\t\tVActiveTimeCriticalSurface = (",
            "\t\t\t\t\t\tisInterlaceTiming ?",
            "\t\t\t\t\t\t\t\tdml_floor((double) VActive[k] / 2.0, 1.0) : VActive[k])",
            "\t\t\t\t\t\t* (double) HTotal[k] / PixelClock[k];",
            "\t\t\t\tBytePerPixelYCriticalSurface = BytePerPixelY[k];",
            "\t\t\t\tSwathWidthYCriticalSurface = SwathWidthY[k];",
            "\t\t\t\tSwathHeightYCriticalSurface = SwathHeightY[k];"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 6000,
          "match": "doublePixelClock = PixelClock",
          "context": [
            "\t\tif (UseMALLForPStateChange[k] != dm_use_mall_pstate_change_phantom_pipe) {",
            "\t\t\tif (BlendingAndTiming[k] == k) {",
            "\t\t\t\tif (TotalNumberOfActiveOTG == 0) {",
            "\t\t\t\t\tdoublePixelClock = PixelClock[k];",
            "\t\t\t\t\tdoubleHTotal = HTotal[k];",
            "\t\t\t\t\tdoubleVTotal = VTotal[k];",
            "\t\t\t\t} else if (doublePixelClock != PixelClock[k] || doubleHTotal != HTotal[k]"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 6003,
          "match": "doublePixelClock != PixelClock",
          "context": [
            "\t\t\t\t\tdoublePixelClock = PixelClock[k];",
            "\t\t\t\t\tdoubleHTotal = HTotal[k];",
            "\t\t\t\t\tdoubleVTotal = VTotal[k];",
            "\t\t\t\t} else if (doublePixelClock != PixelClock[k] || doubleHTotal != HTotal[k]",
            "\t\t\t\t\t\t|| doubleVTotal != VTotal[k]) {",
            "\t\t\t\t\tSameTiming = false;",
            "\t\t\t\t}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 6292,
          "match": "double\tPixelClock",
          "context": [
            "\t\tunsigned int    DETBufferSizeC[],",
            "\t\tunsigned int\tNumOfDPP[],",
            "\t\tunsigned int\tHTotal[],",
            "\t\tdouble\tPixelClock[],",
            "\t\tdouble\tVRatioY[],",
            "\t\tdouble\tVRatioC[],",
            "\t\tenum dm_use_mall_for_pstate_change_mode UsesMALLForPStateChange[],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c",
          "line": 6327,
          "match": "double LineTime = HTotal[k] / PixelClock",
          "context": [
            "",
            "\t/* ensure all DET - 1 swath can hide a fetch for all surfaces */",
            "\tfor (k = 0; k < NumberOfActiveSurfaces; k++) {",
            "\t\tdouble LineTime = HTotal[k] / PixelClock[k];",
            "",
            "\t\t/* only care if surface is not phantom */",
            "\t\tif (UsesMALLForPStateChange[k] != dm_use_mall_pstate_change_phantom_pipe) {"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_util_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_32.c",
          "line": 2869,
          "match": "double) mode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock",
          "context": [
            "\t\t\t\t\t\tmode_lib->vba.swath_width_chroma_ub_this_state[k],",
            "\t\t\t\t\t\tmode_lib->vba.SwathHeightYThisState[k],",
            "\t\t\t\t\t\tmode_lib->vba.SwathHeightCThisState[k],",
            "\t\t\t\t\t\t(double) mode_lib->vba.HTotal[k] / mode_lib->vba.PixelClock[k],",
            "\t\t\t\t\t\tmode_lib->vba.UrgLatency[i],",
            "\t\t\t\t\t\tmode_lib->vba.CursorBufferSize,",
            "\t\t\t\t\t\tmode_lib->vba.CursorWidth[k][0],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_32.c",
          "line": 3609,
          "match": "double *MaxActiveDRAMClock",
          "context": [
            "",
            "\t\t\t\t\t\t/* Output */",
            "\t\t\t\t\t\t&v->DRAMClockChangeSupport[i][j],",
            "\t\t\t\t\t\t&v->dummy_vars.dml32_ModeSupportAndSystemConfigurationFull.dummy_single2[0], // double *MaxActiveDRAMClockChangeLatencySupported",
            "\t\t\t\t\t\t&v->dummy_vars.dml32_ModeSupportAndSystemConfigurationFull.dummy_integer[0], // Long SubViewportLinesNeededInMALL[]",
            "\t\t\t\t\t\t&v->FCLKChangeSupport[i][j],",
            "\t\t\t\t\t\t&v->dummy_vars.dml32_ModeSupportAndSystemConfigurationFull.dummy_single2[1], // double *MinActiveFCLKChangeLatencySupported"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn32\\display_mode_vba_32.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn401\\dcn401_fpu.c",
          "line": 16,
          "match": "double pstate_latency_us = clk_mgr->ctx->dc->dml.soc.dram_clock",
          "context": [
            "void dcn401_build_wm_range_table_fpu(struct clk_mgr *clk_mgr)",
            "{",
            "\t/* defaults */",
            "\tdouble pstate_latency_us = clk_mgr->ctx->dc->dml.soc.dram_clock_change_latency_us;",
            "\tdouble fclk_change_latency_us = clk_mgr->ctx->dc->dml.soc.fclk_change_latency_us;",
            "\tdouble sr_exit_time_us = clk_mgr->ctx->dc->dml.soc.sr_exit_time_us;",
            "\tdouble sr_enter_plus_exit_time_us = clk_mgr->ctx->dc->dml.soc.sr_enter_plus_exit_time_us;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml\\dcn401\\dcn401_fpu.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_dpmm\\dml2_dpmm_dcn4.c",
          "line": 186,
          "match": "double clock",
          "context": [
            "\tin_out->programming->min_clocks.dcn4x.idle.dcfclk_khz = dml_round_up(min_dcfclk_avg > min_dcfclk_latency ? min_dcfclk_avg : min_dcfclk_latency);",
            "}",
            "",
            "static bool add_margin_and_round_to_dfs_grainularity(double clock_khz, double margin, unsigned long vco_freq_khz, unsigned long *rounded_khz, uint32_t *divider_id)",
            "{",
            "\tenum dentist_divider_range {",
            "\t\tDFS_DIVIDER_RANGE_1_START = 8, /* 2.00 */"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_dpmm\\dml2_dpmm_dcn4.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 319,
          "match": "double, mode_lib->mp.Watermark.DRAMClock",
          "context": [
            "dml_get_var_func(wm_fclk_change, double, mode_lib->mp.Watermark.FCLKChangeWatermark);",
            "dml_get_var_func(wm_usr_retraining, double, mode_lib->mp.Watermark.USRRetrainingWatermark);",
            "dml_get_var_func(wm_temp_read_or_ppt, double, mode_lib->mp.Watermark.temp_read_or_ppt_watermark_us);",
            "dml_get_var_func(wm_dram_clock_change, double, mode_lib->mp.Watermark.DRAMClockChangeWatermark);",
            "dml_get_var_func(fraction_of_urgent_bandwidth, double, mode_lib->mp.FractionOfUrgentBandwidth);",
            "dml_get_var_func(fraction_of_urgent_bandwidth_imm_flip, double, mode_lib->mp.FractionOfUrgentBandwidthImmediateFlip);",
            "dml_get_var_func(fraction_of_urgent_bandwidth_mall, double, mode_lib->mp.FractionOfUrgentBandwidthMALL);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 323,
          "match": "double, mode_lib->mp.Watermark.WritebackDRAMClock",
          "context": [
            "dml_get_var_func(fraction_of_urgent_bandwidth, double, mode_lib->mp.FractionOfUrgentBandwidth);",
            "dml_get_var_func(fraction_of_urgent_bandwidth_imm_flip, double, mode_lib->mp.FractionOfUrgentBandwidthImmediateFlip);",
            "dml_get_var_func(fraction_of_urgent_bandwidth_mall, double, mode_lib->mp.FractionOfUrgentBandwidthMALL);",
            "dml_get_var_func(wm_writeback_dram_clock_change, double, mode_lib->mp.Watermark.WritebackDRAMClockChangeWatermark);",
            "dml_get_var_func(wm_writeback_fclk_change, double, mode_lib->mp.Watermark.WritebackFCLKChangeWatermark);",
            "dml_get_var_func(stutter_efficiency, double, mode_lib->mp.StutterEfficiency);",
            "dml_get_var_func(stutter_efficiency_no_vblank, double, mode_lib->mp.StutterEfficiencyNotIncludingVBlank);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 428,
          "match": "double *PixelClock",
          "context": [
            "\t}",
            "}",
            "",
            "static void PixelClockAdjustmentForProgressiveToInterlaceUnit(const struct dml2_display_cfg *display_cfg, bool ptoi_supported, double *PixelClockBackEnd)",
            "{",
            "\t//unsigned int num_active_planes = display_cfg->num_planes;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 434,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "",
            "\t//Progressive To Interlace Unit Effect",
            "\tfor (unsigned int k = 0; k < display_cfg->num_planes; ++k) {",
            "\t\tPixelClockBackEnd[k] = ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
            "\t\tif (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.interlaced == 1 && ptoi_supported == true) {",
            "\t\t\t// FIXME_STAGE2... can sw pass the pixel rate for interlaced directly",
            "\t\t\t//display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz = 2 * display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 772,
          "match": "double PixelClock",
          "context": [
            "\tdouble VRatioChroma,",
            "\tdouble MaxDCHUBToPSCLThroughput,",
            "\tdouble MaxPSCLToLBThroughput,",
            "\tdouble PixelClock,",
            "\tenum dml2_source_format_class SourcePixelFormat,",
            "\tunsigned int HTaps,",
            "\tunsigned int HTapsChroma,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 915,
          "match": "double)display_cfg->plane_descriptors[k].surface.plane0.height, Read256BytesBlock",
          "context": [
            "\t\t\treq_width_horz_c = req_width_horz_c / 2;",
            "",
            "\t\tsurface_width_ub_l = (unsigned int)math_ceil2((double)display_cfg->plane_descriptors[k].surface.plane0.width, req_width_horz_y);",
            "\t\tsurface_height_ub_l = (unsigned int)math_ceil2((double)display_cfg->plane_descriptors[k].surface.plane0.height, Read256BytesBlockHeightY[k]);",
            "\t\tsurface_width_ub_c = (unsigned int)math_ceil2((double)display_cfg->plane_descriptors[k].surface.plane1.width, req_width_horz_c);",
            "\t\tsurface_height_ub_c = (unsigned int)math_ceil2((double)display_cfg->plane_descriptors[k].surface.plane1.height, Read256BytesBlockHeightC[k]);",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 917,
          "match": "double)display_cfg->plane_descriptors[k].surface.plane1.height, Read256BytesBlock",
          "context": [
            "\t\tsurface_width_ub_l = (unsigned int)math_ceil2((double)display_cfg->plane_descriptors[k].surface.plane0.width, req_width_horz_y);",
            "\t\tsurface_height_ub_l = (unsigned int)math_ceil2((double)display_cfg->plane_descriptors[k].surface.plane0.height, Read256BytesBlockHeightY[k]);",
            "\t\tsurface_width_ub_c = (unsigned int)math_ceil2((double)display_cfg->plane_descriptors[k].surface.plane1.width, req_width_horz_c);",
            "\t\tsurface_height_ub_c = (unsigned int)math_ceil2((double)display_cfg->plane_descriptors[k].surface.plane1.height, Read256BytesBlockHeightC[k]);",
            "",
            "\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u surface_width_ub_l=%u\\n\", __func__, k, surface_width_ub_l);",
            "\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u surface_height_ub_l=%u\\n\", __func__, k, surface_height_ub_l);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 963,
          "match": "double)SwathWidthY[k] - 1, Read256BytesBlockHeightY[k]) + Read256BytesBlock",
          "context": [
            "\t\t\tif (display_cfg->plane_descriptors[k].composition.viewport.stationary && DPPPerSurface[k] == 1) {",
            "\t\t\t\tswath_width_luma_ub[k] = (unsigned int)(math_min2(surface_height_ub_l, math_floor2(display_cfg->plane_descriptors[k].composition.viewport.plane0.y_start + SwathWidthY[k] + Read256BytesBlockHeightY[k] - 1, Read256BytesBlockHeightY[k]) - math_floor2(display_cfg->plane_descriptors[k].composition.viewport.plane0.y_start, Read256BytesBlockHeightY[k])));",
            "\t\t\t} else {",
            "\t\t\t\tswath_width_luma_ub[k] = (unsigned int)(math_min2(surface_height_ub_l, math_ceil2((double)SwathWidthY[k] - 1, Read256BytesBlockHeightY[k]) + Read256BytesBlockHeightY[k]));",
            "\t\t\t}",
            "\t\t\treq_per_swath_ub_l[k] = swath_width_luma_ub[k] / Read256BytesBlockHeightY[k];",
            "\t\t\tif (BytePerPixC[k] > 0) {"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 970,
          "match": "double)SwathWidthC[k] - 1, Read256BytesBlockHeightC[k]) + Read256BytesBlock",
          "context": [
            "\t\t\t\tif (display_cfg->plane_descriptors[k].composition.viewport.stationary && DPPPerSurface[k] == 1) {",
            "\t\t\t\t\tswath_width_chroma_ub[k] = (unsigned int)(math_min2(surface_height_ub_c, math_floor2(display_cfg->plane_descriptors[k].composition.viewport.plane1.y_start + SwathWidthC[k] + Read256BytesBlockHeightC[k] - 1, Read256BytesBlockHeightC[k]) - math_floor2(display_cfg->plane_descriptors[k].composition.viewport.plane1.y_start, Read256BytesBlockHeightC[k])));",
            "\t\t\t\t} else {",
            "\t\t\t\t\tswath_width_chroma_ub[k] = (unsigned int)(math_min2(surface_height_ub_c, math_ceil2((double)SwathWidthC[k] - 1, Read256BytesBlockHeightC[k]) + Read256BytesBlockHeightC[k]));",
            "\t\t\t\t}",
            "\t\t\t\treq_per_swath_ub_c[k] = swath_width_chroma_ub[k] / Read256BytesBlockHeightC[k];",
            "\t\t\t} else {"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 1109,
          "match": "double) display_cfg->stream_descriptors[k].timing.pixel_clock",
          "context": [
            "",
            "\t\t\t// Calculate per stream DET budget",
            "\t\t\tfor (unsigned int k = 0; k < display_cfg->num_streams; ++k) {",
            "\t\t\t\tl->DETBudgetPerStream[k] = (unsigned int)((double) display_cfg->stream_descriptors[k].timing.pixel_clock_khz * MaxTotalDETInKByte / l->TotalPixelRate);",
            "\t\t\t\tl->RemainingDETBudgetPerStream[k] = l->DETBudgetPerStream[k];",
            "\t\t\t}",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 1241,
          "match": "double PixelClock",
          "context": [
            "",
            "static double CalculateRequiredDispclk(",
            "\tenum dml2_odm_mode ODMMode,",
            "\tdouble PixelClock)",
            "{",
            "",
            "\tif (ODMMode == dml2_odm_mode_combine_4to1) {"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 1261,
          "match": "double PixelClock",
          "context": [
            "\tunsigned int Lanes,",
            "\tunsigned int HTotal,",
            "\tunsigned int HActive,",
            "\tdouble PixelClock,",
            "\tdouble DesiredBPP,",
            "\tbool DSCEnable,",
            "\tenum dml2_output_encoder_class Output,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 3176,
          "match": "double UrgentLatencyAdjustmentFabricClock",
          "context": [
            "\tdouble UrgentLatencyPixelMixedWithVMData,",
            "\tdouble UrgentLatencyVMDataOnly,",
            "\tbool DoUrgentLatencyAdjustment,",
            "\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
            "\tdouble UrgentLatencyAdjustmentFabricClockReference,",
            "\tdouble FabricClock,",
            "\tdouble uclk_freq_mhz,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 3177,
          "match": "double UrgentLatencyAdjustmentFabricClock",
          "context": [
            "\tdouble UrgentLatencyVMDataOnly,",
            "\tbool DoUrgentLatencyAdjustment,",
            "\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
            "\tdouble UrgentLatencyAdjustmentFabricClockReference,",
            "\tdouble FabricClock,",
            "\tdouble uclk_freq_mhz,",
            "\tenum dml2_qos_param_type qos_type,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 3178,
          "match": "double FabricClock",
          "context": [
            "\tbool DoUrgentLatencyAdjustment,",
            "\tdouble UrgentLatencyAdjustmentFabricClockComponent,",
            "\tdouble UrgentLatencyAdjustmentFabricClockReference,",
            "\tdouble FabricClock,",
            "\tdouble uclk_freq_mhz,",
            "\tenum dml2_qos_param_type qos_type,",
            "\tunsigned int urgent_ramp_uclk_cycles,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 3220,
          "match": "double FabricClock",
          "context": [
            "",
            "static double CalculateTripToMemory(",
            "\tdouble UrgLatency,",
            "\tdouble FabricClock,",
            "\tdouble uclk_freq_mhz,",
            "\tenum dml2_qos_param_type qos_type,",
            "\tunsigned int trip_to_memory_uclk_cycles,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 3260,
          "match": "double FabricClock",
          "context": [
            "",
            "static double CalculateMetaTripToMemory(",
            "\tdouble UrgLatency,",
            "\tdouble FabricClock,",
            "\tdouble uclk_freq_mhz,",
            "\tenum dml2_qos_param_type qos_type,",
            "\tunsigned int meta_trip_to_memory_uclk_cycles,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 3510,
          "match": "double pixel_rate_mhz = ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\tdouble ReadBandwidth = 0.0;",
            "",
            "\tfor (unsigned int k = 0; k < NumberOfActiveSurfaces; ++k) {",
            "\t\tdouble pixel_rate_mhz = ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
            "",
            "\t\tif (display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio <= 1) {",
            "\t\t\tDisplayPipeLineDeliveryTimeLuma = SwathWidthY[k] * DPPPerSurface[k] / display_cfg->plane_descriptors[k].composition.scaler_info.plane0.h_ratio / pixel_rate_mhz;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 3658,
          "match": "double line_time_us = (double)timing->h_total / ((double)timing->pixel_clock",
          "context": [
            "\tunsigned int vblank_size = 0;",
            "\tunsigned int max_vstartup_lines = 0;",
            "",
            "\tdouble line_time_us = (double)timing->h_total / ((double)timing->pixel_clock_khz / 1000);",
            "\tunsigned int vblank_actual = timing->v_total - timing->v_active;",
            "\tunsigned int vblank_nom_default_in_line = (unsigned int)math_floor2((double)vblank_nom_default_us / line_time_us, 1.0);",
            "\tunsigned int vblank_avail = (timing->vblank_nom == 0) ? vblank_nom_default_in_line : (unsigned int)timing->vblank_nom;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 4104,
          "match": "double PixelClock",
          "context": [
            "\tbool DSCEnable,",
            "\tunsigned int TotalNumberOfActiveDPP,",
            "\tunsigned int MaxNumDPP,",
            "\tdouble PixelClock,",
            "\tunsigned int NumberOfDSCSlices,",
            "",
            "\t// Output"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 4201,
          "match": "double PixelClock",
          "context": [
            "\tenum dml2_output_format_class OutputFormat,",
            "\tunsigned int HTotal,",
            "\tunsigned int HActive,",
            "\tdouble PixelClockBackEnd,",
            "\tdouble ForcedOutputLinkBPP,",
            "\tunsigned int DSCInputBitPerComponent,",
            "\tunsigned int NumberOfDSCSlices,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 4434,
          "match": "double PixelClock",
          "context": [
            "",
            "static double CalculateWriteBackDISPCLK(",
            "\tenum dml2_source_format_class WritebackPixelFormat,",
            "\tdouble PixelClock,",
            "\tdouble WritebackHRatio,",
            "\tdouble WritebackVRatio,",
            "\tunsigned int WritebackHTaps,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 4454,
          "match": "double PixelClock",
          "context": [
            "",
            "static double RequiredDTBCLK(",
            "\tbool DSCEnable,",
            "\tdouble PixelClock,",
            "\tenum dml2_output_format_class OutputFormat,",
            "\tdouble OutputBpp,",
            "\tunsigned int DSCSlices,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 4466,
          "match": "double PixelWordRate = PixelClock",
          "context": [
            "\tif (DSCEnable != true) {",
            "\t\treturn math_max2(PixelClock / 4.0 * OutputBpp / 24.0, 25.0);",
            "\t} else {",
            "\t\tdouble PixelWordRate = PixelClock / (OutputFormat == dml2_444 ? 1 : 2);",
            "\t\tdouble HCActive = math_ceil2(DSCSlices * math_ceil2(OutputBpp * math_ceil2(HActive / DSCSlices, 1) / 8.0, 1) / 3.0, 1);",
            "\t\tdouble HCBlank = 64 + 32 * math_ceil2(AudioRate * (AudioLayout == 1 ? 1 : 0.25) * HTotal / (PixelClock * 1000), 1);",
            "\t\tdouble AverageTribyteRate = PixelWordRate * (HCActive + HCBlank) / HTotal;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 4468,
          "match": "double HCBlank = 64 + 32 * math_ceil2(AudioRate * (AudioLayout == 1 ? 1 : 0.25) * HTotal / (PixelClock",
          "context": [
            "\t} else {",
            "\t\tdouble PixelWordRate = PixelClock / (OutputFormat == dml2_444 ? 1 : 2);",
            "\t\tdouble HCActive = math_ceil2(DSCSlices * math_ceil2(OutputBpp * math_ceil2(HActive / DSCSlices, 1) / 8.0, 1) / 3.0, 1);",
            "\t\tdouble HCBlank = 64 + 32 * math_ceil2(AudioRate * (AudioLayout == 1 ? 1 : 0.25) * HTotal / (PixelClock * 1000), 1);",
            "\t\tdouble AverageTribyteRate = PixelWordRate * (HCActive + HCBlank) / HTotal;",
            "\t\tdouble HActiveTribyteRate = PixelWordRate * HCActive / HActive;",
            "\t\treturn math_max4(PixelWordRate / 4.0, AverageTribyteRate / 4.0, HActiveTribyteRate / 4.0, 25.0) * 1.002;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 4485,
          "match": "double PixelClock",
          "context": [
            "\tunsigned int NumberOfDSCSlices,",
            "\tenum dml2_output_format_class OutputFormat,",
            "\tenum dml2_output_encoder_class Output,",
            "\tdouble PixelClock,",
            "\tdouble PixelClockBackEnd)",
            "{",
            "\tunsigned int DSCDelayRequirement_val = 0;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 4486,
          "match": "double PixelClock",
          "context": [
            "\tenum dml2_output_format_class OutputFormat,",
            "\tenum dml2_output_encoder_class Output,",
            "\tdouble PixelClock,",
            "\tdouble PixelClockBackEnd)",
            "{",
            "\tunsigned int DSCDelayRequirement_val = 0;",
            "\tunsigned int NumberOfDSCSlicesFactor = 1;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 4554,
          "match": "double)surface->plane0.width, ReadBlock",
          "context": [
            "\t\tconst struct dml2_surface_cfg *surface = &display_cfg->plane_descriptors[k].surface;",
            "",
            "\t\tif (composition->viewport.stationary) {",
            "\t\t\tSurfaceSizeInMALL[k] = (unsigned int)(math_min2(math_ceil2((double)surface->plane0.width, ReadBlockWidthY[k]),",
            "\t\t\t\tmath_floor2(composition->viewport.plane0.x_start + composition->viewport.plane0.width + ReadBlockWidthY[k] - 1, ReadBlockWidthY[k]) -",
            "\t\t\t\tmath_floor2((double)composition->viewport.plane0.x_start, ReadBlockWidthY[k])) *",
            "\t\t\t\tmath_min2(math_ceil2((double)surface->plane0.height, ReadBlockHeightY[k]),"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 4556,
          "match": "double)composition->viewport.plane0.x_start, ReadBlock",
          "context": [
            "\t\tif (composition->viewport.stationary) {",
            "\t\t\tSurfaceSizeInMALL[k] = (unsigned int)(math_min2(math_ceil2((double)surface->plane0.width, ReadBlockWidthY[k]),",
            "\t\t\t\tmath_floor2(composition->viewport.plane0.x_start + composition->viewport.plane0.width + ReadBlockWidthY[k] - 1, ReadBlockWidthY[k]) -",
            "\t\t\t\tmath_floor2((double)composition->viewport.plane0.x_start, ReadBlockWidthY[k])) *",
            "\t\t\t\tmath_min2(math_ceil2((double)surface->plane0.height, ReadBlockHeightY[k]),",
            "\t\t\t\t\tmath_floor2((double)composition->viewport.plane0.y_start + composition->viewport.plane0.height + ReadBlockHeightY[k] - 1, ReadBlockHeightY[k]) -",
            "\t\t\t\t\tmath_floor2((double)composition->viewport.plane0.y_start, ReadBlockHeightY[k])) * BytesPerPixelY[k]);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 4557,
          "match": "double)surface->plane0.height, ReadBlock",
          "context": [
            "\t\t\tSurfaceSizeInMALL[k] = (unsigned int)(math_min2(math_ceil2((double)surface->plane0.width, ReadBlockWidthY[k]),",
            "\t\t\t\tmath_floor2(composition->viewport.plane0.x_start + composition->viewport.plane0.width + ReadBlockWidthY[k] - 1, ReadBlockWidthY[k]) -",
            "\t\t\t\tmath_floor2((double)composition->viewport.plane0.x_start, ReadBlockWidthY[k])) *",
            "\t\t\t\tmath_min2(math_ceil2((double)surface->plane0.height, ReadBlockHeightY[k]),",
            "\t\t\t\t\tmath_floor2((double)composition->viewport.plane0.y_start + composition->viewport.plane0.height + ReadBlockHeightY[k] - 1, ReadBlockHeightY[k]) -",
            "\t\t\t\t\tmath_floor2((double)composition->viewport.plane0.y_start, ReadBlockHeightY[k])) * BytesPerPixelY[k]);",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 4558,
          "match": "double)composition->viewport.plane0.y_start + composition->viewport.plane0.height + ReadBlockHeightY[k] - 1, ReadBlock",
          "context": [
            "\t\t\t\tmath_floor2(composition->viewport.plane0.x_start + composition->viewport.plane0.width + ReadBlockWidthY[k] - 1, ReadBlockWidthY[k]) -",
            "\t\t\t\tmath_floor2((double)composition->viewport.plane0.x_start, ReadBlockWidthY[k])) *",
            "\t\t\t\tmath_min2(math_ceil2((double)surface->plane0.height, ReadBlockHeightY[k]),",
            "\t\t\t\t\tmath_floor2((double)composition->viewport.plane0.y_start + composition->viewport.plane0.height + ReadBlockHeightY[k] - 1, ReadBlockHeightY[k]) -",
            "\t\t\t\t\tmath_floor2((double)composition->viewport.plane0.y_start, ReadBlockHeightY[k])) * BytesPerPixelY[k]);",
            "",
            "\t\t\tif (ReadBlockWidthC[k] > 0) {"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 4559,
          "match": "double)composition->viewport.plane0.y_start, ReadBlock",
          "context": [
            "\t\t\t\tmath_floor2((double)composition->viewport.plane0.x_start, ReadBlockWidthY[k])) *",
            "\t\t\t\tmath_min2(math_ceil2((double)surface->plane0.height, ReadBlockHeightY[k]),",
            "\t\t\t\t\tmath_floor2((double)composition->viewport.plane0.y_start + composition->viewport.plane0.height + ReadBlockHeightY[k] - 1, ReadBlockHeightY[k]) -",
            "\t\t\t\t\tmath_floor2((double)composition->viewport.plane0.y_start, ReadBlockHeightY[k])) * BytesPerPixelY[k]);",
            "",
            "\t\t\tif (ReadBlockWidthC[k] > 0) {",
            "\t\t\t\tSurfaceSizeInMALL[k] = (unsigned int)(SurfaceSizeInMALL[k] +"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 4563,
          "match": "double)surface->plane1.width, ReadBlock",
          "context": [
            "",
            "\t\t\tif (ReadBlockWidthC[k] > 0) {",
            "\t\t\t\tSurfaceSizeInMALL[k] = (unsigned int)(SurfaceSizeInMALL[k] +",
            "\t\t\t\t\tmath_min2(math_ceil2((double)surface->plane1.width, ReadBlockWidthC[k]),",
            "\t\t\t\t\t\tmath_floor2((double)composition->viewport.plane1.y_start + composition->viewport.plane1.width + ReadBlockWidthC[k] - 1, ReadBlockWidthC[k]) -",
            "\t\t\t\t\t\tmath_floor2((double)composition->viewport.plane1.y_start, ReadBlockWidthC[k])) *",
            "\t\t\t\t\tmath_min2(math_ceil2((double)surface->plane1.height, ReadBlockHeightC[k]),"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 4564,
          "match": "double)composition->viewport.plane1.y_start + composition->viewport.plane1.width + ReadBlockWidthC[k] - 1, ReadBlock",
          "context": [
            "\t\t\tif (ReadBlockWidthC[k] > 0) {",
            "\t\t\t\tSurfaceSizeInMALL[k] = (unsigned int)(SurfaceSizeInMALL[k] +",
            "\t\t\t\t\tmath_min2(math_ceil2((double)surface->plane1.width, ReadBlockWidthC[k]),",
            "\t\t\t\t\t\tmath_floor2((double)composition->viewport.plane1.y_start + composition->viewport.plane1.width + ReadBlockWidthC[k] - 1, ReadBlockWidthC[k]) -",
            "\t\t\t\t\t\tmath_floor2((double)composition->viewport.plane1.y_start, ReadBlockWidthC[k])) *",
            "\t\t\t\t\tmath_min2(math_ceil2((double)surface->plane1.height, ReadBlockHeightC[k]),",
            "\t\t\t\t\t\tmath_floor2((double)composition->viewport.plane1.y_start + composition->viewport.plane1.height + ReadBlockHeightC[k] - 1, ReadBlockHeightC[k]) -"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 4565,
          "match": "double)composition->viewport.plane1.y_start, ReadBlock",
          "context": [
            "\t\t\t\tSurfaceSizeInMALL[k] = (unsigned int)(SurfaceSizeInMALL[k] +",
            "\t\t\t\t\tmath_min2(math_ceil2((double)surface->plane1.width, ReadBlockWidthC[k]),",
            "\t\t\t\t\t\tmath_floor2((double)composition->viewport.plane1.y_start + composition->viewport.plane1.width + ReadBlockWidthC[k] - 1, ReadBlockWidthC[k]) -",
            "\t\t\t\t\t\tmath_floor2((double)composition->viewport.plane1.y_start, ReadBlockWidthC[k])) *",
            "\t\t\t\t\tmath_min2(math_ceil2((double)surface->plane1.height, ReadBlockHeightC[k]),",
            "\t\t\t\t\t\tmath_floor2((double)composition->viewport.plane1.y_start + composition->viewport.plane1.height + ReadBlockHeightC[k] - 1, ReadBlockHeightC[k]) -",
            "\t\t\t\t\t\tmath_floor2(composition->viewport.plane1.y_start, ReadBlockHeightC[k])) * BytesPerPixelC[k]);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 4566,
          "match": "double)surface->plane1.height, ReadBlock",
          "context": [
            "\t\t\t\t\tmath_min2(math_ceil2((double)surface->plane1.width, ReadBlockWidthC[k]),",
            "\t\t\t\t\t\tmath_floor2((double)composition->viewport.plane1.y_start + composition->viewport.plane1.width + ReadBlockWidthC[k] - 1, ReadBlockWidthC[k]) -",
            "\t\t\t\t\t\tmath_floor2((double)composition->viewport.plane1.y_start, ReadBlockWidthC[k])) *",
            "\t\t\t\t\tmath_min2(math_ceil2((double)surface->plane1.height, ReadBlockHeightC[k]),",
            "\t\t\t\t\t\tmath_floor2((double)composition->viewport.plane1.y_start + composition->viewport.plane1.height + ReadBlockHeightC[k] - 1, ReadBlockHeightC[k]) -",
            "\t\t\t\t\t\tmath_floor2(composition->viewport.plane1.y_start, ReadBlockHeightC[k])) * BytesPerPixelC[k]);",
            "\t\t\t}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 4567,
          "match": "double)composition->viewport.plane1.y_start + composition->viewport.plane1.height + ReadBlockHeightC[k] - 1, ReadBlock",
          "context": [
            "\t\t\t\t\t\tmath_floor2((double)composition->viewport.plane1.y_start + composition->viewport.plane1.width + ReadBlockWidthC[k] - 1, ReadBlockWidthC[k]) -",
            "\t\t\t\t\t\tmath_floor2((double)composition->viewport.plane1.y_start, ReadBlockWidthC[k])) *",
            "\t\t\t\t\tmath_min2(math_ceil2((double)surface->plane1.height, ReadBlockHeightC[k]),",
            "\t\t\t\t\t\tmath_floor2((double)composition->viewport.plane1.y_start + composition->viewport.plane1.height + ReadBlockHeightC[k] - 1, ReadBlockHeightC[k]) -",
            "\t\t\t\t\t\tmath_floor2(composition->viewport.plane1.y_start, ReadBlockHeightC[k])) * BytesPerPixelC[k]);",
            "\t\t\t}",
            "\t\t} else {"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 4793,
          "match": "double PixelClock",
          "context": [
            "\tdouble Dppclk,",
            "\tdouble Dispclk,",
            "\tdouble DCFClkDeepSleep,",
            "\tdouble PixelClock,",
            "\tunsigned int HTotal,",
            "\tunsigned int VBlank,",
            "\tunsigned int DynamicMetadataTransmittedBytes,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 4990,
          "match": "double FabricClock",
          "context": [
            "\tunsigned int RoundTripPingLatencyCycles,",
            "\tunsigned int ReorderingBytes,",
            "\tdouble DCFCLK,",
            "\tdouble FabricClock,",
            "\tunsigned int PixelChunkSizeInKByte,",
            "\tdouble ReturnBW,",
            "\tunsigned int NumberOfActiveSurfaces,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 6748,
          "match": "double pixel_clock_mhz = p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\ts->TotalPixelBW = 0.0;",
            "\tfor (unsigned int k = 0; k < p->NumberOfActiveSurfaces; ++k) {",
            "\t\tdouble h_total = (double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.h_total;",
            "\t\tdouble pixel_clock_mhz = p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000.0;",
            "\t\tdouble v_ratio = p->display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio;",
            "\t\tdouble v_ratio_c = p->display_cfg->plane_descriptors[k].composition.scaler_info.plane1.v_ratio;",
            "\t\ts->TotalPixelBW = s->TotalPixelBW + p->DPPPerSurface[k]"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 6760,
          "match": "double pixel_clock_mhz = p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "",
            "\tfor (unsigned int k = 0; k < p->NumberOfActiveSurfaces; ++k) {",
            "\t\tdouble h_total = (double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.h_total;",
            "\t\tdouble pixel_clock_mhz = p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000.0;",
            "\t\tdouble v_ratio = p->display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio;",
            "\t\tdouble v_ratio_c = p->display_cfg->plane_descriptors[k].composition.scaler_info.plane1.v_ratio;",
            "\t\tdouble v_taps = p->display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_taps;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 6792,
          "match": "double)p->DSTXAfterScaler[k] / h_total + (double)p->DSTYAfterScaler[k]) * h_total / pixel_clock",
          "context": [
            "\t\ts->LinesInDETYRoundedDownToSwath[k] = (unsigned int)(math_floor2(s->LinesInDETY[k], p->SwathHeightY[k]));",
            "\t\ts->FullDETBufferingTimeY = s->LinesInDETYRoundedDownToSwath[k] * (h_total / pixel_clock_mhz) / v_ratio;",
            "",
            "\t\ts->ActiveClockChangeLatencyHidingY = s->EffectiveLBLatencyHidingY + s->FullDETBufferingTimeY - ((double)p->DSTXAfterScaler[k] / h_total + (double)p->DSTYAfterScaler[k]) * h_total / pixel_clock_mhz;",
            "",
            "\t\tif (p->NumberOfActiveSurfaces > 1) {",
            "\t\t\ts->ActiveClockChangeLatencyHidingY = s->ActiveClockChangeLatencyHidingY - (1.0 - 1.0 / (double)p->NumberOfActiveSurfaces) * (double)p->SwathHeightY[k] * (double)h_total / pixel_clock_mhz / v_ratio;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 6795,
          "match": "double)p->NumberOfActiveSurfaces) * (double)p->SwathHeightY[k] * (double)h_total / pixel_clock",
          "context": [
            "\t\ts->ActiveClockChangeLatencyHidingY = s->EffectiveLBLatencyHidingY + s->FullDETBufferingTimeY - ((double)p->DSTXAfterScaler[k] / h_total + (double)p->DSTYAfterScaler[k]) * h_total / pixel_clock_mhz;",
            "",
            "\t\tif (p->NumberOfActiveSurfaces > 1) {",
            "\t\t\ts->ActiveClockChangeLatencyHidingY = s->ActiveClockChangeLatencyHidingY - (1.0 - 1.0 / (double)p->NumberOfActiveSurfaces) * (double)p->SwathHeightY[k] * (double)h_total / pixel_clock_mhz / v_ratio;",
            "\t\t}",
            "",
            "\t\tif (p->BytePerPixelDETC[k] > 0) {"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 6802,
          "match": "double)p->DSTXAfterScaler[k] / (double)h_total + (double)p->DSTYAfterScaler[k]) * (double)h_total / pixel_clock",
          "context": [
            "\t\t\ts->LinesInDETC[k] = p->DETBufferSizeC[k] / p->BytePerPixelDETC[k] / p->SwathWidthC[k];",
            "\t\t\ts->LinesInDETCRoundedDownToSwath[k] = (unsigned int)(math_floor2(s->LinesInDETC[k], p->SwathHeightC[k]));",
            "\t\t\ts->FullDETBufferingTimeC = s->LinesInDETCRoundedDownToSwath[k] * (h_total / pixel_clock_mhz) / v_ratio_c;",
            "\t\t\ts->ActiveClockChangeLatencyHidingC = s->EffectiveLBLatencyHidingC + s->FullDETBufferingTimeC - ((double)p->DSTXAfterScaler[k] / (double)h_total + (double)p->DSTYAfterScaler[k]) * (double)h_total / pixel_clock_mhz;",
            "\t\t\tif (p->NumberOfActiveSurfaces > 1) {",
            "\t\t\t\ts->ActiveClockChangeLatencyHidingC = s->ActiveClockChangeLatencyHidingC - (1.0 - 1.0 / (double)p->NumberOfActiveSurfaces) * (double)p->SwathHeightC[k] * (double)h_total / pixel_clock_mhz / v_ratio_c;",
            "\t\t\t}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 6804,
          "match": "double)p->NumberOfActiveSurfaces) * (double)p->SwathHeightC[k] * (double)h_total / pixel_clock",
          "context": [
            "\t\t\ts->FullDETBufferingTimeC = s->LinesInDETCRoundedDownToSwath[k] * (h_total / pixel_clock_mhz) / v_ratio_c;",
            "\t\t\ts->ActiveClockChangeLatencyHidingC = s->EffectiveLBLatencyHidingC + s->FullDETBufferingTimeC - ((double)p->DSTXAfterScaler[k] / (double)h_total + (double)p->DSTYAfterScaler[k]) * (double)h_total / pixel_clock_mhz;",
            "\t\t\tif (p->NumberOfActiveSurfaces > 1) {",
            "\t\t\t\ts->ActiveClockChangeLatencyHidingC = s->ActiveClockChangeLatencyHidingC - (1.0 - 1.0 / (double)p->NumberOfActiveSurfaces) * (double)p->SwathHeightC[k] * (double)h_total / pixel_clock_mhz / v_ratio_c;",
            "\t\t\t}",
            "\t\t\ts->ActiveClockChangeLatencyHiding = math_min2(s->ActiveClockChangeLatencyHidingY, s->ActiveClockChangeLatencyHidingC);",
            "\t\t} else {"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 6826,
          "match": "double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].writeback.writeback_stream[0].input_height * (double)h_total / pixel_clock",
          "context": [
            "\t\t\ts->WritebackLatencyHiding = (double)p->WritebackInterfaceBufferSize * 1024.0",
            "\t\t\t\t/ ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].writeback.writeback_stream[0].output_height",
            "\t\t\t\t\t* (double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].writeback.writeback_stream[0].output_width",
            "\t\t\t\t\t/ ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].writeback.writeback_stream[0].input_height * (double)h_total / pixel_clock_mhz) * 4.0);",
            "\t\t\tif (p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].writeback.writeback_stream[0].pixel_format == dml2_444_64) {",
            "\t\t\t\ts->WritebackLatencyHiding = s->WritebackLatencyHiding / 2;",
            "\t\t\t}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 6953,
          "match": "double)p->display_cfg->stream_descriptors[stream_index].timing.pixel_clock",
          "context": [
            "",
            "\t\tdst_lines_to_hide = (unsigned int)math_ceil(p->latency_to_hide_us /",
            "\t\t\t((double)p->display_cfg->stream_descriptors[stream_index].timing.h_total /",
            "\t\t\t\t(double)p->display_cfg->stream_descriptors[stream_index].timing.pixel_clock_khz * 1000.0));",
            "",
            "\t\tsrc_lines_to_hide_l = (unsigned int)math_ceil2(p->display_cfg->plane_descriptors[plane_index].composition.scaler_info.plane0.v_ratio * dst_lines_to_hide,",
            "\t\t\tp->swath_height_l[plane_index]);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 7058,
          "match": "double)uclk_khz * dram_config->channel_count * dram_config->channel_width_bytes * dram_config->transactions_per_clock",
          "context": [
            "static double uclk_khz_to_dram_bw_mbps(unsigned long uclk_khz, const struct dml2_dram_params *dram_config)",
            "{",
            "\tdouble bw_mbps = 0;",
            "\tbw_mbps = ((double)uclk_khz * dram_config->channel_count * dram_config->channel_width_bytes * dram_config->transactions_per_clock) / 1000.0;",
            "",
            "\treturn bw_mbps;",
            "}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 7067,
          "match": "double)bw_kbps / (dram_config->channel_count * dram_config->channel_width_bytes * dram_config->transactions_per_clock",
          "context": [
            "{",
            "\tdouble uclk_mhz = 0;",
            "",
            "\tuclk_mhz = (double)bw_kbps / (dram_config->channel_count * dram_config->channel_width_bytes * dram_config->transactions_per_clock) / 1000.0;",
            "",
            "\treturn uclk_mhz;",
            "}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 7236,
          "match": "double FabricClock",
          "context": [
            "static double get_max_urgent_latency_us(",
            "\tstruct dml2_dcn4x_soc_qos_params *dcn4x,",
            "\tdouble uclk_freq_mhz,",
            "\tdouble FabricClock,",
            "\tunsigned int min_clk_index)",
            "{",
            "\tdouble latency;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 7261,
          "match": "double)stream_descriptor->timing.h_total * 1000.0 / (double)stream_descriptor->timing.pixel_clock",
          "context": [
            "\t\t\tstream_descriptor = &display_cfg->stream_descriptors[display_cfg->plane_descriptors[i].stream_index];",
            "",
            "\t\t\tpstate_keepout_dst_lines[i] =",
            "\t\t\t\t\t(unsigned int)math_ceil(watermarks->DRAMClockChangeWatermark / ((double)stream_descriptor->timing.h_total * 1000.0 / (double)stream_descriptor->timing.pixel_clock_khz));",
            "",
            "\t\t\tif (pstate_keepout_dst_lines[i] > stream_descriptor->timing.v_total - 1) {",
            "\t\t\t\tpstate_keepout_dst_lines[i] = stream_descriptor->timing.v_total - 1;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 7373,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\t\tmode_lib->ms.support.PrefetchSupported = true;",
            "",
            "\t\tfor (k = 0; k < mode_lib->ms.num_active_planes; k++) {",
            "\t\t\ts->line_times[k] = display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
            "\t\t\ts->pixel_format[k] = display_cfg->plane_descriptors[k].pixel_format;",
            "",
            "\t\t\ts->lb_source_lines_l[k] = get_num_lb_source_lines(mode_lib->ip.max_line_buffer_lines, mode_lib->ip.line_buffer_size_bits,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 7401,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "",
            "\t\t\tmyPipe->Dppclk = mode_lib->ms.RequiredDPPCLK[k];",
            "\t\t\tmyPipe->Dispclk = mode_lib->ms.RequiredDISPCLK;",
            "\t\t\tmyPipe->PixelClock = ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
            "\t\t\tmyPipe->DCFClkDeepSleep = mode_lib->ms.dcfclk_deepsleep;",
            "\t\t\tmyPipe->DPPPerSurface = mode_lib->ms.NoOfDPP[k];",
            "\t\t\tmyPipe->ScalerEnabled = display_cfg->plane_descriptors[k].composition.scaler_info.enabled;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 7761,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\t\t\t\tmode_lib->ms.BandwidthAvailableForImmediateFlip,",
            "\t\t\t\tmode_lib->ms.TotImmediateFlipBytes,",
            "\t\t\t\tdisplay_cfg->plane_descriptors[k].pixel_format,",
            "\t\t\t\t(display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)),",
            "\t\t\t\tdisplay_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio,",
            "\t\t\t\tdisplay_cfg->plane_descriptors[k].composition.scaler_info.plane1.v_ratio,",
            "\t\t\t\tmode_lib->ms.Tno_bw_flip[k],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 7894,
          "match": "double *MaxActiveDRAMClock",
          "context": [
            "\tCalculateWatermarks_params->Watermark = &mode_lib->ms.support.watermarks; // Watermarks *Watermark",
            "\tCalculateWatermarks_params->DRAMClockChangeSupport = mode_lib->ms.support.DRAMClockChangeSupport;",
            "\tCalculateWatermarks_params->global_dram_clock_change_supported = &mode_lib->ms.support.global_dram_clock_change_supported;",
            "\tCalculateWatermarks_params->MaxActiveDRAMClockChangeLatencySupported = &s->dummy_single_array[0]; // double *MaxActiveDRAMClockChangeLatencySupported[]",
            "\tCalculateWatermarks_params->SubViewportLinesNeededInMALL = mode_lib->ms.SubViewportLinesNeededInMALL; // unsigned int SubViewportLinesNeededInMALL[]",
            "\tCalculateWatermarks_params->FCLKChangeSupport = mode_lib->ms.support.FCLKChangeSupport;",
            "\tCalculateWatermarks_params->global_fclk_change_supported = &mode_lib->ms.support.global_fclk_change_supported;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 7936,
          "match": "double)min_clk_table->max_clock",
          "context": [
            "\tmode_lib->ms.SOCCLK = ((double)mode_lib->soc.clk_table.socclk.clk_values_khz[0] / 1000);",
            "\tmode_lib->ms.DCFCLK = ((double)min_clk_table->dram_bw_table.entries[in_out_params->min_clk_index].min_dcfclk_khz / 1000);",
            "\tmode_lib->ms.FabricClock = ((double)min_clk_table->dram_bw_table.entries[in_out_params->min_clk_index].min_fclk_khz / 1000);",
            "\tmode_lib->ms.MaxDCFCLK = (double)min_clk_table->max_clocks_khz.dcfclk / 1000;",
            "\tmode_lib->ms.MaxFabricClock = (double)min_clk_table->max_clocks_khz.fclk / 1000;",
            "\tmode_lib->ms.max_dispclk_freq_mhz = (double)min_clk_table->max_ss_clocks_khz.dispclk / 1000;",
            "\tmode_lib->ms.max_dscclk_freq_mhz = (double)min_clk_table->max_clocks_khz.dscclk / 1000;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 7937,
          "match": "double)min_clk_table->max_clock",
          "context": [
            "\tmode_lib->ms.DCFCLK = ((double)min_clk_table->dram_bw_table.entries[in_out_params->min_clk_index].min_dcfclk_khz / 1000);",
            "\tmode_lib->ms.FabricClock = ((double)min_clk_table->dram_bw_table.entries[in_out_params->min_clk_index].min_fclk_khz / 1000);",
            "\tmode_lib->ms.MaxDCFCLK = (double)min_clk_table->max_clocks_khz.dcfclk / 1000;",
            "\tmode_lib->ms.MaxFabricClock = (double)min_clk_table->max_clocks_khz.fclk / 1000;",
            "\tmode_lib->ms.max_dispclk_freq_mhz = (double)min_clk_table->max_ss_clocks_khz.dispclk / 1000;",
            "\tmode_lib->ms.max_dscclk_freq_mhz = (double)min_clk_table->max_clocks_khz.dscclk / 1000;",
            "\tmode_lib->ms.max_dppclk_freq_mhz = (double)min_clk_table->max_ss_clocks_khz.dppclk / 1000;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 7938,
          "match": "double)min_clk_table->max_ss_clock",
          "context": [
            "\tmode_lib->ms.FabricClock = ((double)min_clk_table->dram_bw_table.entries[in_out_params->min_clk_index].min_fclk_khz / 1000);",
            "\tmode_lib->ms.MaxDCFCLK = (double)min_clk_table->max_clocks_khz.dcfclk / 1000;",
            "\tmode_lib->ms.MaxFabricClock = (double)min_clk_table->max_clocks_khz.fclk / 1000;",
            "\tmode_lib->ms.max_dispclk_freq_mhz = (double)min_clk_table->max_ss_clocks_khz.dispclk / 1000;",
            "\tmode_lib->ms.max_dscclk_freq_mhz = (double)min_clk_table->max_clocks_khz.dscclk / 1000;",
            "\tmode_lib->ms.max_dppclk_freq_mhz = (double)min_clk_table->max_ss_clocks_khz.dppclk / 1000;",
            "\tmode_lib->ms.uclk_freq_mhz = dram_bw_kbps_to_uclk_mhz(min_clk_table->dram_bw_table.entries[in_out_params->min_clk_index].pre_derate_dram_bw_kbps, &mode_lib->soc.clk_table.dram_config);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 7939,
          "match": "double)min_clk_table->max_clock",
          "context": [
            "\tmode_lib->ms.MaxDCFCLK = (double)min_clk_table->max_clocks_khz.dcfclk / 1000;",
            "\tmode_lib->ms.MaxFabricClock = (double)min_clk_table->max_clocks_khz.fclk / 1000;",
            "\tmode_lib->ms.max_dispclk_freq_mhz = (double)min_clk_table->max_ss_clocks_khz.dispclk / 1000;",
            "\tmode_lib->ms.max_dscclk_freq_mhz = (double)min_clk_table->max_clocks_khz.dscclk / 1000;",
            "\tmode_lib->ms.max_dppclk_freq_mhz = (double)min_clk_table->max_ss_clocks_khz.dppclk / 1000;",
            "\tmode_lib->ms.uclk_freq_mhz = dram_bw_kbps_to_uclk_mhz(min_clk_table->dram_bw_table.entries[in_out_params->min_clk_index].pre_derate_dram_bw_kbps, &mode_lib->soc.clk_table.dram_config);",
            "\tmode_lib->ms.dram_bw_mbps = ((double)min_clk_table->dram_bw_table.entries[in_out_params->min_clk_index].pre_derate_dram_bw_kbps / 1000);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 7940,
          "match": "double)min_clk_table->max_ss_clock",
          "context": [
            "\tmode_lib->ms.MaxFabricClock = (double)min_clk_table->max_clocks_khz.fclk / 1000;",
            "\tmode_lib->ms.max_dispclk_freq_mhz = (double)min_clk_table->max_ss_clocks_khz.dispclk / 1000;",
            "\tmode_lib->ms.max_dscclk_freq_mhz = (double)min_clk_table->max_clocks_khz.dscclk / 1000;",
            "\tmode_lib->ms.max_dppclk_freq_mhz = (double)min_clk_table->max_ss_clocks_khz.dppclk / 1000;",
            "\tmode_lib->ms.uclk_freq_mhz = dram_bw_kbps_to_uclk_mhz(min_clk_table->dram_bw_table.entries[in_out_params->min_clk_index].pre_derate_dram_bw_kbps, &mode_lib->soc.clk_table.dram_config);",
            "\tmode_lib->ms.dram_bw_mbps = ((double)min_clk_table->dram_bw_table.entries[in_out_params->min_clk_index].pre_derate_dram_bw_kbps / 1000);",
            "\tmode_lib->ms.max_dram_bw_mbps = ((double)min_clk_table->dram_bw_table.entries[min_clk_table->dram_bw_table.num_entries - 1].pre_derate_dram_bw_kbps / 1000);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 8061,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\t}",
            "",
            "\tfor (k = 0; k <= mode_lib->ms.num_active_planes - 1; k++) {",
            "\t\tmode_lib->ms.vactive_sw_bw_l[k] = mode_lib->ms.SwathWidthYSingleDPP[k] * math_ceil2(mode_lib->ms.BytePerPixelY[k], 1.0) / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio;",
            "\t\tmode_lib->ms.vactive_sw_bw_c[k] = mode_lib->ms.SwathWidthCSingleDPP[k] * math_ceil2(mode_lib->ms.BytePerPixelC[k], 2.0) / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane1.v_ratio;",
            "",
            "\t\tmode_lib->ms.cursor_bw[k] = display_cfg->plane_descriptors[k].cursor.num_cursors * display_cfg->plane_descriptors[k].cursor.cursor_width *"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 8062,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "",
            "\tfor (k = 0; k <= mode_lib->ms.num_active_planes - 1; k++) {",
            "\t\tmode_lib->ms.vactive_sw_bw_l[k] = mode_lib->ms.SwathWidthYSingleDPP[k] * math_ceil2(mode_lib->ms.BytePerPixelY[k], 1.0) / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio;",
            "\t\tmode_lib->ms.vactive_sw_bw_c[k] = mode_lib->ms.SwathWidthCSingleDPP[k] * math_ceil2(mode_lib->ms.BytePerPixelC[k], 2.0) / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane1.v_ratio;",
            "",
            "\t\tmode_lib->ms.cursor_bw[k] = display_cfg->plane_descriptors[k].cursor.num_cursors * display_cfg->plane_descriptors[k].cursor.cursor_width *",
            "\t\t\tdisplay_cfg->plane_descriptors[k].cursor.cursor_bpp / 8.0 / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000));"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 8065,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\t\tmode_lib->ms.vactive_sw_bw_c[k] = mode_lib->ms.SwathWidthCSingleDPP[k] * math_ceil2(mode_lib->ms.BytePerPixelC[k], 2.0) / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane1.v_ratio;",
            "",
            "\t\tmode_lib->ms.cursor_bw[k] = display_cfg->plane_descriptors[k].cursor.num_cursors * display_cfg->plane_descriptors[k].cursor.cursor_width *",
            "\t\t\tdisplay_cfg->plane_descriptors[k].cursor.cursor_bpp / 8.0 / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000));",
            "",
            "#ifdef __DML_VBA_DEBUG__",
            "\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u, old_ReadBandwidthLuma = %f\\n\", __func__, k, mode_lib->ms.SwathWidthYSingleDPP[k] * math_ceil2(mode_lib->ms.BytePerPixelInDETY[k], 1.0) / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 8068,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\t\t\tdisplay_cfg->plane_descriptors[k].cursor.cursor_bpp / 8.0 / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000));",
            "",
            "#ifdef __DML_VBA_DEBUG__",
            "\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u, old_ReadBandwidthLuma = %f\\n\", __func__, k, mode_lib->ms.SwathWidthYSingleDPP[k] * math_ceil2(mode_lib->ms.BytePerPixelInDETY[k], 1.0) / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio);",
            "\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u, old_ReadBandwidthChroma = %f\\n\", __func__, k, mode_lib->ms.SwathWidthYSingleDPP[k] / 2 * math_ceil2(mode_lib->ms.BytePerPixelInDETC[k], 2.0) / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio / 2.0);",
            "\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u, vactive_sw_bw_l = %f\\n\", __func__, k, mode_lib->ms.vactive_sw_bw_l[k]);",
            "\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u, vactive_sw_bw_c = %f\\n\", __func__, k, mode_lib->ms.vactive_sw_bw_c[k]);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 8069,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "",
            "#ifdef __DML_VBA_DEBUG__",
            "\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u, old_ReadBandwidthLuma = %f\\n\", __func__, k, mode_lib->ms.SwathWidthYSingleDPP[k] * math_ceil2(mode_lib->ms.BytePerPixelInDETY[k], 1.0) / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio);",
            "\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u, old_ReadBandwidthChroma = %f\\n\", __func__, k, mode_lib->ms.SwathWidthYSingleDPP[k] / 2 * math_ceil2(mode_lib->ms.BytePerPixelInDETC[k], 2.0) / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio / 2.0);",
            "\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u, vactive_sw_bw_l = %f\\n\", __func__, k, mode_lib->ms.vactive_sw_bw_l[k]);",
            "\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u, vactive_sw_bw_c = %f\\n\", __func__, k, mode_lib->ms.vactive_sw_bw_c[k]);",
            "#endif"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 8082,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\t\t\t\t* display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].writeback.writeback_stream[0].output_width",
            "\t\t\t\t/ (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].writeback.writeback_stream[0].input_height",
            "\t\t\t\t\t* display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total",
            "\t\t\t\t\t/ ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * 8.0;",
            "\t\t} else if (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].writeback.active_writebacks_per_stream > 0) {",
            "\t\t\tmode_lib->ms.WriteBandwidth[k][0] = display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].writeback.writeback_stream[0].output_height",
            "\t\t\t\t* display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].writeback.writeback_stream[0].output_width"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 8088,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\t\t\t\t* display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].writeback.writeback_stream[0].output_width",
            "\t\t\t\t/ (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].writeback.writeback_stream[0].input_height",
            "\t\t\t\t\t* display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total",
            "\t\t\t\t\t/ ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * 4.0;",
            "\t\t} else {",
            "\t\t\tmode_lib->ms.WriteBandwidth[k][0] = 0.0;",
            "\t\t}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 8133,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\t\t\tdisplay_cfg->plane_descriptors[k].composition.scaler_info.plane1.v_ratio,",
            "\t\t\tmode_lib->ip.max_dchub_pscl_bw_pix_per_clk,",
            "\t\t\tmode_lib->ip.max_pscl_lb_bw_pix_per_clk,",
            "\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000),",
            "\t\t\tdisplay_cfg->plane_descriptors[k].pixel_format,",
            "\t\t\tdisplay_cfg->plane_descriptors[k].composition.scaler_info.plane0.h_taps,",
            "\t\t\tdisplay_cfg->plane_descriptors[k].composition.scaler_info.plane1.h_taps,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 8380,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\t\t\tfalse, // DSCEnable",
            "\t\t\tmode_lib->ms.TotalNumberOfActiveDPP,",
            "\t\t\tmode_lib->ip.max_num_dpp,",
            "\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000),",
            "\t\t\tmode_lib->ms.support.NumberOfDSCSlices[k],",
            "",
            "\t\t\t/* Output */"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 8399,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\t\t\ttrue, // DSCEnable",
            "\t\t\tmode_lib->ms.TotalNumberOfActiveDPP,",
            "\t\t\tmode_lib->ip.max_num_dpp,",
            "\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000),",
            "\t\t\tmode_lib->ms.support.NumberOfDSCSlices[k],",
            "",
            "\t\t\t/* Output */"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 8550,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\t\tif (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].writeback.active_writebacks_per_stream > 0) {",
            "\t\t\tmode_lib->ms.WritebackRequiredDISPCLK = math_max2(mode_lib->ms.WritebackRequiredDISPCLK,",
            "\t\t\t\tCalculateWriteBackDISPCLK(display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].writeback.writeback_stream[0].pixel_format,",
            "\t\t\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000),",
            "\t\t\t\t\tdisplay_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].writeback.writeback_stream[0].h_ratio,",
            "\t\t\t\t\tdisplay_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].writeback.writeback_stream[0].v_ratio,",
            "\t\t\t\t\tdisplay_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].writeback.writeback_stream[0].h_taps,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 8700,
          "match": "double)min_clk_table->max_ss_clock",
          "context": [
            "\t\t\t\tdisplay_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].output.audio_sample_rate,",
            "\t\t\t\tdisplay_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].output.audio_sample_layout);",
            "",
            "\t\t\tif (mode_lib->ms.RequiredDTBCLK[k] > ((double)min_clk_table->max_ss_clocks_khz.dtbclk / 1000)) {",
            "\t\t\t\tmode_lib->ms.support.DTBCLKRequiredMoreThanSupported = true;",
            "\t\t\t}",
            "\t\t} else {"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 8799,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\t\t\tmode_lib->ms.support.NumberOfDSCSlices[k],",
            "\t\t\tdisplay_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].output.output_format,",
            "\t\t\tdisplay_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].output.output_encoder,",
            "\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000),",
            "\t\t\ts->PixelClockBackEnd[k]);",
            "\t}",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 8865,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\t}",
            "",
            "\tfor (k = 0; k < mode_lib->ms.num_active_planes; ++k) {",
            "\t\ts->SurfParameters[k].PixelClock = ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
            "\t\ts->SurfParameters[k].DPPPerSurface = mode_lib->ms.NoOfDPP[k];",
            "\t\ts->SurfParameters[k].RotationAngle = display_cfg->plane_descriptors[k].composition.rotation_angle;",
            "\t\ts->SurfParameters[k].ViewportHeight = display_cfg->plane_descriptors[k].composition.viewport.plane0.height;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 9063,
          "match": "double line_time_us = (double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\tmode_lib->ms.TripToMemory = math_max2(mode_lib->ms.UrgLatency, mode_lib->ms.TripToMemory);",
            "",
            "\tfor (k = 0; k < mode_lib->ms.num_active_planes; ++k) {",
            "\t\tdouble line_time_us = (double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
            "\t\tbool cursor_not_enough_urgent_latency_hiding = false;",
            "",
            "\t\tif (display_cfg->plane_descriptors[k].cursor.num_cursors > 0) {"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 9202,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\t\t\ts->SubViewportMALLPStateMethod = true;",
            "\t\t\tif (!display_cfg->overrides.enable_subvp_implicit_pmo) {",
            "\t\t\t\t// For dv, small frame tests will have very high refresh rate",
            "\t\t\t\tunsigned long long refresh_rate = (unsigned long long) ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz * 1000 /",
            "\t\t\t\t\t(double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total /",
            "\t\t\t\t\t(double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.v_total);",
            "\t\t\t\tif (refresh_rate > 120)"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 9619,
          "match": "double pixel_clock_mhz = ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\tdouble DisplayPipeRequestDeliveryTimeChromaPrefetch[])",
            "{",
            "\tfor (unsigned int k = 0; k < NumberOfActiveSurfaces; ++k) {",
            "\t\tdouble pixel_clock_mhz = ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
            "",
            "#ifdef __DML_VBA_DEBUG__",
            "\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u : HRatio = %f\\n\", __func__, k, display_cfg->plane_descriptors[k].composition.scaler_info.plane0.h_ratio);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 9715,
          "match": "double pixel_clock",
          "context": [
            "\tunsigned int dpte_groups_per_row_luma_ub;",
            "\tunsigned int dpte_group_width_chroma;",
            "\tunsigned int dpte_groups_per_row_chroma_ub;",
            "\tdouble pixel_clock_mhz;",
            "",
            "\tfor (unsigned int k = 0; k < p->NumberOfActiveSurfaces; ++k) {",
            "\t\tp->DST_Y_PER_PTE_ROW_NOM_L[k] = p->dpte_row_height[k] / p->display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 9809,
          "match": "double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\t}",
            "",
            "\tfor (unsigned int k = 0; k < p->NumberOfActiveSurfaces; ++k) {",
            "\t\tpixel_clock_mhz = ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
            "",
            "\t\tif (p->display_cfg->plane_descriptors[k].tdlut.setup_for_tdlut)",
            "\t\t\tp->time_per_tdlut_group[k] = 2 * p->dst_y_per_row_vblank[k] * p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.h_total / pixel_clock_mhz / p->tdlut_groups_per_2row_ub[k];"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 9929,
          "match": "double pixel_clock_mhz = ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\tDML_LOG_VERBOSE(\"DML::%s: NumberOfActiveSurfaces = %u\\n\", __func__, NumberOfActiveSurfaces);",
            "#endif",
            "\tfor (unsigned int k = 0; k < NumberOfActiveSurfaces; ++k) {",
            "\t\tdouble pixel_clock_mhz = ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
            "\t\tbool dcc_mrq_enable = display_cfg->plane_descriptors[k].surface.dcc.enable && mrq_present;",
            "#ifdef __DML_VBA_DEBUG__",
            "\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u, dcc_mrq_enable = %u\\n\", __func__, k, dcc_mrq_enable);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 10043,
          "match": "double SinglePixelClock",
          "context": [
            "\tstruct dml2_core_calcs_CalculateStutterEfficiency_locals *l = &scratch->CalculateStutterEfficiency_locals;",
            "",
            "\tunsigned int TotalNumberOfActiveOTG = 0;",
            "\tdouble SinglePixelClock = 0;",
            "\tunsigned int SingleHTotal = 0;",
            "\tunsigned int SingleVTotal = 0;",
            "\tbool SameTiming = true;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 10152,
          "match": "double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\t\tif (!dml_is_phantom_pipe(&p->display_cfg->plane_descriptors[k])) {",
            "\t\t\tl->LinesInDETY = ((double)p->DETBufferSizeY[k] + (p->UnboundedRequestEnabled == true ? l->EffectiveCompressedBufferSize : 0) * p->ReadBandwidthSurfaceLuma[k] / p->TotalDataReadBandwidth) / p->BytePerPixelDETY[k] / p->SwathWidthY[k];",
            "\t\t\tl->LinesInDETYRoundedDownToSwath = math_floor2(l->LinesInDETY, p->SwathHeightY[k]);",
            "\t\t\tl->DETBufferingTimeY = l->LinesInDETYRoundedDownToSwath * ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) / p->display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio;",
            "#ifdef __DML_VBA_DEBUG__",
            "\t\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u, DETBufferSizeY = %u (%u kbytes)\\n\", __func__, k, p->DETBufferSizeY[k], p->DETBufferSizeY[k] / 1024);",
            "\t\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u, BytePerPixelDETY = %f\\n\", __func__, k, p->BytePerPixelDETY[k]);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 10170,
          "match": "double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.v_total / 2.0, 1.0) : p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.v_total) * (double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "",
            "\t\t\t\tFoundCriticalSurface = true;",
            "\t\t\t\t*p->StutterPeriod = l->DETBufferingTimeY;",
            "\t\t\t\tl->FrameTimeCriticalSurface = (isInterlaceTiming ? math_floor2((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.v_total / 2.0, 1.0) : p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.v_total) * (double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
            "\t\t\t\tl->VActiveTimeCriticalSurface = (isInterlaceTiming ? math_floor2((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.v_active / 2.0, 1.0) : p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.v_active) * (double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
            "\t\t\t\tl->BytePerPixelYCriticalSurface = p->BytePerPixelY[k];",
            "\t\t\t\tl->SwathWidthYCriticalSurface = p->SwathWidthY[k];"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 10171,
          "match": "double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.v_active / 2.0, 1.0) : p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.v_active) * (double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\t\t\t\tFoundCriticalSurface = true;",
            "\t\t\t\t*p->StutterPeriod = l->DETBufferingTimeY;",
            "\t\t\t\tl->FrameTimeCriticalSurface = (isInterlaceTiming ? math_floor2((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.v_total / 2.0, 1.0) : p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.v_total) * (double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
            "\t\t\t\tl->VActiveTimeCriticalSurface = (isInterlaceTiming ? math_floor2((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.v_active / 2.0, 1.0) : p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.v_active) * (double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
            "\t\t\t\tl->BytePerPixelYCriticalSurface = p->BytePerPixelY[k];",
            "\t\t\t\tl->SwathWidthYCriticalSurface = p->SwathWidthY[k];",
            "\t\t\t\tl->SwathHeightYCriticalSurface = p->SwathHeightY[k];"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 10242,
          "match": "double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\t\t\t\t\tl->TotalActiveWriteback = l->TotalActiveWriteback + 1;",
            "",
            "\t\t\t\tif (TotalNumberOfActiveOTG == 0) { // first otg",
            "\t\t\t\t\tSinglePixelClock = ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
            "\t\t\t\t\tSingleHTotal = p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.h_total;",
            "\t\t\t\t\tSingleVTotal = p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.v_total;",
            "\t\t\t\t} else if (SinglePixelClock != ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000) ||"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 10245,
          "match": "double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\t\t\t\t\tSinglePixelClock = ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
            "\t\t\t\t\tSingleHTotal = p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.h_total;",
            "\t\t\t\t\tSingleVTotal = p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.v_total;",
            "\t\t\t\t} else if (SinglePixelClock != ((double)p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000) ||",
            "\t\t\t\t\t\t\tSingleHTotal != p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.h_total ||",
            "\t\t\t\t\t\t\tSingleVTotal != p->display_cfg->stream_descriptors[p->display_cfg->plane_descriptors[k].stream_index].timing.v_total) {",
            "\t\t\t\t\tSameTiming = false;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 10351,
          "match": "double max_fclk_mhz = min_clk_table->max_clock",
          "context": [
            "\tbool must_support_iflip;",
            "\tconst long min_return_uclk_cycles = 83;",
            "\tconst long min_return_fclk_cycles = 75;",
            "\tconst double max_fclk_mhz = min_clk_table->max_clocks_khz.fclk / 1000.0;",
            "\tdouble hard_minimum_dcfclk_mhz = (double)min_clk_table->dram_bw_table.entries[0].min_dcfclk_khz / 1000.0;",
            "\tdouble max_uclk_mhz = 0;",
            "\tdouble min_return_latency_in_DCFCLK_cycles = 0;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 10372,
          "match": "double)programming->min_clock",
          "context": [
            "\tmode_lib->mp.dram_bw_mbps = uclk_khz_to_dram_bw_mbps(programming->min_clocks.dcn4x.active.uclk_khz, &mode_lib->soc.clk_table.dram_config);",
            "\tmode_lib->mp.uclk_freq_mhz = programming->min_clocks.dcn4x.active.uclk_khz / 1000.0;",
            "\tmode_lib->mp.GlobalDPPCLK = programming->min_clocks.dcn4x.dpprefclk_khz / 1000.0;",
            "\ts->SOCCLK = (double)programming->min_clocks.dcn4x.socclk_khz / 1000;",
            "\tmode_lib->mp.qos_param_index = get_qos_param_index(programming->min_clocks.dcn4x.active.uclk_khz, mode_lib->soc.qos_parameters.qos_params.dcn4x.per_uclk_dpm_params);",
            "\tmode_lib->mp.active_min_uclk_dpm_index = get_active_min_uclk_dpm_index(programming->min_clocks.dcn4x.active.uclk_khz, &mode_lib->soc.clk_table);",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 10482,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\t\t\tdisplay_cfg->plane_descriptors[k].composition.scaler_info.plane1.v_ratio,",
            "\t\t\tmode_lib->ip.max_dchub_pscl_bw_pix_per_clk,",
            "\t\t\tmode_lib->ip.max_pscl_lb_bw_pix_per_clk,",
            "\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000),",
            "\t\t\tdisplay_cfg->plane_descriptors[k].pixel_format,",
            "\t\t\tdisplay_cfg->plane_descriptors[k].composition.scaler_info.plane0.h_taps,",
            "\t\t\tdisplay_cfg->plane_descriptors[k].composition.scaler_info.plane1.v_taps,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 10548,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "",
            "\tfor (k = 0; k < s->num_active_planes; ++k) {",
            "\t\tmode_lib->mp.cursor_bw[k] = display_cfg->plane_descriptors[k].cursor.num_cursors * display_cfg->plane_descriptors[k].cursor.cursor_width * display_cfg->plane_descriptors[k].cursor.cursor_bpp / 8.0 /",
            "\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000));",
            "\t\tmode_lib->mp.vactive_sw_bw_l[k] = mode_lib->mp.SwathWidthSingleDPPY[k] * mode_lib->mp.BytePerPixelY[k] / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio;",
            "\t\tmode_lib->mp.vactive_sw_bw_c[k] = mode_lib->mp.SwathWidthSingleDPPC[k] * mode_lib->mp.BytePerPixelC[k] / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane1.v_ratio;",
            "\t\tDML_LOG_VERBOSE(\"DML::%s: vactive_sw_bw_l[%i] = %fBps\\n\", __func__, k, mode_lib->mp.vactive_sw_bw_l[k]);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 10549,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\tfor (k = 0; k < s->num_active_planes; ++k) {",
            "\t\tmode_lib->mp.cursor_bw[k] = display_cfg->plane_descriptors[k].cursor.num_cursors * display_cfg->plane_descriptors[k].cursor.cursor_width * display_cfg->plane_descriptors[k].cursor.cursor_bpp / 8.0 /",
            "\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000));",
            "\t\tmode_lib->mp.vactive_sw_bw_l[k] = mode_lib->mp.SwathWidthSingleDPPY[k] * mode_lib->mp.BytePerPixelY[k] / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio;",
            "\t\tmode_lib->mp.vactive_sw_bw_c[k] = mode_lib->mp.SwathWidthSingleDPPC[k] * mode_lib->mp.BytePerPixelC[k] / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane1.v_ratio;",
            "\t\tDML_LOG_VERBOSE(\"DML::%s: vactive_sw_bw_l[%i] = %fBps\\n\", __func__, k, mode_lib->mp.vactive_sw_bw_l[k]);",
            "\t\tDML_LOG_VERBOSE(\"DML::%s: vactive_sw_bw_c[%i] = %fBps\\n\", __func__, k, mode_lib->mp.vactive_sw_bw_c[k]);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 10550,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\t\tmode_lib->mp.cursor_bw[k] = display_cfg->plane_descriptors[k].cursor.num_cursors * display_cfg->plane_descriptors[k].cursor.cursor_width * display_cfg->plane_descriptors[k].cursor.cursor_bpp / 8.0 /",
            "\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000));",
            "\t\tmode_lib->mp.vactive_sw_bw_l[k] = mode_lib->mp.SwathWidthSingleDPPY[k] * mode_lib->mp.BytePerPixelY[k] / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio;",
            "\t\tmode_lib->mp.vactive_sw_bw_c[k] = mode_lib->mp.SwathWidthSingleDPPC[k] * mode_lib->mp.BytePerPixelC[k] / (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)) * display_cfg->plane_descriptors[k].composition.scaler_info.plane1.v_ratio;",
            "\t\tDML_LOG_VERBOSE(\"DML::%s: vactive_sw_bw_l[%i] = %fBps\\n\", __func__, k, mode_lib->mp.vactive_sw_bw_l[k]);",
            "\t\tDML_LOG_VERBOSE(\"DML::%s: vactive_sw_bw_c[%i] = %fBps\\n\", __func__, k, mode_lib->mp.vactive_sw_bw_c[k]);",
            "\t}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 10623,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\t\t\tcfg_support_info->stream_support_info[display_cfg->plane_descriptors[k].stream_index].num_dsc_slices,",
            "\t\t\tdisplay_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].output.output_format,",
            "\t\t\tdisplay_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].output.output_encoder,",
            "\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000),",
            "\t\t\ts->PixelClockBackEnd[k]);",
            "\t}",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 10653,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\t}",
            "",
            "\tfor (k = 0; k < s->num_active_planes; ++k) {",
            "\t\ts->SurfaceParameters[k].PixelClock = ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
            "\t\ts->SurfaceParameters[k].DPPPerSurface = mode_lib->mp.NoOfDPP[k];",
            "\t\ts->SurfaceParameters[k].RotationAngle = display_cfg->plane_descriptors[k].composition.rotation_angle;",
            "\t\ts->SurfaceParameters[k].ViewportHeight = display_cfg->plane_descriptors[k].composition.viewport.plane0.height;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 11033,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\tfor (k = 0; k < s->num_active_planes; ++k) {",
            "\t\tbool cursor_not_enough_urgent_latency_hiding = false;",
            "\t\ts->line_times[k] = display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total /",
            "\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
            "",
            "\t\ts->pixel_format[k] = display_cfg->plane_descriptors[k].pixel_format;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 11168,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "",
            "\t\t\tmyPipe->Dppclk = mode_lib->mp.Dppclk[k];",
            "\t\t\tmyPipe->Dispclk = mode_lib->mp.Dispclk;",
            "\t\t\tmyPipe->PixelClock = ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
            "\t\t\tmyPipe->DCFClkDeepSleep = mode_lib->mp.DCFCLKDeepSleep;",
            "\t\t\tmyPipe->DPPPerSurface = mode_lib->mp.NoOfDPP[k];",
            "\t\t\tmyPipe->ScalerEnabled = display_cfg->plane_descriptors[k].composition.scaler_info.enabled;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 11335,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\t\tif (mode_lib->mp.PrefetchModeSupported == true) {",
            "\t\t\tfor (k = 0; k < s->num_active_planes; ++k) {",
            "\t\t\t\tdouble line_time_us = display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total /",
            "\t\t\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
            "\t\t\t\tCalculateUrgentBurstFactor(",
            "\t\t\t\t\t&display_cfg->plane_descriptors[k],",
            "\t\t\t\t\tmode_lib->mp.swath_width_luma_ub[k],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 11491,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\t\t\t\t\tmode_lib->mp.BandwidthAvailableForImmediateFlip,",
            "\t\t\t\t\tmode_lib->mp.TotImmediateFlipBytes,",
            "\t\t\t\t\tdisplay_cfg->plane_descriptors[k].pixel_format,",
            "\t\t\t\t\tdisplay_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000),",
            "\t\t\t\t\tdisplay_cfg->plane_descriptors[k].composition.scaler_info.plane0.v_ratio,",
            "\t\t\t\t\tdisplay_cfg->plane_descriptors[k].composition.scaler_info.plane1.v_ratio,",
            "\t\t\t\t\tmode_lib->mp.Tno_bw[k],"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 11703,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000) - mode_lib->mp.Watermark.WritebackDRAMClock",
          "context": [
            "\t\tfor (k = 0; k < s->num_active_planes; ++k) {",
            "\t\t\tif (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].writeback.active_writebacks_per_stream > 0) {",
            "\t\t\t\tmode_lib->mp.WritebackAllowDRAMClockChangeEndPosition[k] = math_max2(0, mode_lib->mp.VStartupMin[k] * display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total /",
            "\t\t\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000) - mode_lib->mp.Watermark.WritebackDRAMClockChangeWatermark);",
            "\t\t\t\tmode_lib->mp.WritebackAllowFCLKChangeEndPosition[k] = math_max2(0, mode_lib->mp.VStartupMin[k] * display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total /",
            "\t\t\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000) - mode_lib->mp.Watermark.WritebackFCLKChangeWatermark);",
            "\t\t\t} else {"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 11705,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "\t\t\t\tmode_lib->mp.WritebackAllowDRAMClockChangeEndPosition[k] = math_max2(0, mode_lib->mp.VStartupMin[k] * display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total /",
            "\t\t\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000) - mode_lib->mp.Watermark.WritebackDRAMClockChangeWatermark);",
            "\t\t\t\tmode_lib->mp.WritebackAllowFCLKChangeEndPosition[k] = math_max2(0, mode_lib->mp.VStartupMin[k] * display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total /",
            "\t\t\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000) - mode_lib->mp.Watermark.WritebackFCLKChangeWatermark);",
            "\t\t\t} else {",
            "\t\t\t\tmode_lib->mp.WritebackAllowDRAMClockChangeEndPosition[k] = 0;",
            "\t\t\t\tmode_lib->mp.WritebackAllowFCLKChangeEndPosition[k] = 0;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 11829,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "#ifdef __DML_VBA_DEBUG__",
            "\t\t\tDML_LOG_VERBOSE(\"DML::%s: k=%u, MinTTUVBlank = %f (before vstartup margin)\\n\", __func__, k, mode_lib->mp.MinTTUVBlank[k]);",
            "#endif",
            "\t\t\ts->Tvstartup_margin = (s->MaxVStartupLines[k] - mode_lib->mp.VStartupMin[k]) * display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000);",
            "\t\t\tmode_lib->mp.MinTTUVBlank[k] = mode_lib->mp.MinTTUVBlank[k] + s->Tvstartup_margin;",
            "",
            "#ifdef __DML_VBA_DEBUG__"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 11850,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock",
          "context": [
            "",
            "\t\t\ts->dlg_vblank_start = ((isInterlaceTiming ? math_floor2((display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.v_total - display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.v_front_porch) / 2.0, 1.0) :",
            "\t\t\t\tdisplay_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.v_total) - display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.v_front_porch);",
            "\t\t\ts->LSetup = math_floor2(4.0 * mode_lib->mp.TSetup[k] / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.h_total / ((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.pixel_clock_khz / 1000)), 1.0) / 4.0;",
            "\t\t\ts->blank_lines_remaining = (display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.v_total - display_cfg->stream_descriptors[display_cfg->plane_descriptors[k].stream_index].timing.v_active) - mode_lib->mp.VStartup[k];",
            "",
            "\t\t\tif (s->blank_lines_remaining < 0) {"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 11893,
          "match": "double)display_cfg->stream_descriptors[k].timing.pixel_clock",
          "context": [
            "\t\t\t\ts->WRBandwidth = display_cfg->stream_descriptors[k].writeback.writeback_stream[0].output_height",
            "\t\t\t\t\t* display_cfg->stream_descriptors[k].writeback.writeback_stream[0].output_width /",
            "\t\t\t\t\t(display_cfg->stream_descriptors[k].timing.h_total * display_cfg->stream_descriptors[k].writeback.writeback_stream[0].input_height",
            "\t\t\t\t\t\t/ ((double)display_cfg->stream_descriptors[k].timing.pixel_clock_khz / 1000))",
            "\t\t\t\t\t* (display_cfg->stream_descriptors[k].writeback.writeback_stream[0].pixel_format == dml2_444_32 ? 4.0 : 8.0);",
            "\t\t\t\ts->TotalWRBandwidth = s->TotalWRBandwidth + s->WRBandwidth;",
            "\t\t\t}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 12377,
          "match": "double)l->timing->pixel_clock",
          "context": [
            "\t\tl->hblank_end = l->timing->h_blank_end;",
            "\t\tl->vblank_end = l->timing->v_blank_end;",
            "\t\tl->interlaced = l->timing->interlaced;",
            "\t\tl->pclk_freq_in_mhz = (double)l->timing->pixel_clock_khz / 1000;",
            "\t\tl->ref_freq_to_pix_freq = l->refclk_freq_in_mhz / l->pclk_freq_in_mhz;",
            "",
            "\t\tDML_LOG_VERBOSE(\"DML_DLG::%s: plane_idx = %d\\n\", __func__, l->plane_idx);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 12900,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[plane_idx].stream_index].timing.pixel_clock",
          "context": [
            "",
            "\tout->nominal_vblank_pstate_latency_hiding_us =",
            "\t\t(int)(display_cfg->stream_descriptors[display_cfg->plane_descriptors[plane_idx].stream_index].timing.h_total /",
            "\t\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[plane_idx].stream_index].timing.pixel_clock_khz / 1000) * mode_lib->ms.TWait[plane_idx]);",
            "",
            "\tout->dram_change_latency_hiding_margin_in_active = (int)mode_lib->ms.VActiveLatencyHidingMargin[plane_idx];",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c",
          "line": 12921,
          "match": "double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[plane_index].stream_index].timing.pixel_clock",
          "context": [
            "\tunsigned int rem;",
            "",
            "\tphantom_processing_delay_pix = (double)((mode_lib->ip.subvp_fw_processing_delay_us + mode_lib->ip.subvp_pstate_allow_width_us) *",
            "\t\t((double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[plane_index].stream_index].timing.pixel_clock_khz / 1000));",
            "\tphantom_processing_delay_lines = (unsigned int)(phantom_processing_delay_pix / (double)display_cfg->stream_descriptors[display_cfg->plane_descriptors[plane_index].stream_index].timing.h_total);",
            "\tdml2_core_div_rem(phantom_processing_delay_pix,",
            "\t\t\t\tdisplay_cfg->stream_descriptors[display_cfg->plane_descriptors[plane_index].stream_index].timing.h_total,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_core\\dml2_core_dcn4_calcs.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_mcg\\dml2_mcg_dcn4.c",
          "line": 185,
          "match": "double)min_table->max_clock",
          "context": [
            "\tmin_table->max_clocks_khz.dtbclk = soc_bb->clk_table.dtbclk.clk_values_khz[soc_bb->clk_table.dtbclk.num_clk_values - 1];",
            "\tmin_table->max_clocks_khz.phyclk = soc_bb->clk_table.phyclk.clk_values_khz[soc_bb->clk_table.phyclk.num_clk_values - 1];",
            "",
            "\tmin_table->max_ss_clocks_khz.dispclk = (unsigned int)((double)min_table->max_clocks_khz.dispclk / (1.0 + soc_bb->dcn_downspread_percent / 100.0));",
            "\tmin_table->max_ss_clocks_khz.dppclk = (unsigned int)((double)min_table->max_clocks_khz.dppclk / (1.0 + soc_bb->dcn_downspread_percent / 100.0));",
            "\tmin_table->max_ss_clocks_khz.dtbclk = (unsigned int)((double)min_table->max_clocks_khz.dtbclk / (1.0 + soc_bb->dcn_downspread_percent / 100.0));",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_mcg\\dml2_mcg_dcn4.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_mcg\\dml2_mcg_dcn4.c",
          "line": 186,
          "match": "double)min_table->max_clock",
          "context": [
            "\tmin_table->max_clocks_khz.phyclk = soc_bb->clk_table.phyclk.clk_values_khz[soc_bb->clk_table.phyclk.num_clk_values - 1];",
            "",
            "\tmin_table->max_ss_clocks_khz.dispclk = (unsigned int)((double)min_table->max_clocks_khz.dispclk / (1.0 + soc_bb->dcn_downspread_percent / 100.0));",
            "\tmin_table->max_ss_clocks_khz.dppclk = (unsigned int)((double)min_table->max_clocks_khz.dppclk / (1.0 + soc_bb->dcn_downspread_percent / 100.0));",
            "\tmin_table->max_ss_clocks_khz.dtbclk = (unsigned int)((double)min_table->max_clocks_khz.dtbclk / (1.0 + soc_bb->dcn_downspread_percent / 100.0));",
            "",
            "\tmin_table->max_clocks_khz.dcfclk = soc_bb->clk_table.dcfclk.clk_values_khz[soc_bb->clk_table.dcfclk.num_clk_values - 1];"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_mcg\\dml2_mcg_dcn4.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_mcg\\dml2_mcg_dcn4.c",
          "line": 187,
          "match": "double)min_table->max_clock",
          "context": [
            "",
            "\tmin_table->max_ss_clocks_khz.dispclk = (unsigned int)((double)min_table->max_clocks_khz.dispclk / (1.0 + soc_bb->dcn_downspread_percent / 100.0));",
            "\tmin_table->max_ss_clocks_khz.dppclk = (unsigned int)((double)min_table->max_clocks_khz.dppclk / (1.0 + soc_bb->dcn_downspread_percent / 100.0));",
            "\tmin_table->max_ss_clocks_khz.dtbclk = (unsigned int)((double)min_table->max_clocks_khz.dtbclk / (1.0 + soc_bb->dcn_downspread_percent / 100.0));",
            "",
            "\tmin_table->max_clocks_khz.dcfclk = soc_bb->clk_table.dcfclk.clk_values_khz[soc_bb->clk_table.dcfclk.num_clk_values - 1];",
            "\tmin_table->max_clocks_khz.fclk = soc_bb->clk_table.fclk.clk_values_khz[soc_bb->clk_table.fclk.num_clk_values - 1];"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_mcg\\dml2_mcg_dcn4.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_pmo\\dml2_pmo_dcn4_fams2.c",
          "line": 965,
          "match": "double)master_timing->h_total / master_timing->pixel_clock",
          "context": [
            "",
            "\t\t/* trivially set default timing group to itself */",
            "\t\tset_bit_in_bitfield(&s->pmo_dcn4.synchronized_timing_group_masks[timing_group_idx], i);",
            "\t\ts->pmo_dcn4.group_line_time_us[timing_group_idx] = (double)master_timing->h_total / master_timing->pixel_clock_khz * 1000.0;",
            "",
            "\t\t/* if drr is in use, timing is not sychnronizable */",
            "\t\tif (master_timing->drr_config.enabled) {"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_pmo\\dml2_pmo_dcn4_fams2.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_pmo\\dml2_pmo_dcn4_fams2.c",
          "line": 1681,
          "match": "double)timing->h_total / timing->pixel_clock",
          "context": [
            "",
            "\t/* common */",
            "\tstream_fams2_meta->valid = true;",
            "\tstream_fams2_meta->otg_vline_time_us = (double)timing->h_total / timing->pixel_clock_khz * 1000.0;",
            "\tstream_fams2_meta->nom_vtotal = stream_descriptor->timing.vblank_nom + stream_descriptor->timing.v_active;",
            "\tstream_fams2_meta->nom_refresh_rate_hz = timing->pixel_clock_khz * 1000.0 /",
            "\t\t\t(stream_fams2_meta->nom_vtotal * timing->h_total);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_pmo\\dml2_pmo_dcn4_fams2.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_pmo\\dml2_pmo_dcn4_fams2.c",
          "line": 1691,
          "match": "double)stream_descriptor->timing.pixel_clock",
          "context": [
            "",
            "\tif (stream_descriptor->timing.drr_config.enabled == true) {",
            "\t\tif (stream_descriptor->timing.drr_config.min_refresh_uhz != 0.0) {",
            "\t\t\tstream_fams2_meta->max_vtotal = (unsigned int)math_floor((double)stream_descriptor->timing.pixel_clock_khz /",
            "\t\t\t\t\t((double)stream_descriptor->timing.drr_config.min_refresh_uhz * stream_descriptor->timing.h_total) * 1e9);",
            "\t\t} else {",
            "\t\t\t/* assume min of 48Hz */"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_pmo\\dml2_pmo_dcn4_fams2.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_pmo\\dml2_pmo_dcn4_fams2.c",
          "line": 1695,
          "match": "double)stream_descriptor->timing.pixel_clock",
          "context": [
            "\t\t\t\t\t((double)stream_descriptor->timing.drr_config.min_refresh_uhz * stream_descriptor->timing.h_total) * 1e9);",
            "\t\t} else {",
            "\t\t\t/* assume min of 48Hz */",
            "\t\t\tstream_fams2_meta->max_vtotal = (unsigned int)math_floor((double)stream_descriptor->timing.pixel_clock_khz /",
            "\t\t\t\t\t(48000000.0 * stream_descriptor->timing.h_total) * 1e9);",
            "\t\t}",
            "\t} else {"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_pmo\\dml2_pmo_dcn4_fams2.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_pmo\\dml2_pmo_dcn4_fams2.c",
          "line": 2287,
          "match": "double)in_out->base_display_config->display_config.stream_descriptors[i].timing.h_total / (in_out->base_display_config->display_config.stream_descriptors[i].timing.pixel_clock",
          "context": [
            "\t}",
            "",
            "\tfor (i = 0; i < in_out->base_display_config->display_config.num_streams; i++) {",
            "\t\tline_time_us = (double)in_out->base_display_config->display_config.stream_descriptors[i].timing.h_total / (in_out->base_display_config->display_config.stream_descriptors[i].timing.pixel_clock_khz * 1000) * 1000000;",
            "\t\tvblank_nom_time_us = line_time_us * in_out->base_display_config->display_config.stream_descriptors[i].timing.vblank_nom;",
            "",
            "\t\tif (vblank_nom_time_us < pmo->soc_bb->power_management_parameters.z8_stutter_exit_latency_us * MIN_BLANK_STUTTER_FACTOR) {"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\dml2\\dml21\\src\\dml2_pmo\\dml2_pmo_dcn4_fams2.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\hwss\\dcn20\\dcn20_hwseq.c",
          "line": 2235,
          "match": "double buffered DSCCLK disable logic in post unlock",
          "context": [
            "\t\tif (is_dsc_ungated) {",
            "\t\t\t/*",
            "\t\t\t * seamless update specific where we will postpone non",
            "\t\t\t * double buffered DSCCLK disable logic in post unlock",
            "\t\t\t * sequence after DSC is disconnected from OPP but not",
            "\t\t\t * yet power gated.",
            "\t\t\t */"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\hwss\\dcn20\\dcn20_hwseq.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn20\\dcn20_optc.c",
          "line": 534,
          "match": "doublebuffer_enable = optc2_lock",
          "context": [
            "\t\t.disable_reset_trigger = optc1_disable_reset_trigger,",
            "\t\t.lock = optc1_lock,",
            "\t\t.unlock = optc1_unlock,",
            "\t\t.lock_doublebuffer_enable = optc2_lock_doublebuffer_enable,",
            "\t\t.lock_doublebuffer_disable = optc2_lock_doublebuffer_disable,",
            "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
            "\t\t.set_drr = optc1_set_drr,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn20\\dcn20_optc.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn20\\dcn20_optc.c",
          "line": 535,
          "match": "doublebuffer_disable = optc2_lock",
          "context": [
            "\t\t.lock = optc1_lock,",
            "\t\t.unlock = optc1_unlock,",
            "\t\t.lock_doublebuffer_enable = optc2_lock_doublebuffer_enable,",
            "\t\t.lock_doublebuffer_disable = optc2_lock_doublebuffer_disable,",
            "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
            "\t\t.set_drr = optc1_set_drr,",
            "\t\t.get_last_used_drr_vtotal = optc2_get_last_used_drr_vtotal,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn20\\dcn20_optc.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn30\\dcn30_optc.c",
          "line": 387,
          "match": "doublebuffer_enable = optc3_lock",
          "context": [
            "\t\t.disable_reset_trigger = optc1_disable_reset_trigger,",
            "\t\t.lock = optc3_lock,",
            "\t\t.unlock = optc1_unlock,",
            "\t\t.lock_doublebuffer_enable = optc3_lock_doublebuffer_enable,",
            "\t\t.lock_doublebuffer_disable = optc3_lock_doublebuffer_disable,",
            "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
            "\t\t.set_drr = optc1_set_drr,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn30\\dcn30_optc.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn30\\dcn30_optc.c",
          "line": 388,
          "match": "doublebuffer_disable = optc3_lock",
          "context": [
            "\t\t.lock = optc3_lock,",
            "\t\t.unlock = optc1_unlock,",
            "\t\t.lock_doublebuffer_enable = optc3_lock_doublebuffer_enable,",
            "\t\t.lock_doublebuffer_disable = optc3_lock_doublebuffer_disable,",
            "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
            "\t\t.set_drr = optc1_set_drr,",
            "\t\t.get_last_used_drr_vtotal = optc2_get_last_used_drr_vtotal,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn30\\dcn30_optc.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn301\\dcn301_optc.c",
          "line": 139,
          "match": "doublebuffer_enable = optc3_lock",
          "context": [
            "\t\t.disable_reset_trigger = optc1_disable_reset_trigger,",
            "\t\t.lock = optc3_lock,",
            "\t\t.unlock = optc1_unlock,",
            "\t\t.lock_doublebuffer_enable = optc3_lock_doublebuffer_enable,",
            "\t\t.lock_doublebuffer_disable = optc3_lock_doublebuffer_disable,",
            "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
            "\t\t.set_drr = optc301_set_drr,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn301\\dcn301_optc.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn301\\dcn301_optc.c",
          "line": 140,
          "match": "doublebuffer_disable = optc3_lock",
          "context": [
            "\t\t.lock = optc3_lock,",
            "\t\t.unlock = optc1_unlock,",
            "\t\t.lock_doublebuffer_enable = optc3_lock_doublebuffer_enable,",
            "\t\t.lock_doublebuffer_disable = optc3_lock_doublebuffer_disable,",
            "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
            "\t\t.set_drr = optc301_set_drr,",
            "\t\t.get_last_used_drr_vtotal = optc2_get_last_used_drr_vtotal,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn301\\dcn301_optc.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn31\\dcn31_optc.c",
          "line": 346,
          "match": "doublebuffer_enable = optc3_lock",
          "context": [
            "\t\t.disable_reset_trigger = optc1_disable_reset_trigger,",
            "\t\t.lock = optc3_lock,",
            "\t\t.unlock = optc1_unlock,",
            "\t\t.lock_doublebuffer_enable = optc3_lock_doublebuffer_enable,",
            "\t\t.lock_doublebuffer_disable = optc3_lock_doublebuffer_disable,",
            "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
            "\t\t.set_drr = optc31_set_drr,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn31\\dcn31_optc.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn31\\dcn31_optc.c",
          "line": 347,
          "match": "doublebuffer_disable = optc3_lock",
          "context": [
            "\t\t.lock = optc3_lock,",
            "\t\t.unlock = optc1_unlock,",
            "\t\t.lock_doublebuffer_enable = optc3_lock_doublebuffer_enable,",
            "\t\t.lock_doublebuffer_disable = optc3_lock_doublebuffer_disable,",
            "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
            "\t\t.set_drr = optc31_set_drr,",
            "\t\t.get_last_used_drr_vtotal = optc2_get_last_used_drr_vtotal,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn31\\dcn31_optc.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn314\\dcn314_optc.c",
          "line": 224,
          "match": "doublebuffer_enable = optc3_lock",
          "context": [
            "\t\t.disable_reset_trigger = optc1_disable_reset_trigger,",
            "\t\t.lock = optc3_lock,",
            "\t\t.unlock = optc1_unlock,",
            "\t\t.lock_doublebuffer_enable = optc3_lock_doublebuffer_enable,",
            "\t\t.lock_doublebuffer_disable = optc3_lock_doublebuffer_disable,",
            "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
            "\t\t.set_drr = optc31_set_drr,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn314\\dcn314_optc.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn314\\dcn314_optc.c",
          "line": 225,
          "match": "doublebuffer_disable = optc3_lock",
          "context": [
            "\t\t.lock = optc3_lock,",
            "\t\t.unlock = optc1_unlock,",
            "\t\t.lock_doublebuffer_enable = optc3_lock_doublebuffer_enable,",
            "\t\t.lock_doublebuffer_disable = optc3_lock_doublebuffer_disable,",
            "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
            "\t\t.set_drr = optc31_set_drr,",
            "\t\t.get_last_used_drr_vtotal = optc2_get_last_used_drr_vtotal,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn314\\dcn314_optc.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn35\\dcn35_optc.c",
          "line": 460,
          "match": "doublebuffer_enable = optc3_lock",
          "context": [
            "\t\t.disable_reset_trigger = optc1_disable_reset_trigger,",
            "\t\t.lock = optc3_lock,",
            "\t\t.unlock = optc1_unlock,",
            "\t\t.lock_doublebuffer_enable = optc3_lock_doublebuffer_enable,",
            "\t\t.lock_doublebuffer_disable = optc3_lock_doublebuffer_disable,",
            "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
            "\t\t.set_drr = optc35_set_drr,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn35\\dcn35_optc.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn35\\dcn35_optc.c",
          "line": 461,
          "match": "doublebuffer_disable = optc3_lock",
          "context": [
            "\t\t.lock = optc3_lock,",
            "\t\t.unlock = optc1_unlock,",
            "\t\t.lock_doublebuffer_enable = optc3_lock_doublebuffer_enable,",
            "\t\t.lock_doublebuffer_disable = optc3_lock_doublebuffer_disable,",
            "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
            "\t\t.set_drr = optc35_set_drr,",
            "\t\t.get_last_used_drr_vtotal = optc2_get_last_used_drr_vtotal,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn35\\dcn35_optc.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn32\\dcn32_optc.c",
          "line": 329,
          "match": "doublebuffer_enable = optc3_lock",
          "context": [
            "\t\t.disable_reset_trigger = optc1_disable_reset_trigger,",
            "\t\t.lock = optc3_lock,",
            "\t\t.unlock = optc1_unlock,",
            "\t\t.lock_doublebuffer_enable = optc3_lock_doublebuffer_enable,",
            "\t\t.lock_doublebuffer_disable = optc3_lock_doublebuffer_disable,",
            "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
            "\t\t.set_drr = optc32_set_drr,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn32\\dcn32_optc.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn32\\dcn32_optc.c",
          "line": 330,
          "match": "doublebuffer_disable = optc3_lock",
          "context": [
            "\t\t.lock = optc3_lock,",
            "\t\t.unlock = optc1_unlock,",
            "\t\t.lock_doublebuffer_enable = optc3_lock_doublebuffer_enable,",
            "\t\t.lock_doublebuffer_disable = optc3_lock_doublebuffer_disable,",
            "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
            "\t\t.set_drr = optc32_set_drr,",
            "\t\t.get_last_used_drr_vtotal = optc2_get_last_used_drr_vtotal,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn32\\dcn32_optc.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn401\\dcn401_optc.c",
          "line": 491,
          "match": "doublebuffer_enable = optc3_lock",
          "context": [
            "\t\t.disable_reset_trigger = optc1_disable_reset_trigger,",
            "\t\t.lock = optc3_lock,",
            "\t\t.unlock = optc1_unlock,",
            "\t\t.lock_doublebuffer_enable = optc3_lock_doublebuffer_enable,",
            "\t\t.lock_doublebuffer_disable = optc3_lock_doublebuffer_disable,",
            "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
            "\t\t.set_drr = optc401_set_drr,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn401\\dcn401_optc.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn401\\dcn401_optc.c",
          "line": 492,
          "match": "doublebuffer_disable = optc3_lock",
          "context": [
            "\t\t.lock = optc3_lock,",
            "\t\t.unlock = optc1_unlock,",
            "\t\t.lock_doublebuffer_enable = optc3_lock_doublebuffer_enable,",
            "\t\t.lock_doublebuffer_disable = optc3_lock_doublebuffer_disable,",
            "\t\t.enable_optc_clock = optc1_enable_optc_clock,",
            "\t\t.set_drr = optc401_set_drr,",
            "\t\t.get_last_used_drr_vtotal = optc2_get_last_used_drr_vtotal,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\amd\\display\\dc\\optc\\dcn401\\dcn401_optc.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\bridge\\imx\\imx8mp-hdmi-tx.c",
          "line": 44,
          "match": "double-clock",
          "context": [
            "\tif (abs(round_rate - mode->clock * 1000) > mode->clock * 5)",
            "\t\treturn MODE_CLOCK_RANGE;",
            "",
            "\t/* We don't support double-clocked and Interlaced modes */",
            "\tif ((mode->flags & DRM_MODE_FLAG_DBLCLK) ||",
            "\t    (mode->flags & DRM_MODE_FLAG_INTERLACE))",
            "\t\treturn MODE_BAD;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\bridge\\imx\\imx8mp-hdmi-tx.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\bridge\\synopsys\\dw-hdmi.c",
          "line": 2923,
          "match": "double-clock",
          "context": [
            "\tconst struct dw_hdmi_plat_data *pdata = hdmi->plat_data;",
            "\tenum drm_mode_status mode_status = MODE_OK;",
            "",
            "\t/* We don't support double-clocked modes */",
            "\tif (mode->flags & DRM_MODE_FLAG_DBLCLK)",
            "\t\treturn MODE_BAD;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\bridge\\synopsys\\dw-hdmi.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_display.c",
          "line": 2387,
          "match": "double wide mode when the dot clock",
          "context": [
            "\t\tclock_limit = display->cdclk.max_cdclk_freq * 9 / 10;",
            "",
            "\t\t/*",
            "\t\t * Enable double wide mode when the dot clock",
            "\t\t * is > 90% of the (display) core speed.",
            "\t\t */",
            "\t\tif (intel_crtc_supports_double_wide(crtc) &&"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\display\\intel_display.c"
          ]
        },
        {
          "file": "linux\\drivers\\hwtracing\\coresight\\coresight-cpu-debug.c",
          "line": 131,
          "match": "Double Lock is lock",
          "context": [
            " * registers to avoid lockup issue:",
            " *",
            " * - CPU power domain is powered off;",
            " * - The OS Double Lock is locked;",
            " *",
            " * By checking EDPRSR can get to know if meet these conditions.",
            " */"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hwtracing\\coresight\\coresight-cpu-debug.c"
          ]
        },
        {
          "file": "linux\\drivers\\hwtracing\\coresight\\coresight-cpu-debug.c",
          "line": 141,
          "match": "Double Lock is lock",
          "context": [
            "\tif (!(drvdata->edprsr & EDPRSR_PU))",
            "\t\treturn false;",
            "",
            "\t/* The OS Double Lock is locked */",
            "\tif (drvdata->edprsr & EDPRSR_DLK)",
            "\t\treturn false;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hwtracing\\coresight\\coresight-cpu-debug.c"
          ]
        },
        {
          "file": "linux\\drivers\\i2c\\busses\\i2c-npcm7xx.c",
          "line": 2409,
          "match": "double the timeout for clock",
          "context": [
            "\t\t\t\t       read_block)) {",
            "\t\t/*",
            "\t\t * Adaptive TimeOut: estimated time in usec + 100% margin:",
            "\t\t * 2: double the timeout for clock stretching case",
            "\t\t * 9: bits per transaction (including the ack/nack)",
            "\t\t */",
            "\t\ttimeout_usec = (2 * 9 * USEC_PER_SEC / bus->bus_freq) * (2 + nread + nwrite);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\i2c\\busses\\i2c-npcm7xx.c"
          ]
        },
        {
          "file": "linux\\drivers\\iio\\frequency\\admv4420.c",
          "line": 212,
          "match": "doubler = st->ref_block",
          "context": [
            "\tuint32_t tmp;",
            "\tu8 doubler, divide_by_2;",
            "",
            "\tdoubler = st->ref_block.doubler_en ? 2 : 1;",
            "\tdivide_by_2 = st->ref_block.divide_by_2_en ? 2 : 1;",
            "\ttmp = ADMV4420_REF_FREQ_HZ * doubler;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\iio\\frequency\\admv4420.c"
          ]
        },
        {
          "file": "linux\\drivers\\iio\\frequency\\admv4420.c",
          "line": 326,
          "match": "DOUBLER_MASK, st->ref_block",
          "context": [
            "\tret = regmap_write(st->regmap, ADMV4420_REFERENCE,",
            "\t\t\t   st->ref_block.divide_by_2_en |",
            "\t\t\t   FIELD_PREP(ADMV4420_REFERENCE_MODE_MASK, st->ref_block.ref_single_ended) |",
            "\t\t\t   FIELD_PREP(ADMV4420_REFERENCE_DOUBLER_MASK, st->ref_block.doubler_en));",
            "\tif (ret)",
            "\t\treturn ret;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\iio\\frequency\\admv4420.c"
          ]
        },
        {
          "file": "linux\\drivers\\infiniband\\core\\cma.c",
          "line": 401,
          "match": "double lock",
          "context": [
            "\tint ret;",
            "",
            "\t/*",
            "\t * The FSM uses a funny double locking where state is protected by both",
            "\t * the handler_mutex and the spinlock. State is not allowed to change",
            "\t * to/from a handler_mutex protected value without also holding",
            "\t * handler_mutex."
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\infiniband\\core\\cma.c"
          ]
        },
        {
          "file": "linux\\drivers\\infiniband\\hw\\hfi1\\opfn.c",
          "line": 124,
          "match": "double locking QP s_lock",
          "context": [
            "",
            "/*",
            " * When QP s_lock is held in the caller, the OPFN request must be scheduled",
            " * to a different workqueue to avoid double locking QP s_lock in call to",
            " * ib_post_send in opfn_conn_request",
            " */",
            "static void opfn_schedule_conn_request(struct rvt_qp *qp)"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\infiniband\\hw\\hfi1\\opfn.c"
          ]
        },
        {
          "file": "linux\\drivers\\isdn\\hardware\\mISDN\\hfcmulti.c",
          "line": 1312,
          "match": "double clock",
          "context": [
            "\tif (test_bit(HFC_CHIP_CLOCK2, &hc->chip)) {",
            "\t\tif (debug & DEBUG_HFCMULTI_INIT)",
            "\t\t\tprintk(KERN_DEBUG",
            "\t\t\t       \"%s: setting double clock\\n\", __func__);",
            "\t\tHFC_outb(hc, R_BRG_PCM_CFG, V_PCM_CLK);",
            "\t}",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\isdn\\hardware\\mISDN\\hfcmulti.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\persistent-data\\dm-space-map-common.c",
          "line": 404,
          "match": "double check this block",
          "context": [
            "\t\tif (r)",
            "\t\t\tbreak;",
            "",
            "\t\t/* double check this block wasn't used in the old transaction */",
            "\t\tif (*b >= old_ll->nr_blocks)",
            "\t\t\tcount = 0;",
            "\t\telse {"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\persistent-data\\dm-space-map-common.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\usb\\gspca\\ov519.c",
          "line": 3206,
          "match": "double clock",
          "context": [
            "\treg_w(sd, 0x23, fr_tb[sd->gspca_dev.curr_mode][fr][1]);",
            "\tclock = fr_tb[sd->gspca_dev.curr_mode][fr][2];",
            "\tif (sd->sensor == SEN_OV7660)",
            "\t\tclock |= 0x80;\t\t/* enable double clock */",
            "\tov518_i2c_w(sd, OV7670_R11_CLKRC, clock);",
            "}",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\usb\\gspca\\ov519.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\usb\\gspca\\m5602\\m5602_ov9650.c",
          "line": 42,
          "match": "double clock",
          "context": [
            "\t{BRIDGE, M5602_XB_I2C_CLK_DIV, 0x0a},",
            "\t/* Reset chip */",
            "\t{SENSOR, OV9650_COM7, OV9650_REGISTER_RESET},",
            "\t/* Enable double clock */",
            "\t{SENSOR, OV9650_CLKRC, 0x80},",
            "\t/* Do something out of spec with the power */",
            "\t{SENSOR, OV9650_OFON, 0x40}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\usb\\gspca\\m5602\\m5602_ov9650.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\usb\\gspca\\m5602\\m5602_ov9650.c",
          "line": 72,
          "match": "double clock",
          "context": [
            "\t   properly when resuming from ram, could be a timing issue */",
            "\t{SENSOR, OV9650_COM7, OV9650_REGISTER_RESET},",
            "",
            "\t/* Enable double clock */",
            "\t{SENSOR, OV9650_CLKRC, 0x80},",
            "\t/* Do something out of spec with the power */",
            "\t{SENSOR, OV9650_OFON, 0x40},"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\usb\\gspca\\m5602\\m5602_ov9650.c"
          ]
        },
        {
          "file": "linux\\drivers\\mmc\\host\\sunxi-mmc.c",
          "line": 780,
          "match": "double the card clock",
          "context": [
            "",
            "\t/*",
            "\t * Under the old timing mode, 8 bit DDR requires the module",
            "\t * clock to be double the card clock. Under the new timing",
            "\t * mode, all DDR modes require a doubled module clock.",
            "\t *",
            "\t * We currently only support the standard MMC DDR52 mode."
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\mmc\\host\\sunxi-mmc.c"
          ]
        },
        {
          "file": "linux\\drivers\\mmc\\host\\sunxi-mmc.c",
          "line": 781,
          "match": "doubled module clock",
          "context": [
            "\t/*",
            "\t * Under the old timing mode, 8 bit DDR requires the module",
            "\t * clock to be double the card clock. Under the new timing",
            "\t * mode, all DDR modes require a doubled module clock.",
            "\t *",
            "\t * We currently only support the standard MMC DDR52 mode.",
            "\t * This block should be updated once support for other DDR"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\mmc\\host\\sunxi-mmc.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\wireless\\st\\cw1200\\txrx.c",
          "line": 1204,
          "match": "Double-check status with lock",
          "context": [
            "",
            "\tif (early_data) {",
            "\t\tspin_lock_bh(&priv->ps_state_lock);",
            "\t\t/* Double-check status with lock held */",
            "\t\tif (entry->status == CW1200_LINK_SOFT)",
            "\t\t\tskb_queue_tail(&entry->rx_queue, skb);",
            "\t\telse"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\wireless\\st\\cw1200\\txrx.c"
          ]
        },
        {
          "file": "linux\\drivers\\soc\\fsl\\qe\\tsa.c",
          "line": 781,
          "match": "double-speed-clock",
          "context": [
            "\t\t    of_property_read_bool(tdm_np, \"fsl,fsync-active-low\"))",
            "\t\t\ttdm->simode_tdm |= TSA_QE_SIMODE_TDM_SL;",
            "",
            "\t\tif (of_property_read_bool(tdm_np, \"fsl,double-speed-clock\"))",
            "\t\t\ttdm->simode_tdm |= TSA_SIMODE_TDM_DSC;",
            "",
            "\t\tclk = of_clk_get_by_name(tdm_np, tsa_is_qe(tsa) ? \"rsync\" : \"l1rsync\");"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\soc\\fsl\\qe\\tsa.c"
          ]
        },
        {
          "file": "linux\\drivers\\video\\fbdev\\cirrusfb.c",
          "line": 520,
          "match": "double the pixel clock",
          "context": [
            "\t}",
            "",
            "\t/* If we have a 1MB 5434, we need to put ourselves in a mode where",
            "\t * the VCLK is double the pixel clock. */",
            "\tcinfo->doubleVCLK = 0;",
            "\tif (cinfo->btype == BT_SD64 && info->fix.smem_len <= MB_ &&",
            "\t    var->bits_per_pixel == 16) {"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\video\\fbdev\\cirrusfb.c"
          ]
        },
        {
          "file": "linux\\drivers\\video\\fbdev\\pxafb.c",
          "line": 1020,
          "match": "Double Pixel Clock",
          "context": [
            "{",
            "\tunsigned long long pcd;",
            "",
            "\t/* FIXME: Need to take into account Double Pixel Clock mode",
            "\t * (DPC) bit? or perhaps set it based on the various clock",
            "\t * speeds */",
            "\tpcd = (unsigned long long)(clk_get_rate(fbi->clk) / 10000);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\video\\fbdev\\pxafb.c"
          ]
        },
        {
          "file": "linux\\drivers\\video\\fbdev\\pxafb.c",
          "line": 1961,
          "match": "double pixel clock",
          "context": [
            "\t\t}",
            "\t} else if (!strncmp(this_opt, \"dpc:\", 4)) {",
            "\t\tif (simple_strtoul(this_opt+4, NULL, 0) == 0) {",
            "\t\t\tsprintf(s, \"double pixel clock: false\\n\");",
            "\t\t\tinf->lccr3 &= ~LCCR3_DPC;",
            "\t\t} else {",
            "\t\t\tsprintf(s, \"double pixel clock: true\\n\");"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\video\\fbdev\\pxafb.c"
          ]
        },
        {
          "file": "linux\\drivers\\video\\fbdev\\pxafb.c",
          "line": 1964,
          "match": "double pixel clock",
          "context": [
            "\t\t\tsprintf(s, \"double pixel clock: false\\n\");",
            "\t\t\tinf->lccr3 &= ~LCCR3_DPC;",
            "\t\t} else {",
            "\t\t\tsprintf(s, \"double pixel clock: true\\n\");",
            "\t\t\tinf->lccr3 |= LCCR3_DPC;",
            "\t\t}",
            "\t} else if (!strncmp(this_opt, \"outputen:\", 9)) {"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\video\\fbdev\\pxafb.c"
          ]
        },
        {
          "file": "linux\\fs\\befs\\datastream.c",
          "line": 192,
          "match": "Double indir block, plus all the indirect block",
          "context": [
            "\t\tmetablocks += ds->indirect.len;",
            "",
            "\t/*",
            "\t * Double indir block, plus all the indirect blocks it maps.",
            "\t * In the double-indirect range, all block runs of data are",
            "\t * BEFS_DBLINDIR_BRUN_LEN blocks long. Therefore, we know",
            "\t * how many data block runs are in the double-indirect region,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\befs\\datastream.c"
          ]
        },
        {
          "file": "linux\\fs\\befs\\datastream.c",
          "line": 193,
          "match": "double-indirect range, all block",
          "context": [
            "",
            "\t/*",
            "\t * Double indir block, plus all the indirect blocks it maps.",
            "\t * In the double-indirect range, all block runs of data are",
            "\t * BEFS_DBLINDIR_BRUN_LEN blocks long. Therefore, we know",
            "\t * how many data block runs are in the double-indirect region,",
            "\t * and from that we know how many indirect blocks it takes to"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\befs\\datastream.c"
          ]
        },
        {
          "file": "linux\\fs\\befs\\datastream.c",
          "line": 396,
          "match": "double-indirect block",
          "context": [
            " * maps a particular filesystem block.",
            " *",
            " * We do this in two stages. First we calculate which of the",
            " * inode addresses in the double-indirect block will point us",
            " * to the indirect block that contains the mapping for the data,",
            " * then we calculate which of the inode addresses in that",
            " * indirect block maps the data block we are after."
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\befs\\datastream.c"
          ]
        },
        {
          "file": "linux\\fs\\befs\\datastream.c",
          "line": 403,
          "match": "double-indirect run may be several block",
          "context": [
            " *",
            " * Oh, and once we've done that, we actually read in the blocks",
            " * that contain the inode addresses we calculated above. Even",
            " * though the double-indirect run may be several blocks long,",
            " * we can calculate which of those blocks will contain the index",
            " * we are after and only read that one. We then follow it to",
            " * the indirect block and perform a similar process to find"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\befs\\datastream.c"
          ]
        },
        {
          "file": "linux\\fs\\befs\\datastream.c",
          "line": 439,
          "match": "double indirect block",
          "context": [
            "\toff_t dbl_indir_off = blockno - indir_start_blk;",
            "",
            "\t/* number of data blocks mapped by each of the iaddrs in",
            "\t * the indirect block pointed to by the double indirect block",
            "\t */",
            "\tsize_t iblklen = BEFS_DBLINDIR_BRUN_LEN;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\befs\\datastream.c"
          ]
        },
        {
          "file": "linux\\fs\\befs\\datastream.c",
          "line": 444,
          "match": "double indirect block",
          "context": [
            "\tsize_t iblklen = BEFS_DBLINDIR_BRUN_LEN;",
            "",
            "\t/* number of data blocks mapped by each of the iaddrs in",
            "\t * the double indirect block",
            "\t */",
            "\tsize_t diblklen = iblklen * befs_iaddrs_per_block(sb)",
            "\t    * BEFS_DBLINDIR_BRUN_LEN;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\befs\\datastream.c"
          ]
        },
        {
          "file": "linux\\fs\\befs\\datastream.c",
          "line": 451,
          "match": "double_indir->indir block",
          "context": [
            "",
            "\tbefs_debug(sb, \"---> %s find %lu\", __func__, (unsigned long)blockno);",
            "",
            "\t/* First, discover which of the double_indir->indir blocks",
            "\t * contains pos. Then figure out how much of pos that",
            "\t * accounted for. Then discover which of the iaddrs in",
            "\t * the indirect block contains pos."
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\befs\\datastream.c"
          ]
        },
        {
          "file": "linux\\fs\\befs\\datastream.c",
          "line": 461,
          "match": "double indirect block",
          "context": [
            "\tdblindir_leftover = dbl_indir_off % diblklen;",
            "\tindir_indx = dblindir_leftover / diblklen;",
            "",
            "\t/* Read double indirect block */",
            "\tdbl_which_block = dblindir_indx / befs_iaddrs_per_block(sb);",
            "\tif (dbl_which_block > data->double_indirect.len) {",
            "\t\tbefs_error(sb, \"The double-indirect index calculated by \""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\befs\\datastream.c"
          ]
        },
        {
          "file": "linux\\fs\\befs\\datastream.c",
          "line": 466,
          "match": "double-indirect block",
          "context": [
            "\tif (dbl_which_block > data->double_indirect.len) {",
            "\t\tbefs_error(sb, \"The double-indirect index calculated by \"",
            "\t\t\t   \"%s, %d, is outside the range \"",
            "\t\t\t   \"of the double-indirect block\", __func__,",
            "\t\t\t   dblindir_indx);",
            "\t\treturn BEFS_ERR;",
            "\t}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\befs\\datastream.c"
          ]
        },
        {
          "file": "linux\\fs\\befs\\datastream.c",
          "line": 476,
          "match": "double-indirect block at block",
          "context": [
            "\t\t\t\t\tdbl_which_block);",
            "\tif (dbl_indir_block == NULL) {",
            "\t\tbefs_error(sb, \"%s couldn't read the \"",
            "\t\t\t   \"double-indirect block at blockno %lu\", __func__,",
            "\t\t\t   (unsigned long)",
            "\t\t\t   iaddr2blockno(sb, &data->double_indirect) +",
            "\t\t\t   dbl_which_block);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\befs\\datastream.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\locking.c",
          "line": 304,
          "match": "double-reader-writer-exclusion lock",
          "context": [
            " * DREW locks",
            " * ==========",
            " *",
            " * DREW stands for double-reader-writer-exclusion lock. It's used in situation",
            " * where you want to provide A-B exclusion but not AA or BB.",
            " *",
            " * Currently implementation gives more priority to reader. If a reader and a"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\locking.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\reflink.c",
          "line": 619,
          "match": "double_mmap_lock",
          "context": [
            "\treturn ret;",
            "}",
            "",
            "static void btrfs_double_mmap_lock(struct btrfs_inode *inode1, struct btrfs_inode *inode2)",
            "{",
            "\tif (inode1 < inode2)",
            "\t\tswap(inode1, inode2);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\reflink.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\reflink.c",
          "line": 627,
          "match": "double_mmap_unlock",
          "context": [
            "\tdown_write_nested(&inode2->i_mmap_lock, SINGLE_DEPTH_NESTING);",
            "}",
            "",
            "static void btrfs_double_mmap_unlock(struct btrfs_inode *inode1, struct btrfs_inode *inode2)",
            "{",
            "\tup_write(&inode1->i_mmap_lock);",
            "\tup_write(&inode2->i_mmap_lock);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\reflink.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\reflink.c",
          "line": 877,
          "match": "double_mmap_lock",
          "context": [
            "\t\tbtrfs_inode_lock(src_inode, BTRFS_ILOCK_MMAP);",
            "\t} else {",
            "\t\tlock_two_nondirectories(&src_inode->vfs_inode, &dst_inode->vfs_inode);",
            "\t\tbtrfs_double_mmap_lock(src_inode, dst_inode);",
            "\t}",
            "",
            "\tret = btrfs_remap_file_range_prep(src_file, off, dst_file, destoff,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\reflink.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\reflink.c",
          "line": 895,
          "match": "double_mmap_unlock",
          "context": [
            "\tif (same_inode) {",
            "\t\tbtrfs_inode_unlock(src_inode, BTRFS_ILOCK_MMAP);",
            "\t} else {",
            "\t\tbtrfs_double_mmap_unlock(src_inode, dst_inode);",
            "\t\tunlock_two_nondirectories(&src_inode->vfs_inode,",
            "\t\t\t\t\t  &dst_inode->vfs_inode);",
            "\t}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\reflink.c"
          ]
        },
        {
          "file": "linux\\fs\\ext2\\inode.c",
          "line": 170,
          "match": "double_block",
          "context": [
            "\tint ptrs_bits = EXT2_ADDR_PER_BLOCK_BITS(inode->i_sb);",
            "\tconst long direct_blocks = EXT2_NDIR_BLOCKS,",
            "\t\tindirect_blocks = ptrs,",
            "\t\tdouble_blocks = (1 << (ptrs_bits * 2));",
            "\tint n = 0;",
            "\tint final = 0;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ext2\\inode.c"
          ]
        },
        {
          "file": "linux\\fs\\ext2\\inode.c",
          "line": 184,
          "match": "double_block",
          "context": [
            "\t\toffsets[n++] = EXT2_IND_BLOCK;",
            "\t\toffsets[n++] = i_block;",
            "\t\tfinal = ptrs;",
            "\t} else if ((i_block -= indirect_blocks) < double_blocks) {",
            "\t\toffsets[n++] = EXT2_DIND_BLOCK;",
            "\t\toffsets[n++] = i_block >> ptrs_bits;",
            "\t\toffsets[n++] = i_block & (ptrs - 1);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ext2\\inode.c"
          ]
        },
        {
          "file": "linux\\fs\\ext2\\inode.c",
          "line": 189,
          "match": "double_block",
          "context": [
            "\t\toffsets[n++] = i_block >> ptrs_bits;",
            "\t\toffsets[n++] = i_block & (ptrs - 1);",
            "\t\tfinal = ptrs;",
            "\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {",
            "\t\toffsets[n++] = EXT2_TIND_BLOCK;",
            "\t\toffsets[n++] = i_block >> (ptrs_bits * 2);",
            "\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ext2\\inode.c"
          ]
        },
        {
          "file": "linux\\fs\\ext2\\super.c",
          "line": 781,
          "match": "double indirect block",
          "context": [
            "\t/* indirect blocks */",
            "\tmeta_blocks = 1;",
            "\tupper_limit -= ppb;",
            "\t/* double indirect blocks */",
            "\tif (upper_limit < ppb * ppb) {",
            "\t\tmeta_blocks += 1 + DIV_ROUND_UP(upper_limit, ppb);",
            "\t\tres -= meta_blocks;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ext2\\super.c"
          ]
        },
        {
          "file": "linux\\fs\\ext4\\indirect.c",
          "line": 82,
          "match": "double_block",
          "context": [
            "\tint ptrs_bits = EXT4_ADDR_PER_BLOCK_BITS(inode->i_sb);",
            "\tconst long direct_blocks = EXT4_NDIR_BLOCKS,",
            "\t\tindirect_blocks = ptrs,",
            "\t\tdouble_blocks = (1 << (ptrs_bits * 2));",
            "\tint n = 0;",
            "\tint final = 0;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ext4\\indirect.c"
          ]
        },
        {
          "file": "linux\\fs\\ext4\\indirect.c",
          "line": 93,
          "match": "double_block",
          "context": [
            "\t\toffsets[n++] = EXT4_IND_BLOCK;",
            "\t\toffsets[n++] = i_block;",
            "\t\tfinal = ptrs;",
            "\t} else if ((i_block -= indirect_blocks) < double_blocks) {",
            "\t\toffsets[n++] = EXT4_DIND_BLOCK;",
            "\t\toffsets[n++] = i_block >> ptrs_bits;",
            "\t\toffsets[n++] = i_block & (ptrs - 1);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ext4\\indirect.c"
          ]
        },
        {
          "file": "linux\\fs\\ext4\\indirect.c",
          "line": 98,
          "match": "double_block",
          "context": [
            "\t\toffsets[n++] = i_block >> ptrs_bits;",
            "\t\toffsets[n++] = i_block & (ptrs - 1);",
            "\t\tfinal = ptrs;",
            "\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {",
            "\t\toffsets[n++] = EXT4_TIND_BLOCK;",
            "\t\toffsets[n++] = i_block >> (ptrs_bits * 2);",
            "\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ext4\\indirect.c"
          ]
        },
        {
          "file": "linux\\fs\\ext4\\indirect.c",
          "line": 107,
          "match": "double_block",
          "context": [
            "\t} else {",
            "\t\text4_warning(inode->i_sb, \"block %lu > max in inode %lu\",",
            "\t\t\t     i_block + direct_blocks +",
            "\t\t\t     indirect_blocks + double_blocks, inode->i_ino);",
            "\t}",
            "\tif (boundary)",
            "\t\t*boundary = final - 1 - (i_block & (ptrs - 1));"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ext4\\indirect.c"
          ]
        },
        {
          "file": "linux\\fs\\ext4\\indirect.c",
          "line": 504,
          "match": "double-indirect i_block",
          "context": [
            "",
            "/*",
            " * The ext4_ind_map_blocks() function handles non-extents inodes",
            " * (i.e., using the traditional indirect/double-indirect i_blocks",
            " * scheme) for ext4_map_blocks().",
            " *",
            " * Allocation strategy is simple: if we have to allocate something, we will"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ext4\\indirect.c"
          ]
        },
        {
          "file": "linux\\fs\\ext4\\mballoc.c",
          "line": 2161,
          "match": "double allocate block",
          "context": [
            "\t * take the page reference. We want the page to be pinned",
            "\t * so that we don't get a ext4_mb_init_cache_call for this",
            "\t * group until we update the bitmap. That would mean we",
            "\t * double allocate blocks. The reference is dropped",
            "\t * in ext4_mb_release_context",
            "\t */",
            "\tac->ac_bitmap_folio = e4b->bd_bitmap_folio;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ext4\\mballoc.c"
          ]
        },
        {
          "file": "linux\\fs\\ext4\\move_extent.c",
          "line": 40,
          "match": "double_down_write_data_sem() - write lock",
          "context": [
            "}",
            "",
            "/**",
            " * ext4_double_down_write_data_sem() - write lock two inodes's i_data_sem",
            " * @first: inode to be locked",
            " * @second: inode to be locked",
            " *"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ext4\\move_extent.c"
          ]
        },
        {
          "file": "linux\\fs\\ext4\\move_extent.c",
          "line": 111,
          "match": "double_lock - Grab and lock",
          "context": [
            "}",
            "",
            "/**",
            " * mext_folio_double_lock - Grab and lock folio on both @inode1 and @inode2",
            " *",
            " * @inode1:\tthe inode structure",
            " * @inode2:\tthe inode structure"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ext4\\move_extent.c"
          ]
        },
        {
          "file": "linux\\fs\\ext4\\move_extent.c",
          "line": 122,
          "match": "double_lock",
          "context": [
            " * Grab two locked folio for inode's by inode order",
            " */",
            "static int",
            "mext_folio_double_lock(struct inode *inode1, struct inode *inode2,",
            "\t\t      pgoff_t index1, pgoff_t index2, struct folio *folio[2])",
            "{",
            "\tstruct address_space *mapping[2];"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ext4\\move_extent.c"
          ]
        },
        {
          "file": "linux\\fs\\ext4\\move_extent.c",
          "line": 315,
          "match": "double_lock",
          "context": [
            "",
            "\treplaced_size = data_size;",
            "",
            "\t*err = mext_folio_double_lock(orig_inode, donor_inode, orig_page_offset,",
            "\t\t\t\t     donor_page_offset, folio);",
            "\tif (unlikely(*err < 0))",
            "\t\tgoto stop_journal;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ext4\\move_extent.c"
          ]
        },
        {
          "file": "linux\\fs\\ext4\\resize.c",
          "line": 810,
          "match": "double indirect block",
          "context": [
            "/*",
            " * Called when we need to bring a reserved group descriptor table block into",
            " * use from the resize inode.  The primary copy of the new GDT block currently",
            " * is an indirect block (under the double indirect block in the resize inode).",
            " * The new backup GDT blocks will be stored as leaf blocks in this indirect",
            " * block, in group order.  Even though we know all the block numbers we need,",
            " * we check to ensure that the resize inode has actually reserved these blocks."
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ext4\\resize.c"
          ]
        },
        {
          "file": "linux\\fs\\ext4\\resize.c",
          "line": 901,
          "match": "double-indirect block",
          "context": [
            "\t/*",
            "\t * Finally, we have all of the possible failures behind us...",
            "\t *",
            "\t * Remove new GDT block from inode double-indirect block and clear out",
            "\t * the new GDT block for use (which also \"frees\" the backup GDT blocks",
            "\t * from the reserved inode).  We don't need to change the bitmaps for",
            "\t * these blocks, because they are marked as in-use from being in the"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ext4\\resize.c"
          ]
        },
        {
          "file": "linux\\fs\\ext4\\resize.c",
          "line": 1015,
          "match": "double-indirect block",
          "context": [
            " * Each reserved backup GDT block will go into a different indirect block.",
            " * The indirect blocks are actually the primary reserved GDT blocks,",
            " * so we know in advance what their block numbers are.  We only get the",
            " * double-indirect block to verify it is pointing to the primary reserved",
            " * GDT blocks so we don't overwrite a data block by accident.  The reserved",
            " * backup GDT blocks are stored in their reserved primary GDT block.",
            " */"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ext4\\resize.c"
          ]
        },
        {
          "file": "linux\\fs\\ext4\\super.c",
          "line": 3480,
          "match": "double indirect block",
          "context": [
            "\t/* indirect blocks */",
            "\tmeta_blocks = 1;",
            "\tupper_limit -= ppb;",
            "\t/* double indirect blocks */",
            "\tif (upper_limit < ppb * ppb) {",
            "\t\tmeta_blocks += 1 + DIV_ROUND_UP_ULL(upper_limit, ppb);",
            "\t\tres -= meta_blocks;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ext4\\super.c"
          ]
        },
        {
          "file": "linux\\fs\\f2fs\\iostat.c",
          "line": 122,
          "match": "double check under the lock",
          "context": [
            "\tif (time_is_after_jiffies(sbi->iostat_next_period))",
            "\t\treturn;",
            "",
            "\t/* Need double check under the lock */",
            "\tspin_lock_irqsave(&sbi->iostat_lock, flags);",
            "\tif (time_is_after_jiffies(sbi->iostat_next_period)) {",
            "\t\tspin_unlock_irqrestore(&sbi->iostat_lock, flags);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\f2fs\\iostat.c"
          ]
        },
        {
          "file": "linux\\fs\\nfs\\inode.c",
          "line": 1481,
          "match": "double-checks with spinlock",
          "context": [
            "\t\t/* pairs with nfs_set_cache_invalid()'s smp_store_release() */",
            "\t\tif (!(smp_load_acquire(&nfsi->cache_validity) & NFS_INO_INVALID_DATA))",
            "\t\t\tgoto out;",
            "\t\t/* Slow-path that double-checks with spinlock held */",
            "\t\tspin_lock(&inode->i_lock);",
            "\t\tif (test_bit(NFS_INO_INVALIDATING, bitlock)) {",
            "\t\t\tspin_unlock(&inode->i_lock);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\nfs\\inode.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\namei.c",
          "line": 85,
          "match": "double_lock",
          "context": [
            "\t\t\t\t     struct inode *inode,",
            "\t\t\t\t     const char *symname);",
            "",
            "static int ocfs2_double_lock(struct ocfs2_super *osb,",
            "\t\t\t     struct buffer_head **bh1,",
            "\t\t\t     struct inode *inode1,",
            "\t\t\t     struct buffer_head **bh2,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\namei.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\namei.c",
          "line": 92,
          "match": "double_unlock",
          "context": [
            "\t\t\t     struct inode *inode2,",
            "\t\t\t     int rename);",
            "",
            "static void ocfs2_double_unlock(struct inode *inode1, struct inode *inode2);",
            "/* An orphan dir name is an 8 byte value, printed as a hex string */",
            "#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\namei.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\namei.c",
          "line": 710,
          "match": "double_lock",
          "context": [
            "\t\treturn err;",
            "\t}",
            "",
            "\terr = ocfs2_double_lock(osb, &old_dir_bh, old_dir,",
            "\t\t\t&parent_fe_bh, dir, 0);",
            "\tif (err < 0) {",
            "\t\tif (err != -ENOENT)"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\namei.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\namei.c",
          "line": 830,
          "match": "double_unlock",
          "context": [
            "\tocfs2_inode_unlock(inode, 1);",
            "",
            "out:",
            "\tocfs2_double_unlock(old_dir, dir);",
            "",
            "\tbrelse(fe_bh);",
            "\tbrelse(parent_fe_bh);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\namei.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\namei.c",
          "line": 1111,
          "match": "double_lock",
          "context": [
            " * The only place this should be used is rename and link!",
            " * if they have the same id, then the 1st one is the only one locked.",
            " */",
            "static int ocfs2_double_lock(struct ocfs2_super *osb,",
            "\t\t\t     struct buffer_head **bh1,",
            "\t\t\t     struct inode *inode1,",
            "\t\t\t     struct buffer_head **bh2,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\namei.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\namei.c",
          "line": 1123,
          "match": "double_lock",
          "context": [
            "\tstruct ocfs2_inode_info *oi1 = OCFS2_I(inode1);",
            "\tstruct ocfs2_inode_info *oi2 = OCFS2_I(inode2);",
            "",
            "\ttrace_ocfs2_double_lock((unsigned long long)oi1->ip_blkno,",
            "\t\t\t\t(unsigned long long)oi2->ip_blkno);",
            "",
            "\tif (*bh1)"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\namei.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\namei.c",
          "line": 1183,
          "match": "double_lock",
          "context": [
            "\t\t\tmlog_errno(status);",
            "\t}",
            "",
            "\ttrace_ocfs2_double_lock_end(",
            "\t\t\t(unsigned long long)oi1->ip_blkno,",
            "\t\t\t(unsigned long long)oi2->ip_blkno);",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\namei.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\namei.c",
          "line": 1193,
          "match": "double_unlock",
          "context": [
            "\treturn status;",
            "}",
            "",
            "static void ocfs2_double_unlock(struct inode *inode1, struct inode *inode2)",
            "{",
            "\tocfs2_inode_unlock(inode1, 1);",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\namei.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\namei.c",
          "line": 1295,
          "match": "double_lock",
          "context": [
            "\t}",
            "",
            "\t/* if old and new are the same, this'll just do one lock. */",
            "\tstatus = ocfs2_double_lock(osb, &old_dir_bh, old_dir,",
            "\t\t\t\t   &new_dir_bh, new_dir, 1);",
            "\tif (status < 0) {",
            "\t\tmlog_errno(status);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\namei.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\namei.c",
          "line": 1677,
          "match": "double_unlock",
          "context": [
            "\t\tocfs2_inode_unlock(old_inode, 1);",
            "",
            "\tif (parents_locked)",
            "\t\tocfs2_double_unlock(old_dir, new_dir);",
            "",
            "\tif (rename_lock)",
            "\t\tocfs2_rename_unlock(osb);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\namei.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\refcounttree.c",
          "line": 4735,
          "match": "double_lock",
          "context": [
            "\toi1 = OCFS2_I(inode1);",
            "\toi2 = OCFS2_I(inode2);",
            "",
            "\ttrace_ocfs2_double_lock((unsigned long long)oi1->ip_blkno,",
            "\t\t\t\t(unsigned long long)oi2->ip_blkno);",
            "",
            "\t/* We always want to lock the one with the lower lockid first. */"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\refcounttree.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\refcounttree.c",
          "line": 4773,
          "match": "double_lock",
          "context": [
            "\t*bh_s = bh1;",
            "\t*bh_t = bh2;",
            "",
            "\ttrace_ocfs2_double_lock_end(",
            "\t\t\t(unsigned long long)oi1->ip_blkno,",
            "\t\t\t(unsigned long long)oi2->ip_blkno);",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\refcounttree.c"
          ]
        },
        {
          "file": "linux\\fs\\romfs\\super.c",
          "line": 28,
          "match": "double unlock",
          "context": [
            " *\t\t\t\t\tlookup shouldn't return -ENOENT",
            " *\t\t\t\t\tfrom Horst von Brand:",
            " *\t\t\t\t\t  fail on wrong checksum",
            " *\t\t\t\t\t  double unlock_super was possible",
            " *\t\t\t\t\t  correct namelen for statfs",
            " *\t\t\t\t\tspotted by Bill Hawes:",
            " *\t\t\t\t\t  readlink shouldn't iput()"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\romfs\\super.c"
          ]
        },
        {
          "file": "linux\\fs\\ufs\\inode.c",
          "line": 54,
          "match": "double_block",
          "context": [
            "\tint ptrs_bits = uspi->s_apbshift;",
            "\tconst long direct_blocks = UFS_NDADDR,",
            "\t\tindirect_blocks = ptrs,",
            "\t\tdouble_blocks = (1 << (ptrs_bits * 2));",
            "\tint n = 0;",
            "",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ufs\\inode.c"
          ]
        },
        {
          "file": "linux\\fs\\ufs\\inode.c",
          "line": 58,
          "match": "double_blocks=%ld \\n\",ptrs,double_block",
          "context": [
            "\tint n = 0;",
            "",
            "",
            "\tUFSD(\"ptrs=uspi->s_apb = %d,double_blocks=%ld \\n\",ptrs,double_blocks);",
            "\tif (i_block < direct_blocks) {",
            "\t\toffsets[n++] = i_block;",
            "\t} else if ((i_block -= direct_blocks) < indirect_blocks) {"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ufs\\inode.c"
          ]
        },
        {
          "file": "linux\\fs\\ufs\\inode.c",
          "line": 64,
          "match": "double_block",
          "context": [
            "\t} else if ((i_block -= direct_blocks) < indirect_blocks) {",
            "\t\toffsets[n++] = UFS_IND_BLOCK;",
            "\t\toffsets[n++] = i_block;",
            "\t} else if ((i_block -= indirect_blocks) < double_blocks) {",
            "\t\toffsets[n++] = UFS_DIND_BLOCK;",
            "\t\toffsets[n++] = i_block >> ptrs_bits;",
            "\t\toffsets[n++] = i_block & (ptrs - 1);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ufs\\inode.c"
          ]
        },
        {
          "file": "linux\\fs\\ufs\\inode.c",
          "line": 68,
          "match": "double_block",
          "context": [
            "\t\toffsets[n++] = UFS_DIND_BLOCK;",
            "\t\toffsets[n++] = i_block >> ptrs_bits;",
            "\t\toffsets[n++] = i_block & (ptrs - 1);",
            "\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {",
            "\t\toffsets[n++] = UFS_TIND_BLOCK;",
            "\t\toffsets[n++] = i_block >> (ptrs_bits * 2);",
            "\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ufs\\inode.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\xfs_inode.c",
          "line": 478,
          "match": "double-lock",
          "context": [
            "",
            "/*",
            " * xfs_lock_two_inodes() can only be used to lock ilock. The iolock and",
            " * mmaplock must be double-locked separately since we use i_rwsem and",
            " * invalidate_lock for that. We now support taking one lock EXCL and the",
            " * other SHARED.",
            " */"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\xfs_inode.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\dlm\\dlmdomain.c",
          "line": 508,
          "match": "double spinlock! I need domain_lock",
          "context": [
            "",
            "static void dlm_mark_domain_leaving(struct dlm_ctxt *dlm)",
            "{",
            "\t/* Yikes, a double spinlock! I need domain_lock for the dlm",
            "\t * state and the dlm spinlock for join state... Sorry! */",
            "again:",
            "\tspin_lock(&dlm_domain_lock);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\dlm\\dlmdomain.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\libxfs\\xfs_da_btree.c",
          "line": 895,
          "match": "double-split op below us, then add the extra block",
          "context": [
            "\t * operation always results in a new block whose hashvals",
            "\t * FOLLOW the current block.",
            "\t *",
            "\t * If we had double-split op below us, then add the extra block too.",
            "\t */",
            "\tnode = oldblk->bp->b_addr;",
            "\txfs_da3_node_hdr_from_disk(dp->i_mount, &nodehdr, node);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\libxfs\\xfs_da_btree.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\libxfs\\xfs_inode_util.c",
          "line": 399,
          "match": "double linked unlinked list, and we don't need any extra lock",
          "context": [
            " *",
            " * Given we have an existence guarantee, we can use lockless inode cache lookups",
            " * to resolve aginos to xfs inodes. This means we only need 8 bytes per inode",
            " * for the double linked unlinked list, and we don't need any extra locking to",
            " * keep the list safe as all manipulations are done under the AGI buffer lock.",
            " * Keeping the list up to date does not require memory allocation, just finding",
            " * the XFS inode and updating the next/prev unlinked list aginos."
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\libxfs\\xfs_inode_util.c"
          ]
        },
        {
          "file": "linux\\kernel\\cgroup\\cpuset.c",
          "line": 235,
          "match": "double tripping on callback_lock",
          "context": [
            " * takes callback_lock, blocking everyone else.",
            " *",
            " * Calls to the kernel memory allocator can not be made while holding",
            " * callback_lock, as that would risk double tripping on callback_lock",
            " * from one of the callbacks into the cpuset code from within",
            " * __alloc_pages().",
            " *"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\cgroup\\cpuset.c"
          ]
        },
        {
          "file": "linux\\kernel\\futex\\requeue.c",
          "line": 461,
          "match": "double_lock",
          "context": [
            "\t\tCLASS(hb, hb2)(&key2);",
            "",
            "\t\tfutex_hb_waiters_inc(hb2);",
            "\t\tdouble_lock_hb(hb1, hb2);",
            "",
            "\t\tif (likely(cmpval != NULL)) {",
            "\t\t\tu32 curval;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\futex\\requeue.c"
          ]
        },
        {
          "file": "linux\\kernel\\futex\\requeue.c",
          "line": 470,
          "match": "double_unlock",
          "context": [
            "",
            "\t\t\tif (unlikely(ret)) {",
            "\t\t\t\tfutex_hb_waiters_dec(hb2);",
            "\t\t\t\tdouble_unlock_hb(hb1, hb2);",
            "",
            "\t\t\t\tret = get_user(curval, uaddr1);",
            "\t\t\t\tif (ret)"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\futex\\requeue.c"
          ]
        },
        {
          "file": "linux\\kernel\\futex\\requeue.c",
          "line": 556,
          "match": "double_unlock",
          "context": [
            "\t\t\t\t */",
            "\t\t\tcase -EFAULT:",
            "\t\t\t\tfutex_hb_waiters_dec(hb2);",
            "\t\t\t\tdouble_unlock_hb(hb1, hb2);",
            "\t\t\t\tret = fault_in_user_writeable(uaddr2);",
            "\t\t\t\tif (!ret)",
            "\t\t\t\t\tgoto retry;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\futex\\requeue.c"
          ]
        },
        {
          "file": "linux\\kernel\\futex\\requeue.c",
          "line": 570,
          "match": "double_unlock",
          "context": [
            "\t\t\t\t * - EAGAIN: The user space value changed.",
            "\t\t\t\t */",
            "\t\t\t\tfutex_hb_waiters_dec(hb2);",
            "\t\t\t\tdouble_unlock_hb(hb1, hb2);",
            "\t\t\t\t/*",
            "\t\t\t\t * Handle the case where the owner is in the middle of",
            "\t\t\t\t * exiting. Wait for the exit to complete otherwise"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\futex\\requeue.c"
          ]
        },
        {
          "file": "linux\\kernel\\futex\\requeue.c",
          "line": 688,
          "match": "double_unlock",
          "context": [
            "",
            "out_unlock:",
            "\t\tfutex_hb_waiters_dec(hb2);",
            "\t\tdouble_unlock_hb(hb1, hb2);",
            "\t}",
            "\twake_up_q(&wake_q);",
            "\treturn ret ? ret : task_count;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\futex\\requeue.c"
          ]
        },
        {
          "file": "linux\\kernel\\futex\\waitwake.c",
          "line": 107,
          "match": "double_lock_hb() and double_unlock",
          "context": [
            " * acquiring the lock. It then decrements them again  after releasing it -",
            " * the code that actually moves the futex(es) between hash buckets (requeue_futex)",
            " * will do the additional required waiter count housekeeping. This is done for",
            " * double_lock_hb() and double_unlock_hb(), respectively.",
            " */",
            "",
            "bool __futex_wake_mark(struct futex_q *q)"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\futex\\waitwake.c"
          ]
        },
        {
          "file": "linux\\kernel\\futex\\waitwake.c",
          "line": 272,
          "match": "double_lock",
          "context": [
            "\t\tCLASS(hb, hb1)(&key1);",
            "\t\tCLASS(hb, hb2)(&key2);",
            "",
            "\t\tdouble_lock_hb(hb1, hb2);",
            "\t\top_ret = futex_atomic_op_inuser(op, uaddr2);",
            "\t\tif (unlikely(op_ret < 0)) {",
            "\t\t\tdouble_unlock_hb(hb1, hb2);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\futex\\waitwake.c"
          ]
        },
        {
          "file": "linux\\kernel\\futex\\waitwake.c",
          "line": 275,
          "match": "double_unlock",
          "context": [
            "\t\tdouble_lock_hb(hb1, hb2);",
            "\t\top_ret = futex_atomic_op_inuser(op, uaddr2);",
            "\t\tif (unlikely(op_ret < 0)) {",
            "\t\t\tdouble_unlock_hb(hb1, hb2);",
            "",
            "\t\t\tif (!IS_ENABLED(CONFIG_MMU) ||",
            "\t\t\t    unlikely(op_ret != -EFAULT && op_ret != -EAGAIN)) {"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\futex\\waitwake.c"
          ]
        },
        {
          "file": "linux\\kernel\\futex\\waitwake.c",
          "line": 328,
          "match": "double_unlock",
          "context": [
            "\t\t}",
            "",
            "out_unlock:",
            "\t\tdouble_unlock_hb(hb1, hb2);",
            "\t}",
            "\twake_up_q(&wake_q);",
            "\treturn ret;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\futex\\waitwake.c"
          ]
        },
        {
          "file": "linux\\kernel\\kcsan\\kcsan_test.c",
          "line": 167,
          "match": "Doubled-checked lock",
          "context": [
            "\tchar *cur;",
            "\tint i;",
            "",
            "\t/* Doubled-checked locking. */",
            "\tif (!report_available())",
            "\t\treturn false;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\kcsan\\kcsan_test.c"
          ]
        },
        {
          "file": "linux\\kernel\\rcu\\srcutree.c",
          "line": 333,
          "match": "Double-checked lock",
          "context": [
            "{",
            "\tunsigned long flags;",
            "",
            "\t/* Double-checked locking on ->srcu_size-state. */",
            "\tif (smp_load_acquire(&ssp->srcu_sup->srcu_size_state) != SRCU_SIZE_SMALL)",
            "\t\treturn;",
            "\tspin_lock_irqsave_rcu_node(ssp->srcu_sup, flags);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\rcu\\srcutree.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\core.c",
          "line": 590,
          "match": "double_rq_lock",
          "context": [
            " *    o move_queued_task()",
            " *    o detach_task()",
            " *",
            " *  - for migration called under double_rq_lock():",
            " *",
            " *    o __migrate_swap_task()",
            " *    o push_rt_task() / pull_rt_task()"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\core.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\core.c",
          "line": 655,
          "match": "double_rq_lock - safely lock",
          "context": [
            "",
            "#ifdef CONFIG_SMP",
            "/*",
            " * double_rq_lock - safely lock two runqueues",
            " */",
            "void double_rq_lock(struct rq *rq1, struct rq *rq2)",
            "{"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\core.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\core.c",
          "line": 657,
          "match": "double_rq_lock",
          "context": [
            "/*",
            " * double_rq_lock - safely lock two runqueues",
            " */",
            "void double_rq_lock(struct rq *rq1, struct rq *rq2)",
            "{",
            "\tlockdep_assert_irqs_disabled();",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\core.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\core.c",
          "line": 668,
          "match": "double_rq_clock",
          "context": [
            "\tif (__rq_lockp(rq1) != __rq_lockp(rq2))",
            "\t\traw_spin_rq_lock_nested(rq2, SINGLE_DEPTH_NESTING);",
            "",
            "\tdouble_rq_clock_clear_update(rq1, rq2);",
            "}",
            "#endif",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\core.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\core.c",
          "line": 811,
          "match": "DOUBLE_CLOCK",
          "context": [
            "\tif (rq->clock_update_flags & RQCF_ACT_SKIP)",
            "\t\treturn;",
            "",
            "\tif (sched_feat(WARN_DOUBLE_CLOCK))",
            "\t\tWARN_ON_ONCE(rq->clock_update_flags & RQCF_UPDATED);",
            "\trq->clock_update_flags |= RQCF_UPDATED;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\core.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\core.c",
          "line": 2694,
          "match": "double_unlock",
          "context": [
            "\t\tresched_curr(lowest_rq);",
            "\t}",
            "",
            "\tdouble_unlock_balance(rq, lowest_rq);",
            "",
            "out_unlock:",
            "\trq->push_busy = false;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\core.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\core.c",
          "line": 3411,
          "match": "double_raw_spinlock)(&arg->src_task->pi_lock, &arg->dst_task->pi_lock",
          "context": [
            "\tsrc_rq = cpu_rq(arg->src_cpu);",
            "\tdst_rq = cpu_rq(arg->dst_cpu);",
            "",
            "\tguard(double_raw_spinlock)(&arg->src_task->pi_lock, &arg->dst_task->pi_lock);",
            "\tguard(double_rq_lock)(src_rq, dst_rq);",
            "",
            "\tif (task_cpu(arg->dst_task) != arg->dst_cpu)"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\core.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\core.c",
          "line": 3412,
          "match": "double_rq_lock",
          "context": [
            "\tdst_rq = cpu_rq(arg->dst_cpu);",
            "",
            "\tguard(double_raw_spinlock)(&arg->src_task->pi_lock, &arg->dst_task->pi_lock);",
            "\tguard(double_rq_lock)(src_rq, dst_rq);",
            "",
            "\tif (task_cpu(arg->dst_task) != arg->dst_cpu)",
            "\t\treturn -EAGAIN;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\core.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\core.c",
          "line": 6356,
          "match": "double_rq_lock",
          "context": [
            "\tbool success = false;",
            "",
            "\tguard(irq)();",
            "\tguard(double_rq_lock)(dst, src);",
            "",
            "\tcookie = dst->core->core_cookie;",
            "\tif (!cookie)"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\core.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\deadline.c",
          "line": 715,
          "match": "double_lock",
          "context": [
            "\t\t\tcpu = cpumask_any(cpu_active_mask);",
            "\t\t}",
            "\t\tlater_rq = cpu_rq(cpu);",
            "\t\tdouble_lock_balance(rq, later_rq);",
            "\t}",
            "",
            "\tif (p->dl.dl_non_contending || p->dl.dl_throttled) {"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\deadline.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\deadline.c",
          "line": 751,
          "match": "double_unlock",
          "context": [
            "\traw_spin_unlock(&dl_b->lock);",
            "",
            "\tset_task_cpu(p, later_rq->cpu);",
            "\tdouble_unlock_balance(later_rq, rq);",
            "",
            "\treturn later_rq;",
            "}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\deadline.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\deadline.c",
          "line": 2648,
          "match": "double_lock",
          "context": [
            "\t\t}",
            "",
            "\t\t/* Retry if something changed. */",
            "\t\tif (double_lock_balance(rq, later_rq)) {",
            "\t\t\tif (unlikely(task_rq(task) != rq ||",
            "\t\t\t\t     !cpumask_test_cpu(later_rq->cpu, &task->cpus_mask) ||",
            "\t\t\t\t     task_on_cpu(rq, task) ||"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\deadline.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\deadline.c",
          "line": 2655,
          "match": "double_unlock",
          "context": [
            "\t\t\t\t     !dl_task(task) ||",
            "\t\t\t\t     is_migration_disabled(task) ||",
            "\t\t\t\t     !task_on_rq_queued(task))) {",
            "\t\t\t\tdouble_unlock_balance(rq, later_rq);",
            "\t\t\t\tlater_rq = NULL;",
            "\t\t\t\tbreak;",
            "\t\t\t}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\deadline.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\deadline.c",
          "line": 2670,
          "match": "double_unlock",
          "context": [
            "\t\t\tbreak;",
            "",
            "\t\t/* Otherwise we try again. */",
            "\t\tdouble_unlock_balance(rq, later_rq);",
            "\t\tlater_rq = NULL;",
            "\t}",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\deadline.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\deadline.c",
          "line": 2766,
          "match": "double_unlock",
          "context": [
            "",
            "\tresched_curr(later_rq);",
            "",
            "\tdouble_unlock_balance(rq, later_rq);",
            "",
            "out:",
            "\tput_task_struct(next_task);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\deadline.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\deadline.c",
          "line": 2815,
          "match": "double_lock",
          "context": [
            "",
            "\t\t/* Might drop this_rq->lock */",
            "\t\tpush_task = NULL;",
            "\t\tdouble_lock_balance(this_rq, src_rq);",
            "",
            "\t\t/*",
            "\t\t * If there are no more pullable tasks on the"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\deadline.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\deadline.c",
          "line": 2855,
          "match": "double_unlock",
          "context": [
            "\t\t\t/* Is there any other task even earlier? */",
            "\t\t}",
            "skip:",
            "\t\tdouble_unlock_balance(this_rq, src_rq);",
            "",
            "\t\tif (push_task) {",
            "\t\t\tpreempt_disable();"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\deadline.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\ext.c",
          "line": 2193,
          "match": "double lock",
          "context": [
            "",
            "\t/*",
            "\t * We are in the enqueue path with @rq locked and pinned, and thus can't",
            "\t * double lock a remote rq and enqueue to its local DSQ. For",
            "\t * DSQ_LOCAL_ON verdicts targeting the local DSQ of a remote CPU, defer",
            "\t * the enqueue so that it's executed when @rq can be unlocked.",
            "\t */"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\ext.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\fair.c",
          "line": 3099,
          "match": "double_lock_irq(&my_grp->lock, &grp->lock",
          "context": [
            "\t\treturn;",
            "",
            "\tWARN_ON_ONCE(irqs_disabled());",
            "\tdouble_lock_irq(&my_grp->lock, &grp->lock);",
            "",
            "\tfor (i = 0; i < NR_NUMA_HINT_FAULT_STATS * nr_node_ids; i++) {",
            "\t\tmy_grp->faults[i] -= p->numa_faults[i];"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\fair.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\rt.c",
          "line": 1944,
          "match": "double_lock",
          "context": [
            "\t\t}",
            "",
            "\t\t/* if the prio of this runqueue changed, try again */",
            "\t\tif (double_lock_balance(rq, lowest_rq)) {",
            "\t\t\t/*",
            "\t\t\t * We had to unlock the run queue. In",
            "\t\t\t * the mean time, task could have"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\rt.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\rt.c",
          "line": 1959,
          "match": "double_unlock",
          "context": [
            "\t\t\t\t     !cpumask_test_cpu(lowest_rq->cpu, &task->cpus_mask) ||",
            "\t\t\t\t     task != pick_next_pushable_task(rq))) {",
            "",
            "\t\t\t\tdouble_unlock_balance(rq, lowest_rq);",
            "\t\t\t\tlowest_rq = NULL;",
            "\t\t\t\tbreak;",
            "\t\t\t}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\rt.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\rt.c",
          "line": 1970,
          "match": "double_unlock",
          "context": [
            "\t\t\tbreak;",
            "",
            "\t\t/* try again */",
            "\t\tdouble_unlock_balance(rq, lowest_rq);",
            "\t\tlowest_rq = NULL;",
            "\t}",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\rt.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\rt.c",
          "line": 2093,
          "match": "double_unlock",
          "context": [
            "\tresched_curr(lowest_rq);",
            "\tret = 1;",
            "",
            "\tdouble_unlock_balance(rq, lowest_rq);",
            "out:",
            "\tput_task_struct(next_task);",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\rt.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\rt.c",
          "line": 2326,
          "match": "double_lock",
          "context": [
            "",
            "\t\t/*",
            "\t\t * We can potentially drop this_rq's lock in",
            "\t\t * double_lock_balance, and another CPU could",
            "\t\t * alter this_rq",
            "\t\t */",
            "\t\tpush_task = NULL;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\rt.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\rt.c",
          "line": 2330,
          "match": "double_lock",
          "context": [
            "\t\t * alter this_rq",
            "\t\t */",
            "\t\tpush_task = NULL;",
            "\t\tdouble_lock_balance(this_rq, src_rq);",
            "",
            "\t\t/*",
            "\t\t * We can pull only a task, which is pushable"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\rt.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\rt.c",
          "line": 2371,
          "match": "double_unlock",
          "context": [
            "\t\t\t */",
            "\t\t}",
            "skip:",
            "\t\tdouble_unlock_balance(this_rq, src_rq);",
            "",
            "\t\tif (push_task) {",
            "\t\t\tpreempt_disable();"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\rt.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\syscalls.c",
          "line": 533,
          "match": "Double check policy once rq lock",
          "context": [
            "\t/* The pi code expects interrupts enabled */",
            "\tBUG_ON(pi && in_interrupt());",
            "recheck:",
            "\t/* Double check policy once rq lock held: */",
            "\tif (policy < 0) {",
            "\t\treset_on_fork = p->sched_reset_on_fork;",
            "\t\tpolicy = oldpolicy = p->policy;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\syscalls.c"
          ]
        },
        {
          "file": "linux\\kernel\\sched\\syscalls.c",
          "line": 1446,
          "match": "double_rq_lock",
          "context": [
            "\t\tif (rq->nr_running == 1 && p_rq->nr_running == 1)",
            "\t\t\treturn -ESRCH;",
            "",
            "\t\tguard(double_rq_lock)(rq, p_rq);",
            "\t\tif (task_rq(p) != p_rq)",
            "\t\t\tgoto again;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\sched\\syscalls.c"
          ]
        },
        {
          "file": "linux\\net\\core\\dev.c",
          "line": 26,
          "match": "double lock",
          "context": [
            " *\t\tAlan Cox\t:\tdevice private ioctl copies fields back.",
            " *\t\tAlan Cox\t:\tTransmit queue code does relevant",
            " *\t\t\t\t\tstunts to keep the queue safe.",
            " *\t\tAlan Cox\t:\tFixed double lock.",
            " *\t\tAlan Cox\t:\tFixed promisc NULL pointer trap",
            " *\t\t????????\t:\tSupport the full private ioctl range",
            " *\t\tAlan Cox\t:\tMoved ioctl permission check into"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\core\\dev.c"
          ]
        },
        {
          "file": "linux\\net\\ipv4\\arp.c",
          "line": 22,
          "match": "Double lock",
          "context": [
            " *\t\tStephen Henson\t:\tAdd AX25 support to arp_get_info()",
            " *\t\tAlan Cox\t:\tDrop data when a device is downed.",
            " *\t\tAlan Cox\t:\tUse init_timer().",
            " *\t\tAlan Cox\t:\tDouble lock fixes.",
            " *\t\tMartin Seine\t:\tMove the arphdr structure",
            " *\t\t\t\t\tto if_arp.h for compatibility.",
            " *\t\t\t\t\twith BSD based programs."
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\ipv4\\arp.c"
          ]
        },
        {
          "file": "linux\\net\\ipv4\\tcp_ipv4.c",
          "line": 1899,
          "match": "double-lock",
          "context": [
            "/* The socket must have it's spinlock held when we get",
            " * here, unless it is a TCP_LISTEN socket.",
            " *",
            " * We have a potential double-lock case here, so even when",
            " * doing backlog processing we use the BH locking scheme.",
            " * This is because we cannot sleep with the original spinlock",
            " * held."
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\ipv4\\tcp_ipv4.c"
          ]
        },
        {
          "file": "linux\\net\\ipv6\\tcp_ipv6.c",
          "line": 1587,
          "match": "double-lock",
          "context": [
            "/* The socket must have it's spinlock held when we get",
            " * here, unless it is a TCP_LISTEN socket.",
            " *",
            " * We have a potential double-lock case here, so even when",
            " * doing backlog processing we use the BH locking scheme.",
            " * This is because we cannot sleep with the original spinlock",
            " * held."
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\ipv6\\tcp_ipv6.c"
          ]
        },
        {
          "file": "linux\\net\\mptcp\\pm.c",
          "line": 795,
          "match": "double check after the lock",
          "context": [
            "",
            "\tspin_lock_bh(&msk->pm.lock);",
            "",
            "\t/* double check after the lock is acquired */",
            "\tif (!mptcp_pm_should_add_signal(msk))",
            "\t\tgoto out_unlock;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\mptcp\\pm.c"
          ]
        },
        {
          "file": "linux\\net\\mptcp\\pm.c",
          "line": 838,
          "match": "double check after the lock",
          "context": [
            "",
            "\tspin_lock_bh(&msk->pm.lock);",
            "",
            "\t/* double check after the lock is acquired */",
            "\tif (!mptcp_pm_should_rm_signal(msk))",
            "\t\tgoto out_unlock;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\mptcp\\pm.c"
          ]
        },
        {
          "file": "linux\\net\\netfilter\\nf_conntrack_core.c",
          "line": 129,
          "match": "double_unlock",
          "context": [
            "}",
            "EXPORT_SYMBOL_GPL(nf_conntrack_lock);",
            "",
            "static void nf_conntrack_double_unlock(unsigned int h1, unsigned int h2)",
            "{",
            "\th1 %= CONNTRACK_LOCKS;",
            "\th2 %= CONNTRACK_LOCKS;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\netfilter\\nf_conntrack_core.c"
          ]
        },
        {
          "file": "linux\\net\\netfilter\\nf_conntrack_core.c",
          "line": 139,
          "match": "double_lock",
          "context": [
            "}",
            "",
            "/* return true if we need to recompute hashes (in case hash table was resized) */",
            "static bool nf_conntrack_double_lock(struct net *net, unsigned int h1,",
            "\t\t\t\t     unsigned int h2, unsigned int sequence)",
            "{",
            "\th1 %= CONNTRACK_LOCKS;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\netfilter\\nf_conntrack_core.c"
          ]
        },
        {
          "file": "linux\\net\\netfilter\\nf_conntrack_core.c",
          "line": 155,
          "match": "double_unlock",
          "context": [
            "\t\t\t\t SINGLE_DEPTH_NESTING);",
            "\t}",
            "\tif (read_seqcount_retry(&nf_conntrack_generation, sequence)) {",
            "\t\tnf_conntrack_double_unlock(h1, h2);",
            "\t\treturn true;",
            "\t}",
            "\treturn false;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\netfilter\\nf_conntrack_core.c"
          ]
        },
        {
          "file": "linux\\net\\netfilter\\nf_conntrack_core.c",
          "line": 619,
          "match": "double_lock",
          "context": [
            "\t\treply_hash = hash_conntrack(net,",
            "\t\t\t\t\t   &ct->tuplehash[IP_CT_DIR_REPLY].tuple,",
            "\t\t\t\t\t   nf_ct_zone_id(nf_ct_zone(ct), IP_CT_DIR_REPLY));",
            "\t} while (nf_conntrack_double_lock(net, hash, reply_hash, sequence));",
            "",
            "\tclean_from_lists(ct);",
            "\tnf_conntrack_double_unlock(hash, reply_hash);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\netfilter\\nf_conntrack_core.c"
          ]
        },
        {
          "file": "linux\\net\\netfilter\\nf_conntrack_core.c",
          "line": 622,
          "match": "double_unlock",
          "context": [
            "\t} while (nf_conntrack_double_lock(net, hash, reply_hash, sequence));",
            "",
            "\tclean_from_lists(ct);",
            "\tnf_conntrack_double_unlock(hash, reply_hash);",
            "}",
            "",
            "static void nf_ct_delete_from_lists(struct nf_conn *ct)"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\netfilter\\nf_conntrack_core.c"
          ]
        },
        {
          "file": "linux\\net\\netfilter\\nf_conntrack_core.c",
          "line": 896,
          "match": "double_lock",
          "context": [
            "\t\treply_hash = hash_conntrack(net,",
            "\t\t\t\t\t   &ct->tuplehash[IP_CT_DIR_REPLY].tuple,",
            "\t\t\t\t\t   nf_ct_zone_id(nf_ct_zone(ct), IP_CT_DIR_REPLY));",
            "\t} while (nf_conntrack_double_lock(net, hash, reply_hash, sequence));",
            "",
            "\tmax_chainlen = MIN_CHAINLEN + get_random_u32_below(MAX_CHAINLEN);",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\netfilter\\nf_conntrack_core.c"
          ]
        },
        {
          "file": "linux\\net\\netfilter\\nf_conntrack_core.c",
          "line": 936,
          "match": "double_unlock",
          "context": [
            "\t/* The caller holds a reference to this object */",
            "\trefcount_set(&ct->ct_general.use, 2);",
            "\t__nf_conntrack_hash_insert(ct, hash, reply_hash);",
            "\tnf_conntrack_double_unlock(hash, reply_hash);",
            "\tNF_CT_STAT_INC(net, insert);",
            "\tlocal_bh_enable();",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\netfilter\\nf_conntrack_core.c"
          ]
        },
        {
          "file": "linux\\net\\netfilter\\nf_conntrack_core.c",
          "line": 945,
          "match": "double_unlock",
          "context": [
            "\tNF_CT_STAT_INC(net, chaintoolong);",
            "\terr = -ENOSPC;",
            "out:",
            "\tnf_conntrack_double_unlock(hash, reply_hash);",
            "\tlocal_bh_enable();",
            "\treturn err;",
            "}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\netfilter\\nf_conntrack_core.c"
          ]
        },
        {
          "file": "linux\\net\\netfilter\\nf_conntrack_core.c",
          "line": 1234,
          "match": "double_lock",
          "context": [
            "\t\treply_hash = hash_conntrack(net,",
            "\t\t\t\t\t   &ct->tuplehash[IP_CT_DIR_REPLY].tuple,",
            "\t\t\t\t\t   nf_ct_zone_id(nf_ct_zone(ct), IP_CT_DIR_REPLY));",
            "\t} while (nf_conntrack_double_lock(net, hash, reply_hash, sequence));",
            "",
            "\t/* We're not in hash table, and we refuse to set up related",
            "\t * connections for unconfirmed conns.  But packet copies and"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\netfilter\\nf_conntrack_core.c"
          ]
        },
        {
          "file": "linux\\net\\netfilter\\nf_conntrack_core.c",
          "line": 1248,
          "match": "double_unlock",
          "context": [
            "\t */",
            "\tif (unlikely(nf_ct_is_confirmed(ct))) {",
            "\t\tWARN_ON_ONCE(1);",
            "\t\tnf_conntrack_double_unlock(hash, reply_hash);",
            "\t\tlocal_bh_enable();",
            "\t\treturn NF_DROP;",
            "\t}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\netfilter\\nf_conntrack_core.c"
          ]
        },
        {
          "file": "linux\\net\\netfilter\\nf_conntrack_core.c",
          "line": 1309,
          "match": "double_unlock",
          "context": [
            "\t * stores are visible.",
            "\t */",
            "\t__nf_conntrack_hash_insert(ct, hash, reply_hash);",
            "\tnf_conntrack_double_unlock(hash, reply_hash);",
            "\tlocal_bh_enable();",
            "",
            "\t/* ext area is still valid (rcu read lock is held,"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\netfilter\\nf_conntrack_core.c"
          ]
        },
        {
          "file": "linux\\net\\netfilter\\nf_conntrack_core.c",
          "line": 1333,
          "match": "double_unlock",
          "context": [
            "out:",
            "\tret = nf_ct_resolve_clash(skb, h, reply_hash);",
            "dying:",
            "\tnf_conntrack_double_unlock(hash, reply_hash);",
            "\tlocal_bh_enable();",
            "\treturn ret;",
            "}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\netfilter\\nf_conntrack_core.c"
          ]
        },
        {
          "file": "linux\\net\\unix\\af_unix.c",
          "line": 175,
          "match": "double_lock",
          "context": [
            "\t\t}",
            "\t}",
            "",
            "\t/* unix_state_double_lock(): ascending address order. */",
            "\treturn cmp_ptr(a, b);",
            "}",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\unix\\af_unix.c"
          ]
        },
        {
          "file": "linux\\net\\unix\\af_unix.c",
          "line": 228,
          "match": "double_lock",
          "context": [
            "\treturn UNIX_HASH_MOD + 1 + (hash & UNIX_HASH_MOD);",
            "}",
            "",
            "static void unix_table_double_lock(struct net *net,",
            "\t\t\t\t   unsigned int hash1, unsigned int hash2)",
            "{",
            "\tif (hash1 == hash2) {"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\unix\\af_unix.c"
          ]
        },
        {
          "file": "linux\\net\\unix\\af_unix.c",
          "line": 243,
          "match": "double_unlock",
          "context": [
            "\tspin_lock(&net->unx.table.locks[hash2]);",
            "}",
            "",
            "static void unix_table_double_unlock(struct net *net,",
            "\t\t\t\t     unsigned int hash1, unsigned int hash2)",
            "{",
            "\tif (hash1 == hash2) {"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\unix\\af_unix.c"
          ]
        },
        {
          "file": "linux\\net\\unix\\af_unix.c",
          "line": 1296,
          "match": "double_lock",
          "context": [
            "\tsprintf(addr->name->sun_path + 1, \"%05x\", ordernum);",
            "",
            "\tnew_hash = unix_abstract_hash(addr->name, addr->len, sk->sk_type);",
            "\tunix_table_double_lock(net, old_hash, new_hash);",
            "",
            "\tif (__unix_find_socket_byname(net, addr->name, addr->len, new_hash)) {",
            "\t\tunix_table_double_unlock(net, old_hash, new_hash);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\unix\\af_unix.c"
          ]
        },
        {
          "file": "linux\\net\\unix\\af_unix.c",
          "line": 1299,
          "match": "double_unlock",
          "context": [
            "\tunix_table_double_lock(net, old_hash, new_hash);",
            "",
            "\tif (__unix_find_socket_byname(net, addr->name, addr->len, new_hash)) {",
            "\t\tunix_table_double_unlock(net, old_hash, new_hash);",
            "",
            "\t\t/* __unix_find_socket_byname() may take long time if many names",
            "\t\t * are already in use."
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\unix\\af_unix.c"
          ]
        },
        {
          "file": "linux\\net\\unix\\af_unix.c",
          "line": 1317,
          "match": "double_unlock",
          "context": [
            "\t}",
            "",
            "\t__unix_set_addr_hash(net, sk, addr, new_hash);",
            "\tunix_table_double_unlock(net, old_hash, new_hash);",
            "\terr = 0;",
            "",
            "out:\tmutex_unlock(&u->bindlock);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\unix\\af_unix.c"
          ]
        },
        {
          "file": "linux\\net\\unix\\af_unix.c",
          "line": 1370,
          "match": "double_lock",
          "context": [
            "",
            "\told_hash = sk->sk_hash;",
            "\tnew_hash = unix_bsd_hash(d_backing_inode(dentry));",
            "\tunix_table_double_lock(net, old_hash, new_hash);",
            "\tu->path.mnt = mntget(parent.mnt);",
            "\tu->path.dentry = dget(dentry);",
            "\t__unix_set_addr_hash(net, sk, addr, new_hash);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\unix\\af_unix.c"
          ]
        },
        {
          "file": "linux\\net\\unix\\af_unix.c",
          "line": 1374,
          "match": "double_unlock",
          "context": [
            "\tu->path.mnt = mntget(parent.mnt);",
            "\tu->path.dentry = dget(dentry);",
            "\t__unix_set_addr_hash(net, sk, addr, new_hash);",
            "\tunix_table_double_unlock(net, old_hash, new_hash);",
            "\tunix_insert_bsd_socket(sk);",
            "\tmutex_unlock(&u->bindlock);",
            "\tdone_path_create(&parent, dentry);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\unix\\af_unix.c"
          ]
        },
        {
          "file": "linux\\net\\unix\\af_unix.c",
          "line": 1417,
          "match": "double_lock",
          "context": [
            "",
            "\told_hash = sk->sk_hash;",
            "\tnew_hash = unix_abstract_hash(addr->name, addr->len, sk->sk_type);",
            "\tunix_table_double_lock(net, old_hash, new_hash);",
            "",
            "\tif (__unix_find_socket_byname(net, addr->name, addr->len, new_hash))",
            "\t\tgoto out_spin;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\unix\\af_unix.c"
          ]
        },
        {
          "file": "linux\\net\\unix\\af_unix.c",
          "line": 1423,
          "match": "double_unlock",
          "context": [
            "\t\tgoto out_spin;",
            "",
            "\t__unix_set_addr_hash(net, sk, addr, new_hash);",
            "\tunix_table_double_unlock(net, old_hash, new_hash);",
            "\tmutex_unlock(&u->bindlock);",
            "\treturn 0;",
            ""
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\unix\\af_unix.c"
          ]
        },
        {
          "file": "linux\\net\\unix\\af_unix.c",
          "line": 1428,
          "match": "double_unlock",
          "context": [
            "\treturn 0;",
            "",
            "out_spin:",
            "\tunix_table_double_unlock(net, old_hash, new_hash);",
            "\terr = -EADDRINUSE;",
            "out_mutex:",
            "\tmutex_unlock(&u->bindlock);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\unix\\af_unix.c"
          ]
        },
        {
          "file": "linux\\net\\unix\\af_unix.c",
          "line": 1459,
          "match": "double_lock",
          "context": [
            "\treturn err;",
            "}",
            "",
            "static void unix_state_double_lock(struct sock *sk1, struct sock *sk2)",
            "{",
            "\tif (unlikely(sk1 == sk2) || !sk2) {",
            "\t\tunix_state_lock(sk1);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\unix\\af_unix.c"
          ]
        },
        {
          "file": "linux\\net\\unix\\af_unix.c",
          "line": 1473,
          "match": "double_unlock",
          "context": [
            "\tunix_state_lock(sk2);",
            "}",
            "",
            "static void unix_state_double_unlock(struct sock *sk1, struct sock *sk2)",
            "{",
            "\tif (unlikely(sk1 == sk2) || !sk2) {",
            "\t\tunix_state_unlock(sk1);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\unix\\af_unix.c"
          ]
        },
        {
          "file": "linux\\net\\unix\\af_unix.c",
          "line": 1517,
          "match": "double_lock",
          "context": [
            "\t\t\tgoto out;",
            "\t\t}",
            "",
            "\t\tunix_state_double_lock(sk, other);",
            "",
            "\t\t/* Apparently VFS overslept socket death. Retry. */",
            "\t\tif (sock_flag(other, SOCK_DEAD)) {"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\unix\\af_unix.c"
          ]
        },
        {
          "file": "linux\\net\\unix\\af_unix.c",
          "line": 1521,
          "match": "double_unlock",
          "context": [
            "",
            "\t\t/* Apparently VFS overslept socket death. Retry. */",
            "\t\tif (sock_flag(other, SOCK_DEAD)) {",
            "\t\t\tunix_state_double_unlock(sk, other);",
            "\t\t\tsock_put(other);",
            "\t\t\tgoto restart;",
            "\t\t}"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\unix\\af_unix.c"
          ]
        },
        {
          "file": "linux\\net\\unix\\af_unix.c",
          "line": 1541,
          "match": "double_lock",
          "context": [
            "\t\t *\t1003.1g breaking connected state with AF_UNSPEC",
            "\t\t */",
            "\t\tother = NULL;",
            "\t\tunix_state_double_lock(sk, other);",
            "\t}",
            "",
            "\t/*"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\unix\\af_unix.c"
          ]
        },
        {
          "file": "linux\\net\\unix\\af_unix.c",
          "line": 1555,
          "match": "double_unlock",
          "context": [
            "\t\t\tWRITE_ONCE(sk->sk_state, TCP_CLOSE);",
            "\t\tunix_dgram_peer_wake_disconnect_wakeup(sk, old_peer);",
            "",
            "\t\tunix_state_double_unlock(sk, other);",
            "",
            "\t\tif (other != old_peer) {",
            "\t\t\tunix_dgram_disconnected(sk, old_peer);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\unix\\af_unix.c"
          ]
        },
        {
          "file": "linux\\net\\unix\\af_unix.c",
          "line": 1569,
          "match": "double_unlock",
          "context": [
            "\t\tsock_put(old_peer);",
            "\t} else {",
            "\t\tunix_peer(sk) = other;",
            "\t\tunix_state_double_unlock(sk, other);",
            "\t}",
            "",
            "\treturn 0;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\unix\\af_unix.c"
          ]
        },
        {
          "file": "linux\\net\\unix\\af_unix.c",
          "line": 1575,
          "match": "double_unlock",
          "context": [
            "\treturn 0;",
            "",
            "out_unlock:",
            "\tunix_state_double_unlock(sk, other);",
            "\tsock_put(other);",
            "out:",
            "\treturn err;"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\unix\\af_unix.c"
          ]
        },
        {
          "file": "linux\\net\\unix\\af_unix.c",
          "line": 2210,
          "match": "double_lock",
          "context": [
            "",
            "\t\tif (!sk_locked) {",
            "\t\t\tunix_state_unlock(other);",
            "\t\t\tunix_state_double_lock(sk, other);",
            "\t\t}",
            "",
            "\t\tif (unix_peer(sk) != other ||"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\net\\unix\\af_unix.c"
          ]
        },
        {
          "file": "linux\\tools\\testing\\selftests\\net\\bind_bhash.c",
          "line": 131,
          "match": "double)(end - begin) / CLOCK",
          "context": [
            "",
            "\tend = clock();",
            "",
            "\tprintf(\"time spent = %f\\n\", (double)(end - begin) / CLOCKS_PER_SEC);",
            "",
            "\t/* clean up */",
            "\tclose(sock_fd);"
          ],
          "pattern": "double.*lock",
          "description": "Double locking or reentrant lock issues",
          "code_snippet": [
            "File not found: linux\\linux\\tools\\testing\\selftests\\net\\bind_bhash.c"
          ]
        }
      ]
    },
    "missing_lock": {
      "count": 101,
      "description": "Missing locks for shared resource protection",
      "issues": [
        {
          "file": "linux\\arch\\arm\\kernel\\topology.c",
          "line": 124,
          "match": "missing clock",
          "context": [
            "",
            "\t\trate = of_get_property(cn, \"clock-frequency\", &len);",
            "\t\tif (!rate || len != 4) {",
            "\t\t\tpr_err(\"%pOF missing clock-frequency property\\n\", cn);",
            "\t\t\tcontinue;",
            "\t\t}",
            ""
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\arch\\arm\\kernel\\topology.c"
          ]
        },
        {
          "file": "linux\\arch\\openrisc\\kernel\\setup.c",
          "line": 153,
          "match": "missing CPU 'clock",
          "context": [
            "\tif (of_property_read_u32(cpu, \"clock-frequency\",",
            "\t\t\t\t &cpuinfo->clock_frequency)) {",
            "\t\tprintk(KERN_WARNING",
            "\t\t       \"Device tree missing CPU 'clock-frequency' parameter.\"",
            "\t\t       \"Assuming frequency 25MHZ\"",
            "\t\t       \"This is probably not what you want.\");",
            "\t}"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\arch\\openrisc\\kernel\\setup.c"
          ]
        },
        {
          "file": "linux\\drivers\\clk\\clk-cdce925.c",
          "line": 656,
          "match": "missing parent clock",
          "context": [
            "",
            "\tparent_name = of_clk_get_parent_name(node, 0);",
            "\tif (!parent_name) {",
            "\t\tdev_err(&client->dev, \"missing parent clock\\n\");",
            "\t\treturn -ENODEV;",
            "\t}",
            "\tdev_dbg(&client->dev, \"parent is: %s\\n\", parent_name);"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\clk\\clk-cdce925.c"
          ]
        },
        {
          "file": "linux\\drivers\\clk\\clk-nomadik.c",
          "line": 561,
          "match": "missing clock",
          "context": [
            "\t\tnomadik_src_init();",
            "",
            "\tif (of_property_read_u32(np, \"clock-id\", &clk_id)) {",
            "\t\tpr_err(\"%s: SRC clock \\\"%s\\\" missing clock-id property\\n\",",
            "\t\t\t__func__, clk_name);",
            "\t\treturn;",
            "\t}"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\clk\\clk-nomadik.c"
          ]
        },
        {
          "file": "linux\\drivers\\clk\\clk-si5351.c",
          "line": 1475,
          "match": "missing parent clock",
          "context": [
            "\t */",
            "\tif (IS_ERR(drvdata->pxtal) &&",
            "\t    (drvdata->variant != SI5351_VARIANT_C || IS_ERR(drvdata->pclkin))) {",
            "\t\tdev_err(&client->dev, \"missing parent clock\\n\");",
            "\t\treturn -EINVAL;",
            "\t}",
            ""
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\clk\\clk-si5351.c"
          ]
        },
        {
          "file": "linux\\drivers\\clk\\clk_test.c",
          "line": 3322,
          "match": "missing assigned-clock",
          "context": [
            "\t\t * Test that an assigned-clock-rates property without an assigned-clocks",
            "\t\t * property fails when the property is in the provider.",
            "\t\t */",
            "\t\t.desc = \"provider missing assigned-clocks\",",
            "\t\tTEST_PARAM_OVERLAY(kunit_clk_assigned_rates_without),",
            "\t\t.rate0 = 3000,",
            "\t},"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\clk\\clk_test.c"
          ]
        },
        {
          "file": "linux\\drivers\\clk\\clk_test.c",
          "line": 3331,
          "match": "missing assigned-clock",
          "context": [
            "\t\t * Test that an assigned-clock-rates property without an assigned-clocks",
            "\t\t * property fails when the property is in the consumer.",
            "\t\t */",
            "\t\t.desc = \"consumer missing assigned-clocks\",",
            "\t\tTEST_PARAM_OVERLAY(kunit_clk_assigned_rates_without_consumer),",
            "\t\t.rate0 = 3000,",
            "\t\t.consumer_test = true,"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\clk\\clk_test.c"
          ]
        },
        {
          "file": "linux\\drivers\\dma\\fsl-edma-main.c",
          "line": 746,
          "match": "Missing DMA block clock",
          "context": [
            "\tif (drvdata->flags & FSL_EDMA_DRV_HAS_DMACLK) {",
            "\t\tfsl_edma->dmaclk = devm_clk_get_enabled(&pdev->dev, \"dma\");",
            "\t\tif (IS_ERR(fsl_edma->dmaclk)) {",
            "\t\t\tdev_err(&pdev->dev, \"Missing DMA block clock.\\n\");",
            "\t\t\treturn PTR_ERR(fsl_edma->dmaclk);",
            "\t\t}",
            "\t}"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\dma\\fsl-edma-main.c"
          ]
        },
        {
          "file": "linux\\drivers\\dma\\fsl-edma-main.c",
          "line": 773,
          "match": "Missing DMAMUX block clock",
          "context": [
            "\t\tsprintf(clkname, \"dmamux%d\", i);",
            "\t\tfsl_edma->muxclk[i] = devm_clk_get_enabled(&pdev->dev, clkname);",
            "\t\tif (IS_ERR(fsl_edma->muxclk[i])) {",
            "\t\t\tdev_err(&pdev->dev, \"Missing DMAMUX block clock.\\n\");",
            "\t\t\t/* on error: disable all previously enabled clks */",
            "\t\t\treturn PTR_ERR(fsl_edma->muxclk[i]);",
            "\t\t}"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\dma\\fsl-edma-main.c"
          ]
        },
        {
          "file": "linux\\drivers\\dma\\tegra20-apb-dma.c",
          "line": 1458,
          "match": "Missing controller clock",
          "context": [
            "",
            "\ttdma->dma_clk = devm_clk_get(&pdev->dev, NULL);",
            "\tif (IS_ERR(tdma->dma_clk)) {",
            "\t\tdev_err(&pdev->dev, \"Error: Missing controller clock\\n\");",
            "\t\treturn PTR_ERR(tdma->dma_clk);",
            "\t}",
            ""
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\dma\\tegra20-apb-dma.c"
          ]
        },
        {
          "file": "linux\\drivers\\dma\\tegra210-adma.c",
          "line": 1083,
          "match": "Missing ahub controller clock",
          "context": [
            "",
            "\ttdma->ahub_clk = devm_clk_get(&pdev->dev, \"d_audio\");",
            "\tif (IS_ERR(tdma->ahub_clk)) {",
            "\t\tdev_err(&pdev->dev, \"Error: Missing ahub controller clock\\n\");",
            "\t\treturn PTR_ERR(tdma->ahub_clk);",
            "\t}",
            ""
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\dma\\tegra210-adma.c"
          ]
        },
        {
          "file": "linux\\drivers\\hid\\hid-picolcd_debugfs.c",
          "line": 363,
          "match": "missing\", \"data_missing\", \"block",
          "context": [
            " * Helper code for HID report level dumping/debugging",
            " */",
            "static const char * const error_codes[] = {",
            "\t\"success\", \"parameter missing\", \"data_missing\", \"block readonly\",",
            "\t\"block not erasable\", \"block too big\", \"section overflow\",",
            "\t\"invalid command length\", \"invalid data length\",",
            "};"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hid\\hid-picolcd_debugfs.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\dm-verity-fec.c",
          "line": 707,
          "match": "Missing \" DM_VERITY_OPT_FEC_BLOCK",
          "context": [
            "\tf->rsn = DM_VERITY_FEC_RSM - f->roots;",
            "",
            "\tif (!f->blocks) {",
            "\t\tti->error = \"Missing \" DM_VERITY_OPT_FEC_BLOCKS;",
            "\t\treturn -EINVAL;",
            "\t}",
            ""
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\dm-verity-fec.c"
          ]
        },
        {
          "file": "linux\\drivers\\mfd\\madera-core.c",
          "line": 491,
          "match": "Missing MCLK2, requires 32kHz clock",
          "context": [
            "",
            "\t/* Not using devm_clk_get to prevent breakage of existing DTs */",
            "\tif (!madera->mclk[MADERA_MCLK2].clk)",
            "\t\tdev_warn(madera->dev, \"Missing MCLK2, requires 32kHz clock\\n\");",
            "",
            "\tret = madera_get_reset_gpio(madera);",
            "\tif (ret)"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\mfd\\madera-core.c"
          ]
        },
        {
          "file": "linux\\drivers\\mfd\\syscon.c",
          "line": 90,
          "match": "missing hwlock",
          "context": [
            "\t} else if (ret < 0) {",
            "\t\tswitch (ret) {",
            "\t\tcase -ENOENT:",
            "\t\t\t/* Ignore missing hwlock, it's optional. */",
            "\t\t\tbreak;",
            "\t\tdefault:",
            "\t\t\tpr_err(\"Failed to retrieve valid hwlock: %d\\n\", ret);"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\mfd\\syscon.c"
          ]
        },
        {
          "file": "linux\\drivers\\rtc\\rtc-ac100.c",
          "line": 187,
          "match": "missing clock",
          "context": [
            "\t\t * properly declare and reference in the devicetree and is",
            "\t\t * not implemented in any driver right now.",
            "\t\t * If the clock core looks for the parent of that second",
            "\t\t * missing clock, it can't find one that is registered and",
            "\t\t * returns NULL.",
            "\t\t * So we end up in a situation where clk_hw_get_num_parents",
            "\t\t * returns the amount of clocks we can be parented to, but"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\rtc\\rtc-ac100.c"
          ]
        },
        {
          "file": "linux\\drivers\\spi\\atmel-quadspi.c",
          "line": 1400,
          "match": "missing peripheral clock",
          "context": [
            "",
            "\tif (IS_ERR(aq->pclk))",
            "\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(aq->pclk),",
            "\t\t\t\t     \"missing peripheral clock\\n\");",
            "",
            "\tif (aq->caps->has_qspick) {",
            "\t\t/* Get the QSPI system clock */"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\spi\\atmel-quadspi.c"
          ]
        },
        {
          "file": "linux\\drivers\\spi\\atmel-quadspi.c",
          "line": 1406,
          "match": "missing system clock",
          "context": [
            "\t\t/* Get the QSPI system clock */",
            "\t\taq->qspick = devm_clk_get_enabled(&pdev->dev, \"qspick\");",
            "\t\tif (IS_ERR(aq->qspick)) {",
            "\t\t\tdev_err(&pdev->dev, \"missing system clock\\n\");",
            "\t\t\terr = PTR_ERR(aq->qspick);",
            "\t\t\treturn err;",
            "\t\t}"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\spi\\atmel-quadspi.c"
          ]
        },
        {
          "file": "linux\\drivers\\spi\\atmel-quadspi.c",
          "line": 1415,
          "match": "missing Generic clock",
          "context": [
            "\t\t/* Get the QSPI generic clock */",
            "\t\taq->gclk = devm_clk_get(&pdev->dev, \"gclk\");",
            "\t\tif (IS_ERR(aq->gclk)) {",
            "\t\t\tdev_err(&pdev->dev, \"missing Generic clock\\n\");",
            "\t\t\terr = PTR_ERR(aq->gclk);",
            "\t\t\treturn err;",
            "\t\t}"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\spi\\atmel-quadspi.c"
          ]
        },
        {
          "file": "linux\\drivers\\spi\\spi-aspeed-smc.c",
          "line": 748,
          "match": "missing clock",
          "context": [
            "",
            "\taspi->clk = devm_clk_get_enabled(&pdev->dev, NULL);",
            "\tif (IS_ERR(aspi->clk)) {",
            "\t\tdev_err(dev, \"missing clock\\n\");",
            "\t\treturn PTR_ERR(aspi->clk);",
            "\t}",
            ""
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\spi\\spi-aspeed-smc.c"
          ]
        },
        {
          "file": "linux\\drivers\\spi\\spi-meson-spifc.c",
          "line": 317,
          "match": "missing clock",
          "context": [
            "",
            "\tspifc->clk = devm_clk_get_enabled(spifc->dev, NULL);",
            "\tif (IS_ERR(spifc->clk)) {",
            "\t\tdev_err(spifc->dev, \"missing clock\\n\");",
            "\t\tret = PTR_ERR(spifc->clk);",
            "\t\tgoto out_err;",
            "\t}"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\spi\\spi-meson-spifc.c"
          ]
        },
        {
          "file": "linux\\drivers\\spi\\spi-synquacer.c",
          "line": 662,
          "match": "missing clock",
          "context": [
            "\t}",
            "",
            "\tif (!host->max_speed_hz) {",
            "\t\tdev_err(&pdev->dev, \"missing clock source\\n\");",
            "\t\tret = -EINVAL;",
            "\t\tgoto disable_clk;",
            "\t}"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\spi\\spi-synquacer.c"
          ]
        },
        {
          "file": "linux\\drivers\\target\\target_core_iblock.c",
          "line": 102,
          "match": "Missing udev_path= parameters for IBLOCK",
          "context": [
            "\tint ret;",
            "",
            "\tif (!(ib_dev->ibd_flags & IBDF_HAS_UDEV_PATH)) {",
            "\t\tpr_err(\"Missing udev_path= parameters for IBLOCK\\n\");",
            "\t\treturn -EINVAL;",
            "\t}",
            ""
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\target\\target_core_iblock.c"
          ]
        },
        {
          "file": "linux\\drivers\\char\\hw_random\\stm32-rng.c",
          "line": 582,
          "match": "Missing clock",
          "context": [
            "\t\tstruct clk *clk = priv->clk_bulk[1].clk;",
            "",
            "\t\tif (!priv->clk_bulk[0].id || !priv->clk_bulk[1].id)",
            "\t\t\treturn dev_err_probe(dev, -EINVAL, \"Missing clock name\\n\");",
            "",
            "\t\tif (strcmp(priv->clk_bulk[0].id, \"core\")) {",
            "\t\t\tpriv->clk_bulk[1].id = priv->clk_bulk[0].id;"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\char\\hw_random\\stm32-rng.c"
          ]
        },
        {
          "file": "linux\\drivers\\clk\\davinci\\da8xx-cfgchip.c",
          "line": 516,
          "match": "Missing fck clock",
          "context": [
            "",
            "\tfck_clk = devm_clk_get(dev, \"fck\");",
            "\tif (IS_ERR(fck_clk)) {",
            "\t\treturn dev_err_cast_probe(dev, fck_clk, \"Missing fck clock\\n\");",
            "\t}",
            "",
            "\tusb0 = devm_kzalloc(dev, sizeof(*usb0), GFP_KERNEL);"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\clk\\davinci\\da8xx-cfgchip.c"
          ]
        },
        {
          "file": "linux\\drivers\\clk\\keystone\\pll.c",
          "line": 265,
          "match": "missing parent clock",
          "context": [
            "",
            "\tparent_name = of_clk_get_parent_name(node, 0);",
            "\tif (!parent_name) {",
            "\t\tpr_err(\"%s: missing parent clock\\n\", __func__);",
            "\t\tiounmap(reg);",
            "\t\treturn;",
            "\t}"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\clk\\keystone\\pll.c"
          ]
        },
        {
          "file": "linux\\drivers\\clk\\keystone\\pll.c",
          "line": 315,
          "match": "missing parent clock",
          "context": [
            "",
            "\tof_clk_parent_fill(node, parents, 2);",
            "\tif (!parents[0] || !parents[1]) {",
            "\t\tpr_err(\"%s: missing parent clocks\\n\", __func__);",
            "\t\treturn;",
            "\t}",
            ""
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\clk\\keystone\\pll.c"
          ]
        },
        {
          "file": "linux\\drivers\\clk\\rockchip\\clk-rk3188.c",
          "line": 856,
          "match": "missing clock",
          "context": [
            "",
            "\t\tclk_set_rate(clk1, rate);",
            "\t} else {",
            "\t\tpr_warn(\"%s: missing clocks to reparent aclk_cpu_pre to gpll\\n\",",
            "\t\t\t__func__);",
            "\t}",
            ""
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\clk\\rockchip\\clk-rk3188.c"
          ]
        },
        {
          "file": "linux\\drivers\\clk\\tegra\\clk-dfll.c",
          "line": 1428,
          "match": "missing ref clock",
          "context": [
            "{",
            "\ttd->ref_clk = devm_clk_get(td->dev, \"ref\");",
            "\tif (IS_ERR(td->ref_clk)) {",
            "\t\tdev_err(td->dev, \"missing ref clock\\n\");",
            "\t\treturn PTR_ERR(td->ref_clk);",
            "\t}",
            ""
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\clk\\tegra\\clk-dfll.c"
          ]
        },
        {
          "file": "linux\\drivers\\clk\\tegra\\clk-dfll.c",
          "line": 1434,
          "match": "missing soc clock",
          "context": [
            "",
            "\ttd->soc_clk = devm_clk_get(td->dev, \"soc\");",
            "\tif (IS_ERR(td->soc_clk)) {",
            "\t\tdev_err(td->dev, \"missing soc clock\\n\");",
            "\t\treturn PTR_ERR(td->soc_clk);",
            "\t}",
            ""
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\clk\\tegra\\clk-dfll.c"
          ]
        },
        {
          "file": "linux\\drivers\\clk\\tegra\\clk-dfll.c",
          "line": 1440,
          "match": "missing i2c clock",
          "context": [
            "",
            "\ttd->i2c_clk = devm_clk_get(td->dev, \"i2c\");",
            "\tif (IS_ERR(td->i2c_clk)) {",
            "\t\tdev_err(td->dev, \"missing i2c clock\\n\");",
            "\t\treturn PTR_ERR(td->i2c_clk);",
            "\t}",
            "\ttd->i2c_clk_rate = clk_get_rate(td->i2c_clk);"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\clk\\tegra\\clk-dfll.c"
          ]
        },
        {
          "file": "linux\\drivers\\clk\\tegra\\clk-dfll.c",
          "line": 1919,
          "match": "missing clock",
          "context": [
            "",
            "\tif (of_property_read_string(td->dev->of_node, \"clock-output-names\",",
            "\t\t\t\t    &td->output_clock_name)) {",
            "\t\tdev_err(td->dev, \"missing clock-output-names property\\n\");",
            "\t\tok = false;",
            "\t}",
            ""
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\clk\\tegra\\clk-dfll.c"
          ]
        },
        {
          "file": "linux\\drivers\\clk\\ti\\apll.c",
          "line": 374,
          "match": "missing clock",
          "context": [
            "\tinit->parent_names = &parent_name;",
            "",
            "\tif (of_property_read_u32(node, \"ti,clock-frequency\", &val)) {",
            "\t\tpr_err(\"%pOFn missing clock-frequency\\n\", node);",
            "\t\tgoto cleanup;",
            "\t}",
            "\tclk_hw->fixed_rate = val;"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\clk\\ti\\apll.c"
          ]
        },
        {
          "file": "linux\\drivers\\clk\\ti\\clk.c",
          "line": 422,
          "match": "missing 'clock",
          "context": [
            "\t/* get clocks for this parent */",
            "\tclocks = of_get_child_by_name(parent, \"clocks\");",
            "\tif (!clocks) {",
            "\t\tpr_err(\"%pOFn missing 'clocks' child node.\\n\", parent);",
            "\t\treturn -EINVAL;",
            "\t}",
            ""
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\clk\\ti\\clk.c"
          ]
        },
        {
          "file": "linux\\drivers\\clk\\ti\\clk.c",
          "line": 511,
          "match": "missing clock",
          "context": [
            "/**",
            " * ti_clk_add_aliases - setup clock aliases",
            " *",
            " * Sets up any missing clock aliases. No return value.",
            " */",
            "void __init ti_clk_add_aliases(void)",
            "{"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\clk\\ti\\clk.c"
          ]
        },
        {
          "file": "linux\\drivers\\clk\\ti\\dpll.c",
          "line": 148,
          "match": "missing), the clock",
          "context": [
            " * @node: device node for the clock",
            " *",
            " * Finalizes DPLL registration process. In case a failure (clk-ref or",
            " * clk-bypass is missing), the clock is added to retry list and",
            " * the initialization is retried on later stage.",
            " */",
            "static void __init _register_dpll(void *user,"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\clk\\ti\\dpll.c"
          ]
        },
        {
          "file": "linux\\drivers\\crypto\\rockchip\\rk3288_crypto.c",
          "line": 68,
          "match": "Missing clock",
          "context": [
            "",
            "\tdev->num_clks = devm_clk_bulk_get_all(dev->dev, &dev->clks);",
            "\tif (dev->num_clks < dev->variant->num_clks) {",
            "\t\tdev_err(dev->dev, \"Missing clocks, got %d instead of %d\\n\",",
            "\t\t\tdev->num_clks, dev->variant->num_clks);",
            "\t\treturn -EINVAL;",
            "\t}"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\crypto\\rockchip\\rk3288_crypto.c"
          ]
        },
        {
          "file": "linux\\drivers\\dma\\stm32\\stm32-dmamux.c",
          "line": 251,
          "match": "Missing clock",
          "context": [
            "\tstm32_dmamux->clk = devm_clk_get(&pdev->dev, NULL);",
            "\tif (IS_ERR(stm32_dmamux->clk))",
            "\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(stm32_dmamux->clk),",
            "\t\t\t\t     \"Missing clock controller\\n\");",
            "",
            "\tret = clk_prepare_enable(stm32_dmamux->clk);",
            "\tif (ret < 0) {"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\dma\\stm32\\stm32-dmamux.c"
          ]
        },
        {
          "file": "linux\\drivers\\dma\\stm32\\stm32-mdma.c",
          "line": 1644,
          "match": "Missing clock",
          "context": [
            "\tdmadev->clk = devm_clk_get(&pdev->dev, NULL);",
            "\tif (IS_ERR(dmadev->clk))",
            "\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(dmadev->clk),",
            "\t\t\t\t     \"Missing clock controller\\n\");",
            "",
            "\tret = clk_prepare_enable(dmadev->clk);",
            "\tif (ret < 0) {"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\dma\\stm32\\stm32-mdma.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\logicvc\\logicvc_drm.c",
          "line": 189,
          "match": "Missing non-optional clock",
          "context": [
            "\t\t\tif (PTR_ERR(clk) == -ENOENT && clocks_map[i].optional)",
            "\t\t\t\tcontinue;",
            "",
            "\t\t\tdrm_err(drm_dev, \"Missing non-optional clock %s\\n\",",
            "\t\t\t\tclocks_map[i].name);",
            "",
            "\t\t\tret = PTR_ERR(clk);"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\logicvc\\logicvc_drm.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\xlnx\\zynqmp_dpsub.c",
          "line": 98,
          "match": "Missing audio clock",
          "context": [
            "",
            "\t/*",
            "\t * Try the live PL audio clock, and fall back to the PS clock if the",
            "\t * live PL audio clock isn't valid. Missing audio clock disables audio",
            "\t * but isn't an error.",
            "\t */",
            "\tdpsub->aud_clk = devm_clk_get(dpsub->dev, \"dp_live_audio_aclk\");"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\xlnx\\zynqmp_dpsub.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\xlnx\\zynqmp_dpsub.c",
          "line": 113,
          "match": "missing clock",
          "context": [
            "\t\treturn 0;",
            "\t}",
            "",
            "\tdev_info(dpsub->dev, \"audio disabled due to missing clock\\n\");",
            "\treturn 0;",
            "}",
            ""
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\xlnx\\zynqmp_dpsub.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_cx0_phy.c",
          "line": 2550,
          "match": "MISSING_CASE(clock",
          "context": [
            "\tcase 675000: /* 6.75 Gbps eDP*/",
            "\t\treturn 12;",
            "\tdefault:",
            "\t\tMISSING_CASE(clock);",
            "\t\treturn 0;",
            "\t}",
            "}"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\display\\intel_cx0_phy.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_cx0_phy.c",
          "line": 2570,
          "match": "MISSING_CASE(clock",
          "context": [
            "\tcase 1000000: /* 10 Gbps */",
            "\t\treturn 3;",
            "\tdefault:",
            "\t\tMISSING_CASE(clock);",
            "\t\treturn 0;",
            "\t}",
            "}"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\display\\intel_cx0_phy.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_cx0_phy.c",
          "line": 3122,
          "match": "MISSING_CASE(clock",
          "context": [
            "\tcase XELPDP_DDI_CLOCK_SELECT_TBT_625:",
            "\t\treturn 2000000;",
            "\tdefault:",
            "\t\tMISSING_CASE(clock);",
            "\t\treturn 162000;",
            "\t}",
            "}"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\display\\intel_cx0_phy.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_cx0_phy.c",
          "line": 3152,
          "match": "MISSING_CASE(clock",
          "context": [
            "\t\t}",
            "\t\treturn XELPDP_DDI_CLOCK_SELECT_TBT_625;",
            "\tdefault:",
            "\t\tMISSING_CASE(clock);",
            "\t\treturn XELPDP_DDI_CLOCK_SELECT_TBT_162;",
            "\t}",
            "}"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\display\\intel_cx0_phy.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_ddi.c",
          "line": 286,
          "match": "MISSING_CASE(clock",
          "context": [
            "\t\tcase 810000:",
            "\t\t\treturn DDI_CLK_SEL_TBT_810;",
            "\t\tdefault:",
            "\t\t\tMISSING_CASE(clock);",
            "\t\t\treturn DDI_CLK_SEL_NONE;",
            "\t\t}",
            "\tcase DPLL_ID_ICL_MGPLL1:"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\display\\intel_ddi.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_ddi.c",
          "line": 319,
          "match": "MISSING_CASE(port_clock",
          "context": [
            "\tcase 810000:",
            "\t\treturn DDI_BUF_PHY_LINK_RATE(3);",
            "\tdefault:",
            "\t\tMISSING_CASE(port_clock);",
            "\t\treturn DDI_BUF_PHY_LINK_RATE(0);",
            "\t}",
            "}"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\display\\intel_ddi.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_dpll_mgr.c",
          "line": 1112,
          "match": "MISSING_CASE(clock",
          "context": [
            "\t\tpll_id = DPLL_ID_LCPLL_2700;",
            "\t\tbreak;",
            "\tdefault:",
            "\t\tMISSING_CASE(clock / 2);",
            "\t\treturn NULL;",
            "\t}",
            ""
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\display\\intel_dpll_mgr.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_dpll_mgr.c",
          "line": 2717,
          "match": "MISSING_CASE(clock",
          "context": [
            "\t\t}",
            "\t}",
            "",
            "\tMISSING_CASE(clock);",
            "\treturn -EINVAL;",
            "}",
            ""
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\display\\intel_dpll_mgr.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\display\\intel_pmdemand.c",
          "line": 396,
          "match": "Missing to account genlock",
          "context": [
            "",
            "\t/*",
            "\t * Active_PLLs starts with 1 because of CDCLK PLL.",
            "\t * TODO: Missing to account genlock filter when it gets used.",
            "\t */",
            "\tnew_pmdemand_state->params.plls =",
            "\t\tmin_t(u16, new_pmdemand_state->params.active_phys + 1, 7);"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\display\\intel_pmdemand.c"
          ]
        },
        {
          "file": "linux\\drivers\\gpu\\drm\\i915\\gt\\intel_gt_clock_utils.c",
          "line": 50,
          "match": "MISSING_CASE(crystal_clock",
          "context": [
            "\tcase GEN11_RPM_CONFIG0_CRYSTAL_CLOCK_FREQ_25_MHZ:",
            "\t\treturn f25_mhz;",
            "\tdefault:",
            "\t\tMISSING_CASE(crystal_clock);",
            "\t\treturn 0;",
            "\t}",
            "}"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\gpu\\drm\\i915\\gt\\intel_gt_clock_utils.c"
          ]
        },
        {
          "file": "linux\\drivers\\hid\\usbhid\\hid-pidff.c",
          "line": 465,
          "match": "missing Parameter Block",
          "context": [
            "{",
            "\tint i, max_axis;",
            "",
            "\t/* Devices missing Parameter Block Offset can only have one axis */",
            "\tmax_axis = pidff->quirks & HID_PIDFF_QUIRK_MISSING_PBO ? 1 : 2;",
            "",
            "\tpidff->set_condition[PID_EFFECT_BLOCK_INDEX].value[0] ="
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\hid\\usbhid\\hid-pidff.c"
          ]
        },
        {
          "file": "linux\\drivers\\i2c\\busses\\i2c-altera.c",
          "line": 402,
          "match": "missing clock",
          "context": [
            "",
            "\tidev->i2c_clk = devm_clk_get(&pdev->dev, NULL);",
            "\tif (IS_ERR(idev->i2c_clk)) {",
            "\t\tdev_err(&pdev->dev, \"missing clock\\n\");",
            "\t\treturn PTR_ERR(idev->i2c_clk);",
            "\t}",
            ""
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\i2c\\busses\\i2c-altera.c"
          ]
        },
        {
          "file": "linux\\drivers\\i2c\\busses\\i2c-axxia.c",
          "line": 741,
          "match": "missing clock",
          "context": [
            "",
            "\tidev->i2c_clk = devm_clk_get(&pdev->dev, \"i2c\");",
            "\tif (IS_ERR(idev->i2c_clk)) {",
            "\t\tdev_err(&pdev->dev, \"missing clock\\n\");",
            "\t\treturn PTR_ERR(idev->i2c_clk);",
            "\t}",
            ""
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\i2c\\busses\\i2c-axxia.c"
          ]
        },
        {
          "file": "linux\\drivers\\i2c\\busses\\i2c-bcm-kona.c",
          "line": 709,
          "match": "missing clock",
          "context": [
            "\tint ret = of_property_read_u32(dev->device->of_node, \"clock-frequency\",",
            "\t\t\t\t       &bus_speed);",
            "\tif (ret < 0) {",
            "\t\tdev_err(dev->device, \"missing clock-frequency property\\n\");",
            "\t\treturn -ENODEV;",
            "\t}",
            ""
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\i2c\\busses\\i2c-bcm-kona.c"
          ]
        },
        {
          "file": "linux\\drivers\\i2c\\busses\\i2c-microchip-corei2c.c",
          "line": 555,
          "match": "missing clock",
          "context": [
            "\tidev->i2c_clk = devm_clk_get(&pdev->dev, NULL);",
            "\tif (IS_ERR(idev->i2c_clk))",
            "\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(idev->i2c_clk),",
            "\t\t\t\t     \"missing clock\\n\");",
            "",
            "\tidev->dev = &pdev->dev;",
            "\tinit_completion(&idev->msg_complete);"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\i2c\\busses\\i2c-microchip-corei2c.c"
          ]
        },
        {
          "file": "linux\\drivers\\i2c\\busses\\i2c-ocores.c",
          "line": 557,
          "match": "Missing required parameter 'opencores,ip-clock",
          "context": [
            "\t\t\t\t\t\t&val)) {",
            "\t\t\tif (!clock_frequency_present) {",
            "\t\t\t\tdev_err(&pdev->dev,",
            "\t\t\t\t\t\"Missing required parameter 'opencores,ip-clock-frequency'\\n\");",
            "\t\t\t\treturn -ENODEV;",
            "\t\t\t}",
            "\t\t\ti2c->ip_clock_khz = clock_frequency / 1000;"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\i2c\\busses\\i2c-ocores.c"
          ]
        },
        {
          "file": "linux\\drivers\\i2c\\busses\\i2c-riic.c",
          "line": 516,
          "match": "missing controller clock",
          "context": [
            "\triic->clk = devm_clk_get(dev, NULL);",
            "\tif (IS_ERR(riic->clk))",
            "\t\treturn dev_err_probe(dev, PTR_ERR(riic->clk),",
            "\t\t\t\t     \"missing controller clock\");",
            "",
            "\triic->rstc = devm_reset_control_get_optional_exclusive_deasserted(dev, NULL);",
            "\tif (IS_ERR(riic->rstc))"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\i2c\\busses\\i2c-riic.c"
          ]
        },
        {
          "file": "linux\\drivers\\isdn\\hardware\\mISDN\\hfcmulti.c",
          "line": 1368,
          "match": "missing PCM clock",
          "context": [
            "\t\t}",
            "\t\tif (test_bit(HFC_CHIP_PCM_SLAVE, &hc->chip)) {",
            "\t\t\tprintk(KERN_INFO \"controller is PCM bus SLAVE \"",
            "\t\t\t       \"(ignoring missing PCM clock)\\n\");",
            "\t\t} else {",
            "\t\t\t/* only one pcm master */",
            "\t\t\tif (test_bit(HFC_CHIP_PLXSD, &hc->chip)"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\isdn\\hardware\\mISDN\\hfcmulti.c"
          ]
        },
        {
          "file": "linux\\drivers\\md\\dm-vdo\\indexer\\index-session.c",
          "line": 335,
          "match": "missing required block",
          "context": [
            "\t\treturn -EINVAL;",
            "\t}",
            "\tif (parameters->bdev == NULL) {",
            "\t\tvdo_log_error(\"missing required block device\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "\tif (session == NULL) {"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\md\\dm-vdo\\indexer\\index-session.c"
          ]
        },
        {
          "file": "linux\\drivers\\media\\pci\\cobalt\\cobalt-v4l2.c",
          "line": 561,
          "match": "missing \" : \"found-clock",
          "context": [
            "\t\t(ioread32(&clkloss->ctrl) & M00479_CTRL_BITMAP_ENABLE_MSK) ?",
            "\t\t\t\"enabled \" : \"disabled \",",
            "\t\t(ioread32(&clkloss->status) & M00479_STATUS_BITMAP_CLOCK_MISSING_MSK) ?",
            "\t\t\t\"clock-missing \" : \"found-clock \");",
            "\tcobalt_info(\"rx%d: Packer: %x\\n\", rx, ioread32(&packer->control));",
            "}",
            ""
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\media\\pci\\cobalt\\cobalt-v4l2.c"
          ]
        },
        {
          "file": "linux\\drivers\\mmc\\core\\sdio_uart.c",
          "line": 530,
          "match": "Missing hardware shouldn't block",
          "context": [
            "\tstruct sdio_uart_port *port =",
            "\t\t\tcontainer_of(tport, struct sdio_uart_port, port);",
            "\tunsigned int ret = sdio_uart_claim_func(port);",
            "\tif (ret)\t/* Missing hardware shouldn't block for carrier */",
            "\t\treturn 1;",
            "\tret = sdio_uart_get_mctrl(port);",
            "\tsdio_uart_release_func(port);"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\mmc\\core\\sdio_uart.c"
          ]
        },
        {
          "file": "linux\\drivers\\mmc\\host\\meson-gx-mmc.c",
          "line": 449,
          "match": "Missing clock",
          "context": [
            "\t\tclk = devm_clk_get(host->dev, name);",
            "\t\tif (IS_ERR(clk))",
            "\t\t\treturn dev_err_probe(host->dev, PTR_ERR(clk),",
            "\t\t\t\t\t     \"Missing clock %s\\n\", name);",
            "",
            "\t\tmux_parent_names[i] = __clk_get_name(clk);",
            "\t}"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\mmc\\host\\meson-gx-mmc.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\mdio\\mdio-mux-meson-g12a.c",
          "line": 241,
          "match": "Missing clock",
          "context": [
            "\t\tclk = devm_clk_get(dev, in_name);",
            "\t\tif (IS_ERR(clk))",
            "\t\t\treturn dev_err_probe(dev, PTR_ERR(clk),",
            "\t\t\t\t\t     \"Missing clock %s\\n\", in_name);",
            "",
            "\t\tparent_names[i] = __clk_get_name(clk);",
            "\t}"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\mdio\\mdio-mux-meson-g12a.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\freescale\\ucc_geth.c",
          "line": 3399,
          "match": "missing %s-clock",
          "context": [
            "\t\t\t/* If both *-clock-name and *-clock are missing,",
            "\t\t\t * we want to tell people to use *-clock-name.",
            "\t\t\t */",
            "\t\t\tpr_err(\"missing %s-clock-name property\\n\", buf);",
            "\t\t\treturn -EINVAL;",
            "\t\t}",
            "\t\t*out = val;"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\freescale\\ucc_geth.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\socionext\\netsec.c",
          "line": 1913,
          "match": "missing required property 'socionext,phy-clock",
          "context": [
            "\t\t\t\t       &priv->freq);",
            "\tif (ret)",
            "\t\treturn dev_err_probe(&pdev->dev, ret,",
            "\t\t\t\t     \"missing required property 'socionext,phy-clock-frequency'\\n\");",
            "\treturn 0;",
            "}",
            ""
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\socionext\\netsec.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\socionext\\netsec.c",
          "line": 2083,
          "match": "missing PHY reference clock",
          "context": [
            "\tpriv->phy_addr = phy_addr;",
            "",
            "\tif (!priv->freq) {",
            "\t\tdev_err(&pdev->dev, \"missing PHY reference clock frequency\\n\");",
            "\t\tret = -ENODEV;",
            "\t\tgoto free_ndev;",
            "\t}"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\socionext\\netsec.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\marvell\\mvpp2\\mvpp2_main.c",
          "line": 7686,
          "match": "missing clock",
          "context": [
            "\t} else {",
            "\t\terr = device_property_read_u32(&pdev->dev, \"clock-frequency\", &priv->tclk);",
            "\t\tif (err) {",
            "\t\t\tdev_err(&pdev->dev, \"missing clock-frequency value\\n\");",
            "\t\t\treturn err;",
            "\t\t}",
            "\t}"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\marvell\\mvpp2\\mvpp2_main.c"
          ]
        },
        {
          "file": "linux\\drivers\\net\\ethernet\\stmicro\\stmmac\\dwmac-rk.c",
          "line": 187,
          "match": "Missing clk_mac_speed clock",
          "context": [
            "\tint ret;",
            "",
            "\tif (!clk_mac_speed) {",
            "\t\tdev_err(dev, \"%s: Missing clk_mac_speed clock\\n\", __func__);",
            "\t\treturn;",
            "\t}",
            ""
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\net\\ethernet\\stmicro\\stmmac\\dwmac-rk.c"
          ]
        },
        {
          "file": "linux\\drivers\\nfc\\nxp-nci\\core.c",
          "line": 100,
          "match": "Missing or unstable clock",
          "context": [
            "\t\t\t\t       struct sk_buff *skb)",
            "{",
            "\tnfc_err(&ndev->nfc_dev->dev,",
            "\t\t\"PLL didn't lock. Missing or unstable clock?\\n\");",
            "",
            "\treturn 0;",
            "}"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\nfc\\nxp-nci\\core.c"
          ]
        },
        {
          "file": "linux\\drivers\\phy\\rockchip\\phy-rockchip-samsung-hdptx.c",
          "line": 2024,
          "match": "Missing clock",
          "context": [
            "\tif (ret < 0)",
            "\t\treturn dev_err_probe(dev, ret, \"Failed to get clocks\\n\");",
            "\tif (ret == 0)",
            "\t\treturn dev_err_probe(dev, -EINVAL, \"Missing clocks\\n\");",
            "",
            "\thdptx->nr_clks = ret;",
            ""
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\phy\\rockchip\\phy-rockchip-samsung-hdptx.c"
          ]
        },
        {
          "file": "linux\\drivers\\scsi\\qla4xxx\\ql4_os.c",
          "line": 4029,
          "match": "missing - block",
          "context": [
            "}",
            "",
            "/***",
            " * qla4xxx_mark_device_missing - blocks the session",
            " * @cls_session: Pointer to the session to be blocked",
            " * @ddb_entry: Pointer to device database entry",
            " *"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\scsi\\qla4xxx\\ql4_os.c"
          ]
        },
        {
          "file": "linux\\drivers\\soc\\ti\\pruss.c",
          "line": 391,
          "match": "missing its 'clock",
          "context": [
            "",
            "\tif (!clks_np)",
            "\t\treturn dev_err_probe(dev, -ENODEV,",
            "\t\t\t\t     \"%pOF is missing its 'clocks' node\\n\",",
            "\t\t\t\t     cfg_node);",
            "",
            "\tif (data && data->has_core_mux_clock) {"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\soc\\ti\\pruss.c"
          ]
        },
        {
          "file": "linux\\drivers\\staging\\most\\dim2\\dim2.c",
          "line": 771,
          "match": "missing dt property clock",
          "context": [
            "\tret = of_property_read_string(pdev->dev.of_node,",
            "\t\t\t\t      \"microchip,clock-speed\", &clock_speed);",
            "\tif (ret) {",
            "\t\tdev_err(&pdev->dev, \"missing dt property clock-speed\\n\");",
            "\t\tgoto err_free_dev;",
            "\t}",
            ""
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\staging\\most\\dim2\\dim2.c"
          ]
        },
        {
          "file": "linux\\drivers\\tty\\serial\\milbeaut_usio.c",
          "line": 506,
          "match": "Missing clock",
          "context": [
            "\tint ret;",
            "",
            "\tif (IS_ERR(clk)) {",
            "\t\tdev_err(&pdev->dev, \"Missing clock\\n\");",
            "\t\treturn PTR_ERR(clk);",
            "\t}",
            "\tret = clk_prepare_enable(clk);"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\tty\\serial\\milbeaut_usio.c"
          ]
        },
        {
          "file": "linux\\drivers\\tty\\serial\\ucc_uart.c",
          "line": 1295,
          "match": "missing rx-clock",
          "context": [
            "",
            "\tsprop = of_get_property(np, \"rx-clock-name\", NULL);",
            "\tif (!sprop) {",
            "\t\tdev_err(&ofdev->dev, \"missing rx-clock-name in device tree\\n\");",
            "\t\tret = -ENODEV;",
            "\t\tgoto out_free;",
            "\t}"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\tty\\serial\\ucc_uart.c"
          ]
        },
        {
          "file": "linux\\drivers\\tty\\serial\\ucc_uart.c",
          "line": 1314,
          "match": "missing tx-clock",
          "context": [
            "#else",
            "\tsprop = of_get_property(np, \"tx-clock-name\", NULL);",
            "\tif (!sprop) {",
            "\t\tdev_err(&ofdev->dev, \"missing tx-clock-name in device tree\\n\");",
            "\t\tret = -ENODEV;",
            "\t\tgoto out_free;",
            "\t}"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\tty\\serial\\ucc_uart.c"
          ]
        },
        {
          "file": "linux\\drivers\\ufs\\host\\ufshcd-pltfrm.c",
          "line": 282,
          "match": "Missing clock",
          "context": [
            "",
            "\tcnt = of_property_count_strings(np, \"clock-names\");",
            "\tif (cnt <= 0) {",
            "\t\tdev_err(dev, \"%s: Missing clock-names\\n\",  __func__);",
            "\t\treturn -ENODEV;",
            "\t}",
            ""
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\ufs\\host\\ufshcd-pltfrm.c"
          ]
        },
        {
          "file": "linux\\drivers\\usb\\class\\cdc-acm.c",
          "line": 687,
          "match": "missing ctrlout lock",
          "context": [
            "\telse",
            "\t\tval = 0;",
            "",
            "\t/* FIXME: add missing ctrlout locking throughout driver */",
            "\tacm->ctrlout = val;",
            "",
            "\tres = acm_set_control(acm, val);"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\usb\\class\\cdc-acm.c"
          ]
        },
        {
          "file": "linux\\drivers\\video\\fbdev\\s3c-fb.c",
          "line": 1051,
          "match": "missing_pixclock() - calculates pixel clock",
          "context": [
            "};",
            "",
            "/**",
            " * s3c_fb_missing_pixclock() - calculates pixel clock",
            " * @mode: The video mode to change.",
            " *",
            " * Calculate the pixel clock when none has been given through platform data."
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\video\\fbdev\\s3c-fb.c"
          ]
        },
        {
          "file": "linux\\drivers\\video\\fbdev\\s3c-fb.c",
          "line": 1056,
          "match": "missing_pixclock",
          "context": [
            " *",
            " * Calculate the pixel clock when none has been given through platform data.",
            " */",
            "static void s3c_fb_missing_pixclock(struct fb_videomode *mode)",
            "{",
            "\tu64 pixclk = 1000000000000ULL;",
            "\tu32 div;"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\video\\fbdev\\s3c-fb.c"
          ]
        },
        {
          "file": "linux\\drivers\\video\\fbdev\\s3c-fb.c",
          "line": 1294,
          "match": "missing_pixclock",
          "context": [
            "\tu32 data;",
            "",
            "\tif (!vmode->pixclock)",
            "\t\ts3c_fb_missing_pixclock(vmode);",
            "",
            "\tclkdiv = s3c_fb_calc_pixclk(sfb, vmode->pixclock);",
            ""
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\drivers\\video\\fbdev\\s3c-fb.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\backref.c",
          "line": 1564,
          "match": "missing_keys(ctx->fs_info, &preftrees, path->skip_lock",
          "context": [
            "",
            "\tbtrfs_release_path(path);",
            "",
            "\tret = add_missing_keys(ctx->fs_info, &preftrees, path->skip_locking == 0);",
            "\tif (ret)",
            "\t\tgoto out;",
            ""
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\backref.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\qgroup.c",
          "line": 2661,
          "match": "Missing extent block",
          "context": [
            "\t\treturn -ENOMEM;",
            "",
            "\t/*",
            "\t * Walk down the tree.  Missing extent blocks are filled in as",
            "\t * we go. Metadata is accounted every time we read a new",
            "\t * extent block.",
            "\t *"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\qgroup.c"
          ]
        },
        {
          "file": "linux\\fs\\btrfs\\ref-verify.c",
          "line": 424,
          "match": "missing root in new block",
          "context": [
            "\tre = lookup_root_entry(&be->roots, ref_root);",
            "\tif (!re) {",
            "\t\tspin_unlock(&fs_info->ref_verify_lock);",
            "\t\tbtrfs_err(fs_info, \"missing root in new block entry?\");",
            "\t\treturn -EINVAL;",
            "\t}",
            "\tre->num_refs += num_refs;"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\btrfs\\ref-verify.c"
          ]
        },
        {
          "file": "linux\\fs\\ext4\\move_extent.c",
          "line": 60,
          "match": "double_up_write_data_sem - Release two inodes' write lock",
          "context": [
            "}",
            "",
            "/**",
            " * ext4_double_up_write_data_sem - Release two inodes' write lock of i_data_sem",
            " *",
            " * @orig_inode:\t\toriginal inode structure to be released its lock first",
            " * @donor_inode:\tdonor inode structure to be released its lock second"
          ],
          "pattern": "no.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ext4\\move_extent.c"
          ]
        },
        {
          "file": "linux\\fs\\f2fs\\gc.c",
          "line": 1109,
          "match": "double indirect node block",
          "context": [
            " * Calculate start block index indicating the given node offset.",
            " * Be careful, caller should give this node offset only indicating direct node",
            " * blocks. If any node offsets, which point the other types of node blocks such",
            " * as indirect or double indirect node blocks, are given, it must be a caller's",
            " * bug.",
            " */",
            "block_t f2fs_start_bidx_of_node(unsigned int node_ofs, struct inode *inode)"
          ],
          "pattern": "no.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\f2fs\\gc.c"
          ]
        },
        {
          "file": "linux\\fs\\f2fs\\super.c",
          "line": 3412,
          "match": "double indirect node block",
          "context": [
            "\tleaf_count *= NIDS_PER_BLOCK;",
            "\tresult += (leaf_count * 2);",
            "",
            "\t/* one double indirect node block */",
            "\tleaf_count *= NIDS_PER_BLOCK;",
            "\tresult += leaf_count;",
            ""
          ],
          "pattern": "no.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\f2fs\\super.c"
          ]
        },
        {
          "file": "linux\\fs\\jbd2\\journal.c",
          "line": 308,
          "match": "missing word can then be restored when the block",
          "context": [
            " * this case, we copy the data and replace the first word with 0, and we",
            " * return a result code which indicates that this buffer needs to be",
            " * marked as an escaped buffer in the corresponding log descriptor",
            " * block.  The missing word can then be restored when the block is read",
            " * during recovery.",
            " *",
            " * If the source buffer has already been modified by a new transaction"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\jbd2\\journal.c"
          ]
        },
        {
          "file": "linux\\fs\\jfs\\jfs_dtree.c",
          "line": 2651,
          "match": "missing_indices: Invalid stbl[%d] = %d for inode %ld, block",
          "context": [
            "\tstbl = DT_GETSTBL(p);",
            "\tfor (i = 0; i < p->header.nextindex; i++) {",
            "\t\tif (stbl[i] < 0) {",
            "\t\t\tjfs_err(\"jfs: add_missing_indices: Invalid stbl[%d] = %d for inode %ld, block = %lld\",",
            "\t\t\t\ti, stbl[i], (long)inode->i_ino, (long long)bn);",
            "\t\t\trc = -EIO;",
            ""
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\jfs\\jfs_dtree.c"
          ]
        },
        {
          "file": "linux\\fs\\lockd\\svc4proc.c",
          "line": 56,
          "match": "missing parts of the file_lock",
          "context": [
            "\t\t\tgoto no_locks;",
            "\t\t*filp = file;",
            "",
            "\t\t/* Set up the missing parts of the file_lock structure */",
            "\t\tlock->fl.c.flc_file = file->f_file[mode];",
            "\t\tlock->fl.c.flc_pid = current->tgid;",
            "\t\tlock->fl.fl_start = (loff_t)lock->lock_start;"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\lockd\\svc4proc.c"
          ]
        },
        {
          "file": "linux\\fs\\lockd\\svcproc.c",
          "line": 78,
          "match": "missing parts of the file_lock",
          "context": [
            "\t\t\tgoto no_locks;",
            "\t\t*filp = file;",
            "",
            "\t\t/* Set up the missing parts of the file_lock structure */",
            "\t\tmode = lock_to_openmode(&lock->fl);",
            "\t\tlock->fl.c.flc_flags = FL_POSIX;",
            "\t\tlock->fl.c.flc_file  = file->f_file[mode];"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\lockd\\svcproc.c"
          ]
        },
        {
          "file": "linux\\fs\\nilfs2\\cpfile.c",
          "line": 170,
          "match": "missing header block",
          "context": [
            "",
            "\tif (unlikely(err == -ENOENT)) {",
            "\t\tnilfs_error(cpfile->i_sb,",
            "\t\t\t    \"missing header block in checkpoint metadata\");",
            "\t\terr = -EIO;",
            "\t}",
            "\treturn err;"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\nilfs2\\cpfile.c"
          ]
        },
        {
          "file": "linux\\fs\\nilfs2\\sufile.c",
          "line": 98,
          "match": "missing header block",
          "context": [
            "",
            "\tif (unlikely(err == -ENOENT)) {",
            "\t\tnilfs_error(sufile->i_sb,",
            "\t\t\t    \"missing header block in segment usage metadata\");",
            "\t\terr = -EIO;",
            "\t}",
            "\treturn err;"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\nilfs2\\sufile.c"
          ]
        },
        {
          "file": "linux\\fs\\nilfs2\\sufile.c",
          "line": 1247,
          "match": "missing header block",
          "context": [
            "\tif (unlikely(err)) {",
            "\t\tif (err == -ENOENT) {",
            "\t\t\tnilfs_err(sb,",
            "\t\t\t\t  \"missing header block in segment usage metadata\");",
            "\t\t\terr = -EINVAL;",
            "\t\t}",
            "\t\tgoto failed;"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\nilfs2\\sufile.c"
          ]
        },
        {
          "file": "linux\\fs\\ocfs2\\dcache.c",
          "line": 393,
          "match": "missing cluster lock",
          "context": [
            "\t\t\tunsigned long long ino = 0ULL;",
            "\t\t\tif (inode)",
            "\t\t\t\tino = (unsigned long long)OCFS2_I(inode)->ip_blkno;",
            "\t\t\tmlog(ML_ERROR, \"Dentry is missing cluster lock. \"",
            "\t\t\t     \"inode: %llu, d_flags: 0x%x, d_name: %pd\\n\",",
            "\t\t\t     ino, dentry->d_flags, dentry);",
            "\t\t}"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\ocfs2\\dcache.c"
          ]
        },
        {
          "file": "linux\\fs\\xfs\\libxfs\\xfs_dir2_leaf.c",
          "line": 765,
          "match": "missing block",
          "context": [
            "\t\tneedbytes += sizeof(xfs_dir2_data_off_t);",
            "",
            "\t/*",
            "\t * Now kill use_block if it refers to a missing block, so we",
            "\t * can use it as an indication of allocation needed.",
            "\t */",
            "\tif (use_block != -1 && bestsp[use_block] == cpu_to_be16(NULLDATAOFF))"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\fs\\xfs\\libxfs\\xfs_dir2_leaf.c"
          ]
        },
        {
          "file": "linux\\kernel\\locking\\lockdep.c",
          "line": 3009,
          "match": "missing lock",
          "context": [
            "\t__print_lock_name(nxt, next);",
            "\tprintk(KERN_CONT \");\\n\");",
            "\tprintk(\"\\n *** DEADLOCK ***\\n\\n\");",
            "\tprintk(\" May be due to missing lock nesting notation\\n\\n\");",
            "}",
            "",
            "static void"
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\kernel\\locking\\lockdep.c"
          ]
        },
        {
          "file": "linux\\net\\ipv4\\arp.c",
          "line": 43,
          "match": "Missing unlock",
          "context": [
            " *\t\t\t\t\teg intelligent arp probing and",
            " *\t\t\t\t\tgeneration",
            " *\t\t\t\t\tof host down events.",
            " *\t\tAlan Cox\t:\tMissing unlock in device events.",
            " *\t\tEckes\t\t:\tARP ioctl control errors.",
            " *\t\tAlexey Kuznetsov:\tArp free fix.",
            " *\t\tManuel Rodriguez:\tGratuitous ARP."
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\net\\ipv4\\arp.c"
          ]
        },
        {
          "file": "linux\\net\\ipv4\\ip_output.c",
          "line": 22,
          "match": "Missing nonblock",
          "context": [
            " *\tSee ip_input.c for original log",
            " *",
            " *\tFixes:",
            " *\t\tAlan Cox\t:\tMissing nonblock feature in ip_build_xmit.",
            " *\t\tMike Kilburn\t:\thtons() missing in ip_build_xmit.",
            " *\t\tBradford Johnson:\tFix faulty handling of some frames when",
            " *\t\t\t\t\tno route is found."
          ],
          "pattern": "missing.*lock",
          "description": "Missing locks for shared resource protection",
          "code_snippet": [
            "File not found: linux\\linux\\net\\ipv4\\ip_output.c"
          ]
        }
      ]
    }
  }
}