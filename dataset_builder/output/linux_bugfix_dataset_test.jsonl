{"input": {"original code": "if (t == NULL)\n\t\treturn;\n\n\t/* Send signal and deal with periodic signals */\n\tspin_lock_irqsave(&t->it_lock, flags);\n\tspin_lock(&x->lock);\n\t/* If timer was deleted between interrupt and here, leave */\n\tif (t != x->timer)\n\t\tgoto out;\n\tt->it_overrun = 0;\n\n\tif (tasklist_lock.write_lock || posix_timer_event(t, 0) != 0) {\n\n\t\t// printk(KERN_WARNING \"mmtimer: cannot deliver signal.\\n\");\n\n\t\tt->it_overrun++;\n\t}\n\tif(t->it.mmtimer.incr) {\n\t\t/* Periodic timer */", "instruction": "[PATCH] mmtimer build fix"}, "output": {"diff codes": "@@ -485,7 +485,7 @@ void mmtimer_tasklet(unsigned long data) {\n \t\tgoto out;\n \tt->it_overrun = 0;\n \n-\tif (tasklist_lock.write_lock || posix_timer_event(t, 0) != 0) {\n+\tif (posix_timer_event(t, 0) != 0) {\n \n \t\t// printk(KERN_WARNING \"mmtimer: cannot deliver signal.\\n\");"}}
{"input": {"original code": "static int bi_complete(struct bio *bio, unsigned int bytes_done, int error)\n{\n\tif (bio->bi_size)\n\t\treturn 1;\n\n\tcomplete((struct completion*)bio->bi_private);\n\treturn 0;\n}\n\nstatic int sync_page_io(struct block_device *bdev, sector_t sector, int size,\n\t\t   struct page *page, int rw)\n{\n\tstruct bio *bio = bio_alloc(GFP_KERNEL, 1);\n\tstruct completion event;\n\tint ret;\n\n\trw |= (1 << BIO_RW_SYNC);\n\n\tbio->bi_bdev = bdev;\n\tbio->bi_sector = sector;", "instruction": "..as sync_page_io can be called on the write-out path."}, "output": {"diff codes": "@@ -332,7 +332,7 @@ static int bi_complete(struct bio *bio, unsigned int bytes_done, int error)\n static int sync_page_io(struct block_device *bdev, sector_t sector, int size,\n \t\t   struct page *page, int rw)\n {\n-\tstruct bio *bio = bio_alloc(GFP_KERNEL, 1);\n+\tstruct bio *bio = bio_alloc(GFP_NOIO, 1);\n \tstruct completion event;\n \tint ret;"}}
{"input": {"original code": "show_pte(mm, addr);\n\tdie(\"Oops\", regs, fsr);\n\tbust_spinlocks(0);\n\tdo_exit(SIGKILL);\n}\n\n/*\n * Something tried to access memory that isn't in our memory map..\n * User mode accesses just cause a SIGSEGV\n */\nstatic void\n__do_user_fault(struct task_struct *tsk, unsigned long addr,\n\t\tunsigned int fsr, int code, struct pt_regs *regs)\n{\n\tstruct siginfo si;\n\n#ifdef CONFIG_DEBUG_USER\n\tif (user_debug & UDBG_SEGV) {\n\t\tprintk(KERN_DEBUG \"%s: unhandled page fault at 0x%08lx, code 0x%03x\\n\",\n\t\t       tsk->comm, addr, fsr);", "instruction": ")"}, "output": {"diff codes": "@@ -108,14 +108,15 @@ __do_kernel_fault(struct mm_struct *mm, unsigned long addr, unsigned int fsr,\n  */\n static void\n __do_user_fault(struct task_struct *tsk, unsigned long addr,\n-\t\tunsigned int fsr, int code, struct pt_regs *regs)\n+\t\tunsigned int fsr, unsigned int sig, int code,\n+\t\tstruct pt_regs *regs)\n {\n \tstruct siginfo si;\n \n #ifdef CONFIG_DEBUG_USER\n \tif (user_debug & UDBG_SEGV) {\n-\t\tprintk(KERN_DEBUG \"%s: unhandled page fault at 0x%08lx, code 0x%03x\\n\",\n-\t\t       tsk->comm, addr, fsr);\n+\t\tprintk(KERN_DEBUG \"%s: unhandled page fault (%d) at 0x%08lx, code 0x%03x\\n\",\n+\t\t       tsk->comm, sig, addr, fsr);\n \t\tshow_pte(tsk->mm, addr);\n \t\tshow_regs(regs);\n \t}\n@@ -124,11 +125,11 @@ __do_user_fault(struct task_struct *tsk, unsigned long addr,\n \ttsk->thread.address = addr;\n \ttsk->thread.error_code = fsr;\n \ttsk->thread.trap_no = 14;\n-\tsi.si_signo = SIGSEGV;\n+\tsi.si_signo = sig;\n \tsi.si_errno = 0;\n \tsi.si_code = code;\n \tsi.si_addr = (void __user *)addr;\n-\tforce_sig_info(SIGSEGV, &si, tsk);\n+\tforce_sig_info(sig, &si, tsk);\n }\n \n void\n@@ -140,7 +141,7 @@ do_bad_area(struct task_struct *tsk, struct mm_struct *mm, unsigned long addr,\n \t * have no context to handle this fault with.\n \t */\n \tif (user_mode(regs))\n-\t\t__do_user_fault(tsk, addr, fsr, SEGV_MAPERR, regs);\n+\t\t__do_user_fault(tsk, addr, fsr, SIGSEGV, SEGV_MAPERR, regs);\n \telse\n \t\t__do_kernel_fault(mm, addr, fsr, regs);\n }\n@@ -201,10 +202,11 @@ __do_page_fault(struct mm_struct *mm, unsigned long addr, unsigned int fsr,\n \t\tgoto out;\n \n \t/*\n-\t * If we are out of memory for pid1,\n-\t * sleep for a while and retry\n+\t * If we are out of memory for pid1, sleep for a while and retry\n \t */\n+\tup_read(&mm->mmap_sem);\n \tyield();\n+\tdown_read(&mm->mmap_sem);\n \tgoto survive;\n \n check_stack:\n@@ -219,7 +221,7 @@ do_page_fault(unsigned long addr, unsigned int fsr, struct pt_regs *regs)\n {\n \tstruct task_struct *tsk;\n \tstruct mm_struct *mm;\n-\tint fault;\n+\tint fault, sig, code;\n \n \ttsk = current;\n \tmm  = tsk->mm;\n@@ -241,13 +243,6 @@ do_page_fault(unsigned long addr, unsigned int fsr, struct pt_regs *regs)\n \tif (fault > 0)\n \t\treturn 0;\n \n-\t/*\n-\t * We had some memory, but were unable to\n-\t * successfully fix up this page fault.\n-\t */\n-\tif (fault == 0)\n-\t\tgoto do_sigbus;\n-\n \t/*\n \t * If we are in kernel mode at this point, we\n \t * have no context to handle this fault with.\n@@ -255,42 +250,39 @@ do_page_fault(unsigned long addr, unsigned int fsr, struct pt_regs *regs)\n \tif (!user_mode(regs))\n \t\tgoto no_context;\n \n-\tif (fault == VM_FAULT_OOM) {\n+\tswitch (fault) {\n+\tcase VM_FAULT_OOM:\n \t\t/*\n-\t\t * We ran out of memory, or some other thing happened to\n-\t\t * us that made us unable to handle the page fault gracefully.\n+\t\t * We ran out of memory, or some other thing\n+\t\t * happened to us that made us unable to handle\n+\t\t * the page fault gracefully.\n \t\t */\n \t\tprintk(\"VM: killing process %s\\n\", tsk->comm);\n \t\tdo_exit(SIGKILL);\n-\t} else\n-\t\t__do_user_fault(tsk, addr, fsr, fault == VM_FAULT_BADACCESS ?\n-\t\t\t\tSEGV_ACCERR : SEGV_MAPERR, regs);\n-\treturn 0;\n+\t\treturn 0;\n \n+\tcase 0:\n+\t\t/*\n+\t\t * We had some memory, but were unable to\n+\t\t * successfully fix up this page fault.\n+\t\t */\n+\t\tsig = SIGBUS;\n+\t\tcode = BUS_ADRERR;\n+\t\tbreak;\n \n-/*\n- * We ran out of memory, or some other thing happened to us that made\n- * us unable to handle the page fault gracefully.\n- */\n-do_sigbus:\n-\t/*\n-\t * Send a sigbus, regardless of whether we were in kernel\n-\t * or user mode.\n-\t */\n-\ttsk->thread.address = addr;\n-\ttsk->thread.error_code = fsr;\n-\ttsk->thread.trap_no = 14;\n-\tforce_sig(SIGBUS, tsk);\n-#ifdef CONFIG_DEBUG_USER\n-\tif (user_debug & UDBG_BUS) {\n-\t\tprintk(KERN_DEBUG \"%s: sigbus at 0x%08lx, pc=0x%08lx\\n\",\n-\t\t\tcurrent->comm, addr, instruction_pointer(regs));\n+\tdefault:\n+\t\t/*\n+\t\t * Something tried to access memory that\n+\t\t * isn't in our memory map..\n+\t\t */\n+\t\tsig = SIGSEGV;\n+\t\tcode = fault == VM_FAULT_BADACCESS ?\n+\t\t\tSEGV_ACCERR : SEGV_MAPERR;\n+\t\tbreak;\n \t}\n-#endif\n \n-\t/* Kernel mode? Handle exceptions or die */\n-\tif (user_mode(regs))\n-\t\treturn 0;\n+\t__do_user_fault(tsk, addr, fsr, sig, code, regs);\n+\treturn 0;\n \n no_context:\n \t__do_kernel_fault(mm, addr, fsr, regs);"}}
{"input": {"original code": "ret = -EINVAL;\n\t\tgoto out_free;\n\t}\nout:\n\treturn ret;\nout_free:\n\tkfree(stream->workspace);\n\tgoto out;\n}\n\nstatic void deflate_comp_exit(struct deflate_ctx *ctx)\n{\n\tvfree(ctx->comp_stream.workspace);\n}\n\nstatic void deflate_decomp_exit(struct deflate_ctx *ctx)\n{\n\tkfree(ctx->decomp_stream.workspace);\n}", "instruction": "In the deflate_[compress|uncompress|pcompress] functions we call the"}, "output": {"diff codes": "@@ -93,11 +93,13 @@ static int deflate_decomp_init(struct deflate_ctx *ctx)\n \n static void deflate_comp_exit(struct deflate_ctx *ctx)\n {\n+\tzlib_deflateEnd(&ctx->comp_stream);\n \tvfree(ctx->comp_stream.workspace);\n }\n \n static void deflate_decomp_exit(struct deflate_ctx *ctx)\n {\n+\tzlib_inflateEnd(&ctx->decomp_stream);\n \tkfree(ctx->decomp_stream.workspace);\n }"}}
{"input": {"original code": "ext2_iset_acl(inode, &ei->i_default_acl, acl);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn error;\n}\n\nstatic int\next2_check_acl(struct inode *inode, int mask)\n{\n\tstruct posix_acl *acl = ext2_get_acl(inode, ACL_TYPE_ACCESS);\n\n\tif (acl) {\n\t\tint error = posix_acl_permission(inode, acl, mask);\n\t\tposix_acl_release(acl);\n\t\treturn error;\n\t}\n\n\treturn -EAGAIN;\n}", "instruction": ")"}, "output": {"diff codes": "@@ -283,6 +283,8 @@ ext2_check_acl(struct inode *inode, int mask)\n {\n \tstruct posix_acl *acl = ext2_get_acl(inode, ACL_TYPE_ACCESS);\n \n+\tif (IS_ERR(acl))\n+\t\treturn PTR_ERR(acl);\n \tif (acl) {\n \t\tint error = posix_acl_permission(inode, acl, mask);\n \t\tposix_acl_release(acl);"}}
{"input": {"original code": "ext3_iset_acl(inode, &ei->i_default_acl, acl);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn error;\n}\n\nstatic int\next3_check_acl(struct inode *inode, int mask)\n{\n\tstruct posix_acl *acl = ext3_get_acl(inode, ACL_TYPE_ACCESS);\n\n\tif (acl) {\n\t\tint error = posix_acl_permission(inode, acl, mask);\n\t\tposix_acl_release(acl);\n\t\treturn error;\n\t}\n\n\treturn -EAGAIN;\n}", "instruction": ")"}, "output": {"diff codes": "@@ -286,6 +286,8 @@ ext3_check_acl(struct inode *inode, int mask)\n {\n \tstruct posix_acl *acl = ext3_get_acl(inode, ACL_TYPE_ACCESS);\n \n+\tif (IS_ERR(acl))\n+\t\treturn PTR_ERR(acl);\n \tif (acl) {\n \t\tint error = posix_acl_permission(inode, acl, mask);\n \t\tposix_acl_release(acl);"}}
{"input": {"original code": "struct task_struct * p, struct pt_regs * regs)\n{\n\tstruct pt_regs * childregs;\n\tstruct task_struct *tsk;\n\tint err;\n\n\tchildregs = ((struct pt_regs *) (THREAD_SIZE + (unsigned long) p->thread_info)) - 1;\n\t*childregs = *regs;\n\tchildregs->eax = 0;\n\tchildregs->esp = esp;\n\n\tp->thread.esp = (unsigned long) childregs;\n\tp->thread.esp0 = (unsigned long) (childregs+1);\n\n\tp->thread.eip = (unsigned long) ret_from_fork;\n\n\tsavesegment(fs,p->thread.fs);\n\tsavesegment(gs,p->thread.gs);\n\n\ttsk = current;", "instruction": "Fix the access-above-bottom-of-stack crash."}, "output": {"diff codes": "@@ -405,7 +405,17 @@ int copy_thread(int nr, unsigned long clone_flags, unsigned long esp,\n \tchildregs->esp = esp;\n \n \tp->thread.esp = (unsigned long) childregs;\n-\tp->thread.esp0 = (unsigned long) (childregs+1);\n+\t/*\n+\t * The below -8 is to reserve 8 bytes on top of the ring0 stack.\n+\t * This is necessary to guarantee that the entire \"struct pt_regs\"\n+\t * is accessable even if the CPU haven't stored the SS/ESP registers\n+\t * on the stack (interrupt gate does not save these registers\n+\t * when switching to the same priv ring).\n+\t * Therefore beware: accessing the xss/esp fields of the\n+\t * \"struct pt_regs\" is possible, but they may contain the\n+\t * completely wrong values.\n+\t */\n+\tp->thread.esp0 = (unsigned long) (childregs+1) - 8;\n \n \tp->thread.eip = (unsigned long) ret_from_fork;"}}
{"input": {"original code": "} \n\n/*\n * We currently only need the following fields from the sigevent\n * structure: sigev_value, sigev_signo, sig_notify and (sometimes\n * sigev_notify_thread_id).  The others are handled in user mode.\n * We also assume that copying sigev_value.sival_int is sufficient\n * to keep all the bits of sigev_value.sival_ptr intact.\n */\nint get_compat_sigevent(struct sigevent *event,\n\t\tconst struct compat_sigevent __user *u_event)\n{\n\tmemset(&event, 0, sizeof(*event));\n\treturn (!access_ok(VERIFY_READ, u_event, sizeof(*u_event)) ||\n\t\t__get_user(event->sigev_value.sival_int,\n\t\t\t&u_event->sigev_value.sival_int) ||\n\t\t__get_user(event->sigev_signo, &u_event->sigev_signo) ||\n\t\t__get_user(event->sigev_notify, &u_event->sigev_notify) ||\n\t\t__get_user(event->sigev_notify_thread_id,\n\t\t\t&u_event->sigev_notify_thread_id))", "instruction": "I have no idea how a bug like this lasted so long.  Anyways, obvious"}, "output": {"diff codes": "@@ -640,7 +640,7 @@ long compat_sys_clock_nanosleep(clockid_t which_clock, int flags,\n int get_compat_sigevent(struct sigevent *event,\n \t\tconst struct compat_sigevent __user *u_event)\n {\n-\tmemset(&event, 0, sizeof(*event));\n+\tmemset(event, 0, sizeof(*event));\n \treturn (!access_ok(VERIFY_READ, u_event, sizeof(*u_event)) ||\n \t\t__get_user(event->sigev_value.sival_int,\n \t\t\t&u_event->sigev_value.sival_int) ||"}}
{"input": {"original code": "btv->pll.pll_crystal = BT848_IFORM_XT0;\n                        break;\n                case 2: /* 35 MHz */\n\t\tcase 35:\n                        btv->pll.pll_ifreq   = 35468950;\n\t\t\tbtv->pll.pll_ofreq   = 0;\n                        btv->pll.pll_crystal = BT848_IFORM_XT1;\n                        break;\n                }\n        }\n\tbtv->pll.pll_current = -1;\n\n\tbttv_reset_audio(btv);\n\n\t/* tuner configuration (from card list / autodetect / insmod option) */\n \tif (UNSET != bttv_tvcards[btv->c.type].tuner_type)\n\t\tif(UNSET == btv->tuner_type)\n                \tbtv->tuner_type = bttv_tvcards[btv->c.type].tuner_type;\n\tif (UNSET != tuner[btv->c.nr])\n\t\tbtv->tuner_type = tuner[btv->c.nr];", "instruction": ")"}, "output": {"diff codes": "@@ -2785,8 +2785,6 @@ void __devinit bttv_init_card2(struct bttv *btv)\n         }\n \tbtv->pll.pll_current = -1;\n \n-\tbttv_reset_audio(btv);\n-\n \t/* tuner configuration (from card list / autodetect / insmod option) */\n  \tif (UNSET != bttv_tvcards[btv->c.type].tuner_type)\n \t\tif(UNSET == btv->tuner_type)"}}
{"input": {"original code": "int selinux_nlmsg_lookup(u16 sclass, u16 nlmsg_type, u32 *perm)\n{\n\tint err = 0;\n\n\tswitch (sclass) {\n\tcase SECCLASS_NETLINK_ROUTE_SOCKET:\n\t\terr = nlmsg_perm(nlmsg_type, perm, nlmsg_route_perms,\n\t\t\t\t sizeof(nlmsg_route_perms));\n\t\tbreak;\n\n\tcase SECCLASS_NETLINK_FIREWALL_SOCKET:\n\tcase NETLINK_IP6_FW:\n\t\terr = nlmsg_perm(nlmsg_type, perm, nlmsg_firewall_perms,\n\t\t\t\t sizeof(nlmsg_firewall_perms));\n\t\tbreak;\n\n\tcase SECCLASS_NETLINK_TCPDIAG_SOCKET:\n\t\terr = nlmsg_perm(nlmsg_type, perm, nlmsg_tcpdiag_perms,\n\t\t\t\t sizeof(nlmsg_tcpdiag_perms));", "instruction": "This patch fixes a bug in the SELinux Netlink message type detection code,"}, "output": {"diff codes": "@@ -126,7 +126,7 @@ int selinux_nlmsg_lookup(u16 sclass, u16 nlmsg_type, u32 *perm)\n \t\tbreak;\n \n \tcase SECCLASS_NETLINK_FIREWALL_SOCKET:\n-\tcase NETLINK_IP6_FW:\n+\tcase SECCLASS_NETLINK_IP6FW_SOCKET:\n \t\terr = nlmsg_perm(nlmsg_type, perm, nlmsg_firewall_perms,\n \t\t\t\t sizeof(nlmsg_firewall_perms));\n \t\tbreak;"}}
{"input": {"original code": "LOCK_TEST_WITH_RETURN( dev, filp );\n\n\tDRM_COPY_FROM_USER_IOCTL( depth, (drm_r128_depth_t __user *) data,\n\t\t\t     sizeof(depth) );\n\n\tRING_SPACE_TEST_WITH_RETURN( dev_priv );\n\n\tret = DRM_ERR(EINVAL);\n\tswitch ( depth.func ) {\n\tcase R128_WRITE_SPAN:\n\t\tret = r128_cce_dispatch_write_span( dev, &depth );\n\tcase R128_WRITE_PIXELS:\n\t\tret = r128_cce_dispatch_write_pixels( dev, &depth );\n\tcase R128_READ_SPAN:\n\t\tret = r128_cce_dispatch_read_span( dev, &depth );\n\tcase R128_READ_PIXELS:\n\t\tret = r128_cce_dispatch_read_pixels( dev, &depth );\n\t}", "instruction": "drm: fix r128_state.c switch statements..  in drivers/char/drm/r128_state.c"}, "output": {"diff codes": "@@ -1549,12 +1549,16 @@ static int r128_cce_depth( DRM_IOCTL_ARGS )\n \tswitch ( depth.func ) {\n \tcase R128_WRITE_SPAN:\n \t\tret = r128_cce_dispatch_write_span( dev, &depth );\n+\t\tbreak;\n \tcase R128_WRITE_PIXELS:\n \t\tret = r128_cce_dispatch_write_pixels( dev, &depth );\n+\t\tbreak;\n \tcase R128_READ_SPAN:\n \t\tret = r128_cce_dispatch_read_span( dev, &depth );\n+\t\tbreak;\n \tcase R128_READ_PIXELS:\n \t\tret = r128_cce_dispatch_read_pixels( dev, &depth );\n+\t\tbreak;\n \t}\n \n \tCOMMIT_RING();"}}
{"input": {"original code": "retry_find:\n\tpage = find_get_page(mapping, pgoff);\n\tif (!page) {\n\t\tif (nonblock)\n\t\t\treturn NULL;\n\t\tgoto no_cached_page;\n\t}\n\n\t/*\n\t * Ok, found a page in the page cache, now we need to check\n\t * that it's up-to-date.\n\t */\n\tif (!PageUptodate(page))\n\t\tgoto page_not_uptodate;\n\nsuccess:\n\t/*\n\t * Found the page and have a reference on it.\n\t */\n\tmark_page_accessed(page);", "instruction": "We will return NULL from filemap_getpage when a page does not exist in the"}, "output": {"diff codes": "@@ -1379,8 +1379,13 @@ static struct page * filemap_getpage(struct file *file, unsigned long pgoff,\n \t * Ok, found a page in the page cache, now we need to check\n \t * that it's up-to-date.\n \t */\n-\tif (!PageUptodate(page))\n+\tif (!PageUptodate(page)) {\n+\t\tif (nonblock) {\n+\t\t\tpage_cache_release(page);\n+\t\t\treturn NULL;\n+\t\t}\n \t\tgoto page_not_uptodate;\n+\t}\n \n success:\n \t/*"}}
{"input": {"original code": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (test_set_buffer_locked(bh))\n\t\t\tcontinue;\n\n\t\tget_bh(bh);\n\t\tif (rw == WRITE) {\n\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\tif (!buffer_uptodate(bh)) {", "instruction": "[PATCH] end_buffer_write_sync() avoid pointless assignments"}, "output": {"diff codes": "@@ -2838,14 +2838,14 @@ void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n \n \t\tget_bh(bh);\n \t\tif (rw == WRITE) {\n-\t\t\tbh->b_end_io = end_buffer_write_sync;\n \t\t\tif (test_clear_buffer_dirty(bh)) {\n+\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n \t\t\t\tsubmit_bh(WRITE, bh);\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t} else {\n-\t\t\tbh->b_end_io = end_buffer_read_sync;\n \t\t\tif (!buffer_uptodate(bh)) {\n+\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n \t\t\t\tsubmit_bh(rw, bh);\n \t\t\t\tcontinue;\n \t\t\t}"}}
{"input": {"original code": "#ifndef __LINUX_ATALK_H__\n#define __LINUX_ATALK_H__\n\n#include <net/sock.h>\n\n/*\n * AppleTalk networking structures\n *\n * The following are directly referenced from the University Of Michigan\n * netatalk for compatibility reasons.\n */", "instruction": "This recently got changed to include a lot of kernel internal stuff in the"}, "output": {"diff codes": "@@ -1,8 +1,6 @@\n #ifndef __LINUX_ATALK_H__\n #define __LINUX_ATALK_H__\n \n-#include <net/sock.h>\n-\n /*\n  * AppleTalk networking structures\n  *\n@@ -39,6 +37,10 @@ struct atalk_netrange {\n \t__u16\tnr_lastnet;\n };\n \n+#ifdef __KERNEL__\n+\n+#include <net/sock.h>\n+\n struct atalk_route {\n \tstruct net_device  *dev;\n \tstruct atalk_addr  target;\n@@ -81,8 +83,6 @@ static inline struct atalk_sock *at_sk(struct sock *sk)\n \treturn (struct atalk_sock *)sk;\n }\n \n-#ifdef __KERNEL__\n-\n #include <asm/byteorder.h>\n \n struct ddpehdr {"}}
{"input": {"original code": "sock_put(sk);\n}\n\nEXPORT_SYMBOL(sk_common_release);\n\nstatic DEFINE_RWLOCK(proto_list_lock);\nstatic LIST_HEAD(proto_list);\n\nint proto_register(struct proto *prot, int alloc_slab)\n{\n\tint rc = -ENOBUFS;\n\n\twrite_lock(&proto_list_lock);\n\n\tif (alloc_slab) {\n\t\tprot->slab = kmem_cache_create(prot->name, prot->obj_size, 0,\n\t\t\t\t\t       SLAB_HWCACHE_ALIGN, NULL, NULL);\n\n\t\tif (prot->slab == NULL) {\n\t\t\tprintk(KERN_CRIT \"%s: Can't create sock SLAB cache!\\n\",", "instruction": "This fixes the warning reported by Marcel Holtmann (Thanks!)."}, "output": {"diff codes": "@@ -1359,8 +1359,6 @@ int proto_register(struct proto *prot, int alloc_slab)\n {\n \tint rc = -ENOBUFS;\n \n-\twrite_lock(&proto_list_lock);\n-\n \tif (alloc_slab) {\n \t\tprot->slab = kmem_cache_create(prot->name, prot->obj_size, 0,\n \t\t\t\t\t       SLAB_HWCACHE_ALIGN, NULL, NULL);\n@@ -1368,14 +1366,15 @@ int proto_register(struct proto *prot, int alloc_slab)\n \t\tif (prot->slab == NULL) {\n \t\t\tprintk(KERN_CRIT \"%s: Can't create sock SLAB cache!\\n\",\n \t\t\t       prot->name);\n-\t\t\tgoto out_unlock;\n+\t\t\tgoto out;\n \t\t}\n \t}\n \n+\twrite_lock(&proto_list_lock);\n \tlist_add(&prot->node, &proto_list);\n-\trc = 0;\n-out_unlock:\n \twrite_unlock(&proto_list_lock);\n+\trc = 0;\n+out:\n \treturn rc;\n }"}}
{"input": {"original code": "if (dst->ops->destroy)\n\t\tdst->ops->destroy(dst);\n\tif (dst->dev)\n\t\tdev_put(dst->dev);\n#if RT_CACHE_DEBUG >= 2 \n\tatomic_dec(&dst_total);\n#endif\n\tkmem_cache_free(dst->ops->kmem_cachep, dst);\n\n\tdst = child;\n\tif (dst) {\n\t\tif (atomic_dec_and_test(&dst->__refcnt)) {\n\t\t\t/* We were real parent of this dst, so kill child. */\n\t\t\tif (dst->flags&DST_NOHASH)\n\t\t\t\tgoto again;\n\t\t} else {\n\t\t\t/* Child is still referenced, return it for freeing. */\n\t\t\tif (dst->flags&DST_NOHASH)\n\t\t\t\treturn dst;", "instruction": "When we are not the real parent of the dst (e.g., when we're xfrm_dst and"}, "output": {"diff codes": "@@ -198,13 +198,15 @@ struct dst_entry *dst_destroy(struct dst_entry * dst)\n \n \tdst = child;\n \tif (dst) {\n+\t\tint nohash = dst->flags & DST_NOHASH;\n+\n \t\tif (atomic_dec_and_test(&dst->__refcnt)) {\n \t\t\t/* We were real parent of this dst, so kill child. */\n-\t\t\tif (dst->flags&DST_NOHASH)\n+\t\t\tif (nohash)\n \t\t\t\tgoto again;\n \t\t} else {\n \t\t\t/* Child is still referenced, return it for freeing. */\n-\t\t\tif (dst->flags&DST_NOHASH)\n+\t\t\tif (nohash)\n \t\t\t\treturn dst;\n \t\t\t/* Child is still in his hash table */\n \t\t}"}}
{"input": {"original code": "*\n *    Called when we have detected that another station is transmitting\n *    in contention mode.\n */\nvoid irda_device_set_media_busy(struct net_device *dev, int status)\n{\n\tstruct irlap_cb *self;\n\n\tIRDA_DEBUG(4, \"%s(%s)\\n\", __FUNCTION__, status ? \"TRUE\" : \"FALSE\");\n\n\tself = (struct irlap_cb *) dev->atalk_ptr;\n\n\tIRDA_ASSERT(self != NULL, return;);\n\tIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\n\n\tif (status) {\n\t\tself->media_busy = TRUE;\n\t\tif (status == SMALL)\n\t\t\tirlap_start_mbusy_timer(self, SMALLBUSY_TIMEOUT);\n\t\telse", "instruction": "[PATCH] irda_device() oops fix"}, "output": {"diff codes": "@@ -125,8 +125,15 @@ void irda_device_set_media_busy(struct net_device *dev, int status)\n \n \tself = (struct irlap_cb *) dev->atalk_ptr;\n \n-\tIRDA_ASSERT(self != NULL, return;);\n-\tIRDA_ASSERT(self->magic == LAP_MAGIC, return;);\n+\t/* Some drivers may enable the receive interrupt before calling\n+\t * irlap_open(), or they may disable the receive interrupt\n+\t * after calling irlap_close().\n+\t * The IrDA stack is protected from this in irlap_driver_rcv().\n+\t * However, the driver calls directly the wrapper, that calls\n+\t * us directly. Make sure we protect ourselves.\n+\t * Jean II */\n+\tif (!self || self->magic != LAP_MAGIC)\n+\t\treturn;\n \n \tif (status) {\n \t\tself->media_busy = TRUE;"}}
{"input": {"original code": "case NETLINK_NFLOG:\n\t\t\treturn SECCLASS_NETLINK_NFLOG_SOCKET;\n\t\tcase NETLINK_XFRM:\n\t\t\treturn SECCLASS_NETLINK_XFRM_SOCKET;\n\t\tcase NETLINK_SELINUX:\n\t\t\treturn SECCLASS_NETLINK_SELINUX_SOCKET;\n\t\tcase NETLINK_AUDIT:\n\t\t\treturn SECCLASS_NETLINK_AUDIT_SOCKET;\n\t\tcase NETLINK_IP6_FW:\n\t\t\treturn SECCLASS_NETLINK_IP6FW_SOCKET;\n\t\tcase NETLINK_DNRTMSG:\n\t\t\treturn SECCLASS_NETLINK_DNRT_SOCKET;\n\t\tdefault:\n\t\t\treturn SECCLASS_NETLINK_SOCKET;\n\t\t}\n\tcase PF_PACKET:\n\t\treturn SECCLASS_PACKET_SOCKET;\n\tcase PF_KEY:\n\t\treturn SECCLASS_KEY_SOCKET;\n\t}", "instruction": "This patch adds SELinux support for the KOBJECT_UEVENT Netlink family, so"}, "output": {"diff codes": "@@ -672,6 +672,8 @@ static inline u16 socket_type_to_security_class(int family, int type, int protoc\n \t\t\treturn SECCLASS_NETLINK_IP6FW_SOCKET;\n \t\tcase NETLINK_DNRTMSG:\n \t\t\treturn SECCLASS_NETLINK_DNRT_SOCKET;\n+\t\tcase NETLINK_KOBJECT_UEVENT:\n+\t\t\treturn SECCLASS_NETLINK_KOBJECT_UEVENT_SOCKET;\n \t\tdefault:\n \t\t\treturn SECCLASS_NETLINK_SOCKET;\n \t\t}"}}
{"input": {"original code": "S_(SECCLASS_SEM, ipc, 0x00000200UL)\n   S_(SECCLASS_MSGQ, ipc, 0x00000200UL)\n   S_(SECCLASS_SHM, ipc, 0x00000200UL)\n   S_(SECCLASS_NETLINK_ROUTE_SOCKET, socket, 0x00400000UL)\n   S_(SECCLASS_NETLINK_FIREWALL_SOCKET, socket, 0x00400000UL)\n   S_(SECCLASS_NETLINK_TCPDIAG_SOCKET, socket, 0x00400000UL)\n   S_(SECCLASS_NETLINK_NFLOG_SOCKET, socket, 0x00400000UL)\n   S_(SECCLASS_NETLINK_XFRM_SOCKET, socket, 0x00400000UL)\n   S_(SECCLASS_NETLINK_SELINUX_SOCKET, socket, 0x00400000UL)\n   S_(SECCLASS_NETLINK_AUDIT_SOCKET, socket, 0x00400000UL)\n   S_(SECCLASS_NETLINK_IP6FW_SOCKET, socket, 0x00400000UL)\n   S_(SECCLASS_NETLINK_DNRT_SOCKET, socket, 0x00400000UL)", "instruction": "This patch adds SELinux support for the KOBJECT_UEVENT Netlink family, so"}, "output": {"diff codes": "@@ -28,3 +28,4 @@\n    S_(SECCLASS_NETLINK_AUDIT_SOCKET, socket, 0x00400000UL)\n    S_(SECCLASS_NETLINK_IP6FW_SOCKET, socket, 0x00400000UL)\n    S_(SECCLASS_NETLINK_DNRT_SOCKET, socket, 0x00400000UL)\n+   S_(SECCLASS_NETLINK_KOBJECT_UEVENT_SOCKET, socket, 0x00400000UL)"}}
{"input": {"original code": "S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_RAWIO, \"sys_rawio\")\n   S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_CHROOT, \"sys_chroot\")\n   S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_PTRACE, \"sys_ptrace\")\n   S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_PACCT, \"sys_pacct\")\n   S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_ADMIN, \"sys_admin\")\n   S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_BOOT, \"sys_boot\")\n   S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_NICE, \"sys_nice\")\n   S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_RESOURCE, \"sys_resource\")\n   S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_TIME, \"sys_time\")\n   S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_TTY_CONFIG, \"sys_tty_config\")\n   S_(SECCLASS_CAPABILITY, CAPABILITY__MKNOD, \"mknod\")\n   S_(SECCLASS_CAPABILITY, CAPABILITY__LEASE, \"lease\")\n   S_(SECCLASS_PASSWD, PASSWD__PASSWD, \"passwd\")\n   S_(SECCLASS_PASSWD, PASSWD__CHFN, \"chfn\")\n   S_(SECCLASS_PASSWD, PASSWD__CHSH, \"chsh\")\n   S_(SECCLASS_PASSWD, PASSWD__ROOTOK, \"rootok\")\n   S_(SECCLASS_PASSWD, PASSWD__CRONTAB, \"crontab\")\n   S_(SECCLASS_DRAWABLE, DRAWABLE__CREATE, \"create\")\n   S_(SECCLASS_DRAWABLE, DRAWABLE__DESTROY, \"destroy\")\n   S_(SECCLASS_DRAWABLE, DRAWABLE__DRAW, \"draw\")", "instruction": "This patch adds SELinux support for the KOBJECT_UEVENT Netlink family, so"}, "output": {"diff codes": "@@ -118,6 +118,8 @@\n    S_(SECCLASS_CAPABILITY, CAPABILITY__SYS_TTY_CONFIG, \"sys_tty_config\")\n    S_(SECCLASS_CAPABILITY, CAPABILITY__MKNOD, \"mknod\")\n    S_(SECCLASS_CAPABILITY, CAPABILITY__LEASE, \"lease\")\n+   S_(SECCLASS_CAPABILITY, CAPABILITY__AUDIT_WRITE, \"audit_write\")\n+   S_(SECCLASS_CAPABILITY, CAPABILITY__AUDIT_CONTROL, \"audit_control\")\n    S_(SECCLASS_PASSWD, PASSWD__PASSWD, \"passwd\")\n    S_(SECCLASS_PASSWD, PASSWD__CHFN, \"chfn\")\n    S_(SECCLASS_PASSWD, PASSWD__CHSH, \"chsh\")\n@@ -230,3 +232,5 @@\n    S_(SECCLASS_NSCD, NSCD__SHMEMPWD, \"shmempwd\")\n    S_(SECCLASS_NSCD, NSCD__SHMEMGRP, \"shmemgrp\")\n    S_(SECCLASS_NSCD, NSCD__SHMEMHOST, \"shmemhost\")\n+   S_(SECCLASS_ASSOCIATION, ASSOCIATION__SENDTO, \"sendto\")\n+   S_(SECCLASS_ASSOCIATION, ASSOCIATION__RECVFROM, \"recvfrom\")"}}
{"input": {"original code": "#define CAPABILITY__SYS_RAWIO                     0x00020000UL\n#define CAPABILITY__SYS_CHROOT                    0x00040000UL\n#define CAPABILITY__SYS_PTRACE                    0x00080000UL\n#define CAPABILITY__SYS_PACCT                     0x00100000UL\n#define CAPABILITY__SYS_ADMIN                     0x00200000UL\n#define CAPABILITY__SYS_BOOT                      0x00400000UL\n#define CAPABILITY__SYS_NICE                      0x00800000UL\n#define CAPABILITY__SYS_RESOURCE                  0x01000000UL\n#define CAPABILITY__SYS_TIME                      0x02000000UL\n#define CAPABILITY__SYS_TTY_CONFIG                0x04000000UL\n#define CAPABILITY__MKNOD                         0x08000000UL\n#define CAPABILITY__LEASE                         0x10000000UL\n\n#define PASSWD__PASSWD                            0x00000001UL\n#define PASSWD__CHFN                              0x00000002UL\n#define PASSWD__CHSH                              0x00000004UL\n#define PASSWD__ROOTOK                            0x00000008UL\n#define PASSWD__CRONTAB                           0x00000010UL\n\n#define DRAWABLE__CREATE                          0x00000001UL", "instruction": "This patch adds SELinux support for the KOBJECT_UEVENT Netlink family, so"}, "output": {"diff codes": "@@ -559,6 +559,8 @@\n #define CAPABILITY__SYS_TTY_CONFIG                0x04000000UL\n #define CAPABILITY__MKNOD                         0x08000000UL\n #define CAPABILITY__LEASE                         0x10000000UL\n+#define CAPABILITY__AUDIT_WRITE                   0x20000000UL\n+#define CAPABILITY__AUDIT_CONTROL                 0x40000000UL\n \n #define PASSWD__PASSWD                            0x00000001UL\n #define PASSWD__CHFN                              0x00000002UL\n@@ -900,3 +902,29 @@\n #define NSCD__SHMEMGRP                            0x00000040UL\n #define NSCD__SHMEMHOST                           0x00000080UL\n \n+#define ASSOCIATION__SENDTO                       0x00000001UL\n+#define ASSOCIATION__RECVFROM                     0x00000002UL\n+\n+#define NETLINK_KOBJECT_UEVENT_SOCKET__IOCTL      0x00000001UL\n+#define NETLINK_KOBJECT_UEVENT_SOCKET__READ       0x00000002UL\n+#define NETLINK_KOBJECT_UEVENT_SOCKET__WRITE      0x00000004UL\n+#define NETLINK_KOBJECT_UEVENT_SOCKET__CREATE     0x00000008UL\n+#define NETLINK_KOBJECT_UEVENT_SOCKET__GETATTR    0x00000010UL\n+#define NETLINK_KOBJECT_UEVENT_SOCKET__SETATTR    0x00000020UL\n+#define NETLINK_KOBJECT_UEVENT_SOCKET__LOCK       0x00000040UL\n+#define NETLINK_KOBJECT_UEVENT_SOCKET__RELABELFROM 0x00000080UL\n+#define NETLINK_KOBJECT_UEVENT_SOCKET__RELABELTO  0x00000100UL\n+#define NETLINK_KOBJECT_UEVENT_SOCKET__APPEND     0x00000200UL\n+#define NETLINK_KOBJECT_UEVENT_SOCKET__BIND       0x00000400UL\n+#define NETLINK_KOBJECT_UEVENT_SOCKET__CONNECT    0x00000800UL\n+#define NETLINK_KOBJECT_UEVENT_SOCKET__LISTEN     0x00001000UL\n+#define NETLINK_KOBJECT_UEVENT_SOCKET__ACCEPT     0x00002000UL\n+#define NETLINK_KOBJECT_UEVENT_SOCKET__GETOPT     0x00004000UL\n+#define NETLINK_KOBJECT_UEVENT_SOCKET__SETOPT     0x00008000UL\n+#define NETLINK_KOBJECT_UEVENT_SOCKET__SHUTDOWN   0x00010000UL\n+#define NETLINK_KOBJECT_UEVENT_SOCKET__RECVFROM   0x00020000UL\n+#define NETLINK_KOBJECT_UEVENT_SOCKET__SENDTO     0x00040000UL\n+#define NETLINK_KOBJECT_UEVENT_SOCKET__RECV_MSG   0x00080000UL\n+#define NETLINK_KOBJECT_UEVENT_SOCKET__SEND_MSG   0x00100000UL\n+#define NETLINK_KOBJECT_UEVENT_SOCKET__NAME_BIND  0x00200000UL\n+"}}
{"input": {"original code": "S_(\"pax\")\n    S_(\"netlink_route_socket\")\n    S_(\"netlink_firewall_socket\")\n    S_(\"netlink_tcpdiag_socket\")\n    S_(\"netlink_nflog_socket\")\n    S_(\"netlink_xfrm_socket\")\n    S_(\"netlink_selinux_socket\")\n    S_(\"netlink_audit_socket\")\n    S_(\"netlink_ip6fw_socket\")\n    S_(\"netlink_dnrt_socket\")\n    S_(\"dbus\")\n    S_(\"nscd\")", "instruction": "This patch adds SELinux support for the KOBJECT_UEVENT Netlink family, so"}, "output": {"diff codes": "@@ -56,3 +56,5 @@\n     S_(\"netlink_dnrt_socket\")\n     S_(\"dbus\")\n     S_(\"nscd\")\n+    S_(\"association\")\n+    S_(\"netlink_kobject_uevent_socket\")"}}
{"input": {"original code": "#define SECCLASS_PAX                                     42\n#define SECCLASS_NETLINK_ROUTE_SOCKET                    43\n#define SECCLASS_NETLINK_FIREWALL_SOCKET                 44\n#define SECCLASS_NETLINK_TCPDIAG_SOCKET                  45\n#define SECCLASS_NETLINK_NFLOG_SOCKET                    46\n#define SECCLASS_NETLINK_XFRM_SOCKET                     47\n#define SECCLASS_NETLINK_SELINUX_SOCKET                  48\n#define SECCLASS_NETLINK_AUDIT_SOCKET                    49\n#define SECCLASS_NETLINK_IP6FW_SOCKET                    50\n#define SECCLASS_NETLINK_DNRT_SOCKET                     51\n#define SECCLASS_DBUS                                    52\n#define SECCLASS_NSCD                                    53\n\n/*\n * Security identifier indices for initial entities\n */\n#define SECINITSID_KERNEL                               1\n#define SECINITSID_SECURITY                             2\n#define SECINITSID_UNLABELED                            3\n#define SECINITSID_FS                                   4", "instruction": "This patch adds SELinux support for the KOBJECT_UEVENT Netlink family, so"}, "output": {"diff codes": "@@ -58,6 +58,8 @@\n #define SECCLASS_NETLINK_DNRT_SOCKET                     51\n #define SECCLASS_DBUS                                    52\n #define SECCLASS_NSCD                                    53\n+#define SECCLASS_ASSOCIATION                             54\n+#define SECCLASS_NETLINK_KOBJECT_UEVENT_SOCKET           55\n \n /*\n  * Security identifier indices for initial entities"}}
{"input": {"original code": "* mistake.\n */\nint do_signal(sigset_t *oldset, struct pt_regs *regs)\n{\n\tsiginfo_t info;\n\tstruct k_sigaction ka;\n\tunsigned long frame, newsp;\n\tint signr, ret;\n\n\tif (current->flags & PF_FREEZE) {\n\t\trefrigerator(PF_FREEZE);\n\t\tsignr = 0;\n\t\tret = regs->gpr[3];\n\t\tif (!signal_pending(current))\n\t\t\tgoto no_signal;\n\t}\n\n\tif (!oldset)\n\t\toldset = &current->blocked;", "instruction": "The code that went into arch/ppc/kernel/signal.c recently to handle process"}, "output": {"diff codes": "@@ -708,7 +708,6 @@ int do_signal(sigset_t *oldset, struct pt_regs *regs)\n \tif (current->flags & PF_FREEZE) {\n \t\trefrigerator(PF_FREEZE);\n \t\tsignr = 0;\n-\t\tret = regs->gpr[3];\n \t\tif (!signal_pending(current))\n \t\t\tgoto no_signal;\n \t}\n@@ -719,7 +718,7 @@ int do_signal(sigset_t *oldset, struct pt_regs *regs)\n \tnewsp = frame = 0;\n \n \tsignr = get_signal_to_deliver(&info, &ka, regs, NULL);\n-\n+ no_signal:\n \tif (TRAP(regs) == 0x0C00\t\t/* System Call! */\n \t    && regs->ccr & 0x10000000\t\t/* error signalled */\n \t    && ((ret = regs->gpr[3]) == ERESTARTSYS\n@@ -735,7 +734,6 @@ int do_signal(sigset_t *oldset, struct pt_regs *regs)\n \t\t\tregs->gpr[3] = EINTR;\n \t\t\t/* note that the cr0.SO bit is already set */\n \t\t} else {\n-no_signal:\n \t\t\tregs->nip -= 4;\t/* Back up & retry system call */\n \t\t\tregs->result = 0;\n \t\t\tregs->trap = 0;"}}
{"input": {"original code": "extern struct ppc4xx_uic_settings ppc4xx_core_uic_cfg[NR_UICS]\n    __attribute__ ((weak));\nextern unsigned char ppc4xx_uic_ext_irq_cfg[] __attribute__ ((weak));\n\n#define IRQ_MASK_UIC0(irq)\t\t(1 << (31 - (irq)))\n#define IRQ_MASK_UICx(irq)\t\t(1 << (31 - ((irq) & 0x1f)))\n#define IRQ_MASK_UIC1(irq)\t\tIRQ_MASK_UICx(irq)\n#define IRQ_MASK_UIC2(irq)\t\tIRQ_MASK_UICx(irq)\n\n#define UIC_HANDLERS(n)\t\t\t\t\t\t\t\\\nstatic void ppc4xx_uic##n##_enable(unsigned int irq)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tppc_cached_irq_mask[n] |= IRQ_MASK_UIC##n(irq);\t\t\t\\\n\tmtdcr(DCRN_UIC_ER(UIC##n), ppc_cached_irq_mask[n]);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic void ppc4xx_uic##n##_disable(unsigned int irq)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tppc_cached_irq_mask[n] &= ~IRQ_MASK_UIC##n(irq);\t\t\\\n\tmtdcr(DCRN_UIC_ER(UIC##n), ppc_cached_irq_mask[n]);\t\t\\", "instruction": "This patch adds interrupt acknowledge to the PPC4xx PIC enable_irq"}, "output": {"diff codes": "@@ -41,7 +41,10 @@ extern unsigned char ppc4xx_uic_ext_irq_cfg[] __attribute__ ((weak));\n #define UIC_HANDLERS(n)\t\t\t\t\t\t\t\\\n static void ppc4xx_uic##n##_enable(unsigned int irq)\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-\tppc_cached_irq_mask[n] |= IRQ_MASK_UIC##n(irq);\t\t\t\\\n+\tu32 mask = IRQ_MASK_UIC##n(irq);\t\t\t\t\\\n+\tif (irq_desc[irq].status & IRQ_LEVEL)\t\t\t\t\\\n+\t\tmtdcr(DCRN_UIC_SR(UIC##n), mask);\t\t\t\\\n+\tppc_cached_irq_mask[n] |= mask;\t\t\t\t\t\\\n \tmtdcr(DCRN_UIC_ER(UIC##n), ppc_cached_irq_mask[n]);\t\t\\\n }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\"}}
{"input": {"original code": "if (debugger_sstep(regs))\n\t\treturn;\n\t_exception(SIGTRAP, regs, TRAP_TRACE, 0);\n}\n\nvoid AlignmentException(struct pt_regs *regs)\n{\n\tint fixed;\n\n\tfixed = fix_alignment(regs);\n\tif (fixed == 1) {\n\t\tregs->nip += 4;\t/* skip over emulated instruction */\n\t\treturn;\n\t}\n\tif (fixed == -EFAULT) {\n\t\t/* fixed == -EFAULT means the operand address was bad */\n\t\tif (user_mode(regs))\n\t\t\t_exception(SIGSEGV, regs, SEGV_ACCERR, regs->dar);\n\t\telse\n\t\t\tbad_page_fault(regs, regs->dar, SIGSEGV);", "instruction": "On ppc, we emulate instructions that cause alignment exceptions.  If we are"}, "output": {"diff codes": "@@ -679,6 +679,7 @@ void AlignmentException(struct pt_regs *regs)\n \tfixed = fix_alignment(regs);\n \tif (fixed == 1) {\n \t\tregs->nip += 4;\t/* skip over emulated instruction */\n+\t\temulate_single_step(regs);\n \t\treturn;\n \t}\n \tif (fixed == -EFAULT) {"}}
{"input": {"original code": "/*\n *  arch/ppc/platforms/pmac_cpufreq.c\n *\n *  Copyright (C) 2002 - 2004 Benjamin Herrenschmidt <benh@kernel.crashing.org>\n *  Copyright (C) 2004        John Steele Scott <toojays@toojays.net>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n *\n */", "instruction": "This patch updates the PowerMac cpufreq driver.  It depends on the addition"}, "output": {"diff codes": "@@ -1,13 +1,18 @@\n /*\n  *  arch/ppc/platforms/pmac_cpufreq.c\n  *\n- *  Copyright (C) 2002 - 2004 Benjamin Herrenschmidt <benh@kernel.crashing.org>\n+ *  Copyright (C) 2002 - 2005 Benjamin Herrenschmidt <benh@kernel.crashing.org>\n  *  Copyright (C) 2004        John Steele Scott <toojays@toojays.net>\n  *\n  * This program is free software; you can redistribute it and/or modify\n  * it under the terms of the GNU General Public License version 2 as\n  * published by the Free Software Foundation.\n  *\n+ * TODO: Need a big cleanup here. Basically, we need to have different\n+ * cpufreq_driver structures for the different type of HW instead of the\n+ * current mess. We also need to better deal with the detection of the\n+ * type of machine.\n+ *\n  */\n \n #include <linux/config.h>\n@@ -35,6 +40,7 @@\n #include <asm/time.h>\n #include <asm/system.h>\n #include <asm/open_pic.h>\n+#include <asm/keylargo.h>\n \n /* WARNING !!! This will cause calibrate_delay() to be called,\n  * but this is an __init function ! So you MUST go edit\n@@ -61,11 +67,13 @@ extern void low_sleep_handler(void);\n static unsigned int low_freq;\n static unsigned int hi_freq;\n static unsigned int cur_freq;\n+static unsigned int sleep_freq;\n \n /*\n  * Different models uses different mecanisms to switch the frequency\n  */\n static int (*set_speed_proc)(int low_speed);\n+static unsigned int (*get_speed_proc)(void);\n \n /*\n  * Some definitions used by the various speedprocs\n@@ -73,6 +81,8 @@ static int (*set_speed_proc)(int low_speed);\n static u32 voltage_gpio;\n static u32 frequency_gpio;\n static u32 slew_done_gpio;\n+static int no_schedule;\n+static int has_cpu_l2lve;\n \n \n #define PMAC_CPU_LOW_SPEED\t1\n@@ -90,6 +100,14 @@ static struct cpufreq_frequency_table pmac_cpu_freqs[] = {\n \t{0,\t\t\tCPUFREQ_TABLE_END},\n };\n \n+static inline void local_delay(unsigned long ms)\n+{\n+\tif (no_schedule)\n+\t\tmdelay(ms);\n+\telse\n+\t\tmsleep(ms);\n+}\n+\n static inline void wakeup_decrementer(void)\n {\n \tset_dec(tb_ticks_per_jiffy);\n@@ -118,20 +136,48 @@ static inline void debug_calc_bogomips(void)\n  */\n static int __pmac cpu_750fx_cpu_speed(int low_speed)\n {\n-#ifdef DEBUG_FREQ\n-\tprintk(KERN_DEBUG \"HID1, before: %x\\n\", mfspr(SPRN_HID1));\n-#endif\n+\tu32 hid2;\n+\n+\tif (low_speed == 0) {\n+\t\t/* ramping up, set voltage first */\n+\t\tpmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL, voltage_gpio, 0x05);\n+\t\t/* Make sure we sleep for at least 1ms */\n+\t\tlocal_delay(10);\n+\n+\t\t/* tweak L2 for high voltage */\n+\t\tif (has_cpu_l2lve) {\n+\t\t\thid2 = mfspr(SPRN_HID2);\n+\t\t\thid2 &= ~0x2000;\n+\t\t\tmtspr(SPRN_HID2, hid2);\n+\t\t}\n+\t}\n #ifdef CONFIG_6xx\n \tlow_choose_750fx_pll(low_speed);\n #endif\n-#ifdef DEBUG_FREQ\n-\tprintk(KERN_DEBUG \"HID1, after: %x\\n\", mfspr(SPRN_HID1));\n-\tdebug_calc_bogomips();\n-#endif\n+\tif (low_speed == 1) {\n+\t\t/* tweak L2 for low voltage */\n+\t\tif (has_cpu_l2lve) {\n+\t\t\thid2 = mfspr(SPRN_HID2);\n+\t\t\thid2 |= 0x2000;\n+\t\t\tmtspr(SPRN_HID2, hid2);\n+\t\t}\n+\n+\t\t/* ramping down, set voltage last */\n+\t\tpmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL, voltage_gpio, 0x04);\n+\t\tlocal_delay(10);\n+\t}\n \n \treturn 0;\n }\n \n+static unsigned int __pmac cpu_750fx_get_cpu_speed(void)\n+{\n+\tif (mfspr(SPRN_HID1) & HID1_PS)\n+\t\treturn low_freq;\n+\telse\n+\t\treturn hi_freq;\n+}\n+\n /* Switch CPU speed using DFS */\n static int __pmac dfs_set_cpu_speed(int low_speed)\n {\n@@ -139,22 +185,25 @@ static int __pmac dfs_set_cpu_speed(int low_speed)\n \t\t/* ramping up, set voltage first */\n \t\tpmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL, voltage_gpio, 0x05);\n \t\t/* Make sure we sleep for at least 1ms */\n-\t\tmsleep(1);\n+\t\tlocal_delay(1);\n \t}\n \n \t/* set frequency */\n+#ifdef CONFIG_6xx\n \tlow_choose_7447a_dfs(low_speed);\n+#endif\n+\tudelay(100);\n \n \tif (low_speed == 1) {\n \t\t/* ramping down, set voltage last */\n \t\tpmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL, voltage_gpio, 0x04);\n-\t\tmsleep(1);\n+\t\tlocal_delay(1);\n \t}\n \n \treturn 0;\n }\n \n-static unsigned int __pmac dfs_get_cpu_speed(unsigned int cpu)\n+static unsigned int __pmac dfs_get_cpu_speed(void)\n {\n \tif (mfspr(SPRN_HID1) & HID1_DFS)\n \t\treturn low_freq;\n@@ -167,30 +216,35 @@ static unsigned int __pmac dfs_get_cpu_speed(unsigned int cpu)\n  */\n static int __pmac gpios_set_cpu_speed(int low_speed)\n {\n-\tint gpio;\n+\tint gpio, timeout = 0;\n \n \t/* If ramping up, set voltage first */\n \tif (low_speed == 0) {\n \t\tpmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL, voltage_gpio, 0x05);\n \t\t/* Delay is way too big but it's ok, we schedule */\n-\t\tmsleep(10);\n+\t\tlocal_delay(10);\n \t}\n \n \t/* Set frequency */\n+\tgpio = \tpmac_call_feature(PMAC_FTR_READ_GPIO, NULL, frequency_gpio, 0);\n+\tif (low_speed == ((gpio & 0x01) == 0))\n+\t\tgoto skip;\n+\n \tpmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL, frequency_gpio,\n \t\t\t  low_speed ? 0x04 : 0x05);\n \tudelay(200);\n \tdo {\n-\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n-\t\tschedule_timeout(1);\n+\t\tif (++timeout > 100)\n+\t\t\tbreak;\n+\t\tlocal_delay(1);\n \t\tgpio = pmac_call_feature(PMAC_FTR_READ_GPIO, NULL, slew_done_gpio, 0);\n \t} while((gpio & 0x02) == 0);\n-\n+ skip:\n \t/* If ramping down, set voltage last */\n \tif (low_speed == 1) {\n \t\tpmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL, voltage_gpio, 0x04);\n \t\t/* Delay is way too big but it's ok, we schedule */\n-\t\tmsleep(10);\n+\t\tlocal_delay(10);\n \t}\n \n #ifdef DEBUG_FREQ\n@@ -207,6 +261,8 @@ static int __pmac pmu_set_cpu_speed(int low_speed)\n \tstruct adb_request req;\n \tunsigned long save_l2cr;\n \tunsigned long save_l3cr;\n+\tunsigned int pic_prio;\n+\tunsigned long flags;\n \n \tpreempt_disable();\n \n@@ -214,7 +270,8 @@ static int __pmac pmu_set_cpu_speed(int low_speed)\n \tprintk(KERN_DEBUG \"HID1, before: %x\\n\", mfspr(SPRN_HID1));\n #endif\n \t/* Disable all interrupt sources on openpic */\n- \topenpic_set_priority(0xf);\n+ \tpic_prio = openpic_get_priority();\n+\topenpic_set_priority(0xf);\n \n \t/* Make sure the decrementer won't interrupt us */\n \tasm volatile(\"mtdec %0\" : : \"r\" (0x7fffffff));\n@@ -224,7 +281,7 @@ static int __pmac pmu_set_cpu_speed(int low_speed)\n \tasm volatile(\"mtdec %0\" : : \"r\" (0x7fffffff));\n \n \t/* We can now disable MSR_EE */\n-\tlocal_irq_disable();\n+\tlocal_irq_save(flags);\n \n \t/* Giveup the FPU & vec */\n \tenable_kernel_fp();\n@@ -277,10 +334,10 @@ static int __pmac pmu_set_cpu_speed(int low_speed)\n \twakeup_decrementer();\n \n \t/* Restore interrupts */\n- \topenpic_set_priority(0);\n+ \topenpic_set_priority(pic_prio);\n \n \t/* Let interrupts flow again ... */\n-\tlocal_irq_enable();\n+\tlocal_irq_restore(flags);\n \n #ifdef DEBUG_FREQ\n \tdebug_calc_bogomips();\n@@ -291,9 +348,11 @@ static int __pmac pmu_set_cpu_speed(int low_speed)\n \treturn 0;\n }\n \n-static int __pmac do_set_cpu_speed(int speed_mode)\n+static int __pmac do_set_cpu_speed(int speed_mode, int notify)\n {\n \tstruct cpufreq_freqs freqs;\n+\tunsigned long l3cr;\n+\tstatic unsigned long prev_l3cr;\n \n \tfreqs.old = cur_freq;\n \tfreqs.new = (speed_mode == PMAC_CPU_HIGH_SPEED) ? hi_freq : low_freq;\n@@ -302,14 +361,35 @@ static int __pmac do_set_cpu_speed(int speed_mode)\n \tif (freqs.old == freqs.new)\n \t\treturn 0;\n \n-\tcpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);\n+\tif (notify)\n+\t\tcpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);\n+\tif (speed_mode == PMAC_CPU_LOW_SPEED &&\n+\t    cpu_has_feature(CPU_FTR_L3CR)) {\n+\t\tl3cr = _get_L3CR();\n+\t\tif (l3cr & L3CR_L3E) {\n+\t\t\tprev_l3cr = l3cr;\n+\t\t\t_set_L3CR(0);\n+\t\t}\n+\t}\n \tset_speed_proc(speed_mode == PMAC_CPU_LOW_SPEED);\n-\tcpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);\n+\tif (speed_mode == PMAC_CPU_HIGH_SPEED &&\n+\t    cpu_has_feature(CPU_FTR_L3CR)) {\n+\t\tl3cr = _get_L3CR();\n+\t\tif ((prev_l3cr & L3CR_L3E) && l3cr != prev_l3cr)\n+\t\t\t_set_L3CR(prev_l3cr);\n+\t}\n+\tif (notify)\n+\t\tcpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);\n \tcur_freq = (speed_mode == PMAC_CPU_HIGH_SPEED) ? hi_freq : low_freq;\n \n \treturn 0;\n }\n \n+static unsigned int __pmac pmac_cpufreq_get_speed(unsigned int cpu)\n+{\n+\treturn cur_freq;\n+}\n+\n static int __pmac pmac_cpufreq_verify(struct cpufreq_policy *policy)\n {\n \treturn cpufreq_frequency_table_verify(policy, pmac_cpu_freqs);\n@@ -325,7 +405,7 @@ static int __pmac pmac_cpufreq_target(\tstruct cpufreq_policy *policy,\n \t\t\ttarget_freq, relation, &newstate))\n \t\treturn -EINVAL;\n \n-\treturn do_set_cpu_speed(newstate);\n+\treturn do_set_cpu_speed(newstate, 1);\n }\n \n unsigned int __pmac pmac_get_one_cpufreq(int i)\n@@ -349,19 +429,65 @@ static int __pmac pmac_cpufreq_cpu_init(struct cpufreq_policy *policy)\n static u32 __pmac read_gpio(struct device_node *np)\n {\n \tu32 *reg = (u32 *)get_property(np, \"reg\", NULL);\n+\tu32 offset;\n \n \tif (reg == NULL)\n \t\treturn 0;\n \t/* That works for all keylargos but shall be fixed properly\n-\t * some day...\n+\t * some day... The problem is that it seems we can't rely\n+\t * on the \"reg\" property of the GPIO nodes, they are either\n+\t * relative to the base of KeyLargo or to the base of the\n+\t * GPIO space, and the device-tree doesn't help.\n+\t */\n+\toffset = *reg;\n+\tif (offset < KEYLARGO_GPIO_LEVELS0)\n+\t\toffset += KEYLARGO_GPIO_LEVELS0;\n+\treturn offset;\n+}\n+\n+static int __pmac pmac_cpufreq_suspend(struct cpufreq_policy *policy, u32 state)\n+{\n+\t/* Ok, this could be made a bit smarter, but let's be robust for now. We\n+\t * always force a speed change to high speed before sleep, to make sure\n+\t * we have appropriate voltage and/or bus speed for the wakeup process,\n+\t * and to make sure our loops_per_jiffies are \"good enough\", that is will\n+\t * not cause too short delays if we sleep in low speed and wake in high\n+\t * speed..\n \t */\n-\treturn 0x50 + (*reg);\n+\tno_schedule = 1;\n+\tsleep_freq = cur_freq;\n+\tif (cur_freq == low_freq)\n+\t\tdo_set_cpu_speed(PMAC_CPU_HIGH_SPEED, 0);\n+\treturn 0;\n+}\n+\n+static int __pmac pmac_cpufreq_resume(struct cpufreq_policy *policy)\n+{\n+\t/* If we resume, first check if we have a get() function */\n+\tif (get_speed_proc)\n+\t\tcur_freq = get_speed_proc();\n+\telse\n+\t\tcur_freq = 0;\n+\n+\t/* We don't, hrm... we don't really know our speed here, best\n+\t * is that we force a switch to whatever it was, which is\n+\t * probably high speed due to our suspend() routine\n+\t */\n+\tdo_set_cpu_speed(sleep_freq == low_freq ? PMAC_CPU_LOW_SPEED\n+\t\t\t : PMAC_CPU_HIGH_SPEED, 0);\n+\n+\tno_schedule = 0;\n+\treturn 0;\n }\n \n static struct cpufreq_driver pmac_cpufreq_driver = {\n \t.verify \t= pmac_cpufreq_verify,\n \t.target \t= pmac_cpufreq_target,\n+\t.get\t\t= pmac_cpufreq_get_speed,\n \t.init\t\t= pmac_cpufreq_cpu_init,\n+\t.suspend\t= pmac_cpufreq_suspend,\n+\t.resume\t\t= pmac_cpufreq_resume,\n+\t.flags\t\t= CPUFREQ_PM_NO_WARN,\n \t.name\t\t= \"powermac\",\n \t.owner\t\t= THIS_MODULE,\n };\n@@ -461,14 +587,14 @@ static int __pmac pmac_cpufreq_init_MacRISC3(struct device_node *cpunode)\n static int __pmac pmac_cpufreq_init_7447A(struct device_node *cpunode)\n {\n \tstruct device_node *volt_gpio_np;\n-\tu32 *reg;\n-\tstruct cpufreq_driver *driver = &pmac_cpufreq_driver;\n \n-\t/* Look for voltage GPIO */\n+\tif (get_property(cpunode, \"dynamic-power-step\", NULL) == NULL)\n+\t\treturn 1;\n+\n \tvolt_gpio_np = of_find_node_by_name(NULL, \"cpu-vcore-select\");\n-\treg = (u32 *)get_property(volt_gpio_np, \"reg\", NULL);\n-\tvoltage_gpio = *reg;\n-\tif (!volt_gpio_np){\n+\tif (volt_gpio_np)\n+\t\tvoltage_gpio = read_gpio(volt_gpio_np);\n+\tif (!voltage_gpio){\n \t\tprintk(KERN_ERR \"cpufreq: missing cpu-vcore-select gpio\\n\");\n \t\treturn 1;\n \t}\n@@ -478,9 +604,37 @@ static int __pmac pmac_cpufreq_init_7447A(struct device_node *cpunode)\n \tlow_freq = cur_freq/2;\n \n \t/* Read actual frequency from CPU */\n-\tdriver->get = dfs_get_cpu_speed;\n-\tcur_freq = driver->get(0);\n+\tcur_freq = dfs_get_cpu_speed();\n \tset_speed_proc = dfs_set_cpu_speed;\n+\tget_speed_proc = dfs_get_cpu_speed;\n+\n+\treturn 0;\n+}\n+\n+static int __pmac pmac_cpufreq_init_750FX(struct device_node *cpunode)\n+{\n+\tstruct device_node *volt_gpio_np;\n+\tu32 pvr, *value;\n+\n+\tif (get_property(cpunode, \"dynamic-power-step\", NULL) == NULL)\n+\t\treturn 1;\n+\n+\thi_freq = cur_freq;\n+\tvalue = (u32 *)get_property(cpunode, \"reduced-clock-frequency\", NULL);\n+\tif (!value)\n+\t\treturn 1;\n+\tlow_freq = (*value) / 1000;\n+\n+\tvolt_gpio_np = of_find_node_by_name(NULL, \"cpu-vcore-select\");\n+\tif (volt_gpio_np)\n+\t\tvoltage_gpio = read_gpio(volt_gpio_np);\n+\n+\tpvr = mfspr(SPRN_PVR);\n+\thas_cpu_l2lve = !((pvr & 0xf00) == 0x100);\n+\n+\tset_speed_proc = cpu_750fx_cpu_speed;\n+\tget_speed_proc = cpu_750fx_get_cpu_speed;\n+\tcur_freq = cpu_750fx_get_cpu_speed();\n \n \treturn 0;\n }\n@@ -543,16 +697,8 @@ static int __init pmac_cpufreq_setup(void)\n \t\tset_speed_proc = pmu_set_cpu_speed;\n \t}\n \t/* Else check for 750FX */\n-\telse if (PVR_VER(mfspr(SPRN_PVR)) == 0x7000) {\n-\t\tif (get_property(cpunode, \"dynamic-power-step\", NULL) == NULL)\n-\t\t\tgoto out;\n-\t\thi_freq = cur_freq;\n-\t\tvalue = (u32 *)get_property(cpunode, \"reduced-clock-frequency\", NULL);\n-\t\tif (!value)\n-\t\t\tgoto out;\n-\t\tlow_freq = (*value) / 1000;\t\t\n-\t\tset_speed_proc = cpu_750fx_cpu_speed;\n-\t}\n+\telse if (PVR_VER(mfspr(SPRN_PVR)) == 0x7000)\n+\t\tpmac_cpufreq_init_750FX(cpunode);\n out:\n \tif (set_speed_proc == NULL)\n \t\treturn -ENODEV;"}}
{"input": {"original code": "UN_OUT(UNI_N_POWER_MGT, UNI_N_POWER_MGT_IDLE2);\n\t\t} else {\n\t\t\tUN_OUT(UNI_N_POWER_MGT, UNI_N_POWER_MGT_NORMAL);\n\t\t\tudelay(10);\n\t\t\tUN_OUT(UNI_N_HWINIT_STATE, UNI_N_HWINIT_STATE_RUNNING);\n\t\t\tudelay(10);\n\t\t}\n\t\treturn 0;\n\t}\n\tif ((pmac_mb.board_flags & PMAC_MB_CAN_SLEEP) == 0)\n\t\treturn -EPERM;\n\n#ifdef CONFIG_CPU_FREQ_PMAC\n\t/* XXX should be elsewhere */\n\tif (machine_is_compatible(\"PowerBook6,5\") ||\n\t    machine_is_compatible(\"PowerBook6,4\") ||\n\t    machine_is_compatible(\"PowerBook5,5\") ||\n\t    machine_is_compatible(\"PowerBook5,4\")) {\n\t\tstruct device_node *volt_gpio_np;\n\t\tu32 *reg = NULL;", "instruction": "This patch updates the PowerMac cpufreq driver.  It depends on the addition"}, "output": {"diff codes": "@@ -1779,32 +1779,6 @@ core99_sleep_state(struct device_node* node, long param, long value)\n \tif ((pmac_mb.board_flags & PMAC_MB_CAN_SLEEP) == 0)\n \t\treturn -EPERM;\n \n-#ifdef CONFIG_CPU_FREQ_PMAC\n-\t/* XXX should be elsewhere */\n-\tif (machine_is_compatible(\"PowerBook6,5\") ||\n-\t    machine_is_compatible(\"PowerBook6,4\") ||\n-\t    machine_is_compatible(\"PowerBook5,5\") ||\n-\t    machine_is_compatible(\"PowerBook5,4\")) {\n-\t\tstruct device_node *volt_gpio_np;\n-\t\tu32 *reg = NULL;\n-\n-\t\tvolt_gpio_np = of_find_node_by_name(NULL, \"cpu-vcore-select\");\n-\t\tif (volt_gpio_np != NULL)\n-\t\t\treg = (u32 *)get_property(volt_gpio_np, \"reg\", NULL);\n-\t\tif (reg != NULL) {\n-\t\t\t/* Set the CPU voltage high if sleeping */\n-\t\t\tif (value == 1) {\n-\t\t\t\tpmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL,\n-\t\t\t\t\t\t  *reg, 0x05);\n-\t\t\t} else if (value == 0 && (mfspr(SPRN_HID1) & HID1_DFS)) {\n-\t\t\t\tpmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL,\n-\t\t\t\t\t\t  *reg, 0x04);\n-\t\t\t}\n-\t\t\tmdelay(2);\n-\t\t}\n-\t}\n-#endif /* CONFIG_CPU_FREQ_PMAC */\n-\n \tif (value == 1)\n \t\treturn core99_sleep();\n \telse if (value == 0)"}}
{"input": {"original code": "static void openpic_enable_irq(u_int irq);\nstatic void openpic_disable_irq(u_int irq);\nstatic void openpic_initirq(u_int irq, u_int pri, u_int vector, int polarity,\n\t\t\t    int is_level);\nstatic void openpic_mapirq(u_int irq, cpumask_t cpumask, cpumask_t keepmask);\n\n/*\n * These functions are not used but the code is kept here\n * for completeness and future reference.\n */\n#ifdef notused\nstatic void openpic_enable_8259_pass_through(void);\nstatic u_int openpic_get_priority(void);\nstatic u_int openpic_get_spurious(void);\nstatic void openpic_set_sense(u_int irq, int sense);\n#endif /* notused */\n\n/*\n * Description of the openpic for the higher-level irq code\n */", "instruction": "This patch updates the PowerMac cpufreq driver.  It depends on the addition"}, "output": {"diff codes": "@@ -78,7 +78,6 @@ static void openpic_mapirq(u_int irq, cpumask_t cpumask, cpumask_t keepmask);\n  */\n #ifdef notused\n static void openpic_enable_8259_pass_through(void);\n-static u_int openpic_get_priority(void);\n static u_int openpic_get_spurious(void);\n static void openpic_set_sense(u_int irq, int sense);\n #endif /* notused */\n@@ -465,8 +464,7 @@ void openpic_eoi(void)\n \t(void)openpic_read(&OpenPIC->THIS_CPU.EOI);\n }\n \n-#ifdef notused\n-static u_int openpic_get_priority(void)\n+u_int openpic_get_priority(void)\n {\n \tDECL_THIS_CPU;\n \n@@ -474,7 +472,6 @@ static u_int openpic_get_priority(void)\n \treturn openpic_readfield(&OpenPIC->THIS_CPU.Current_Task_Priority,\n \t\t\t\t OPENPIC_CURRENT_TASK_PRIORITY_MASK);\n }\n-#endif /* notused */\n \n void openpic_set_priority(u_int pri)\n {"}}
{"input": {"original code": "extern u_int openpic_irq(void);\nextern void openpic_eoi(void);\nextern void openpic_request_IPIs(void);\nextern void do_openpic_setup_cpu(void);\nextern int openpic_get_irq(struct pt_regs *regs);\nextern void openpic_reset_processor_phys(u_int cpumask);\nextern void openpic_setup_ISU(int isu_num, unsigned long addr);\nextern void openpic_cause_IPI(u_int ipi, cpumask_t cpumask);\nextern void smp_openpic_message_pass(int target, int msg, unsigned long data,\n\t\t\t\t     int wait);\nextern void openpic_set_k2_cascade(int irq);\nextern void openpic_set_priority(u_int pri);\n\nextern inline int openpic_to_irq(int irq)\n{\n\t/* IRQ 0 usually means 'disabled'.. don't mess with it\n\t * exceptions to this (sandpoint maybe?)\n\t * shouldn't use openpic_to_irq\n\t */\n\tif (irq != 0){", "instruction": "This patch updates the PowerMac cpufreq driver.  It depends on the addition"}, "output": {"diff codes": "@@ -56,6 +56,7 @@ extern void smp_openpic_message_pass(int target, int msg, unsigned long data,\n \t\t\t\t     int wait);\n extern void openpic_set_k2_cascade(int irq);\n extern void openpic_set_priority(u_int pri);\n+extern u_int openpic_get_priority(void);\n \n extern inline int openpic_to_irq(int irq)\n {"}}
{"input": {"original code": "#define HID0_NOPDST\t(1<<1)\t\t/* No-op dst, dstt, etc. instr. */\n#define HID0_NOPTI\t(1<<0)\t\t/* No-op dcbt and dcbst instr. */\n\n#define SPRN_HID1\t0x3F1\t\t/* Hardware Implementation Register 1 */\n#define HID1_EMCP\t(1<<31)\t\t/* 7450 Machine Check Pin Enable */\n#define HID1_DFS\t(1<<22)\t\t/* 7447A Dynamic Frequency Scaling */\n#define HID1_PC0\t(1<<16)\t\t/* 7450 PLL_CFG[0] */\n#define HID1_PC1\t(1<<15)\t\t/* 7450 PLL_CFG[1] */\n#define HID1_PC2\t(1<<14)\t\t/* 7450 PLL_CFG[2] */\n#define HID1_PC3\t(1<<13)\t\t/* 7450 PLL_CFG[3] */\n#define HID1_SYNCBE\t(1<<11)\t\t/* 7450 ABE for sync, eieio */\n#define HID1_ABE\t(1<<10)\t\t/* 7450 Address Broadcast Enable */\n#define SPRN_HID2\t0x3F8\t\t/* Hardware Implementation Register 2 */\n#define SPRN_IABR\t0x3F2\t/* Instruction Address Breakpoint Register */\n#define SPRN_HID4\t0x3F4\t\t/* 970 HID4 */\n#define SPRN_HID5\t0x3F6\t\t/* 970 HID5 */\n#if !defined(SPRN_IAC1) && !defined(SPRN_IAC2)\n#define SPRN_IAC1\t0x3F4\t\t/* Instruction Address Compare 1 */\n#define SPRN_IAC2\t0x3F5\t\t/* Instruction Address Compare 2 */\n#endif", "instruction": "This patch updates the PowerMac cpufreq driver.  It depends on the addition"}, "output": {"diff codes": "@@ -181,6 +181,7 @@\n #define HID1_PC3\t(1<<13)\t\t/* 7450 PLL_CFG[3] */\n #define HID1_SYNCBE\t(1<<11)\t\t/* 7450 ABE for sync, eieio */\n #define HID1_ABE\t(1<<10)\t\t/* 7450 Address Broadcast Enable */\n+#define HID1_PS\t\t(1<<16)\t\t/* 750FX PLL selection */\n #define SPRN_HID2\t0x3F8\t\t/* Hardware Implementation Register 2 */\n #define SPRN_IABR\t0x3F2\t/* Instruction Address Breakpoint Register */\n #define SPRN_HID4\t0x3F4\t\t/* 970 HID4 */"}}
{"input": {"original code": "preempt_disable();\n\tpmac_early_vresume_proc = proc;\n\tpmac_early_vresume_data = data;\n\tpreempt_enable();\n}\nEXPORT_SYMBOL(pmac_set_early_video_resume);\n\nvoid __pmac pmac_call_early_video_resume(void)\n{\n\tif (pmac_early_vresume_proc)\n\t\tpmac_early_vresume_proc(pmac_early_vresume_data);\n}", "instruction": "My previous patch that added sleep support for uninorth-agp and some AGP"}, "output": {"diff codes": "@@ -2944,3 +2944,48 @@ void __pmac pmac_call_early_video_resume(void)\n \tif (pmac_early_vresume_proc)\n \t\tpmac_early_vresume_proc(pmac_early_vresume_data);\n }\n+\n+/*\n+ * AGP related suspend/resume code\n+ */\n+\n+static struct pci_dev *pmac_agp_bridge __pmacdata;\n+static int (*pmac_agp_suspend)(struct pci_dev *bridge) __pmacdata;\n+static int (*pmac_agp_resume)(struct pci_dev *bridge) __pmacdata;\n+\n+void __pmac pmac_register_agp_pm(struct pci_dev *bridge,\n+\t\t\t\t int (*suspend)(struct pci_dev *bridge),\n+\t\t\t\t int (*resume)(struct pci_dev *bridge))\n+{\n+\tif (suspend || resume) {\n+\t\tpmac_agp_bridge = bridge;\n+\t\tpmac_agp_suspend = suspend;\n+\t\tpmac_agp_resume = resume;\n+\t\treturn;\n+\t}\n+\tif (bridge != pmac_agp_bridge)\n+\t\treturn;\n+\tpmac_agp_suspend = pmac_agp_resume = NULL;\n+\treturn;\n+}\n+EXPORT_SYMBOL(pmac_register_agp_pm);\n+\n+void __pmac pmac_suspend_agp_for_card(struct pci_dev *dev)\n+{\n+\tif (pmac_agp_bridge == NULL || pmac_agp_suspend == NULL)\n+\t\treturn;\n+\tif (pmac_agp_bridge->bus != dev->bus)\n+\t\treturn;\n+\tpmac_agp_suspend(pmac_agp_bridge);\n+}\n+EXPORT_SYMBOL(pmac_suspend_agp_for_card);\n+\n+void __pmac pmac_resume_agp_for_card(struct pci_dev *dev)\n+{\n+\tif (pmac_agp_bridge == NULL || pmac_agp_resume == NULL)\n+\t\treturn;\n+\tif (pmac_agp_bridge->bus != dev->bus)\n+\t\treturn;\n+\tpmac_agp_resume(pmac_agp_bridge);\n+}\n+EXPORT_SYMBOL(pmac_resume_agp_for_card);"}}
{"input": {"original code": "px_hose = pcix_node->phb;\n\tpx_bus = pcix_node->busno;\n\tpx_devfn = pcix_node->devfn;\n\t\n\tearly_read_config_dword(px_hose, px_bus, px_devfn, 0xc4, &cfg);\n\tearly_read_config_dword(px_hose, px_bus, px_devfn, 0xcc, &freq);\n\tdump_HT_speeds(\"PCI-X HT Uplink\", cfg, freq);\n\tearly_read_config_dword(px_hose, px_bus, px_devfn, 0xc8, &cfg);\n\tearly_read_config_dword(px_hose, px_bus, px_devfn, 0xd0, &freq);\n\tdump_HT_speeds(\"PCI-X HT Downlink\", cfg, freq);\n#endif\n}", "instruction": "My previous patch that added sleep support for uninorth-agp and some AGP"}, "output": {"diff codes": "@@ -674,3 +674,67 @@ void __init pmac_check_ht_link(void)\n \tdump_HT_speeds(\"PCI-X HT Downlink\", cfg, freq);\n #endif\n }\n+\n+/*\n+ * Early video resume hook\n+ */\n+\n+static void (*pmac_early_vresume_proc)(void *data) __pmacdata;\n+static void *pmac_early_vresume_data __pmacdata;\n+\n+void pmac_set_early_video_resume(void (*proc)(void *data), void *data)\n+{\n+\tif (_machine != _MACH_Pmac)\n+\t\treturn;\n+\tpreempt_disable();\n+\tpmac_early_vresume_proc = proc;\n+\tpmac_early_vresume_data = data;\n+\tpreempt_enable();\n+}\n+EXPORT_SYMBOL(pmac_set_early_video_resume);\n+\n+\n+/*\n+ * AGP related suspend/resume code\n+ */\n+\n+static struct pci_dev *pmac_agp_bridge __pmacdata;\n+static int (*pmac_agp_suspend)(struct pci_dev *bridge) __pmacdata;\n+static int (*pmac_agp_resume)(struct pci_dev *bridge) __pmacdata;\n+\n+void __pmac pmac_register_agp_pm(struct pci_dev *bridge,\n+\t\t\t\t int (*suspend)(struct pci_dev *bridge),\n+\t\t\t\t int (*resume)(struct pci_dev *bridge))\n+{\n+\tif (suspend || resume) {\n+\t\tpmac_agp_bridge = bridge;\n+\t\tpmac_agp_suspend = suspend;\n+\t\tpmac_agp_resume = resume;\n+\t\treturn;\n+\t}\n+\tif (bridge != pmac_agp_bridge)\n+\t\treturn;\n+\tpmac_agp_suspend = pmac_agp_resume = NULL;\n+\treturn;\n+}\n+EXPORT_SYMBOL(pmac_register_agp_pm);\n+\n+void __pmac pmac_suspend_agp_for_card(struct pci_dev *dev)\n+{\n+\tif (pmac_agp_bridge == NULL || pmac_agp_suspend == NULL)\n+\t\treturn;\n+\tif (pmac_agp_bridge->bus != dev->bus)\n+\t\treturn;\n+\tpmac_agp_suspend(pmac_agp_bridge);\n+}\n+EXPORT_SYMBOL(pmac_suspend_agp_for_card);\n+\n+void __pmac pmac_resume_agp_for_card(struct pci_dev *dev)\n+{\n+\tif (pmac_agp_bridge == NULL || pmac_agp_resume == NULL)\n+\t\treturn;\n+\tif (pmac_agp_bridge->bus != dev->bus)\n+\t\treturn;\n+\tpmac_agp_resume(pmac_agp_bridge);\n+}\n+EXPORT_SYMBOL(pmac_resume_agp_for_card);"}}
{"input": {"original code": "/*\n * UniNorth AGPGART routines.\n */\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/agp_backend.h>\n#include <linux/delay.h>\n#include <asm/uninorth.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include \"agp.h\"\n\n/*\n * NOTES for uninorth3 (G5 AGP) supports :\n *\n * There maybe also possibility to have bigger cache line size for\n * agp (see pmac_pci.c and look for cache line). Need to be investigated\n * by someone.", "instruction": "My previous patch that added sleep support for uninorth-agp and some AGP"}, "output": {"diff codes": "@@ -10,6 +10,7 @@\n #include <asm/uninorth.h>\n #include <asm/pci-bridge.h>\n #include <asm/prom.h>\n+#include <asm/pmac_feature.h>\n #include \"agp.h\"\n \n /*\n@@ -26,6 +27,7 @@\n static int uninorth_rev;\n static int is_u3;\n \n+\n static int uninorth_fetch_size(void)\n {\n \tint i;\n@@ -264,7 +266,8 @@ static void uninorth_agp_enable(struct agp_bridge_data *bridge, u32 mode)\n \t\t\t\t       &scratch);\n \t} while ((scratch & PCI_AGP_COMMAND_AGP) == 0 && ++timeout < 1000);\n \tif ((scratch & PCI_AGP_COMMAND_AGP) == 0)\n-\t\tprintk(KERN_ERR PFX \"failed to write UniNorth AGP command reg\\n\");\n+\t\tprintk(KERN_ERR PFX \"failed to write UniNorth AGP\"\n+\t\t       \" command register\\n\");\n \n \tif (uninorth_rev >= 0x30) {\n \t\t/* This is an AGP V3 */\n@@ -278,13 +281,24 @@ static void uninorth_agp_enable(struct agp_bridge_data *bridge, u32 mode)\n }\n \n #ifdef CONFIG_PM\n-static int agp_uninorth_suspend(struct pci_dev *pdev, pm_message_t state)\n+/*\n+ * These Power Management routines are _not_ called by the normal PCI PM layer,\n+ * but directly by the video driver through function pointers in the device\n+ * tree.\n+ */\n+static int agp_uninorth_suspend(struct pci_dev *pdev)\n {\n+\tstruct agp_bridge_data *bridge;\n \tu32 cmd;\n \tu8 agp;\n \tstruct pci_dev *device = NULL;\n \n-\tif (state != PMSG_SUSPEND)\n+\tbridge = agp_find_bridge(pdev);\n+\tif (bridge == NULL)\n+\t\treturn -ENODEV;\n+\n+\t/* Only one suspend supported */\n+\tif (bridge->dev_private_data)\n \t\treturn 0;\n \n \t/* turn off AGP on the video chip, if it was enabled */\n@@ -315,6 +329,7 @@ static int agp_uninorth_suspend(struct pci_dev *pdev, pm_message_t state)\n \t/* turn off AGP on the bridge */\n \tagp = pci_find_capability(pdev, PCI_CAP_ID_AGP);\n \tpci_read_config_dword(pdev, agp + PCI_AGP_COMMAND, &cmd);\n+\tbridge->dev_private_data = (void *)cmd;\n \tif (cmd & PCI_AGP_COMMAND_AGP) {\n \t\tprintk(\"uninorth-agp: disabling AGP on bridge %s\\n\",\n \t\t\t\tpci_name(pdev));\n@@ -329,9 +344,23 @@ static int agp_uninorth_suspend(struct pci_dev *pdev, pm_message_t state)\n \n static int agp_uninorth_resume(struct pci_dev *pdev)\n {\n+\tstruct agp_bridge_data *bridge;\n+\tu32 command;\n+\n+\tbridge = agp_find_bridge(pdev);\n+\tif (bridge == NULL)\n+\t\treturn -ENODEV;\n+\n+\tcommand = (u32)bridge->dev_private_data;\n+\tbridge->dev_private_data = NULL;\n+\tif (!(command & PCI_AGP_COMMAND_AGP))\n+\t\treturn 0;\n+\n+\tuninorth_agp_enable(bridge, command);\n+\n \treturn 0;\n }\n-#endif\n+#endif /* CONFIG_PM */\n \n static int uninorth_create_gatt_table(struct agp_bridge_data *bridge)\n {\n@@ -575,6 +604,12 @@ static int __devinit agp_uninorth_probe(struct pci_dev *pdev,\n \t\tof_node_put(uninorth_node);\n \t}\n \n+#ifdef CONFIG_PM\n+\t/* Inform platform of our suspend/resume caps */\n+\tpmac_register_agp_pm(pdev, agp_uninorth_suspend, agp_uninorth_resume);\n+#endif\n+\n+\t/* Allocate & setup our driver */\n \tbridge = agp_alloc_bridge();\n \tif (!bridge)\n \t\treturn -ENOMEM;\n@@ -599,6 +634,11 @@ static void __devexit agp_uninorth_remove(struct pci_dev *pdev)\n {\n \tstruct agp_bridge_data *bridge = pci_get_drvdata(pdev);\n \n+#ifdef CONFIG_PM\n+\t/* Inform platform of our suspend/resume caps */\n+\tpmac_register_agp_pm(pdev, NULL, NULL);\n+#endif\n+\n \tagp_remove_bridge(bridge);\n \tagp_put_bridge(bridge);\n }\n@@ -622,10 +662,6 @@ static struct pci_driver agp_uninorth_pci_driver = {\n \t.id_table\t= agp_uninorth_pci_table,\n \t.probe\t\t= agp_uninorth_probe,\n \t.remove\t\t= agp_uninorth_remove,\n-#ifdef CONFIG_PM\n-\t.suspend\t= agp_uninorth_suspend,\n-\t.resume\t\t= agp_uninorth_resume,\n-#endif\n };\n \n static int __init agp_uninorth_init(void)"}}
{"input": {"original code": "/* Switch back PCI power management to D0 */\n\t\tmdelay(100);\n\t\tpci_write_config_word(pdev, par->pm_reg+PCI_PM_CTRL, 0);\n\t\tpci_read_config_word(pdev, par->pm_reg+PCI_PM_CTRL, &pwr_command);\n\t\tmdelay(100);\n\t}\n}\n\nstatic int aty128_pci_suspend(struct pci_dev *pdev, pm_message_t state)\n{\n\tstruct fb_info *info = pci_get_drvdata(pdev);\n\tstruct aty128fb_par *par = info->par;\n\tu8 agp;\n\n\t/* We don't do anything but D2, for now we return 0, but\n\t * we may want to change that. How do we know if the BIOS\n\t * can properly take care of D3 ? Also, with swsusp, we\n\t * know we'll be rebooted, ...\n\t */\n#ifdef CONFIG_PPC_PMAC", "instruction": "My previous patch that added sleep support for uninorth-agp and some AGP"}, "output": {"diff codes": "@@ -2331,7 +2331,6 @@ static int aty128_pci_suspend(struct pci_dev *pdev, pm_message_t state)\n {\n \tstruct fb_info *info = pci_get_drvdata(pdev);\n \tstruct aty128fb_par *par = info->par;\n-\tu8 agp;\n \n \t/* We don't do anything but D2, for now we return 0, but\n \t * we may want to change that. How do we know if the BIOS\n@@ -2369,26 +2368,13 @@ static int aty128_pci_suspend(struct pci_dev *pdev, pm_message_t state)\n \tpar->asleep = 1;\n \tpar->lock_blank = 1;\n \n-\t/* Disable AGP. The AGP host should have done it, but since ordering\n-\t * isn't always properly guaranteed in this specific case, let's make\n-\t * sure it's disabled on card side now. Ultimately, when merging fbdev\n-\t * and dri into some common infrastructure, this will be handled\n-\t * more nicely. The host bridge side will (or will not) be dealt with\n-\t * by the bridge AGP driver, we don't attempt to touch it here.\n+#ifdef CONFIG_PPC_PMAC\n+\t/* On powermac, we have hooks to properly suspend/resume AGP now,\n+\t * use them here. We'll ultimately need some generic support here,\n+\t * but the generic code isn't quite ready for that yet\n \t */\n-\tagp = pci_find_capability(pdev, PCI_CAP_ID_AGP);\n-\tif (agp) {\n-\t\tu32 cmd;\n-\n-\t\tpci_read_config_dword(pdev, agp + PCI_AGP_COMMAND, &cmd);\n-\t\tif (cmd & PCI_AGP_COMMAND_AGP) {\n-\t\t\tprintk(KERN_INFO \"aty128fb: AGP was enabled, \"\n-\t\t\t       \"disabling ...\\n\");\n-\t\t\tcmd &= ~PCI_AGP_COMMAND_AGP;\n-\t\t\tpci_write_config_dword(pdev, agp + PCI_AGP_COMMAND,\n-\t\t\t\t\t       cmd);\n-\t\t}\n-\t}\n+\tpmac_suspend_agp_for_card(pdev);\n+#endif /* CONFIG_PPC_PMAC */\n \n \t/* We need a way to make sure the fbdev layer will _not_ touch the\n \t * framebuffer before we put the chip to suspend state. On 2.4, I\n@@ -2432,6 +2418,14 @@ static int aty128_do_resume(struct pci_dev *pdev)\n \tpar->lock_blank = 0;\n \taty128fb_blank(0, info);\n \n+#ifdef CONFIG_PPC_PMAC\n+\t/* On powermac, we have hooks to properly suspend/resume AGP now,\n+\t * use them here. We'll ultimately need some generic support here,\n+\t * but the generic code isn't quite ready for that yet\n+\t */\n+\tpmac_resume_agp_for_card(pdev);\n+#endif /* CONFIG_PPC_PMAC */\n+\n \tpdev->dev.power.power_state = PMSG_ON;\n \n \tprintk(KERN_DEBUG \"aty128fb: resumed !\\n\");"}}
{"input": {"original code": "if (radeon_cfg_after_resume[i] != rinfo->cfg_save[i])\n\t\t\tpci_write_config_dword(rinfo->pdev, i * 4,\n\t\t\t\t\t       rinfo->cfg_save[i]);\n\t}\n\tpci_write_config_word(rinfo->pdev, PCI_CACHE_LINE_SIZE,\n\t\t\t      rinfo->cfg_save[PCI_CACHE_LINE_SIZE/4]);\n\tpci_write_config_word(rinfo->pdev, PCI_COMMAND,\n\t\t\t      rinfo->cfg_save[PCI_COMMAND/4]);\n\treturn 1;\n}\n\n\nstatic/*extern*/ int susdisking = 0;\n\nint radeonfb_pci_suspend(struct pci_dev *pdev, pm_message_t state)\n{\n        struct fb_info *info = pci_get_drvdata(pdev);\n        struct radeonfb_info *rinfo = info->par;\n\tu8 agp;\n\tint i;", "instruction": "My previous patch that added sleep support for uninorth-agp and some AGP"}, "output": {"diff codes": "@@ -2520,13 +2520,10 @@ static int radeon_restore_pci_cfg(struct radeonfb_info *rinfo)\n }\n \n \n-static/*extern*/ int susdisking = 0;\n-\n int radeonfb_pci_suspend(struct pci_dev *pdev, pm_message_t state)\n {\n         struct fb_info *info = pci_get_drvdata(pdev);\n         struct radeonfb_info *rinfo = info->par;\n-\tu8 agp;\n \tint i;\n \n \tif (state == pdev->dev.power.power_state)\n@@ -2542,11 +2539,6 @@ int radeonfb_pci_suspend(struct pci_dev *pdev, pm_message_t state)\n \t */\n \tif (state != PM_SUSPEND_MEM)\n \t\tgoto done;\n-\tif (susdisking) {\n-\t\tprintk(\"radeonfb (%s): suspending to disk but state = %d\\n\",\n-\t\t       pci_name(pdev), state);\n-\t\tgoto done;\n-\t}\n \n \tacquire_console_sem();\n \n@@ -2567,27 +2559,13 @@ int radeonfb_pci_suspend(struct pci_dev *pdev, pm_message_t state)\n \trinfo->lock_blank = 1;\n \tdel_timer_sync(&rinfo->lvds_timer);\n \n-\t/* Disable AGP. The AGP host should have done it, but since ordering\n-\t * isn't always properly guaranteed in this specific case, let's make\n-\t * sure it's disabled on card side now. Ultimately, when merging fbdev\n-\t * and dri into some common infrastructure, this will be handled\n-\t * more nicely. The host bridge side will (or will not) be dealt with\n-\t * by the bridge AGP driver, we don't attempt to touch it here.\n+#ifdef CONFIG_PPC_PMAC\n+\t/* On powermac, we have hooks to properly suspend/resume AGP now,\n+\t * use them here. We'll ultimately need some generic support here,\n+\t * but the generic code isn't quite ready for that yet\n \t */\n-\tagp = pci_find_capability(pdev, PCI_CAP_ID_AGP);\n-\tif (agp) {\n-\t\tu32 cmd;\n-\n-\t\tpci_read_config_dword(pdev, agp + PCI_AGP_COMMAND, &cmd);\n-\t\tif (cmd & PCI_AGP_COMMAND_AGP) {\n-\t\t\tprintk(KERN_INFO \"radeonfb (%s): AGP was enabled, \"\n-\t\t\t       \"disabling ...\\n\",\n-\t\t\t       pci_name(pdev));\n-\t\t\tcmd &= ~PCI_AGP_COMMAND_AGP;\n-\t\t\tpci_write_config_dword(pdev, agp + PCI_AGP_COMMAND,\n-\t\t\t\t\t       cmd);\n-\t\t}\n-\t}\n+\tpmac_suspend_agp_for_card(pdev);\n+#endif /* CONFIG_PPC_PMAC */\n \n \t/* If we support wakeup from poweroff, we save all regs we can including cfg\n \t * space\n@@ -2699,6 +2677,15 @@ int radeonfb_pci_resume(struct pci_dev *pdev)\n \trinfo->lock_blank = 0;\n \tradeon_screen_blank(rinfo, FB_BLANK_UNBLANK, 1);\n \n+#ifdef CONFIG_PPC_PMAC\n+\t/* On powermac, we have hooks to properly suspend/resume AGP now,\n+\t * use them here. We'll ultimately need some generic support here,\n+\t * but the generic code isn't quite ready for that yet\n+\t */\n+\tpmac_resume_agp_for_card(pdev);\n+#endif /* CONFIG_PPC_PMAC */\n+\n+\n \t/* Check status of dynclk */\n \tif (rinfo->dynclk == 1)\n \t\tradeon_pm_enable_dynamic_mode(rinfo);"}}
{"input": {"original code": "/* Don't use those directly, they are for the sake of pmac_setup.c */\nextern long pmac_do_feature_call(unsigned int selector, ...);\nextern void pmac_feature_init(void);\n\n/* Video suspend tweak */\nextern void pmac_set_early_video_resume(void (*proc)(void *data), void *data);\nextern void pmac_call_early_video_resume(void);\n\n#define PMAC_FTR_DEF(x) ((_MACH_Pmac << 16) | (x))\n\n\n/*\n * The part below is for use by macio_asic.c only, do not rely\n * on the data structures or constants below in a normal driver\n *\n */\n\n#define MAX_MACIO_CHIPS\t\t2", "instruction": "My previous patch that added sleep support for uninorth-agp and some AGP"}, "output": {"diff codes": "@@ -305,6 +305,17 @@ extern void pmac_call_early_video_resume(void);\n \n #define PMAC_FTR_DEF(x) ((_MACH_Pmac << 16) | (x))\n \n+/* The AGP driver registers itself here */\n+extern void pmac_register_agp_pm(struct pci_dev *bridge,\n+\t\t\t\t int (*suspend)(struct pci_dev *bridge),\n+\t\t\t\t int (*resume)(struct pci_dev *bridge));\n+\n+/* Those are meant to be used by video drivers to deal with AGP\n+ * suspend resume properly\n+ */\n+extern void pmac_suspend_agp_for_card(struct pci_dev *dev);\n+extern void pmac_resume_agp_for_card(struct pci_dev *dev);\n+\n \n /*\n  * The part below is for use by macio_asic.c only, do not rely"}}
{"input": {"original code": "*/\nextern int flush_hash_pages(unsigned context, unsigned long va,\n\t\t\t    unsigned long pmdval, int count);\n\n/* Add an HPTE to the hash table */\nextern void add_hash_page(unsigned context, unsigned long va,\n\t\t\t  unsigned long pmdval);\n\n/*\n * Atomic PTE updates.\n *\n * pte_update clears and sets bit atomically, and returns\n * the old pte value.\n * The ((unsigned long)(p+1) - 4) hack is to get to the least-significant\n * 32 bits of the PTE regardless of whether PTEs are 32 or 64 bits.\n */\nstatic inline unsigned long pte_update(pte_t *p, unsigned long clr,\n\t\t\t\t       unsigned long set)\n{\n\tunsigned long old, tmp;", "instruction": "While the existing pte_update code handled atomically modifying a 64-bit PTE,"}, "output": {"diff codes": "@@ -526,10 +526,10 @@ extern void add_hash_page(unsigned context, unsigned long va,\n  * Atomic PTE updates.\n  *\n  * pte_update clears and sets bit atomically, and returns\n- * the old pte value.\n- * The ((unsigned long)(p+1) - 4) hack is to get to the least-significant\n- * 32 bits of the PTE regardless of whether PTEs are 32 or 64 bits.\n+ * the old pte value.  In the 64-bit PTE case we lock around the\n+ * low PTE word since we expect ALL flag bits to be there\n  */\n+#ifndef CONFIG_PTE_64BIT\n static inline unsigned long pte_update(pte_t *p, unsigned long clr,\n \t\t\t\t       unsigned long set)\n {\n@@ -543,10 +543,31 @@ static inline unsigned long pte_update(pte_t *p, unsigned long clr,\n \"\tstwcx.\t%1,0,%3\\n\\\n \tbne-\t1b\"\n \t: \"=&r\" (old), \"=&r\" (tmp), \"=m\" (*p)\n-\t: \"r\" ((unsigned long)(p+1) - 4), \"r\" (clr), \"r\" (set), \"m\" (*p)\n+\t: \"r\" (p), \"r\" (clr), \"r\" (set), \"m\" (*p)\n \t: \"cc\" );\n \treturn old;\n }\n+#else\n+static inline unsigned long long pte_update(pte_t *p, unsigned long clr,\n+\t\t\t\t       unsigned long set)\n+{\n+\tunsigned long long old;\n+\tunsigned long tmp;\n+\n+\t__asm__ __volatile__(\"\\\n+1:\tlwarx\t%L0,0,%4\\n\\\n+\tlwzx\t%0,0,%3\\n\\\n+\tandc\t%1,%L0,%5\\n\\\n+\tor\t%1,%1,%6\\n\"\n+\tPPC405_ERR77(0,%3)\n+\"\tstwcx.\t%1,0,%4\\n\\\n+\tbne-\t1b\"\n+\t: \"=&r\" (old), \"=&r\" (tmp), \"=m\" (*p)\n+\t: \"r\" (p), \"r\" ((unsigned long)(p) + 4), \"r\" (clr), \"r\" (set), \"m\" (*p)\n+\t: \"cc\" );\n+\treturn old;\n+}\n+#endif\n \n /*\n  * set_pte stores a linux PTE into the linux page table."}}
{"input": {"original code": "#endif /* HAVE_BATS */\n\n#ifdef HAVE_TLBCAM\nextern unsigned int tlbcam_index;\nextern unsigned int num_tlbcam_entries;\nextern unsigned long v_mapped_by_tlbcam(unsigned long va);\nextern unsigned long p_mapped_by_tlbcam(unsigned long pa);\n#else /* !HAVE_TLBCAM */\n#define v_mapped_by_tlbcam(x)\t(0UL)\n#define p_mapped_by_tlbcam(x)\t(0UL)\n#endif /* HAVE_TLBCAM */\n\n#ifdef CONFIG_44x\n/* 44x uses an 8kB pgdir because it has 8-byte Linux PTEs. */\n#define PGDIR_ORDER\t1\n#else\n#define PGDIR_ORDER\t0\n#endif\n\npgd_t *pgd_alloc(struct mm_struct *mm)", "instruction": "CONFIG_PTE_64BIT & CONFIG_PHYS_64BIT are not currently consistently used in"}, "output": {"diff codes": "@@ -74,7 +74,7 @@ extern unsigned long p_mapped_by_tlbcam(unsigned long pa);\n #define p_mapped_by_tlbcam(x)\t(0UL)\n #endif /* HAVE_TLBCAM */\n \n-#ifdef CONFIG_44x\n+#ifdef CONFIG_PTE_64BIT\n /* 44x uses an 8kB pgdir because it has 8-byte Linux PTEs. */\n #define PGDIR_ORDER\t1\n #else\n@@ -142,13 +142,13 @@ void pte_free(struct page *ptepage)\n \t__free_page(ptepage);\n }\n \n-#ifndef CONFIG_44x\n+#ifndef CONFIG_PHYS_64BIT\n void __iomem *\n ioremap(phys_addr_t addr, unsigned long size)\n {\n \treturn __ioremap(addr, size, _PAGE_NO_CACHE);\n }\n-#else /* CONFIG_44x */\n+#else /* CONFIG_PHYS_64BIT */\n void __iomem *\n ioremap64(unsigned long long addr, unsigned long size)\n {\n@@ -162,7 +162,7 @@ ioremap(phys_addr_t addr, unsigned long size)\n \n \treturn ioremap64(addr64, size);\n }\n-#endif /* CONFIG_44x */\n+#endif /* CONFIG_PHYS_64BIT */\n \n void __iomem *\n __ioremap(phys_addr_t addr, unsigned long size, unsigned long flags)\n@@ -193,7 +193,7 @@ __ioremap(phys_addr_t addr, unsigned long size, unsigned long flags)\n \t */\n \tif ( mem_init_done && (p < virt_to_phys(high_memory)) )\n \t{\n-\t\tprintk(\"__ioremap(): phys addr \"PTE_FMT\" is RAM lr %p\\n\", p,\n+\t\tprintk(\"__ioremap(): phys addr \"PHYS_FMT\" is RAM lr %p\\n\", p,\n \t\t       __builtin_return_address(0));\n \t\treturn NULL;\n \t}"}}
{"input": {"original code": "#ifndef _PPC_MMU_H_\n#define _PPC_MMU_H_\n\n#include <linux/config.h>\n\n#ifndef __ASSEMBLY__\n\n/*\n * Define physical address type.  Machines using split size\n * virtual/physical addressing like 32-bit virtual / 36-bit\n * physical need a larger than native word size type. -Matt\n */\n#ifndef CONFIG_PTE_64BIT\ntypedef unsigned long phys_addr_t;\n#else\ntypedef unsigned long long phys_addr_t;\nextern phys_addr_t fixup_bigphys_addr(phys_addr_t, phys_addr_t);\n#endif\n\n/* Default \"unsigned long\" context */", "instruction": "CONFIG_PTE_64BIT & CONFIG_PHYS_64BIT are not currently consistently used in"}, "output": {"diff codes": "@@ -15,11 +15,13 @@\n  * virtual/physical addressing like 32-bit virtual / 36-bit\n  * physical need a larger than native word size type. -Matt\n  */\n-#ifndef CONFIG_PTE_64BIT\n+#ifndef CONFIG_PHYS_64BIT\n typedef unsigned long phys_addr_t;\n+#define PHYS_FMT\t\"%.8lx\"\n #else\n typedef unsigned long long phys_addr_t;\n extern phys_addr_t fixup_bigphys_addr(phys_addr_t, phys_addr_t);\n+#define PHYS_FMT\t\"%16Lx\"\n #endif\n \n /* Default \"unsigned long\" context */"}}
{"input": {"original code": "#include <asm/mmu.h>\n\n/* ************************************************************************ */\n/* Return the value of CCSRBAR for the current board */\n\nphys_addr_t\nget_ccsrbar(void)\n{\n        return BOARD_CCSRBAR;\n}\n\nEXPORT_SYMBOL(get_ccsrbar);", "instruction": "To add support for 36-bit physical addressing on e500 the following changes"}, "output": {"diff codes": "@@ -31,3 +31,11 @@ get_ccsrbar(void)\n }\n \n EXPORT_SYMBOL(get_ccsrbar);\n+\n+/* For now this is a pass through */\n+phys_addr_t fixup_bigphys_addr(phys_addr_t addr, phys_addr_t size)\n+{\n+\treturn addr;\n+};\n+EXPORT_SYMBOL(fixup_bigphys_addr);\n+"}}
{"input": {"original code": "#define CPU_FTR_CAN_DOZE\t\t0x00000020\n#define CPU_FTR_USE_TB\t\t\t0x00000040\n#define CPU_FTR_604_PERF_MON\t\t0x00000080\n#define CPU_FTR_601\t\t\t0x00000100\n#define CPU_FTR_HPTE_TABLE\t\t0x00000200\n#define CPU_FTR_CAN_NAP\t\t\t0x00000400\n#define CPU_FTR_L3CR\t\t\t0x00000800\n#define CPU_FTR_L3_DISABLE_NAP\t\t0x00001000\n#define CPU_FTR_NAP_DISABLE_L2_PR\t0x00002000\n#define CPU_FTR_DUAL_PLL_750FX\t\t0x00004000\n#define CPU_FTR_NO_DPM\t\t\t0x00008000\n#define CPU_FTR_HAS_HIGH_BATS\t\t0x00010000\n#define CPU_FTR_NEED_COHERENT           0x00020000\n#define CPU_FTR_NO_BTIC\t\t\t0x00040000\n\n#ifdef __ASSEMBLY__\n\n#define BEGIN_FTR_SECTION\t\t98:\n\n#define END_FTR_SECTION(msk, val)\t\t\\", "instruction": "To add support for 36-bit physical addressing on e500 the following changes"}, "output": {"diff codes": "@@ -86,8 +86,9 @@ static inline unsigned int cpu_has_feature(unsigned int feature)\n #define CPU_FTR_DUAL_PLL_750FX\t\t0x00004000\n #define CPU_FTR_NO_DPM\t\t\t0x00008000\n #define CPU_FTR_HAS_HIGH_BATS\t\t0x00010000\n-#define CPU_FTR_NEED_COHERENT           0x00020000\n+#define CPU_FTR_NEED_COHERENT\t\t0x00020000\n #define CPU_FTR_NO_BTIC\t\t\t0x00040000\n+#define CPU_FTR_BIG_PHYS\t\t0x00080000\n \n #ifdef __ASSEMBLY__"}}
{"input": {"original code": "#define _PAGE_FILE\t0x00000400\t\t/* S: nonlinear file mapping */\n#define\t_PAGE_NO_CACHE\t0x00000400\t\t/* H: I bit */\n#define\t_PAGE_WRITETHRU\t0x00000800\t\t/* H: W bit */\n\n/* TODO: Add large page lowmem mapping support */\n#define _PMD_PRESENT\t0\n#define _PMD_PRESENT_MASK (PAGE_MASK)\n#define _PMD_BAD\t(~PAGE_MASK)\n\n/* ERPN in a PTE never gets cleared, ignore it */\n#define _PTE_NONE_MASK\t0xffffffff00000000ULL\n\n#elif defined(CONFIG_E500)\n\n/*\n   MMU Assist Register 3:\n\n   32 33 34 35 36  ... 50 51 52 53 54 55 56 57 58 59 60 61 62 63\n   RPN......................  0  0 U0 U1 U2 U3 UX SX UW SW UR SR", "instruction": "To add support for 36-bit physical addressing on e500 the following changes"}, "output": {"diff codes": "@@ -225,8 +225,7 @@ extern unsigned long ioremap_bot, ioremap_base;\n /* ERPN in a PTE never gets cleared, ignore it */\n #define _PTE_NONE_MASK\t0xffffffff00000000ULL\n \n-#elif defined(CONFIG_E500)\n-\n+#elif defined(CONFIG_FSL_BOOKE)\n /*\n    MMU Assist Register 3:\n \n@@ -240,21 +239,29 @@ extern unsigned long ioremap_bot, ioremap_base;\n      entries use the top 29 bits.\n */\n \n-/* Definitions for e500 core */\n-#define _PAGE_PRESENT\t0x001\t/* S: PTE contains a translation */\n-#define _PAGE_USER\t0x002\t/* S: User page (maps to UR) */\n-#define _PAGE_FILE\t0x002\t/* S: when !present: nonlinear file mapping */\n-#define _PAGE_ACCESSED\t0x004\t/* S: Page referenced */\n-#define _PAGE_HWWRITE\t0x008\t/* H: Dirty & RW, set in exception */\n-#define _PAGE_RW\t0x010\t/* S: Write permission */\n-#define _PAGE_HWEXEC\t0x020\t/* H: UX permission */\n-\n-#define _PAGE_ENDIAN\t0x040\t/* H: E bit */\n-#define _PAGE_GUARDED\t0x080\t/* H: G bit */\n-#define _PAGE_COHERENT\t0x100\t/* H: M bit */\n-#define _PAGE_NO_CACHE\t0x200\t/* H: I bit */\n-#define _PAGE_WRITETHRU\t0x400\t/* H: W bit */\n-#define _PAGE_DIRTY\t0x800\t/* S: Page dirty */\n+/* Definitions for FSL Book-E Cores */\n+#define _PAGE_PRESENT\t0x00001\t/* S: PTE contains a translation */\n+#define _PAGE_USER\t0x00002\t/* S: User page (maps to UR) */\n+#define _PAGE_FILE\t0x00002\t/* S: when !present: nonlinear file mapping */\n+#define _PAGE_ACCESSED\t0x00004\t/* S: Page referenced */\n+#define _PAGE_HWWRITE\t0x00008\t/* H: Dirty & RW, set in exception */\n+#define _PAGE_RW\t0x00010\t/* S: Write permission */\n+#define _PAGE_HWEXEC\t0x00020\t/* H: UX permission */\n+\n+#define _PAGE_ENDIAN\t0x00040\t/* H: E bit */\n+#define _PAGE_GUARDED\t0x00080\t/* H: G bit */\n+#define _PAGE_COHERENT\t0x00100\t/* H: M bit */\n+#define _PAGE_NO_CACHE\t0x00200\t/* H: I bit */\n+#define _PAGE_WRITETHRU\t0x00400\t/* H: W bit */\n+\n+#ifdef CONFIG_PTE_64BIT\n+#define _PAGE_DIRTY\t0x08000\t/* S: Page dirty */\n+\n+/* ERPN in a PTE never gets cleared, ignore it */\n+#define _PTE_NONE_MASK\t0xffffffffffff0000ULL\n+#else\n+#define _PAGE_DIRTY\t0x00800\t/* S: Page dirty */\n+#endif\n \n #define _PMD_PRESENT\t0\n #define _PMD_PRESENT_MASK (PAGE_MASK)\n@@ -433,7 +440,11 @@ extern unsigned long bad_call_to_PMD_PAGE_SIZE(void);\n \n /* in some case we want to additionaly adjust where the pfn is in the pte to\n  * allow room for more flags */\n+#if defined(CONFIG_FSL_BOOKE) && defined(CONFIG_PTE_64BIT)\n+#define PFN_SHIFT_OFFSET\t(PAGE_SHIFT + 8)\n+#else\n #define PFN_SHIFT_OFFSET\t(PAGE_SHIFT)\n+#endif\n \n #define pte_pfn(x)\t\t(pte_val(x) >> PFN_SHIFT_OFFSET)\n #define pte_page(x)\t\tpfn_to_page(pte_pfn(x))"}}
{"input": {"original code": "#define SPRN_IVOR35\t0x213\t/* Interrupt Vector Offset Register 35 */\n#define SPRN_MCSRR0\t0x23A\t/* Machine Check Save and Restore Register 0 */\n#define SPRN_MCSRR1\t0x23B\t/* Machine Check Save and Restore Register 1 */\n#define SPRN_MCSR\t0x23C\t/* Machine Check Status Register */\n#define SPRN_MCAR\t0x23D\t/* Machine Check Address Register */\n#define SPRN_MAS0\t0x270\t/* MMU Assist Register 0 */\n#define SPRN_MAS1\t0x271\t/* MMU Assist Register 1 */\n#define SPRN_MAS2\t0x272\t/* MMU Assist Register 2 */\n#define SPRN_MAS3\t0x273\t/* MMU Assist Register 3 */\n#define SPRN_MAS4\t0x274\t/* MMU Assist Register 4 */\n#define SPRN_MAS5\t0x275\t/* MMU Assist Register 5 */\n#define SPRN_MAS6\t0x276\t/* MMU Assist Register 6 */\n#define SPRN_PID1\t0x279\t/* Process ID Register 1 */\n#define SPRN_PID2\t0x27A\t/* Process ID Register 2 */\n#define SPRN_TLB0CFG\t0x2B0\t/* TLB 0 Config Register */\n#define SPRN_TLB1CFG\t0x2B1\t/* TLB 1 Config Register */\n#define SPRN_CCR1\t0x378\t/* Core Configuration Register 1 */\n#define SPRN_ZPR\t0x3B0\t/* Zone Protection Register (40x) */\n#define SPRN_MMUCR\t0x3B2\t/* MMU Control Register */\n#define SPRN_CCR0\t0x3B3\t/* Core Configuration Register 0 */", "instruction": "To add support for 36-bit physical addressing on e500 the following changes"}, "output": {"diff codes": "@@ -172,6 +172,7 @@ do {\t\t\t\t\t\t\\\n #define SPRN_MAS4\t0x274\t/* MMU Assist Register 4 */\n #define SPRN_MAS5\t0x275\t/* MMU Assist Register 5 */\n #define SPRN_MAS6\t0x276\t/* MMU Assist Register 6 */\n+#define SPRN_MAS7\t0x3b0\t/* MMU Assist Register 7 */\n #define SPRN_PID1\t0x279\t/* Process ID Register 1 */\n #define SPRN_PID2\t0x27A\t/* Process ID Register 2 */\n #define SPRN_TLB0CFG\t0x2B0\t/* TLB 0 Config Register */"}}
{"input": {"original code": "* m8xx_wdt.c - MPC8xx watchdog driver\n *\n * Author: Florian Schirmer <jolt@tuxbox.org>\n *\n * 2002 (c) Florian Schirmer <jolt@tuxbox.org> This file is licensed under\n * the terms of the GNU General Public License version 2. This program\n * is licensed \"as is\" without any warranty of any kind, whether express\n * or implied.\n */\n\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <asm/8xx_immap.h>\n#include <syslib/m8xx_wdt.h>\n\nstatic int wdt_timeout;\n\nvoid m8xx_wdt_reset(void)", "instruction": "The CONFIG_8xx_WDT option got broken in the generic hardirq update as ppc32"}, "output": {"diff codes": "@@ -11,6 +11,7 @@\n \n #include <linux/init.h>\n #include <linux/interrupt.h>\n+#include <linux/irq.h>\n #include <linux/kernel.h>\n #include <linux/sched.h>\n #include <asm/8xx_immap.h>\n@@ -18,6 +19,12 @@\n \n static int wdt_timeout;\n \n+static irqreturn_t m8xx_wdt_interrupt(int, void *, struct pt_regs *);\n+static struct irqaction m8xx_wdt_irqaction = {\n+\t.handler = m8xx_wdt_interrupt,\n+\t.name = \"watchdog\",\n+};\n+\n void m8xx_wdt_reset(void)\n {\n \tvolatile immap_t *imap = (volatile immap_t *)IMAP_ADDR;\n@@ -84,8 +91,8 @@ void __init m8xx_wdt_handler_install(bd_t * binfo)\n \timap->im_sit.sit_piscr =\n \t    (mk_int_int_mask(PIT_INTERRUPT) << 8) | PISCR_PIE | PISCR_PTE;\n \n-\tif (request_irq(PIT_INTERRUPT, m8xx_wdt_interrupt, 0, \"watchdog\", NULL))\n-\t\tpanic(\"m8xx_wdt: could not allocate watchdog irq!\");\n+\tif (setup_irq(PIT_INTERRUPT, &m8xx_wdt_irqaction))\n+\t\tpanic(\"m8xx_wdt: error setting up the watchdog irq!\");\n \n \tprintk(KERN_NOTICE\n \t       \"m8xx_wdt: keep-alive trigger installed (PITC: 0x%04X)\\n\", pitc);"}}
{"input": {"original code": "wtm_nsec = wall_to_monotonic.tv_nsec + (xtime.tv_nsec - new_nsec);\n\n\tset_normalized_timespec(&xtime, new_sec, new_nsec);\n\tset_normalized_timespec(&wall_to_monotonic, wtm_sec, wtm_nsec);\n\n\t/* In case of a large backwards jump in time with NTP, we want the\n\t * clock to be updated as soon as the PLL is again in lock.\n\t */\n\tlast_rtc_update = new_sec - 658;\n\n\ttime_adjust = 0;                /* stop active adjtime() */\n\ttime_status |= STA_UNSYNC;\n\ttime_state = TIME_ERROR;        /* p. 24, (a) */\n\ttime_maxerror = NTP_PHASE_LIMIT;\n\ttime_esterror = NTP_PHASE_LIMIT;\n\twrite_sequnlock_irqrestore(&xtime_lock, flags);\n\tclock_was_set();\n\treturn 0;\n}", "instruction": "The following problem was found by Giovambattista Pulcini"}, "output": {"diff codes": "@@ -272,7 +272,6 @@ int do_settimeofday(struct timespec *tv)\n \n \ttime_adjust = 0;                /* stop active adjtime() */\n \ttime_status |= STA_UNSYNC;\n-\ttime_state = TIME_ERROR;        /* p. 24, (a) */\n \ttime_maxerror = NTP_PHASE_LIMIT;\n \ttime_esterror = NTP_PHASE_LIMIT;\n \twrite_sequnlock_irqrestore(&xtime_lock, flags);"}}
{"input": {"original code": "chrp_cmos_clock_write(tm.tm_year,RTC_YEAR);\n\n\t/* The following flags have to be released exactly in this order,\n\t * otherwise the DS12887 (popular MC146818A clone with integrated\n\t * battery and quartz) will not reset the oscillator and will not\n\t * update precisely 500 ms later. You won't find this mentioned in\n\t * the Dallas Semiconductor data sheets, but who believes data\n\t * sheets anyway ...                           -- Markus Kuhn\n\t */\n\tchrp_cmos_clock_write(save_control, RTC_CONTROL);\n\tchrp_cmos_clock_write(save_freq_select, RTC_FREQ_SELECT);\n\n\tif ( (time_state == TIME_ERROR) || (time_state == TIME_BAD) )\n\t\ttime_state = TIME_OK;\n\tspin_unlock(&rtc_lock);\n\treturn 0;\n}\n\nunsigned long __chrp chrp_get_rtc_time(void)\n{", "instruction": "The following problem was found by Giovambattista Pulcini"}, "output": {"diff codes": "@@ -115,8 +115,6 @@ int __chrp chrp_set_rtc_time(unsigned long nowtime)\n \tchrp_cmos_clock_write(save_control, RTC_CONTROL);\n \tchrp_cmos_clock_write(save_freq_select, RTC_FREQ_SELECT);\n \n-\tif ( (time_state == TIME_ERROR) || (time_state == TIME_BAD) )\n-\t\ttime_state = TIME_OK;\n \tspin_unlock(&rtc_lock);\n \treturn 0;\n }"}}
{"input": {"original code": "#endif\n\n\tgemini_rtc_write(tm.tm_sec, M48T35_RTC_SECONDS);\n\tgemini_rtc_write(tm.tm_min, M48T35_RTC_MINUTES);\n\tgemini_rtc_write(tm.tm_hour, M48T35_RTC_HOURS);\n\tgemini_rtc_write(tm.tm_mday, M48T35_RTC_DOM);\n\tgemini_rtc_write(tm.tm_mon, M48T35_RTC_MONTH);\n\tgemini_rtc_write(tm.tm_year, M48T35_RTC_YEAR);\n\n\t/* done writing */\n\tgemini_rtc_write(reg, M48T35_RTC_CONTROL);\n\n\tif ((time_state == TIME_ERROR) || (time_state == TIME_BAD))\n\t\ttime_state = TIME_OK;\n\n\treturn 0;\n}\n\n/*  use the RTC to determine the decrementer count */\nvoid __init gemini_calibrate_decr(void)", "instruction": "The following problem was found by Giovambattista Pulcini"}, "output": {"diff codes": "@@ -433,9 +433,6 @@ gemini_set_rtc_time( unsigned long now )\n \t/* done writing */\n \tgemini_rtc_write(reg, M48T35_RTC_CONTROL);\n \n-\tif ((time_state == TIME_ERROR) || (time_state == TIME_BAD))\n-\t\ttime_state = TIME_OK;\n-\n \treturn 0;\n }"}}
{"input": {"original code": "* non-zero, use the callback (if provided)\n\t\t */\n\t\telse {\n\t\t\tif (Motherboard_non0 != NULL)\n\t\t\t\tMotherboard_non0(dev);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tpci_write_config_byte(dev, PCI_INTERRUPT_LINE, dev->irq);\n\t}\n\n\t/* Setup the Winbond or Via PIB */\n\tprep_pib_init();\n}\n\nstatic void __init\nprep_pcibios_after_init(void)\n{\n#if 0", "instruction": "This patch restores the original behaviour of prep_pcibios_fixup() to only"}, "output": {"diff codes": "@@ -1245,8 +1245,13 @@ prep_pcibios_fixup(void)\n \t\tpci_write_config_byte(dev, PCI_INTERRUPT_LINE, dev->irq);\n \t}\n \n-\t/* Setup the Winbond or Via PIB */\n-\tprep_pib_init();\n+\t/* Setup the Winbond or Via PIB - prep_pib_init() is coded for\n+\t * the non-openpic case, but it breaks (at least) the Utah\n+\t * (Powerstack II Pro4000), so only call it if we have an\n+\t * openpic.\n+\t */\n+\tif (have_openpic)\n+\t\tprep_pib_init();\n }\n \n static void __init"}}
{"input": {"original code": "#endif\n\n\n    /*\n     *  Miscellaneous\n     */\n\n#define NUM_MEMINFO\t4\n#define CL_SIZE\t\t256\n#define COMMAND_LINE_SIZE\tCL_SIZE\n\n#ifndef __ASSEMBLY__\nextern int m68k_num_memory;\t\t/* # of memory blocks found (and used) */\nextern int m68k_realnum_memory;\t\t/* real # of memory blocks found */\nextern struct mem_info m68k_memory[NUM_MEMINFO];/* memory description */\n\nstruct mem_info {\n\tunsigned long addr;\t\t/* physical address of memory chunk */\n\tunsigned long size;\t\t/* length of memory chunk (in bytes) */\n};", "instruction": "make defconfig give the following error on ppc (gcc-4):"}, "output": {"diff codes": "@@ -360,14 +360,14 @@ extern int m68k_is040or060;\n #define COMMAND_LINE_SIZE\tCL_SIZE\n \n #ifndef __ASSEMBLY__\n-extern int m68k_num_memory;\t\t/* # of memory blocks found (and used) */\n-extern int m68k_realnum_memory;\t\t/* real # of memory blocks found */\n-extern struct mem_info m68k_memory[NUM_MEMINFO];/* memory description */\n-\n struct mem_info {\n \tunsigned long addr;\t\t/* physical address of memory chunk */\n \tunsigned long size;\t\t/* length of memory chunk (in bytes) */\n };\n+\n+extern int m68k_num_memory;\t\t/* # of memory blocks found (and used) */\n+extern int m68k_realnum_memory;\t\t/* real # of memory blocks found */\n+extern struct mem_info m68k_memory[NUM_MEMINFO];/* memory description */\n #endif\n \n #endif /* __KERNEL__ */"}}
{"input": {"original code": "time_t last_rtc_update;\n\n/* The decrementer counts down by 128 every 128ns on a 601. */\n#define DECREMENTER_COUNT_601\t(1000000000 / HZ)\n\nunsigned tb_ticks_per_jiffy;\nunsigned tb_to_us;\nunsigned tb_last_stamp;\nunsigned long tb_to_ns_scale;\n\nextern unsigned long wall_jiffies;\n\nstatic long time_offset;\n\nDEFINE_SPINLOCK(rtc_lock);\n\nEXPORT_SYMBOL(rtc_lock);\n\n/* Timer interrupt helper function */\nstatic inline int tb_delta(unsigned *jiffy_stamp) {", "instruction": "make defconfig give the following error on ppc (gcc-4):"}, "output": {"diff codes": "@@ -89,8 +89,6 @@ unsigned long tb_to_ns_scale;\n \n extern unsigned long wall_jiffies;\n \n-static long time_offset;\n-\n DEFINE_SPINLOCK(rtc_lock);\n \n EXPORT_SYMBOL(rtc_lock);"}}
{"input": {"original code": "* Copyright (C) 1996 Paul Mackerras.\n */\n#ifdef __KERNEL__\n#ifndef _PPC_PROM_H\n#define _PPC_PROM_H\n\n#include <linux/config.h>\n#include <linux/types.h>\n\ntypedef u32 phandle;\ntypedef u32 ihandle;\n\nextern char *prom_display_paths[];\nextern unsigned int prom_num_displays;\n\nstruct address_range {\n\tunsigned int space;\n\tunsigned int address;\n\tunsigned int size;\n};", "instruction": "make defconfig give the following error on ppc (gcc-4):"}, "output": {"diff codes": "@@ -14,9 +14,6 @@\n typedef u32 phandle;\n typedef u32 ihandle;\n \n-extern char *prom_display_paths[];\n-extern unsigned int prom_num_displays;\n-\n struct address_range {\n \tunsigned int space;\n \tunsigned int address;"}}
{"input": {"original code": "*/\n    OpenPIC_Global Global;\n    /*\n     *  Interrupt Source Configuration Registers\n     */\n    OpenPIC_Source Source[OPENPIC_MAX_SOURCES];\n    /*\n     *  Per Processor Registers\n     */\n    OpenPIC_Processor Processor[OPENPIC_MAX_PROCESSORS];\n};\n\nextern volatile struct OpenPIC __iomem *OpenPIC;\n\n\n    /*\n     *  Current Task Priority Register\n     */\n\n#define OPENPIC_CURRENT_TASK_PRIORITY_MASK\t0x0000000f", "instruction": "make defconfig give the following error on ppc (gcc-4):"}, "output": {"diff codes": "@@ -172,9 +172,6 @@ struct OpenPIC {\n     OpenPIC_Processor Processor[OPENPIC_MAX_PROCESSORS];\n };\n \n-extern volatile struct OpenPIC __iomem *OpenPIC;\n-\n-\n     /*\n      *  Current Task Priority Register\n      */"}}
{"input": {"original code": "* Output :\tzero of success , nonzero if fails.\n */\n\nstatic int mv643xx_eth_open(struct net_device *dev)\n{\n\tstruct mv643xx_private *mp = netdev_priv(dev);\n\tunsigned int port_num = mp->port_num;\n\tint err;\n\n\tspin_lock_irq(&mp->lock);\n\n\terr = request_irq(dev->irq, mv643xx_eth_int_handler,\n\t\t\tSA_INTERRUPT | SA_SAMPLE_RANDOM, dev->name, dev);\n\n\tif (err) {\n\t\tprintk(KERN_ERR \"Can not assign IRQ number to MV643XX_eth%d\\n\",\n\t\t\t\t\t\t\t\tport_num);\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}", "instruction": "This patch allows Kconfig to build the MV643xx ethernet driver on Pegasos"}, "output": {"diff codes": "@@ -668,7 +668,7 @@ static int mv643xx_eth_open(struct net_device *dev)\n \tspin_lock_irq(&mp->lock);\n \n \terr = request_irq(dev->irq, mv643xx_eth_int_handler,\n-\t\t\tSA_INTERRUPT | SA_SAMPLE_RANDOM, dev->name, dev);\n+\t\t\tSA_SHIRQ | SA_SAMPLE_RANDOM, dev->name, dev);\n \n \tif (err) {\n \t\tprintk(KERN_ERR \"Can not assign IRQ number to MV643XX_eth%d\\n\","}}
{"input": {"original code": "#endif\n\tint active_state;\n} pmac_gpio_t;\n\ntypedef struct pmac_tumbler_t {\n\tpmac_keywest_t i2c;\n\tpmac_gpio_t audio_reset;\n\tpmac_gpio_t amp_mute;\n\tpmac_gpio_t hp_mute;\n\tpmac_gpio_t hp_detect;\n\tint headphone_irq;\n\tunsigned int master_vol[2];\n\tunsigned int master_switch[2];\n\tunsigned int mono_vol[VOL_IDX_LAST_MONO];\n\tunsigned int mix_vol[VOL_IDX_LAST_MIX][2]; /* stereo volumes for tas3004 */\n\tint drc_range;\n\tint drc_enable;\n\tint capture_source;\n} pmac_tumbler_t;", "instruction": "This patch improves the behaviour of the \"tumbler/snapper\" driver used on"}, "output": {"diff codes": "@@ -94,12 +94,17 @@ typedef struct pmac_tumbler_t {\n \tpmac_gpio_t hp_detect;\n \tint headphone_irq;\n \tunsigned int master_vol[2];\n+\tunsigned int save_master_switch[2];\n \tunsigned int master_switch[2];\n \tunsigned int mono_vol[VOL_IDX_LAST_MONO];\n \tunsigned int mix_vol[VOL_IDX_LAST_MIX][2]; /* stereo volumes for tas3004 */\n \tint drc_range;\n \tint drc_enable;\n \tint capture_source;\n+\tint anded_reset;\n+\tint auto_mute_notify;\n+\tint reset_on_sleep;\n+\tu8  acs;\n } pmac_tumbler_t;\n \n \n@@ -654,7 +659,8 @@ static int snapper_put_mix(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucont\n \n \n /*\n- * mute switches\n+ * mute switches. FIXME: Turn that into software mute when both outputs are muted\n+ * to avoid codec reset on ibook M7\n  */\n \n enum { TUMBLER_MUTE_HP, TUMBLER_MUTE_AMP };\n@@ -696,8 +702,11 @@ static int snapper_set_capture_source(pmac_tumbler_t *mix)\n {\n \tif (! mix->i2c.client)\n \t\treturn -ENODEV;\n-\treturn i2c_smbus_write_byte_data(mix->i2c.client, TAS_REG_ACS,\n-\t\t\t\t\t mix->capture_source ? 2 : 0);\n+\tif (mix->capture_source)\n+\t\tmix->acs = mix->acs |= 2;\n+\telse\n+\t\tmix->acs &= ~2;\n+\treturn i2c_smbus_write_byte_data(mix->i2c.client, TAS_REG_ACS, mix->acs);\n }\n \n static int snapper_info_capture_source(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)\n@@ -855,8 +864,7 @@ static void check_mute(pmac_t *chip, pmac_gpio_t *gp, int val, int do_notify, sn\n \n static struct work_struct device_change;\n \n-static void\n-device_change_handler(void *self)\n+static void device_change_handler(void *self)\n {\n \tpmac_t *chip = (pmac_t*) self;\n \tpmac_tumbler_t *mix;\n@@ -865,6 +873,33 @@ device_change_handler(void *self)\n \t\treturn;\n \n \tmix = chip->mixer_data;\n+\tsnd_assert(mix, return);\n+\n+\tif (tumbler_detect_headphone(chip)) {\n+\t\t/* mute speaker */\n+\t\tcheck_mute(chip, &mix->hp_mute, 0, mix->auto_mute_notify,\n+\t\t\t   chip->master_sw_ctl);\n+\t\tif (mix->anded_reset)\n+\t\t\tbig_mdelay(10);\n+\t\tcheck_mute(chip, &mix->amp_mute, 1, mix->auto_mute_notify,\n+\t\t\t   chip->speaker_sw_ctl);\n+\t\tmix->drc_enable = 0;\n+\t} else {\n+\t\t/* unmute speaker */\n+\t\tcheck_mute(chip, &mix->amp_mute, 0, mix->auto_mute_notify,\n+\t\t\t   chip->speaker_sw_ctl);\n+\t\tif (mix->anded_reset)\n+\t\t\tbig_mdelay(10);\n+\t\tcheck_mute(chip, &mix->hp_mute, 1, mix->auto_mute_notify,\n+\t\t\t   chip->master_sw_ctl);\n+\t\tmix->drc_enable = 1;\n+\t}\n+\tif (mix->auto_mute_notify) {\n+\t\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\n+\t\t\t\t       &chip->hp_detect_ctl->id);\n+\t\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\n+\t\t\t       &chip->drc_sw_ctl->id);\n+\t}\n \n \t/* first set the DRC so the speaker do not explode -ReneR */\n \tif (chip->model == PMAC_TUMBLER)\n@@ -879,31 +914,11 @@ device_change_handler(void *self)\n static void tumbler_update_automute(pmac_t *chip, int do_notify)\n {\n \tif (chip->auto_mute) {\n-\t\tpmac_tumbler_t *mix = chip->mixer_data;\n+\t\tpmac_tumbler_t *mix;\n+\t\tmix = chip->mixer_data;\n \t\tsnd_assert(mix, return);\n-\t\tif (tumbler_detect_headphone(chip)) {\n-\t\t\t/* mute speaker */\n-\t\t\tcheck_mute(chip, &mix->amp_mute, 1, do_notify, chip->speaker_sw_ctl);\n-\t\t\tcheck_mute(chip, &mix->hp_mute, 0, do_notify, chip->master_sw_ctl);\n-\t\t\tmix->drc_enable = 0;\n-\n-\t\t} else {\n-\t\t\t/* unmute speaker */\n-\t\t\tcheck_mute(chip, &mix->amp_mute, 0, do_notify, chip->speaker_sw_ctl);\n-\t\t\tcheck_mute(chip, &mix->hp_mute, 1, do_notify, chip->master_sw_ctl);\n-\t\t\tmix->drc_enable = 1;\n-\t\t}\n-\t\tif (do_notify) {\n-\t\t\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\n-\t\t\t\t       &chip->hp_detect_ctl->id);\n-\t\t\tsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\n-\t\t\t               &chip->drc_sw_ctl->id);\n-\t\t}\n-\n-\t\t/* finally we need to schedule an update of the mixer values\n-\t\t   (master and DRC are enough for now) -ReneR */\n+\t\tmix->auto_mute_notify = do_notify;\n \t\tschedule_work(&device_change);\n-\n \t}\n }\n #endif /* PMAC_SUPPORT_AUTOMUTE */\n@@ -1002,15 +1017,53 @@ static void tumbler_reset_audio(pmac_t *chip)\n {\n \tpmac_tumbler_t *mix = chip->mixer_data;\n \n-\twrite_audio_gpio(&mix->audio_reset, 0);\n-\tbig_mdelay(200);\n-\twrite_audio_gpio(&mix->audio_reset, 1);\n-\tbig_mdelay(100);\n-\twrite_audio_gpio(&mix->audio_reset, 0);\n-\tbig_mdelay(100);\n+\tif (mix->anded_reset) {\n+\t\twrite_audio_gpio(&mix->hp_mute, 0);\n+\t\twrite_audio_gpio(&mix->amp_mute, 0);\n+\t\tbig_mdelay(200);\n+\t\twrite_audio_gpio(&mix->hp_mute, 1);\n+\t\twrite_audio_gpio(&mix->amp_mute, 1);\n+\t\tbig_mdelay(100);\n+\t\twrite_audio_gpio(&mix->hp_mute, 0);\n+\t\twrite_audio_gpio(&mix->amp_mute, 0);\n+\t\tbig_mdelay(100);\n+\t} else {\n+\t\twrite_audio_gpio(&mix->audio_reset, 0);\n+\t\tbig_mdelay(200);\n+\t\twrite_audio_gpio(&mix->audio_reset, 1);\n+\t\tbig_mdelay(100);\n+\t\twrite_audio_gpio(&mix->audio_reset, 0);\n+\t\tbig_mdelay(100);\n+\t}\n }\n \n #ifdef CONFIG_PMAC_PBOOK\n+/* suspend mixer */\n+static void tumbler_suspend(pmac_t *chip)\n+{\n+\tpmac_tumbler_t *mix = chip->mixer_data;\n+\n+\tif (mix->headphone_irq >= 0)\n+\t\tdisable_irq(mix->headphone_irq);\n+\tmix->save_master_switch[0] = mix->master_switch[0];\n+\tmix->save_master_switch[1] = mix->master_switch[1];\n+\tmix->master_switch[0] = mix->master_switch[1] = 0;\n+\ttumbler_set_master_volume(mix);\n+\tif (!mix->anded_reset) {\n+\t\twrite_audio_gpio(&mix->amp_mute, 1);\n+\t\twrite_audio_gpio(&mix->hp_mute, 1);\n+\t}\n+\tif (chip->model == PMAC_SNAPPER) {\n+\t\tmix->acs |= 1;\n+\t\ti2c_smbus_write_byte_data(mix->i2c.client, TAS_REG_ACS, mix->acs);\n+\t}\n+\tif (mix->anded_reset) {\n+\t\twrite_audio_gpio(&mix->amp_mute, 1);\n+\t\twrite_audio_gpio(&mix->hp_mute, 1);\n+\t} else\n+\t\twrite_audio_gpio(&mix->audio_reset, 1);\n+}\n+\n /* resume mixer */\n static void tumbler_resume(pmac_t *chip)\n {\n@@ -1018,6 +1071,9 @@ static void tumbler_resume(pmac_t *chip)\n \n \tsnd_assert(mix, return);\n \n+\tmix->acs &= ~1;\n+\tmix->master_switch[0] = mix->save_master_switch[0];\n+\tmix->master_switch[1] = mix->save_master_switch[1];\n \ttumbler_reset_audio(chip);\n \tif (mix->i2c.client && mix->i2c.init_client) {\n \t\tif (mix->i2c.init_client(&mix->i2c) < 0)\n@@ -1041,6 +1097,8 @@ static void tumbler_resume(pmac_t *chip)\n \ttumbler_set_master_volume(mix);\n \tif (chip->update_automute)\n \t\tchip->update_automute(chip, 0);\n+\tif (mix->headphone_irq >= 0)\n+\t\tenable_irq(mix->headphone_irq);\n }\n #endif\n \n@@ -1103,7 +1161,7 @@ int __init snd_pmac_tumbler_init(pmac_t *chip)\n \tint i, err;\n \tpmac_tumbler_t *mix;\n \tu32 *paddr;\n-\tstruct device_node *tas_node;\n+\tstruct device_node *tas_node, *np;\n \tchar *chipname;\n \n #ifdef CONFIG_KMOD\n@@ -1119,7 +1177,18 @@ int __init snd_pmac_tumbler_init(pmac_t *chip)\n \n \tchip->mixer_data = mix;\n \tchip->mixer_free = tumbler_cleanup;\n-\n+\tmix->anded_reset = 0;\n+\tmix->reset_on_sleep = 1;\n+\n+\tfor (np = chip->node->child; np; np = np->sibling) {\n+\t\tif (!strcmp(np->name, \"sound\")) {\n+\t\t\tif (get_property(np, \"has-anded-reset\", NULL))\n+\t\t\t\tmix->anded_reset = 1;\n+\t\t\tif (get_property(np, \"layout-id\", NULL))\n+\t\t\t\tmix->reset_on_sleep = 0;\n+\t\t\tbreak;\n+\t\t}\n+\t}\n \tif ((err = tumbler_init(chip)) < 0)\n \t\treturn err;\n \n@@ -1178,6 +1247,7 @@ int __init snd_pmac_tumbler_init(pmac_t *chip)\n \t\treturn err;\n \n #ifdef CONFIG_PMAC_PBOOK\n+\tchip->suspend = tumbler_suspend;\n \tchip->resume = tumbler_resume;\n #endif"}}
{"input": {"original code": "*/\nstatic DEFINE_SPINLOCK(feature_lock  __pmacdata);\n\n#define LOCK(flags)\tspin_lock_irqsave(&feature_lock, flags);\n#define UNLOCK(flags)\tspin_unlock_irqrestore(&feature_lock, flags);\n\n\n/*\n * Instance of some macio stuffs\n */\nstruct macio_chip macio_chips[MAX_MACIO_CHIPS]  __pmacdata;\n\nstruct macio_chip* __pmac\nmacio_find(struct device_node* child, int type)\n{\n\twhile(child) {\n\t\tint\ti;\n\n\t\tfor (i=0; i < MAX_MACIO_CHIPS && macio_chips[i].of_node; i++)\n\t\t\tif (child == macio_chips[i].of_node &&", "instruction": "This patch hacks the current PowerMac Alsa driver to add some basic support"}, "output": {"diff codes": "@@ -74,8 +74,7 @@ static DEFINE_SPINLOCK(feature_lock  __pmacdata);\n  */\n struct macio_chip macio_chips[MAX_MACIO_CHIPS]  __pmacdata;\n \n-struct macio_chip* __pmac\n-macio_find(struct device_node* child, int type)\n+struct macio_chip* __pmac macio_find(struct device_node* child, int type)\n {\n \twhile(child) {\n \t\tint\ti;\n@@ -88,6 +87,7 @@ macio_find(struct device_node* child, int type)\n \t}\n \treturn NULL;\n }\n+EXPORT_SYMBOL_GPL(macio_find);\n \n static const char* macio_names[] __pmacdata =\n {"}}
{"input": {"original code": "*/\nstatic DEFINE_SPINLOCK(feature_lock  __pmacdata);\n\n#define LOCK(flags)\tspin_lock_irqsave(&feature_lock, flags);\n#define UNLOCK(flags)\tspin_unlock_irqrestore(&feature_lock, flags);\n\n\n/*\n * Instance of some macio stuffs\n */\nstruct macio_chip macio_chips[MAX_MACIO_CHIPS]  __pmacdata;\n\nstruct macio_chip* __pmac\nmacio_find(struct device_node* child, int type)\n{\n\twhile(child) {\n\t\tint\ti;\n\n\t\tfor (i=0; i < MAX_MACIO_CHIPS && macio_chips[i].of_node; i++)\n\t\t\tif (child == macio_chips[i].of_node &&", "instruction": "This patch hacks the current PowerMac Alsa driver to add some basic support"}, "output": {"diff codes": "@@ -64,8 +64,7 @@ static DEFINE_SPINLOCK(feature_lock  __pmacdata);\n  */\n struct macio_chip macio_chips[MAX_MACIO_CHIPS]  __pmacdata;\n \n-struct macio_chip* __pmac\n-macio_find(struct device_node* child, int type)\n+struct macio_chip* __pmac macio_find(struct device_node* child, int type)\n {\n \twhile(child) {\n \t\tint\ti;\n@@ -78,6 +77,7 @@ macio_find(struct device_node* child, int type)\n \t}\n \treturn NULL;\n }\n+EXPORT_SYMBOL_GPL(macio_find);\n \n static const char* macio_names[] __pmacdata =\n {\n@@ -250,6 +250,30 @@ static long __pmac g5_eth_phy_reset(struct device_node* node, long param, long v\n \treturn 0;\n }\n \n+static long __pmac g5_i2s_enable(struct device_node *node, long param, long value)\n+{\n+\t/* Very crude implementation for now */\n+\tstruct macio_chip* macio = &macio_chips[0];\n+\tunsigned long flags;\n+\n+\tif (value == 0)\n+\t\treturn 0; /* don't disable yet */\n+\n+\tLOCK(flags);\n+\tMACIO_BIS(KEYLARGO_FCR3, KL3_CLK45_ENABLE | KL3_CLK49_ENABLE |\n+\t\t  KL3_I2S0_CLK18_ENABLE);\n+\tudelay(10);\n+\tMACIO_BIS(KEYLARGO_FCR1, K2_FCR1_I2S0_CELL_ENABLE |\n+\t\t  K2_FCR1_I2S0_CLK_ENABLE_BIT | K2_FCR1_I2S0_ENABLE);\n+\tudelay(10);\n+\tMACIO_BIC(KEYLARGO_FCR1, K2_FCR1_I2S0_RESET);\n+\tUNLOCK(flags);\n+\tudelay(10);\n+\n+\treturn 0;\n+}\n+\n+\n #ifdef CONFIG_SMP\n static long __pmac g5_reset_cpu(struct device_node* node, long param, long value)\n {\n@@ -337,6 +361,7 @@ static struct feature_table_entry g5_features[]  __pmacdata = {\n \t{ PMAC_FTR_READ_GPIO,\t\tg5_read_gpio },\n \t{ PMAC_FTR_WRITE_GPIO,\t\tg5_write_gpio },\n \t{ PMAC_FTR_GMAC_PHY_RESET,\tg5_eth_phy_reset },\n+\t{ PMAC_FTR_SOUND_CHIP_ENABLE,\tg5_i2s_enable },\n #ifdef CONFIG_SMP\n \t{ PMAC_FTR_RESET_CPU,\t\tg5_reset_cpu },\n #endif /* CONFIG_SMP */"}}
{"input": {"original code": "#define BR_NEVER\t0\t/* don't branch */\n#define BR_IFSET\t0x4\t/* branch if condition bit is 1 */\n#define BR_IFCLR\t0x8\t/* branch if condition bit is 0 */\n#define BR_ALWAYS\t0xc\t/* always branch */\n\n/* Wait control values in command field */\n#define WAIT_NEVER\t0\t/* don't wait */\n#define WAIT_IFSET\t1\t/* wait if condition bit is 1 */\n#define WAIT_IFCLR\t2\t/* wait if condition bit is 0 */\n#define WAIT_ALWAYS\t3\t/* always wait */\n\n/* Align an address for a DBDMA command structure */\n#define DBDMA_ALIGN(x)\t(((unsigned)(x) + sizeof(struct dbdma_cmd) - 1) \\\n\t\t\t & -sizeof(struct dbdma_cmd))\n\n/* Useful macros */\n#define DBDMA_DO_STOP(regs) do {\t\t\t\t\\\n\tout_le32(&((regs)->control), (RUN|FLUSH)<<16);\t\t\\\n\twhile(in_le32(&((regs)->status)) & (ACTIVE|FLUSH))\t\\\n\t\t;\t\t\t\t\t\t\\", "instruction": "This patch hacks the current PowerMac Alsa driver to add some basic support"}, "output": {"diff codes": "@@ -88,7 +88,7 @@ struct dbdma_cmd {\n #define WAIT_ALWAYS\t3\t/* always wait */\n \n /* Align an address for a DBDMA command structure */\n-#define DBDMA_ALIGN(x)\t(((unsigned)(x) + sizeof(struct dbdma_cmd) - 1) \\\n+#define DBDMA_ALIGN(x)\t(((unsigned long)(x) + sizeof(struct dbdma_cmd) - 1) \\\n \t\t\t & -sizeof(struct dbdma_cmd))\n \n /* Useful macros */"}}
{"input": {"original code": "#define KL5_PWM_CLK32_EN\t\t0x00000004\n#define KL5_CLK3_68_EN\t\t\t0x00000010\n#define KL5_CLK32_EN\t\t\t0x00000020\n\n\n/* K2 definitions */\n#define K2_FCR0_USB0_SWRESET\t\t0x00200000\n#define K2_FCR0_USB1_SWRESET\t\t0x02000000\n#define K2_FCR0_RING_PME_DISABLE\t0x08000000\n\n#define K2_FCR1_PCI1_BUS_RESET_N\t0x00000010\n#define K2_FCR1_PCI1_SLEEP_RESET_EN\t0x00000020\n#define K2_FCR1_PCI1_CLK_ENABLE\t\t0x00004000\n#define K2_FCR1_FW_CLK_ENABLE\t\t0x00008000\n#define K2_FCR1_FW_RESET_N\t\t0x00010000\n#define K2_FCR1_GMAC_CLK_ENABLE\t\t0x00400000\n#define K2_FCR1_GMAC_POWER_DOWN\t\t0x00800000\n#define K2_FCR1_GMAC_RESET_N\t\t0x01000000\n#define K2_FCR1_SATA_CLK_ENABLE\t\t0x02000000\n#define K2_FCR1_SATA_POWER_DOWN\t\t0x04000000", "instruction": "This patch hacks the current PowerMac Alsa driver to add some basic support"}, "output": {"diff codes": "@@ -228,6 +228,11 @@\n \n #define K2_FCR1_PCI1_BUS_RESET_N\t0x00000010\n #define K2_FCR1_PCI1_SLEEP_RESET_EN\t0x00000020\n+#define K2_FCR1_I2S0_CELL_ENABLE\t0x00000400\n+#define K2_FCR1_I2S0_RESET\t\t0x00000800\n+#define K2_FCR1_I2S0_CLK_ENABLE_BIT\t0x00001000\n+#define K2_FCR1_I2S0_ENABLE    \t\t0x00002000\n+\n #define K2_FCR1_PCI1_CLK_ENABLE\t\t0x00004000\n #define K2_FCR1_FW_CLK_ENABLE\t\t0x00008000\n #define K2_FCR1_FW_RESET_N\t\t0x00010000"}}
{"input": {"original code": "*\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n */\n\n#include <sound/driver.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include \"pmac.h\"\n\nstruct snd_pmac_beep {\n\tint running;\t/* boolean */\n\tint volume;\t/* mixer volume: 0-100 */\n\tint volume_play;\t/* currently playing volume */", "instruction": "This patch hacks the current PowerMac Alsa driver to add some basic support"}, "output": {"diff codes": "@@ -24,6 +24,8 @@\n #include <linux/init.h>\n #include <linux/slab.h>\n #include <linux/input.h>\n+#include <linux/pci.h>\n+#include <linux/dma-mapping.h>\n #include <sound/core.h>\n #include <sound/control.h>\n #include \"pmac.h\"\n@@ -35,7 +37,7 @@ struct snd_pmac_beep {\n \tint hz;\n \tint nsamples;\n \tshort *buf;\t\t/* allocated wave buffer */\n-\tunsigned long addr;\t/* physical address of buffer */\n+\tdma_addr_t addr;\t/* physical address of buffer */\n \tstruct input_dev dev;\n };\n \n@@ -217,12 +219,8 @@ int __init snd_pmac_attach_beep(pmac_t *chip)\n \t\treturn -ENOMEM;\n \n \tmemset(beep, 0, sizeof(*beep));\n-\tbeep->buf = (short *) kmalloc(BEEP_BUFLEN * 4, GFP_KERNEL);\n-\tif (! beep->buf) {\n-\t\tkfree(beep);\n-\t\treturn -ENOMEM;\n-\t}\n-\tbeep->addr = virt_to_bus(beep->buf);\n+\tbeep->buf = dma_alloc_coherent(&chip->pdev->dev, BEEP_BUFLEN * 4,\n+\t\t\t\t\t&beep->addr, GFP_KERNEL);\n \n \tbeep->dev.evbit[0] = BIT(EV_SND);\n \tbeep->dev.sndbit[0] = BIT(SND_BELL) | BIT(SND_TONE);\n@@ -255,7 +253,8 @@ void snd_pmac_detach_beep(pmac_t *chip)\n {\n \tif (chip->beep) {\n \t\tinput_unregister_device(&chip->beep->dev);\n-\t\tkfree(chip->beep->buf);\n+\t\tdma_free_coherent(&chip->pdev->dev, BEEP_BUFLEN * 4,\n+\t\t\t\t  chip->beep->buf, chip->beep->addr);\n \t\tkfree(chip->beep);\n \t\tchip->beep = NULL;\n \t}"}}
{"input": {"original code": "*   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n */\n\n\n#include <sound/driver.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <sound/core.h>\n#include \"pmac.h\"\n#include <sound/pcm_params.h>\n#ifdef CONFIG_PPC_HAS_FEATURE_CALLS\n#include <asm/pmac_feature.h>\n#else\n#include <asm/feature.h>\n#endif", "instruction": "This patch hacks the current PowerMac Alsa driver to add some basic support"}, "output": {"diff codes": "@@ -27,14 +27,13 @@\n #include <linux/delay.h>\n #include <linux/slab.h>\n #include <linux/interrupt.h>\n+#include <linux/pci.h>\n+#include <linux/dma-mapping.h>\n #include <sound/core.h>\n #include \"pmac.h\"\n #include <sound/pcm_params.h>\n-#ifdef CONFIG_PPC_HAS_FEATURE_CALLS\n #include <asm/pmac_feature.h>\n-#else\n-#include <asm/feature.h>\n-#endif\n+#include <asm/pci-bridge.h>\n \n \n #if defined(CONFIG_PM) && defined(CONFIG_PMAC_PBOOK)\n@@ -57,22 +56,29 @@ static int tumbler_freqs[1] = {\n /*\n  * allocate DBDMA command arrays\n  */\n-static int snd_pmac_dbdma_alloc(pmac_dbdma_t *rec, int size)\n+static int snd_pmac_dbdma_alloc(pmac_t *chip, pmac_dbdma_t *rec, int size)\n {\n-\trec->space = kmalloc(sizeof(struct dbdma_cmd) * (size + 1), GFP_KERNEL);\n+\tunsigned int rsize = sizeof(struct dbdma_cmd) * (size + 1);\n+\n+\trec->space = dma_alloc_coherent(&chip->pdev->dev, rsize,\n+\t\t\t\t\t&rec->dma_base, GFP_KERNEL);\n \tif (rec->space == NULL)\n \t\treturn -ENOMEM;\n \trec->size = size;\n-\tmemset(rec->space, 0, sizeof(struct dbdma_cmd) * (size + 1));\n+\tmemset(rec->space, 0, rsize);\n \trec->cmds = (void __iomem *)DBDMA_ALIGN(rec->space);\n-\trec->addr = virt_to_bus(rec->cmds);\n+\trec->addr = rec->dma_base + (unsigned long)((char *)rec->cmds - (char *)rec->space);\n+\n \treturn 0;\n }\n \n-static void snd_pmac_dbdma_free(pmac_dbdma_t *rec)\n+static void snd_pmac_dbdma_free(pmac_t *chip, pmac_dbdma_t *rec)\n {\n-\tif (rec)\n-\t\tkfree(rec->space);\n+\tif (rec) {\n+\t\tunsigned int rsize = sizeof(struct dbdma_cmd) * (rec->size + 1);\n+\n+\t\tdma_free_coherent(&chip->pdev->dev, rsize, rec->space, rec->dma_base);\n+\t}\n }\n \n \n@@ -237,7 +243,7 @@ static int snd_pmac_pcm_prepare(pmac_t *chip, pmac_stream_t *rec, snd_pcm_substr\n \t/* continuous DMA memory type doesn't provide the physical address,\n \t * so we need to resolve the address here...\n \t */\n-\toffset = virt_to_bus(runtime->dma_area);\n+\toffset = runtime->dma_addr;\n \tfor (i = 0, cp = rec->cmd.cmds; i < rec->nperiods; i++, cp++) {\n \t\tst_le32(&cp->phy_addr, offset);\n \t\tst_le16(&cp->req_count, rec->period_size);\n@@ -664,8 +670,8 @@ int __init snd_pmac_pcm_new(pmac_t *chip)\n \tchip->capture.cur_freqs = chip->freqs_ok;\n \n \t/* preallocate 64k buffer */\n-\tsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS, \n-\t\t\t\t\t      snd_dma_continuous_data(GFP_KERNEL),\n+\tsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\n+\t\t\t\t\t      &chip->pdev->dev,\n \t\t\t\t\t      64 * 1024, 64 * 1024);\n \n \treturn 0;\n@@ -757,28 +763,10 @@ snd_pmac_ctrl_intr(int irq, void *devid, struct pt_regs *regs)\n /*\n  * a wrapper to feature call for compatibility\n  */\n-#if defined(CONFIG_PM) && defined(CONFIG_PMAC_PBOOK)\n static void snd_pmac_sound_feature(pmac_t *chip, int enable)\n {\n-#ifdef CONFIG_PPC_HAS_FEATURE_CALLS\n \tppc_md.feature_call(PMAC_FTR_SOUND_CHIP_ENABLE, chip->node, 0, enable);\n-#else\n-\tif (chip->is_pbook_G3) {\n-\t\tpmu_suspend();\n-\t\tfeature_clear(chip->node, FEATURE_Sound_power);\n-\t\tfeature_clear(chip->node, FEATURE_Sound_CLK_enable);\n-\t\tbig_mdelay(1000); /* XXX */\n-\t\tpmu_resume();\n-\t}\n-\tif (chip->is_pbook_3400) {\n-\t\tfeature_set(chip->node, FEATURE_IOBUS_enable);\n-\t\tudelay(10);\n-\t}\n-#endif\n }\n-#else /* CONFIG_PM && CONFIG_PMAC_PBOOK */\n-#define snd_pmac_sound_feature(chip,enable) /**/\n-#endif /* CONFIG_PM && CONFIG_PMAC_PBOOK */\n \n /*\n  * release resources\n@@ -786,8 +774,6 @@ static void snd_pmac_sound_feature(pmac_t *chip, int enable)\n \n static int snd_pmac_free(pmac_t *chip)\n {\n-\tint i;\n-\n \t/* stop sounds */\n \tif (chip->initialized) {\n \t\tsnd_pmac_dbdma_reset(chip);\n@@ -813,9 +799,9 @@ static int snd_pmac_free(pmac_t *chip)\n \t\tfree_irq(chip->tx_irq, (void*)chip);\n \tif (chip->rx_irq >= 0)\n \t\tfree_irq(chip->rx_irq, (void*)chip);\n-\tsnd_pmac_dbdma_free(&chip->playback.cmd);\n-\tsnd_pmac_dbdma_free(&chip->capture.cmd);\n-\tsnd_pmac_dbdma_free(&chip->extra_dma);\n+\tsnd_pmac_dbdma_free(chip, &chip->playback.cmd);\n+\tsnd_pmac_dbdma_free(chip, &chip->capture.cmd);\n+\tsnd_pmac_dbdma_free(chip, &chip->extra_dma);\n \tif (chip->macio_base)\n \t\tiounmap(chip->macio_base);\n \tif (chip->latch_base)\n@@ -826,12 +812,23 @@ static int snd_pmac_free(pmac_t *chip)\n \t\tiounmap(chip->playback.dma);\n \tif (chip->capture.dma)\n \t\tiounmap(chip->capture.dma);\n+#ifndef CONFIG_PPC64\n \tif (chip->node) {\n+\t\tint i;\n+\n \t\tfor (i = 0; i < 3; i++) {\n-\t\t\tif (chip->of_requested & (1 << i))\n-\t\t\t\trelease_OF_resource(chip->node, i);\n+\t\t\tif (chip->of_requested & (1 << i)) {\n+\t\t\t\tif (chip->is_k2)\n+\t\t\t\t\trelease_OF_resource(chip->node->parent,\n+\t\t\t\t\t\t\t    i);\n+\t\t\t\telse\n+\t\t\t\t\trelease_OF_resource(chip->node, i);\n+\t\t\t}\n \t\t}\n \t}\n+#endif /* CONFIG_PPC64 */\n+\tif (chip->pdev)\n+\t\tpci_dev_put(chip->pdev);\n \tkfree(chip);\n \treturn 0;\n }\n@@ -881,6 +878,8 @@ static int __init snd_pmac_detect(pmac_t *chip)\n {\n \tstruct device_node *sound;\n \tunsigned int *prop, l;\n+\tstruct macio_chip* macio;\n+\n \tu32 layout_id = 0;\n \n \tif (_machine != _MACH_Pmac)\n@@ -918,10 +917,17 @@ static int __init snd_pmac_detect(pmac_t *chip)\n \t * if we didn't find a davbus device, try 'i2s-a' since\n \t * this seems to be what iBooks have\n \t */\n-\tif (! chip->node)\n+\tif (! chip->node) {\n \t\tchip->node = find_devices(\"i2s-a\");\n+\t\tif (chip->node && chip->node->parent && chip->node->parent->parent) {\n+\t\t\tif (device_is_compatible(chip->node->parent->parent,\n+\t\t\t\t\t\t \"K2-Keylargo\"))\n+\t\t\t\tchip->is_k2 = 1;\n+\t\t}\n+\t}\n \tif (! chip->node)\n \t\treturn -ENODEV;\n+\n \tsound = find_devices(\"sound\");\n \twhile (sound && sound->parent != chip->node)\n \t\tsound = sound->next;\n@@ -966,7 +972,8 @@ static int __init snd_pmac_detect(pmac_t *chip)\n \t\tchip->control_mask = MASK_IEPC | 0x11; /* disable IEE */\n \t}\n \tif (device_is_compatible(sound, \"AOAKeylargo\") ||\n-\t    device_is_compatible(sound, \"AOAbase\")) {\n+\t    device_is_compatible(sound, \"AOAbase\") ||\n+\t    device_is_compatible(sound, \"AOAK2\")) {\n \t\t/* For now, only support very basic TAS3004 based machines with\n \t\t * single frequency until proper i2s control is implemented\n \t\t */\n@@ -975,6 +982,7 @@ static int __init snd_pmac_detect(pmac_t *chip)\n \t\tcase 0x46:\n \t\tcase 0x33:\n \t\tcase 0x29:\n+\t\tcase 0x24:\n \t\t\tchip->num_freqs = ARRAY_SIZE(tumbler_freqs);\n \t\t\tchip->model = PMAC_SNAPPER;\n \t\t\tchip->can_byte_swap = 0; /* FIXME: check this */\n@@ -987,6 +995,26 @@ static int __init snd_pmac_detect(pmac_t *chip)\n \t\tchip->device_id = *prop;\n \tchip->has_iic = (find_devices(\"perch\") != NULL);\n \n+\t/* We need the PCI device for DMA allocations, let's use a crude method\n+\t * for now ...\n+\t */\n+\tmacio = macio_find(chip->node, macio_unknown);\n+\tif (macio == NULL)\n+\t\tprintk(KERN_WARNING \"snd-powermac: can't locate macio !\\n\");\n+\telse {\n+\t\tstruct pci_dev *pdev = NULL;\n+\n+\t\tfor_each_pci_dev(pdev) {\n+\t\t\tstruct device_node *np = pci_device_to_OF_node(pdev);\n+\t\t\tif (np && np == macio->of_node) {\n+\t\t\t\tchip->pdev = pdev;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif (chip->pdev == NULL)\n+\t\tprintk(KERN_WARNING \"snd-powermac: can't locate macio PCI device !\\n\");\n+\n \tdetect_byte_swap(chip);\n \n \t/* look for a property saying what sample rates\n@@ -1091,8 +1119,10 @@ int __init snd_pmac_add_automute(pmac_t *chip)\n \tint err;\n \tchip->auto_mute = 1;\n \terr = snd_ctl_add(chip->card, snd_ctl_new1(&auto_mute_controls[0], chip));\n-\tif (err < 0)\n+\tif (err < 0) {\n+\t\tprintk(KERN_ERR \"snd-powermac: Failed to add automute control\\n\");\n \t\treturn err;\n+\t}\n \tchip->hp_detect_ctl = snd_ctl_new1(&auto_mute_controls[1], chip);\n \treturn snd_ctl_add(chip->card, chip->hp_detect_ctl);\n }\n@@ -1106,6 +1136,7 @@ int __init snd_pmac_new(snd_card_t *card, pmac_t **chip_return)\n \tpmac_t *chip;\n \tstruct device_node *np;\n \tint i, err;\n+\tunsigned long ctrl_addr, txdma_addr, rxdma_addr;\n \tstatic snd_device_ops_t ops = {\n \t\t.dev_free =\tsnd_pmac_dev_free,\n \t};\n@@ -1127,32 +1158,59 @@ int __init snd_pmac_new(snd_card_t *card, pmac_t **chip_return)\n \tif ((err = snd_pmac_detect(chip)) < 0)\n \t\tgoto __error;\n \n-\tif (snd_pmac_dbdma_alloc(&chip->playback.cmd, PMAC_MAX_FRAGS + 1) < 0 ||\n-\t    snd_pmac_dbdma_alloc(&chip->capture.cmd, PMAC_MAX_FRAGS + 1) < 0 ||\n-\t    snd_pmac_dbdma_alloc(&chip->extra_dma, 2) < 0) {\n+\tif (snd_pmac_dbdma_alloc(chip, &chip->playback.cmd, PMAC_MAX_FRAGS + 1) < 0 ||\n+\t    snd_pmac_dbdma_alloc(chip, &chip->capture.cmd, PMAC_MAX_FRAGS + 1) < 0 ||\n+\t    snd_pmac_dbdma_alloc(chip, &chip->extra_dma, 2) < 0) {\n \t\terr = -ENOMEM;\n \t\tgoto __error;\n \t}\n \n \tnp = chip->node;\n-\tif (np->n_addrs < 3 || np->n_intrs < 3) {\n-\t\terr = -ENODEV;\n-\t\tgoto __error;\n-\t}\n+\tif (chip->is_k2) {\n+\t\tif (np->parent->n_addrs < 2 || np->n_intrs < 3) {\n+\t\t\terr = -ENODEV;\n+\t\t\tgoto __error;\n+\t\t}\n+\t\tfor (i = 0; i < 2; i++) {\n+#ifndef CONFIG_PPC64\n+\t\t\tstatic char *name[2] = { \"- Control\", \"- DMA\" };\n+\t\t\tif (! request_OF_resource(np->parent, i, name[i])) {\n+\t\t\t\tsnd_printk(KERN_ERR \"pmac: can't request resource %d!\\n\", i);\n+\t\t\t\terr = -ENODEV;\n+\t\t\t\tgoto __error;\n+\t\t\t}\n+\t\t\tchip->of_requested |= (1 << i);\n+#endif /* CONFIG_PPC64 */\n+\t\t\tctrl_addr = np->parent->addrs[0].address;\n+\t\t\ttxdma_addr = np->parent->addrs[1].address;\n+\t\t\trxdma_addr = txdma_addr + 0x100;\n+\t\t}\n \n-\tfor (i = 0; i < 3; i++) {\n-\t\tstatic char *name[3] = { NULL, \"- Tx DMA\", \"- Rx DMA\" };\n-\t\tif (! request_OF_resource(np, i, name[i])) {\n-\t\t\tsnd_printk(KERN_ERR \"pmac: can't request resource %d!\\n\", i);\n+\t} else {\n+\t\tif (np->n_addrs < 3 || np->n_intrs < 3) {\n \t\t\terr = -ENODEV;\n \t\t\tgoto __error;\n \t\t}\n-\t\tchip->of_requested |= (1 << i);\n+\n+\t\tfor (i = 0; i < 3; i++) {\n+#ifndef CONFIG_PPC64\n+\t\t\tstatic char *name[3] = { \"- Control\", \"- Tx DMA\", \"- Rx DMA\" };\n+\t\t\tif (! request_OF_resource(np, i, name[i])) {\n+\t\t\t\tsnd_printk(KERN_ERR \"pmac: can't request resource %d!\\n\", i);\n+\t\t\t\terr = -ENODEV;\n+\t\t\t\tgoto __error;\n+\t\t\t}\n+\t\t\tchip->of_requested |= (1 << i);\n+#endif /* CONFIG_PPC64 */\n+\t\t\tctrl_addr = np->addrs[0].address;\n+\t\t\ttxdma_addr = np->addrs[1].address;\n+\t\t\trxdma_addr = np->addrs[2].address;\n+\t\t}\n \t}\n \n-\tchip->awacs = ioremap(np->addrs[0].address, 0x1000);\n-\tchip->playback.dma = ioremap(np->addrs[1].address, 0x100);\n-\tchip->capture.dma = ioremap(np->addrs[2].address, 0x100);\n+\tchip->awacs = ioremap(ctrl_addr, 0x1000);\n+\tchip->playback.dma = ioremap(txdma_addr, 0x100);\n+\tchip->capture.dma = ioremap(rxdma_addr, 0x100);\n \tif (chip->model <= PMAC_BURGUNDY) {\n \t\tif (request_irq(np->intrs[0].line, snd_pmac_ctrl_intr, 0,\n \t\t\t\t\"PMac\", (void*)chip)) {\n@@ -1180,7 +1238,8 @@ int __init snd_pmac_new(snd_card_t *card, pmac_t **chip_return)\n \tsnd_pmac_sound_feature(chip, 1);\n \n \t/* reset */\n-\tout_le32(&chip->awacs->control, 0x11);\n+\tif (chip->model == PMAC_AWACS)\n+\t\tout_le32(&chip->awacs->control, 0x11);\n \n \t/* Powerbooks have odd ways of enabling inputs such as\n \t   an expansion-bay CD or sound from an internal modem\n@@ -1232,6 +1291,8 @@ int __init snd_pmac_new(snd_card_t *card, pmac_t **chip_return)\n \treturn 0;\n \n  __error:\n+\tif (chip->pdev)\n+\t\tpci_dev_put(chip->pdev);\n \tsnd_pmac_free(chip);\n \treturn err;\n }"}}
{"input": {"original code": "* typedefs\n */\ntypedef struct snd_pmac pmac_t;\ntypedef struct snd_pmac_stream pmac_stream_t;\ntypedef struct snd_pmac_beep pmac_beep_t;\ntypedef struct snd_pmac_dbdma pmac_dbdma_t;\n\n\n/*\n * DBDMA space\n */\nstruct snd_pmac_dbdma {\n\tunsigned long addr;\n\tstruct dbdma_cmd __iomem *cmds;\n\tvoid *space;\n\tint size;\n};\n\n/*\n * playback/capture stream", "instruction": "This patch hacks the current PowerMac Alsa driver to add some basic support"}, "output": {"diff codes": "@@ -60,7 +60,8 @@ typedef struct snd_pmac_dbdma pmac_dbdma_t;\n  * DBDMA space\n  */\n struct snd_pmac_dbdma {\n-\tunsigned long addr;\n+\tdma_addr_t dma_base;\n+\tdma_addr_t addr;\n \tstruct dbdma_cmd __iomem *cmds;\n \tvoid *space;\n \tint size;\n@@ -101,6 +102,7 @@ struct snd_pmac {\n \n \t/* h/w info */\n \tstruct device_node *node;\n+\tstruct pci_dev *pdev;\n \tunsigned int revision;\n \tunsigned int manufacturer;\n \tunsigned int subframe;\n@@ -110,6 +112,7 @@ struct snd_pmac {\n \tunsigned int has_iic : 1;\n \tunsigned int is_pbook_3400 : 1;\n \tunsigned int is_pbook_G3 : 1;\n+\tunsigned int is_k2 : 1;\n \n \tunsigned int can_byte_swap : 1;\n \tunsigned int can_duplex : 1;\n@@ -157,6 +160,7 @@ struct snd_pmac {\n \tsnd_kcontrol_t *speaker_sw_ctl;\n \tsnd_kcontrol_t *drc_sw_ctl;\t/* only used for tumbler -ReneR */\n \tsnd_kcontrol_t *hp_detect_ctl;\n+\tsnd_kcontrol_t *lineout_sw_ctl;\n \n \t/* lowlevel callbacks */\n \tvoid (*set_format)(pmac_t *chip);"}}
{"input": {"original code": "#include <sound/driver.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/i2c-dev.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <sound/core.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#ifdef CONFIG_PPC_HAS_FEATURE_CALLS\n#include <asm/pmac_feature.h>\n#else\n#error old crap\n#endif\n#include \"pmac.h\"\n#include \"tumbler_volume.h\"", "instruction": "This patch hacks the current PowerMac Alsa driver to add some basic support"}, "output": {"diff codes": "@@ -35,14 +35,19 @@\n #include <sound/core.h>\n #include <asm/io.h>\n #include <asm/irq.h>\n-#ifdef CONFIG_PPC_HAS_FEATURE_CALLS\n+#include <asm/machdep.h>\n #include <asm/pmac_feature.h>\n-#else\n-#error old crap\n-#endif\n #include \"pmac.h\"\n #include \"tumbler_volume.h\"\n \n+#undef DEBUG\n+\n+#ifdef DEBUG\n+#define DBG(fmt...) printk(fmt)\n+#else\n+#define DBG(fmt...)\n+#endif\n+\n /* i2c address for tumbler */\n #define TAS_I2C_ADDR\t0x34\n \n@@ -78,21 +83,22 @@ enum {\n };\n \n typedef struct pmac_gpio {\n-#ifdef CONFIG_PPC_HAS_FEATURE_CALLS\n \tunsigned int addr;\n-#else\n-\tvoid __iomem *addr;\n-#endif\n-\tint active_state;\n+\tu8 active_val;\n+\tu8 inactive_val;\n+\tu8 active_state;\n } pmac_gpio_t;\n \n typedef struct pmac_tumbler_t {\n \tpmac_keywest_t i2c;\n \tpmac_gpio_t audio_reset;\n \tpmac_gpio_t amp_mute;\n+\tpmac_gpio_t line_mute;\n+\tpmac_gpio_t line_detect;\n \tpmac_gpio_t hp_mute;\n \tpmac_gpio_t hp_detect;\n \tint headphone_irq;\n+\tint lineout_irq;\n \tunsigned int master_vol[2];\n \tunsigned int save_master_switch[2];\n \tunsigned int master_switch[2];\n@@ -120,6 +126,7 @@ static int send_init_client(pmac_keywest_t *i2c, unsigned int *regs)\n \t\t\t\t\t\t\tregs[0], regs[1]);\n \t\t\tif (err >= 0)\n \t\t\t\tbreak;\n+\t\t\tDBG(\"(W) i2c error %d\\n\", err);\n \t\t\tmdelay(10);\n \t\t} while (count--);\n \t\tif (err < 0)\n@@ -137,6 +144,7 @@ static int tumbler_init_client(pmac_keywest_t *i2c)\n \t\tTAS_REG_MCS, (1<<6)|(2<<4)|(2<<2)|0,\n \t\t0, /* terminator */\n \t};\n+\tDBG(\"(I) tumbler init client\\n\");\n \treturn send_init_client(i2c, regs);\n }\n \n@@ -151,36 +159,27 @@ static int snapper_init_client(pmac_keywest_t *i2c)\n \t\tTAS_REG_ACS, 0,\n \t\t0, /* terminator */\n \t};\n+\tDBG(\"(I) snapper init client\\n\");\n \treturn send_init_client(i2c, regs);\n }\n \t\n /*\n  * gpio access\n  */\n-#ifdef CONFIG_PPC_HAS_FEATURE_CALLS\n #define do_gpio_write(gp, val) \\\n \tpmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL, (gp)->addr, val)\n #define do_gpio_read(gp) \\\n \tpmac_call_feature(PMAC_FTR_READ_GPIO, NULL, (gp)->addr, 0)\n #define tumbler_gpio_free(gp) /* NOP */\n-#else\n-#define do_gpio_write(gp, val)\twriteb(val, (gp)->addr)\n-#define do_gpio_read(gp)\treadb((gp)->addr)\n-static inline void tumbler_gpio_free(pmac_gpio_t *gp)\n-{\n-\tif (gp->addr) {\n-\t\tiounmap(gp->addr);\n-\t\tgp->addr = NULL;\n-\t}\n-}\n-#endif /* CONFIG_PPC_HAS_FEATURE_CALLS */\n \n static void write_audio_gpio(pmac_gpio_t *gp, int active)\n {\n \tif (! gp->addr)\n \t\treturn;\n-\tactive = active ? gp->active_state : !gp->active_state;\n-\tdo_gpio_write(gp, active ? 0x05 : 0x04);\n+\tactive = active ? gp->active_val : gp->inactive_val;\n+\n+\tdo_gpio_write(gp, active);\n+\tDBG(\"(I) gpio %x write %d\\n\", gp->addr, active);\n }\n \n static int read_audio_gpio(pmac_gpio_t *gp)\n@@ -663,7 +662,7 @@ static int snapper_put_mix(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucont\n  * to avoid codec reset on ibook M7\n  */\n \n-enum { TUMBLER_MUTE_HP, TUMBLER_MUTE_AMP };\n+enum { TUMBLER_MUTE_HP, TUMBLER_MUTE_AMP, TUMBLER_MUTE_LINE };\n \n static int tumbler_get_mute_switch(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)\n {\n@@ -672,7 +671,18 @@ static int tumbler_get_mute_switch(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_\n \tpmac_gpio_t *gp;\n \tif (! (mix = chip->mixer_data))\n \t\treturn -ENODEV;\n-\tgp = (kcontrol->private_value == TUMBLER_MUTE_HP) ? &mix->hp_mute : &mix->amp_mute;\n+\tswitch(kcontrol->private_value) {\n+\tcase TUMBLER_MUTE_HP:\n+\t\tgp = &mix->hp_mute;\tbreak;\n+\tcase TUMBLER_MUTE_AMP:\n+\t\tgp = &mix->amp_mute;\tbreak;\n+\tcase TUMBLER_MUTE_LINE:\n+\t\tgp = &mix->line_mute;\tbreak;\n+\tdefault:\n+\t\tgp = NULL;\n+\t}\n+\tif (gp == NULL)\n+\t\treturn -EINVAL;\n \tucontrol->value.integer.value[0] = ! read_audio_gpio(gp);\n \treturn 0;\n }\n@@ -689,7 +699,18 @@ static int tumbler_put_mute_switch(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_\n #endif\t\n \tif (! (mix = chip->mixer_data))\n \t\treturn -ENODEV;\n-\tgp = (kcontrol->private_value == TUMBLER_MUTE_HP) ? &mix->hp_mute : &mix->amp_mute;\n+\tswitch(kcontrol->private_value) {\n+\tcase TUMBLER_MUTE_HP:\n+\t\tgp = &mix->hp_mute;\tbreak;\n+\tcase TUMBLER_MUTE_AMP:\n+\t\tgp = &mix->amp_mute;\tbreak;\n+\tcase TUMBLER_MUTE_LINE:\n+\t\tgp = &mix->line_mute;\tbreak;\n+\tdefault:\n+\t\tgp = NULL;\n+\t}\n+\tif (gp == NULL)\n+\t\treturn -EINVAL;\n \tval = ! read_audio_gpio(gp);\n \tif (val != ucontrol->value.integer.value[0]) {\n \t\twrite_audio_gpio(gp, ! ucontrol->value.integer.value[0]);\n@@ -833,6 +854,14 @@ static snd_kcontrol_new_t tumbler_speaker_sw __initdata = {\n \t.put = tumbler_put_mute_switch,\n \t.private_value = TUMBLER_MUTE_AMP,\n };\n+static snd_kcontrol_new_t tumbler_lineout_sw __initdata = {\n+\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n+\t.name = \"Line Out Playback Switch\",\n+\t.info = snd_pmac_boolean_mono_info,\n+\t.get = tumbler_get_mute_switch,\n+\t.put = tumbler_put_mute_switch,\n+\t.private_value = TUMBLER_MUTE_LINE,\n+};\n static snd_kcontrol_new_t tumbler_drc_sw __initdata = {\n \t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n \t.name = \"DRC Switch\",\n@@ -849,7 +878,21 @@ static snd_kcontrol_new_t tumbler_drc_sw __initdata = {\n static int tumbler_detect_headphone(pmac_t *chip)\n {\n \tpmac_tumbler_t *mix = chip->mixer_data;\n-\treturn read_audio_gpio(&mix->hp_detect);\n+\tint detect = 0;\n+\n+\tif (mix->hp_detect.addr)\n+\t\tdetect |= read_audio_gpio(&mix->hp_detect);\n+\treturn detect;\n+}\n+\n+static int tumbler_detect_lineout(pmac_t *chip)\n+{\n+\tpmac_tumbler_t *mix = chip->mixer_data;\n+\tint detect = 0;\n+\n+\tif (mix->line_detect.addr)\n+\t\tdetect |= read_audio_gpio(&mix->line_detect);\n+\treturn detect;\n }\n \n static void check_mute(pmac_t *chip, pmac_gpio_t *gp, int val, int do_notify, snd_kcontrol_t *sw)\n@@ -868,6 +911,7 @@ static void device_change_handler(void *self)\n {\n \tpmac_t *chip = (pmac_t*) self;\n \tpmac_tumbler_t *mix;\n+\tint headphone, lineout;\n \n \tif (!chip)\n \t\treturn;\n@@ -875,23 +919,35 @@ static void device_change_handler(void *self)\n \tmix = chip->mixer_data;\n \tsnd_assert(mix, return);\n \n-\tif (tumbler_detect_headphone(chip)) {\n-\t\t/* mute speaker */\n-\t\tcheck_mute(chip, &mix->hp_mute, 0, mix->auto_mute_notify,\n-\t\t\t   chip->master_sw_ctl);\n+\theadphone = tumbler_detect_headphone(chip);\n+\tlineout = tumbler_detect_lineout(chip);\n+\n+\tDBG(\"headphone: %d, lineout: %d\\n\", headphone, lineout);\n+\n+\tif (headphone || lineout) {\n+\t\t/* unmute headphone/lineout & mute speaker */\n+\t\tif (headphone)\n+\t\t\tcheck_mute(chip, &mix->hp_mute, 0, mix->auto_mute_notify,\n+\t\t\t\t   chip->master_sw_ctl);\n+\t\tif (lineout && mix->line_mute.addr != 0)\n+\t\t\tcheck_mute(chip, &mix->line_mute, 0, mix->auto_mute_notify,\n+\t\t\t\t   chip->lineout_sw_ctl);\n \t\tif (mix->anded_reset)\n \t\t\tbig_mdelay(10);\n \t\tcheck_mute(chip, &mix->amp_mute, 1, mix->auto_mute_notify,\n \t\t\t   chip->speaker_sw_ctl);\n \t\tmix->drc_enable = 0;\n \t} else {\n-\t\t/* unmute speaker */\n+\t\t/* unmute speaker, mute others */\n \t\tcheck_mute(chip, &mix->amp_mute, 0, mix->auto_mute_notify,\n \t\t\t   chip->speaker_sw_ctl);\n \t\tif (mix->anded_reset)\n \t\t\tbig_mdelay(10);\n \t\tcheck_mute(chip, &mix->hp_mute, 1, mix->auto_mute_notify,\n \t\t\t   chip->master_sw_ctl);\n+\t\tif (mix->line_mute.addr != 0)\n+\t\t\tcheck_mute(chip, &mix->line_mute, 1, mix->auto_mute_notify,\n+\t\t\t\t   chip->lineout_sw_ctl);\n \t\tmix->drc_enable = 1;\n \t}\n \tif (mix->auto_mute_notify) {\n@@ -967,7 +1023,7 @@ static struct device_node *find_compatible_audio_device(const char *name)\n }\n \n /* find an audio device and get its address */\n-static long tumbler_find_device(const char *device, pmac_gpio_t *gp, int is_compatible)\n+static long tumbler_find_device(const char *device, const char *platform, pmac_gpio_t *gp, int is_compatible)\n {\n \tstruct device_node *node;\n \tu32 *base, addr;\n@@ -977,6 +1033,7 @@ static long tumbler_find_device(const char *device, pmac_gpio_t *gp, int is_comp\n \telse\n \t\tnode = find_audio_device(device);\n \tif (! node) {\n+\t\tDBG(\"(W) cannot find audio device %s !\\n\", device);\n \t\tsnd_printdd(\"cannot find device %s\\n\", device);\n \t\treturn -ENODEV;\n \t}\n@@ -985,29 +1042,48 @@ static long tumbler_find_device(const char *device, pmac_gpio_t *gp, int is_comp\n \tif (! base) {\n \t\tbase = (u32 *)get_property(node, \"reg\", NULL);\n \t\tif (!base) {\n+\t\t\tDBG(\"(E) cannot find address for device %s !\\n\", device);\n \t\t\tsnd_printd(\"cannot find address for device %s\\n\", device);\n \t\t\treturn -ENODEV;\n \t\t}\n-\t\t/* this only work if PPC_HAS_FEATURE_CALLS is set as we\n-\t\t * are only getting the low part of the address\n-\t\t */\n \t\taddr = *base;\n \t\tif (addr < 0x50)\n \t\t\taddr += 0x50;\n \t} else\n \t\taddr = *base;\n \n-#ifdef CONFIG_PPC_HAS_FEATURE_CALLS\n \tgp->addr = addr & 0x0000ffff;\n-#else\n-\tgp->addr = ioremap((unsigned long)addr, 1);\n-#endif\n \t/* Try to find the active state, default to 0 ! */\n \tbase = (u32 *)get_property(node, \"audio-gpio-active-state\", NULL);\n-\tif (base)\n+\tif (base) {\n \t\tgp->active_state = *base;\n-\telse\n+\t\tgp->active_val = (*base) ? 0x5 : 0x4;\n+\t\tgp->inactive_val = (*base) ? 0x4 : 0x5;\n+\t} else {\n+\t\tu32 *prop = NULL;\n \t\tgp->active_state = 0;\n+\t\tgp->active_val = 0x4;\n+\t\tgp->inactive_val = 0x5;\n+\t\t/* Here are some crude hacks to extract the GPIO polarity and\n+\t\t * open collector informations out of the do-platform script\n+\t\t * as we don't yet have an interpreter for these things\n+\t\t */\n+\t\tif (platform)\n+\t\t\tprop = (u32 *)get_property(node, platform, NULL);\n+\t\tif (prop) {\n+\t\t\tif (prop[3] == 0x9 && prop[4] == 0x9) {\n+\t\t\t\tgp->active_val = 0xd;\n+\t\t\t\tgp->inactive_val = 0xc;\n+\t\t\t}\n+\t\t\tif (prop[3] == 0x1 && prop[4] == 0x1) {\n+\t\t\t\tgp->active_val = 0x5;\n+\t\t\t\tgp->inactive_val = 0x4;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tDBG(\"(I) GPIO device %s found, offset: %x, active state: %d !\\n\",\n+\t    device, gp->addr, gp->active_state);\n \n \treturn (node->n_intrs > 0) ? node->intrs[0].line : 0;\n }\n@@ -1018,6 +1094,7 @@ static void tumbler_reset_audio(pmac_t *chip)\n \tpmac_tumbler_t *mix = chip->mixer_data;\n \n \tif (mix->anded_reset) {\n+\t\tDBG(\"(I) codec anded reset !\\n\");\n \t\twrite_audio_gpio(&mix->hp_mute, 0);\n \t\twrite_audio_gpio(&mix->amp_mute, 0);\n \t\tbig_mdelay(200);\n@@ -1028,6 +1105,8 @@ static void tumbler_reset_audio(pmac_t *chip)\n \t\twrite_audio_gpio(&mix->amp_mute, 0);\n \t\tbig_mdelay(100);\n \t} else {\n+\t\tDBG(\"(I) codec normal reset !\\n\");\n+\n \t\twrite_audio_gpio(&mix->audio_reset, 0);\n \t\tbig_mdelay(200);\n \t\twrite_audio_gpio(&mix->audio_reset, 1);\n@@ -1045,6 +1124,8 @@ static void tumbler_suspend(pmac_t *chip)\n \n \tif (mix->headphone_irq >= 0)\n \t\tdisable_irq(mix->headphone_irq);\n+\tif (mix->lineout_irq >= 0)\n+\t\tdisable_irq(mix->lineout_irq);\n \tmix->save_master_switch[0] = mix->master_switch[0];\n \tmix->save_master_switch[1] = mix->master_switch[1];\n \tmix->master_switch[0] = mix->master_switch[1] = 0;\n@@ -1099,41 +1180,59 @@ static void tumbler_resume(pmac_t *chip)\n \t\tchip->update_automute(chip, 0);\n \tif (mix->headphone_irq >= 0)\n \t\tenable_irq(mix->headphone_irq);\n+\tif (mix->lineout_irq >= 0)\n+\t\tenable_irq(mix->lineout_irq);\n }\n #endif\n \n /* initialize tumbler */\n static int __init tumbler_init(pmac_t *chip)\n {\n-\tint irq, err;\n+\tint irq;\n \tpmac_tumbler_t *mix = chip->mixer_data;\n \tsnd_assert(mix, return -EINVAL);\n \n-\tif (tumbler_find_device(\"audio-hw-reset\", &mix->audio_reset, 0) < 0)\n-\t\ttumbler_find_device(\"hw-reset\", &mix->audio_reset, 1);\n-\tif (tumbler_find_device(\"amp-mute\", &mix->amp_mute, 0) < 0)\n-\t\ttumbler_find_device(\"amp-mute\", &mix->amp_mute, 1);\n-\tif (tumbler_find_device(\"headphone-mute\", &mix->hp_mute, 0) < 0)\n-\t\ttumbler_find_device(\"headphone-mute\", &mix->hp_mute, 1);\n-\tirq = tumbler_find_device(\"headphone-detect\", &mix->hp_detect, 0);\n+\tif (tumbler_find_device(\"audio-hw-reset\",\n+\t\t\t\t\"platform-do-hw-reset\",\n+\t\t\t\t&mix->audio_reset, 0) < 0)\n+\t\ttumbler_find_device(\"hw-reset\",\n+\t\t\t\t    \"platform-do-hw-reset\",\n+\t\t\t\t    &mix->audio_reset, 1);\n+\tif (tumbler_find_device(\"amp-mute\",\n+\t\t\t\t\"platform-do-amp-mute\",\n+\t\t\t\t&mix->amp_mute, 0) < 0)\n+\t\ttumbler_find_device(\"amp-mute\",\n+\t\t\t\t    \"platform-do-amp-mute\",\n+\t\t\t\t    &mix->amp_mute, 1);\n+\tif (tumbler_find_device(\"headphone-mute\",\n+\t\t\t\t\"platform-do-headphone-mute\",\n+\t\t\t\t&mix->hp_mute, 0) < 0)\n+\t\ttumbler_find_device(\"headphone-mute\",\n+\t\t\t\t    \"platform-do-headphone-mute\",\n+\t\t\t\t    &mix->hp_mute, 1);\n+\tif (tumbler_find_device(\"line-output-mute\",\n+\t\t\t\t\"platform-do-lineout-mute\",\n+\t\t\t\t&mix->line_mute, 0) < 0)\n+\t\ttumbler_find_device(\"line-output-mute\",\n+\t\t\t\t   \"platform-do-lineout-mute\",\n+\t\t\t\t    &mix->line_mute, 1);\n+\tirq = tumbler_find_device(\"headphone-detect\",\n+\t\t\t\t  NULL, &mix->hp_detect, 0);\n \tif (irq < 0)\n-\t\tirq = tumbler_find_device(\"headphone-detect\", &mix->hp_detect, 1);\n+\t\tirq = tumbler_find_device(\"headphone-detect\",\n+\t\t\t\t\t  NULL, &mix->hp_detect, 1);\n \tif (irq < 0)\n-\t\tirq = tumbler_find_device(\"keywest-gpio15\", &mix->hp_detect, 1);\n+\t\tirq = tumbler_find_device(\"keywest-gpio15\",\n+\t\t\t\t\t  NULL, &mix->hp_detect, 1);\n+\tmix->headphone_irq = irq;\n+ \tirq = tumbler_find_device(\"line-output-detect\",\n+\t\t\t\t  NULL, &mix->line_detect, 0);\n+ \tif (irq < 0)\n+\t\tirq = tumbler_find_device(\"line-output-detect\",\n+\t\t\t\t\t  NULL, &mix->line_detect, 1);\n+\tmix->lineout_irq = irq;\n \n \ttumbler_reset_audio(chip);\n-\n-\t/* activate headphone status interrupts */\n-  \tif (irq >= 0) {\n-\t\tunsigned char val;\n-\t\tif ((err = request_irq(irq, headphone_intr, 0,\n-\t\t\t\t       \"Tumbler Headphone Detection\", chip)) < 0)\n-\t\t\treturn err;\n-\t\t/* activate headphone status interrupts */\n-\t\tval = do_gpio_read(&mix->hp_detect);\n-\t\tdo_gpio_write(&mix->hp_detect, val | 0x80);\n-\t}\n-\tmix->headphone_irq = irq;\n   \n \treturn 0;\n }\n@@ -1146,6 +1245,8 @@ static void tumbler_cleanup(pmac_t *chip)\n \n \tif (mix->headphone_irq >= 0)\n \t\tfree_irq(mix->headphone_irq, chip);\n+\tif (mix->lineout_irq >= 0)\n+\t\tfree_irq(mix->lineout_irq, chip);\n \ttumbler_gpio_free(&mix->audio_reset);\n \ttumbler_gpio_free(&mix->amp_mute);\n \ttumbler_gpio_free(&mix->hp_mute);\n@@ -1207,6 +1308,8 @@ int __init snd_pmac_tumbler_init(pmac_t *chip)\n \telse\n \t\tmix->i2c.addr = TAS_I2C_ADDR;\n \n+\tDBG(\"(I) TAS i2c address is: %x\\n\", mix->i2c.addr);\n+\n \tif (chip->model == PMAC_TUMBLER) {\n \t\tmix->i2c.init_client = tumbler_init_client;\n \t\tmix->i2c.name = \"TAS3001c\";\n@@ -1242,6 +1345,11 @@ int __init snd_pmac_tumbler_init(pmac_t *chip)\n \tchip->speaker_sw_ctl = snd_ctl_new1(&tumbler_speaker_sw, chip);\n \tif ((err = snd_ctl_add(chip->card, chip->speaker_sw_ctl)) < 0)\n \t\treturn err;\n+\tif (mix->line_mute.addr != 0) {\n+\t\tchip->lineout_sw_ctl = snd_ctl_new1(&tumbler_lineout_sw, chip);\n+\t\tif ((err = snd_ctl_add(chip->card, chip->lineout_sw_ctl)) < 0)\n+\t\t\treturn err;\n+\t}\n \tchip->drc_sw_ctl = snd_ctl_new1(&tumbler_drc_sw, chip);\n \tif ((err = snd_ctl_add(chip->card, chip->drc_sw_ctl)) < 0)\n \t\treturn err;\n@@ -1254,11 +1362,32 @@ int __init snd_pmac_tumbler_init(pmac_t *chip)\n \tINIT_WORK(&device_change, device_change_handler, (void *)chip);\n \n #ifdef PMAC_SUPPORT_AUTOMUTE\n-\tif (mix->headphone_irq >=0 && (err = snd_pmac_add_automute(chip)) < 0)\n+\tif ((mix->headphone_irq >=0 || mix->lineout_irq >= 0)\n+\t    && (err = snd_pmac_add_automute(chip)) < 0)\n \t\treturn err;\n \tchip->detect_headphone = tumbler_detect_headphone;\n \tchip->update_automute = tumbler_update_automute;\n \ttumbler_update_automute(chip, 0); /* update the status only */\n+\n+\t/* activate headphone status interrupts */\n+  \tif (mix->headphone_irq >= 0) {\n+\t\tunsigned char val;\n+\t\tif ((err = request_irq(mix->headphone_irq, headphone_intr, 0,\n+\t\t\t\t       \"Sound Headphone Detection\", chip)) < 0)\n+\t\t\treturn 0;\n+\t\t/* activate headphone status interrupts */\n+\t\tval = do_gpio_read(&mix->hp_detect);\n+\t\tdo_gpio_write(&mix->hp_detect, val | 0x80);\n+\t}\n+  \tif (mix->lineout_irq >= 0) {\n+\t\tunsigned char val;\n+\t\tif ((err = request_irq(mix->lineout_irq, headphone_intr, 0,\n+\t\t\t\t       \"Sound Lineout Detection\", chip)) < 0)\n+\t\t\treturn 0;\n+\t\t/* activate headphone status interrupts */\n+\t\tval = do_gpio_read(&mix->line_detect);\n+\t\tdo_gpio_write(&mix->line_detect, val | 0x80);\n+\t}\n #endif\n \n \treturn 0;"}}
{"input": {"original code": "* and call ioremap\n\t */\n\thpte_init_native();\n\n\t/* Find the serial port */\n\tgeneric_find_legacy_serial_ports(&physport, &default_speed);\n\n\tDBG(\"phys port addr: %lx\\n\", (long)physport);\n\n\tif (physport) {\n\t\tvoid *comport;\n\t\t/* Map the uart for udbg. */\n\t\tcomport = (void *)__ioremap(physport, 16, _PAGE_NO_CACHE);\n\t\tudbg_init_uart(comport, default_speed);\n\n\t\tppc_md.udbg_putc = udbg_putc;\n\t\tppc_md.udbg_getc = udbg_getc;\n\t\tppc_md.udbg_getc_poll = udbg_getc_poll;\n\t\tDBG(\"Hello World !\\n\");\n\t}", "instruction": "This patch fixes ppc64 __ioremap() so that it stops adding implicitely"}, "output": {"diff codes": "@@ -142,7 +142,7 @@ static void __init maple_init_early(void)\n \tif (physport) {\n \t\tvoid *comport;\n \t\t/* Map the uart for udbg. */\n-\t\tcomport = (void *)__ioremap(physport, 16, _PAGE_NO_CACHE);\n+\t\tcomport = (void *)ioremap(physport, 16);\n \t\tudbg_init_uart(comport, default_speed);\n \n \t\tppc_md.udbg_putc = udbg_putc;"}}
{"input": {"original code": "else {\n\t\thpte_init_native();\n\t\tiommu_off = (of_chosen &&\n\t\t\t     get_property(of_chosen, \"linux,iommu-off\", NULL));\n\t}\n\n\tgeneric_find_legacy_serial_ports(&physport, &default_speed);\n\n\tif (systemcfg->platform & PLATFORM_LPAR)\n\t\tfind_udbg_vterm();\n\telse if (physport) {\n\t\t/* Map the uart for udbg. */\n\t\tcomport = (void *)__ioremap(physport, 16, _PAGE_NO_CACHE);\n\t\tudbg_init_uart(comport, default_speed);\n\n\t\tppc_md.udbg_putc = udbg_putc;\n\t\tppc_md.udbg_getc = udbg_getc;\n\t\tppc_md.udbg_getc_poll = udbg_getc_poll;\n\t\tDBG(\"Hello World !\\n\");\n\t}", "instruction": "This patch fixes ppc64 __ioremap() so that it stops adding implicitely"}, "output": {"diff codes": "@@ -363,7 +363,7 @@ static void __init pSeries_init_early(void)\n \t\tfind_udbg_vterm();\n \telse if (physport) {\n \t\t/* Map the uart for udbg. */\n-\t\tcomport = (void *)__ioremap(physport, 16, _PAGE_NO_CACHE);\n+\t\tcomport = (void *)ioremap(physport, 16);\n \t\tudbg_init_uart(comport, default_speed);\n \n \t\tppc_md.udbg_putc = udbg_putc;"}}
{"input": {"original code": "void __iomem * phb_io_base_virt)\n{\n\tstruct isa_range *range;\n\tunsigned long pci_addr;\n\tunsigned int isa_addr;\n\tunsigned int size;\n\tint rlen = 0;\n\n\trange = (struct isa_range *) get_property(isa_node, \"ranges\", &rlen);\n\tif (range == NULL || (rlen < sizeof(struct isa_range))) {\n\t\tprintk(KERN_ERR \"no ISA ranges or unexpected isa range size,\"\n\t\t       \"mapping 64k\\n\");\n\t\t__ioremap_explicit(phb_io_base_phys, (unsigned long)phb_io_base_virt, \n\t\t\t\t   0x10000, _PAGE_NO_CACHE);\n\t\treturn;\t\n\t}\n\t\n\t/* From \"ISA Binding to 1275\"\n\t * The ranges property is laid out as an array of elements,\n\t * each of which comprises:", "instruction": "This patch fixes ppc64 __ioremap() so that it stops adding implicitely"}, "output": {"diff codes": "@@ -547,8 +547,9 @@ static void __devinit pci_process_ISA_OF_ranges(struct device_node *isa_node,\n \tif (range == NULL || (rlen < sizeof(struct isa_range))) {\n \t\tprintk(KERN_ERR \"no ISA ranges or unexpected isa range size,\"\n \t\t       \"mapping 64k\\n\");\n-\t\t__ioremap_explicit(phb_io_base_phys, (unsigned long)phb_io_base_virt, \n-\t\t\t\t   0x10000, _PAGE_NO_CACHE);\n+\t\t__ioremap_explicit(phb_io_base_phys,\n+\t\t\t\t   (unsigned long)phb_io_base_virt,\n+\t\t\t\t   0x10000, _PAGE_NO_CACHE | _PAGE_GUARDED);\n \t\treturn;\t\n \t}\n \t\n@@ -576,7 +577,7 @@ static void __devinit pci_process_ISA_OF_ranges(struct device_node *isa_node,\n \n \t\t__ioremap_explicit(phb_io_base_phys, \n \t\t\t\t   (unsigned long) phb_io_base_virt, \n-\t\t\t\t   size, _PAGE_NO_CACHE);\n+\t\t\t\t   size, _PAGE_NO_CACHE | _PAGE_GUARDED);\n \t}\n }\n \n@@ -692,7 +693,7 @@ void __devinit pci_setup_phb_io_dynamic(struct pci_controller *hose,\n \tstruct resource *res;\n \n \those->io_base_virt = __ioremap(hose->io_base_phys, size,\n-\t\t\t\t\t_PAGE_NO_CACHE);\n+\t\t\t\t\t_PAGE_NO_CACHE | _PAGE_GUARDED);\n \tDBG(\"phb%d io_base_phys 0x%lx io_base_virt 0x%lx\\n\",\n \t\those->global_number, hose->io_base_phys,\n \t\t(unsigned long) hose->io_base_virt);\n@@ -780,7 +781,8 @@ int remap_bus_range(struct pci_bus *bus)\n \tif (get_bus_io_range(bus, &start_phys, &start_virt, &size))\n \t\treturn 1;\n \tprintk(\"mapping IO %lx -> %lx, size: %lx\\n\", start_phys, start_virt, size);\n-\tif (__ioremap_explicit(start_phys, start_virt, size, _PAGE_NO_CACHE))\n+\tif (__ioremap_explicit(start_phys, start_virt, size,\n+\t\t\t       _PAGE_NO_CACHE | _PAGE_GUARDED))\n \t\treturn 1;\n \n \treturn 0;"}}
{"input": {"original code": "pgd_t *pgdp;\n\tpmd_t *pmdp;\n\tpte_t *ptep;\n\tunsigned long vsid;\n\n\tif (mem_init_done) {\n\t\tspin_lock(&ioremap_mm.page_table_lock);\n\t\tpgdp = pgd_offset_i(ea);\n\t\tpmdp = pmd_alloc(&ioremap_mm, pgdp, ea);\n\t\tptep = pte_alloc_kernel(&ioremap_mm, pmdp, ea);\n\n\t\tpa = abs_to_phys(pa);\n\t\tset_pte_at(&ioremap_mm, ea, ptep, pfn_pte(pa >> PAGE_SHIFT, __pgprot(flags)));\n\t\tspin_unlock(&ioremap_mm.page_table_lock);\n\t} else {\n\t\tunsigned long va, vpn, hash, hpteg;\n\n\t\t/*\n\t\t * If the mm subsystem is not fully up, we cannot create a\n\t\t * linux page table entry for this mapping.  Simply bolt an", "instruction": "This patch fixes ppc64 __ioremap() so that it stops adding implicitely"}, "output": {"diff codes": "@@ -155,7 +155,8 @@ static void map_io_page(unsigned long ea, unsigned long pa, int flags)\n \t\tptep = pte_alloc_kernel(&ioremap_mm, pmdp, ea);\n \n \t\tpa = abs_to_phys(pa);\n-\t\tset_pte_at(&ioremap_mm, ea, ptep, pfn_pte(pa >> PAGE_SHIFT, __pgprot(flags)));\n+\t\tset_pte_at(&ioremap_mm, ea, ptep, pfn_pte(pa >> PAGE_SHIFT,\n+\t\t\t\t\t\t\t  __pgprot(flags)));\n \t\tspin_unlock(&ioremap_mm.page_table_lock);\n \t} else {\n \t\tunsigned long va, vpn, hash, hpteg;\n@@ -191,12 +192,9 @@ static void __iomem * __ioremap_com(unsigned long addr, unsigned long pa,\n \n \tif ((flags & _PAGE_PRESENT) == 0)\n \t\tflags |= pgprot_val(PAGE_KERNEL);\n-\tif (flags & (_PAGE_NO_CACHE | _PAGE_WRITETHRU))\n-\t\tflags |= _PAGE_GUARDED;\n \n-\tfor (i = 0; i < size; i += PAGE_SIZE) {\n+\tfor (i = 0; i < size; i += PAGE_SIZE)\n \t\tmap_io_page(ea+i, pa+i, flags);\n-\t}\n \n \treturn (void __iomem *) (ea + (addr & ~PAGE_MASK));\n }\n@@ -205,7 +203,7 @@ static void __iomem * __ioremap_com(unsigned long addr, unsigned long pa,\n void __iomem *\n ioremap(unsigned long addr, unsigned long size)\n {\n-\treturn __ioremap(addr, size, _PAGE_NO_CACHE);\n+\treturn __ioremap(addr, size, _PAGE_NO_CACHE | _PAGE_GUARDED);\n }\n \n void __iomem *\n@@ -272,7 +270,8 @@ int __ioremap_explicit(unsigned long pa, unsigned long ea,\n \t\t\treturn 1;\n \t\t}\n \t\tif (ea != (unsigned long) area->addr) {\n-\t\t\tprintk(KERN_ERR \"unexpected addr return from im_get_area\\n\");\n+\t\t\tprintk(KERN_ERR \"unexpected addr return from \"\n+\t\t\t       \"im_get_area\\n\");\n \t\t\treturn 1;\n \t\t}\n \t}\n@@ -315,7 +314,8 @@ static void unmap_im_area_pte(pmd_t *pmd, unsigned long address,\n \t\t\tcontinue;\n \t\tif (pte_present(page))\n \t\t\tcontinue;\n-\t\tprintk(KERN_CRIT \"Whee.. Swapped out page in kernel page table\\n\");\n+\t\tprintk(KERN_CRIT \"Whee.. Swapped out page in kernel page\"\n+\t\t       \" table\\n\");\n \t} while (address < end);\n }\n \n@@ -352,7 +352,7 @@ static void unmap_im_area_pmd(pgd_t *dir, unsigned long address,\n  * Access to IO memory should be serialized by driver.\n  * This code is modeled after vmalloc code - unmap_vm_area()\n  *\n- * XXX\twhat about calls before mem_init_done (ie python_countermeasures())\t\n+ * XXX\twhat about calls before mem_init_done (ie python_countermeasures())\n  */\n void iounmap(volatile void __iomem *token)\n {"}}
{"input": {"original code": "EXPORT_SYMBOL(_outsl);\nEXPORT_SYMBOL(_insw_ns);\nEXPORT_SYMBOL(_outsw_ns);\nEXPORT_SYMBOL(_insl_ns);\nEXPORT_SYMBOL(_outsl_ns);\n\nEXPORT_SYMBOL(kernel_thread);\n\nEXPORT_SYMBOL(giveup_fpu);\n#ifdef CONFIG_ALTIVEC\nEXPORT_SYMBOL(giveup_altivec);\n#endif\nEXPORT_SYMBOL(flush_icache_range);\n\n#ifdef CONFIG_SMP\n#ifdef CONFIG_PPC_ISERIES\nEXPORT_SYMBOL(local_get_flags);\nEXPORT_SYMBOL(local_irq_disable);\nEXPORT_SYMBOL(local_irq_restore);\n#endif", "instruction": "In arch/ppc64/kernel/ppc_ksyms.c, we are still exporting"}, "output": {"diff codes": "@@ -74,7 +74,7 @@ EXPORT_SYMBOL(giveup_fpu);\n #ifdef CONFIG_ALTIVEC\n EXPORT_SYMBOL(giveup_altivec);\n #endif\n-EXPORT_SYMBOL(flush_icache_range);\n+EXPORT_SYMBOL(__flush_icache_range);\n \n #ifdef CONFIG_SMP\n #ifdef CONFIG_PPC_ISERIES"}}
